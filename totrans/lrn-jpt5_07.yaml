- en: Jupyter Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala has become very popular. It is built on top of Java (so has full interoperability,
    including resorting to inline Java in your Scala code). However, the syntax is
    much cleaner and more intuitive, reworking some of the quirks in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Scala for Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Scala features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Scala kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for macOS are as follows (taken from [https://developer.ibm.com/hadoop/2016/05/04/install-jupyter-notebook-spark](https://developer.ibm.com/hadoop/2016/05/04/install-jupyter-notebook-spark)):'
  prefs: []
  type: TYPE_NORMAL
- en: I could not get the steps for using the Scala kernel to work on a Windows 10
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `git` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `scala` package locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `sbt` build tool by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the `jupyter-scala` directory to the `scala` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch Scala shell, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the kernels installed by running this command (you should now see Scala
    in the list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the Jupyter Notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can now choose to use a Scala 2.11 shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, if you start Jupyter, you will see Scala listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15744930-19af-444a-ae79-ff8f777136a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we create a Scala Notebook, we end up with the familiar layout with an icon
    displaying that we are running Scala and the engine type string identified as
    Scala. The kernel name is also specified in the URL to Jupyter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f7e9abe-8026-471e-85e8-d4833d05eaee.png)'
  prefs: []
  type: TYPE_IMG
- en: So, after naming our Notebook as Scala Notebook and then saving it, we get the
    familiar display of Notebooks on the home page, where the new Notebook is called
    `Scala Notebook.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look in the `.ipynb` file, we can see markup similar to other Notebook
    types, with special markings for Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can enter Scala coding in some of the cells. Following the previous
    language examples (from earlier chapters), we can enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Scala has changeable variables (`var`) and fixed variables (`val`). We are not
    going to be changing the fields, so they are `val`. The last statement, `show`,
    is a Jupyter extension for use in Scala to display a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this script in Jupyter, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b1cc8ba-804b-436c-af82-e9c3a45dadb5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the output area of the cell, we see the expected `Dan is 37`. Interestingly,
    Scala also displays the current type and value for each variable in the script
    at that point as well.
  prefs: []
  type: TYPE_NORMAL
- en: Scala data access in Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a copy of the `iris` dataset on the University of California''s website
    (**Irvine**) at [https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data](https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data).
    We will access this data and perform several statistical operations on the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There seems to be an issue with accessing the CSV file over the internet. So,
    I copied the file locally, into the same directory where the Notebook resides).
  prefs: []
  type: TYPE_NORMAL
- en: One noteworthy aspect regarding this script is the fact that we do not have
    to wrap the Scala code in an object, as would normally be required, since Jupyter
    provides the `wrapper` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the script, we see these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d28e144-b10e-493d-bf9a-e0d5e7476a6c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a different version of the `iris` data, hence, we see different results
    in the statistics than we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Scala array operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala does not have pandas, but we can emulate some of that logic with our own
    coding. We will use the `Titanic` dataset used in [Chapter 2](5b1dcec0-2cf7-45b3-b09d-7b3536095926.xhtml), *Jupyter
    Python Scripting*, from [http://titanic-gettingStarted/fdownload/train.csv](http://titanic-gettingStarted/fdownload/train.csv)
    which we have downloaded to our local space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use similar coding to that used in [Chapter 2](5b1dcec0-2cf7-45b3-b09d-7b3536095926.xhtml), *Jupyter
    Python Scripting,* for pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we read the file line by line, parse out the columns (it is CSV),
    and then make calculations based on the `sex` column of the data. What is interesting
    is that Scala arrays are not zero-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this script, we see very similar results to before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe76cf0c-5397-416f-99d0-08edf15d846a.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we see drastically higher survival rates for women. I think the stories
    about women and children first are true.
  prefs: []
  type: TYPE_NORMAL
- en: Scala random numbers in Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we simulate rolling dice and counting how many times each combination
    appears. We then present a simple histogram for illustrative purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We first pull in the Scala `Random` library. We set the seed (in order to have
    repeatable results). We are drawing `1000` rolls. For each roll, we increment
    a counter of how many times the total number of pips on die one and die two appear.
    We then present an abbreviated histogram of the results.
  prefs: []
  type: TYPE_NORMAL
- en: Scala has a number of shortcut methods for quickly scanning through a list/collection,
    as seen in the `reduceLeft(_ max _)` statement. We can also find the minimum value
    by using `min` instead of `max` in the `reduceLeft` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the script, we get these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dca9b1e4-0b6e-49f2-ba91-be0381ea936f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see the crude histogram and the follow-on display of the current values
    of scalar variables in the script. Do note that I divided by three so that the
    results would fit on one page.
  prefs: []
  type: TYPE_NORMAL
- en: Scala closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A closure is a function. The function resultant value depends on the value of
    variable(s) declared outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this small script by way of illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We define a function named `multiplier`. The function expects an `Int` argument.
    For each argument, we take the argument and multiply it by the external `factor`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1c38549-bc39-43c4-a300-d9e8618ecc66.png)'
  prefs: []
  type: TYPE_IMG
- en: Closures have a nice feel as they do what you expect with little fanfare.
  prefs: []
  type: TYPE_NORMAL
- en: Scala higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A higher-order function either takes other functions as arguments or returns
    a function as its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this example script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We define two functions: one squares the number passed, and the other cubes
    the number passed.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a higher-order function that takes a number to work on and a
    processor to apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we call each function. For example, we call `process()` with `5` and
    the `squared` function. The `process()` function passes `5` to the `squared()`
    function and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cafafeae-b8fc-4543-ad8c-49c02cb40cf3.png)'
  prefs: []
  type: TYPE_IMG
- en: We take advantage of Scala's engine automatically printing out variable values
    to see the  expected result.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are not doing very much. When I ran them, it took a few seconds
    for the results to display. I think there is a big performance hit using higher-order
    functions in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Scala pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala has very useful, built-in pattern matching. Pattern matching can be used
    to test for exact and/or partial matches of entire values, parts of objects, you
    name it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this sample script for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We define a function called `matchTest`. The `matchTest` function takes any
    kind of argument and can return any type of result. (Not sure if that is real-life
    programming).
  prefs: []
  type: TYPE_NORMAL
- en: The keyword of interest is `match`. This means the function will walk down the
    list of choices until it gets a match on to the `x` value passed and then returns.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have numbers and strings as input and output.
  prefs: []
  type: TYPE_NORMAL
- en: The last `case` statement is a wildcard, and `_` is `catchall`, meaning that
    if the code gets that far, it will match any argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daebe713-33d9-4c05-ba21-6bd051a54120.png)'
  prefs: []
  type: TYPE_IMG
- en: Scala case classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `case` class is a simplified type that can be used without calling `new Classname(..)`.
    For example, we could have this script that defines a `case` class and uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, we have a `case` class called `Car`. We make an instance of that class called
    `buickLeSabre`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `case` classes are most useful for pattern matching, since we can easily
    construct complex objects and examine their content. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We define a pattern `match` block (as in the previous section of this chapter).
    In the `match` block, we look at a `Car` object that has `brand` as `GM` and `model`
    as `Denali`, and so forth. For each of the models of interest, we classify its
    type. We also have the `catchall _` at the end so we can catch unexpected values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can exercise the `case` classes in Jupyter, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76e06323-2a6a-4072-b8a3-89c13a0d27ab.png)'
  prefs: []
  type: TYPE_IMG
- en: We defined and used the `case` class as `Car`. We then did pattern matching
    using the `Car` class.
  prefs: []
  type: TYPE_NORMAL
- en: Scala immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutable means you cannot change something. In Scala, all variables are immutable,
    unless specifically marked otherwise. This is the opposite to languages such as
    Java, where all variables are mutable unless specifically marked otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we can have the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can modify the value of `amount` inside the `calculate` function. We can
    tell Java not to allow changing the value if we use the `final` keyword, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar routine leaves the value of the `amount` variable as it was before
    the routine was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daf89191-deb2-483f-8bbc-b2b3757a783c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the display that even though `balance` is a variable (marked as
    `var`), Scala will not allow you to change its value inside the function. The
    `amount` parameter to the `calculate` function is assumed to be a `val` and cannot
    be changed once initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Scala collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, collections are automatically `mutable` or `immutable` depending
    on your usage. All collections in `scala.collections.immutable` are `immutable`.
    And vice-versa for `scala.collections.immutable`. Scala picks `immutable` collections
    by default, so your code will then draw automatically from the `mutable` collections,
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can prefix your variable with `immutable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this in this short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in this Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cc19d53-856b-400e-91ea-122c47b02234.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that Scala cheated a little here: it created a new `collection` when we
    updated `immutableList`, as you can see with the variable name `real_3` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Named arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala allows you to specify parameter assignment by name rather than just ordinal
    position. For example, we can have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this in a Notebook, we can see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed4ba648-b628-4de2-9abc-4632f7b2be1a.png)'
  prefs: []
  type: TYPE_IMG
- en: The first call divides the assigned parameters by position. The second call
    sets the parameters specifically, rather than using standard ordinal position
    assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Scala traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `trait` function in Scala defines a set of features that can be implemented
    by classes. A `trait` interface is similar to an interface in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The `trait` function can be partially implemented, forcing the user (class)
    of `trait` to implement the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of an example, we could have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a `trait` called `Color`, with one partially implemented function, `isRed`.
    So, every class that uses `Color` will have to implement `isRed()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then implement two classes, `Red` and `Blue`, that extend the `Color` trait
    (this is the Scala syntax for using `trait`). Since the `isRed()` function is
    partially implemented, both classes have to provide implementations for the `trait`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how this operates in the following Notebook display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c55974d0-4def-45fb-b94d-0d5e6405088a.png)'
  prefs: []
  type: TYPE_IMG
- en: We see (in the output section at the bottom) that `trait` and `class` are created,
    and that two instances are created, along with the result of calling the `trait`
    function for both classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we installed Scala for Jupyter. We used Scala coding to access
    larger datasets. We saw how Scala can manipulate arrays. We generated random numbers
    in Scala. There were examples of higher-order functions and pattern matching.
    We used `case` classes. We saw examples of immutability in Scala. We built collections
    using Scala packages. Finally, we looked at Scala traits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at using big data in Jupyter.
  prefs: []
  type: TYPE_NORMAL
