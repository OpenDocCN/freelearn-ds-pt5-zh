- en: Introduction to Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"I''m Scala. I''m a scalable, functional and object-oriented programming language.
    I can grow with you and you can play with me by typing one-line expressions and
    observing the results instantly"*'
  prefs: []
  type: TYPE_NORMAL
- en: '- Scala Quote'
  prefs: []
  type: TYPE_NORMAL
- en: 'In last few years, Scala has observed steady rise and wide adoption by developers
    and practitioners, especially in the fields of data science and analytics. On
    the other hand, Apache Spark which is ;written in Scala is a fast and general
    engine for large-scale data processing. Spark''s success is due to many factors:
    easy-to-use API, clean programming model, performance, and so on. Therefore, naturally,
    Spark has more support for Scala: more APIs are available for Scala compared to
    Python or Java; although, new Scala APIs are available before those for Java,
    Python, and R.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that before we start writing your data analytics program using Spark and
    Scala (part II), we will first get familiar with Scala's functional programming
    concepts, object oriented features and the Scala collection APIs in detail (part
    I). As a starting point, we will provide a brief introduction to Scala in this
    chapter. We will cover some basic aspects of Scala including it's history and
    purposes. Then we will see how to install Scala on different platforms including
    Windows, Linux, and Mac OS so that your data analytics programs can be written
    on your favourite editors and IDEs. Later in this chapter, we will provide a comparative
    analysis between Java and Scala. Finally, we will dive into Scala programming
    with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: History and purposes of Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platforms and editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and setting up Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scala: the scalable language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala for Java programmers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala for the beginners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History and purposes of Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala is a general-purpose programming language that comes with support of `functional
    programming` and a strong `static type` system. The source code of Scala is intended
    to be compiled into `Java` bytecode, so that the resulting executable code can
    be run on `Java virtual machine` (JVM).
  prefs: []
  type: TYPE_NORMAL
- en: Martin Odersky started the design of Scala back in 2001 at the **École Polytechnique
    Fédérale de Lausanne** (**EPFL**). It was an extension of his work on Funnel,
    which is a programming language that uses functional programming and Petri nets.
    The first public release appears in 2004 but with only on the Java platform support.
    Later on, it was followed by .`NET` framework in June 2004.
  prefs: []
  type: TYPE_NORMAL
- en: Scala has become very popular and experienced wide adoptions because it not
    only supports the object-oriented programming paradigm, but it also embraces the
    functional programming concepts. In addition, although Scala's symbolic operators
    are hardly easy to read, compared to Java, most of the Scala codes are comparatively
    concise and easy to read -e.g. Java is too verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other programming languages, Scala was prosed and developed for specific
    purposes. Now, the question is, why was Scala created and what problems does it
    solve? To answer these questions, Odersky said in his blog: ;'
  prefs: []
  type: TYPE_NORMAL
- en: '"The work on Scala stems from a research effort to develop better language
    support for component software. There are two hypotheses that we would like to
    validate with the Scala experiment. First, we postulate that a programming language
    for component software needs to be scalable in the sense that the same concepts
    can describe small as well as large parts. Therefore, we concentrate on mechanisms
    for abstraction, composition, and decomposition, rather than adding a large set
    of primitives, which might be useful for components at some level of scale but
    not at other levels. Second, we postulate that scalable support for components
    can be provided by a programming language which unifies and generalizes object-oriented
    and functional programming. For statically typed languages, of which Scala is
    an instance, these two paradigms were up to now largely separate."'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, pattern matching and higher order functions, and so on, are also
    provided in Scala, not to fill the gap between FP and OOP, but because ;they are
    typical features of functional programming. For this, it has some incredibly powerful
    pattern-matching features, which are an actor-based concurrency framework. Moreover,
    it has the support of the first- and higher-order functions. In summary, the name
    "Scala" is a portmanteau of scalable language, signifying that it is designed
    to grow with the demands of its users.
  prefs: []
  type: TYPE_NORMAL
- en: Platforms and editors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala runs on **Java Virtual Machine** (**JVM**), which makes Scala a good
    choice for Java programmers too who would like to have a functional programming
    flavor in their codes. There are lots of options when it comes to editors. It''s
    better for you to spend some time making some sort of a comparative study between
    the available editors because being comfortable with an IDE is one of the key
    factors for a successful programming experience. Following are some options to
    choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Scala IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala plugin for Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emacs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VIM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala support programming on Eclipse has several advantages using numerous beta
    plugins. Eclipse provides some exciting features such as local, remote, and high-level
    debugging facilities with semantic highlighting and code completion for Scala.
    You can use Eclipse for Java as well as Scala application development with equal
    ease. However, I would also suggest Scala IDE ([http://scala-ide.org/](http://scala-ide.org/))--it's
    a full-fledged Scala editor based on Eclipse and customized with a set of interesting
    features (for example, Scala worksheets, ScalaTest support, Scala refactoring,
    and so on). ;
  prefs: []
  type: TYPE_NORMAL
- en: The second best option, in my view, is the IntelliJ IDEA. The first release
    came in 2001 as the first available Java IDEs with advanced code navigation and
    refactoring capabilities integrated. According to the InfoWorld report (see at
    [http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html](http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html)),
    out of the four top Java programming IDE (that is, Eclipse, IntelliJ IDEA, NetBeans,
    and JDeveloper), IntelliJ received the highest test center score of 8.5 out of
    10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding scoring is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)**Figure 1:** Best IDEs for Scala/Java developers'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding ;figure, you may be interested in using other IDEs such as
    NetBeans and JDeveloper too. Ultimately, the choice is an everlasting debate among
    the developers, which means the final choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned, Scala uses JVM, therefore make sure you have Java
    installed ;on your machine. If not, refer to the next subsection, which shows
    how to install Java on Ubuntu. In this section, at first, we will show you how
    to install Java 8 on Ubuntu. Then, we will see how to install Scala on Windows,
    Mac OS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simplicity, we will show how to install Java 8 on an Ubuntu 14.04 LTS 64-bit
    machine. But for Windows and Mac OS, it would be better to invest some time on
    Google to know how. For a minimum clue for the Windows users: refer to this link
    for details [https://java.com/en/download/help/windows_manual_download.xml](https://java.com/en/download/help/windows_manual_download.xml)[.](https://java.com/en/download/help/windows_manual_download.xml.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to install Java 8 on Ubuntu with step-by-step commands
    and instructions. At first, check whether ;Java is already installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If it returns `The program java cannot be found in the following packages`,
    Java hasn''t been installed yet. Then you would like to execute the following
    command to get rid of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will install the **Java Runtime Environment** (**JRE**). However, if you
    may instead need the **Java Development Kit** (**JDK**), which is usually needed
    to compile Java applications on Apache Ant, Apache Maven, Eclipse, and IntelliJ
    IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Oracle JDK is the official JDK, however, it is no longer provided by Oracle
    as a default installation for Ubuntu. You can still install it using apt-get.
    To install any version, first execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, depending on the version you want to install, execute one of the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing, don''t forget to set the Java home environmental variable.
    Just apply the following ;commands (for the simplicity, we assume that Java is
    installed at `/usr/lib/jvm/java-8-oracle`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the `Java_HOME` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should observe the following result on Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check to make sure that Java has been installed successfully by
    issuing the following command (you might see the latest version!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Now you have Java installed on your machine, thus you're ready Scala
    codes once it is installed. Let's do this in the next few subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part will focus on installing Scala on the PC with Windows 7, but in the
    end, it won''t matter which version of Windows you to run at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to download a zipped file of Scala from the official site.
    You will find it at [https://www.Scala-lang.org/download/all.html](https://www.scala-lang.org/download/all.html).
    Under the other resources section of this page, you will find a list of the archive
    files from which you can install Scala. We will choose to download the zipped
    file for Scala 2.11.8, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00174.gif)**Figure 2:** Scala installer for Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the downloading has finished, unzip the file and place it in your favorite
    folder. You can also rename the file Scala for navigation flexibility. Finally,
    a `PATH` variable needs to be created for Scala to be globally seen on your OS.
    For this, navigate to Computer | Properties, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)**Figure 3:** Environmental variable tab on windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Environment Variables from there and get the location of the `bin` folder
    of Scala; then, append it to the `PATH` environment variable. Apply the changes
    and then press OK, ;as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)**Figure 4:** Adding environmental variables for Scala'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are ready to go for the Windows installation. Open the CMD and just
    type `scala`. If you were successful in the installation process, then you should
    see an output similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)**Figure 5:** Accessing Scala from "Scala shell"'
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time now to install Scala on your Mac. There are lots of ways in which
    you can install Scala on your Mac, and here, we are going to mention two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Homebrew installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first, check your system to see whether it has Xcode installed or not because
    it's required in this step. You can install it from the Apple App Store free of
    charge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you need to install `Homebrew` from the terminal by running the following
    command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The preceding ;command is changed by the Homebrew guys from time to time.
    If the command doesn''t seem to be working, check the Homebrew website for the
    latest incantation: [http://brew.sh/](http://brew.sh/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to go and install Scala by typing this command `brew install
    scala` ;in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you are ready to go by simply typing Scala in your terminal (the second
    line) and you will observe the following on your terminal: ;'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00226.jpeg)**Figure 6**: Scala shell on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: Installing manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before installing Scala manually, choose your preferred version of Scala and
    download the corresponding `.tgz` file of that version `Scala-verion.tgz` from
    [http://www.Scala-lang.org/download/](http://www.scala-lang.org/download/). After
    downloading your preferred version of Scala, extract it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, move it to `/usr/local/share` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make the installation permanent, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now, let's see how it can be done on Linux distributions like Ubuntu
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we will show you the installation procedure of Scala on
    the Ubuntu distribution of Linux. Before starting, let''s check to make sure Scala
    is installed properly. Checking this is straightforward using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If Scala is already installed on your system, you should get the following
    message on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, during the writing of this installation, we used the latest version
    of Scala, that is, 2.11.8\. If you do not have Scala installed on your system,
    make sure you install it before proceeding to the next step. ; You can download
    the latest version of Scala from the Scala website at [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)
    (for a clearer view, refer to *Figure 2*). For ease, let''s download Scala 2.11.8,
    as follows: ;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After the download has been finished, you should find the Scala tar file in
    the download folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user should first go into the `Download` directory with the following command:
    `$ cd /Downloads/`. Note that the name of the downloads folder may change depending
    on the system''s selected language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the Scala `tar` file from its location or more, type the following
    command. Using this, the Scala tar file can be extracted from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move the Scala distribution to the user''s perspective (for example, `/usr/local/scala/share`)
    by typing the following command or doing it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Move to your home directory issue using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set the Scala home using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make the change permanent for the session by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation has been completed, you should better to verify it using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If Scala has successfully been configured on your system, you should get the
    following message on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! Now, let''s enter into the Scala shell by typing the ;`scala` command
    on the terminal, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/00033.jpeg)****Figure 7:** Scala shell on Linux (Ubuntu distribution)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can also install Scala using the apt-get command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command will download the latest version of Scala (that is, 2.12.x). However,
    Spark does not have support for Scala 2.12 yet (at least when we wrote this chapter).
    Therefore, we would recommend the manual installation described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala: the scalable language'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The name Scala comes from a scalable language because Scala''s concepts scale
    well to large programs. Some programs in other languages will take tens of lines
    to be coded, but in Scala, you will get the power to express the general patterns
    and concepts of programming in a concise and effective manner. In this section,
    we will describe some exciting features of Scala that Odersky has created for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: Scala is object-oriented
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala is a very good example of an object-oriented language. To define a type
    or behavior for your objects you need to use the notion of classes and traits,
    which will be explained later, in the next chapter. Scala doesn't support direct
    multiple inheritances, but to achieve this structure, you need to use Scala's
    extension of the **subclassing** and **mixing-based composition**. This will be
    discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Scala is functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming treats functions like first-class citizens. In Scala,
    this is achieved with syntactic sugar and objects that extend traits (like *Function2*),
    but this is how functional programming is achieved in Scala. Also, Scala defines
    a simple and easy way to define **anonymous** **functions** (functions without
    names). It also supports higher-order functions and it allows nested functions**.**
    The syntax of these concepts will be explained in deeper details in the coming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it helps you to code in an immutable way, and by this, you can easily
    apply it to parallelism with synchronization and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Scala is statically typed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the other statically typed languages like Pascal, Rust, and so on, Scala
    does not expect you to provide redundant type information. You don't have to specify
    the type in most cases. Most importantly, you don't even need to repeat them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'A programming language is called statically typed if the type of a variable
    is known at compile time: this also means that, as a programmer, you must specify
    what the type of each variable is. For example, Scala, Java, C, OCaml, Haskell,
    and C++, and so on. On the other hand, Perl, Ruby, Python, and so on are dynamically
    typed languages, where the type is not associated with the variables or fields,
    but with the runtime values.'
  prefs: []
  type: TYPE_NORMAL
- en: The statically typed nature of Scala ensures that all kinds of checking are
    done by the compiler. This extremely powerful feature of Scala helps you find/catch
    most trivial bugs and errors at a very early stage, before being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Scala runs on the JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Java, Scala is also compiled into bytecode which can easily be executed
    by the JVM. This means that the runtime platforms of Scala and Java are the same
    because both generate bytecodes as the compilation output. So, you can easily
    switch from Java to Scala, you can ;and also easily integrate both, or even use
    Scala in your Android application to add a functional flavor. ;
  prefs: []
  type: TYPE_NORMAL
- en: Note that, while using Java code in a Scala program is quite easy, the opposite
    is very difficult, mostly because of Scala's syntactic sugar.
  prefs: []
  type: TYPE_NORMAL
- en: Also, just like the `javac` command, which compiles Java code into bytecode,
    Scala has the `scalas` command, which compiles the Scala code into bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: Scala can execute Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, Scala can also be used to execute your Java code. Not
    just installing your Java code; it also enables you to use all the available classes
    from the Java SDK, and even your own predefined classes, projects, and packages
    right in the Scala environment.
  prefs: []
  type: TYPE_NORMAL
- en: Scala can do concurrent and ;synchronized processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some programs in other languages will take tens of lines to be coded, but in
    Scala, you will get the power to express the general patterns and concepts of
    programming in a concise and effective manner. Also, it helps you to code in an
    immutable way, and by this, you can easily apply it to parallelism with synchronization
    and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Scala for Java programmers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala has a set of features that completely differ from Java. In this section,
    we will discuss some of these features. This section will be helpful for those
    who are from a Java background or are at least familiar with basic Java syntax
    and semantics.
  prefs: []
  type: TYPE_NORMAL
- en: All types are objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, every value in Scala will look like an object. This statement
    means everything looks like an object, but some of them do not actually object
    and you will see the interpretation of this in the coming chapters (for example,
    ;the difference between the reference types and the primitive types still exists
    in Scala, but it hides it for the most part). For example, in Scala, strings are
    implicitly converted to collections of characters, but not in Java!
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not familiar with the term, it is nothing but the deduction of types
    at compile time. Hold on, isn't that what dynamic typing means? Well, no. Notice
    that I said deduction of types; this is drastically different from what dynamically
    typed languages do, and another thing is, it is done at compile time and not runtime.
    Many languages have this built in, but the implementation varies from one language
    to another. This might be confusing at the beginning, but it will become clearer
    with code examples. Let's jump into the Scala REPL for some experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Scala REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Scala REPL is a powerful feature that makes it more straightforward and
    concise to write Scala code on ;the Scala shell. **REPL** stands for **Read-Eval-Print-Loop**
    also called **the Interactive Interpreter**. This means it is a program for:'
  prefs: []
  type: TYPE_NORMAL
- en: ;Reading the expressions you type in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluating the expression in step 1 using the Scala compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printing out the result of the evaluation in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Waiting (looping) for you to enter further expressions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)**Figure 8:** Scala REPL example 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the figure, it is evident that there is no magic, the variables are inferred
    automatically to the best types they deem fit at compile time. If you look even
    more carefully, when I tried to declare: ;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the Scala shell throws an error saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'According to Odersky, *"Mapping a character to the character map over a RichString
    should again yield a RichString, as in the following interaction with the Scala
    REP"*. The preceding statement can be proved using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, if someone applies a method from `Char` to `Int` to a `String`, then
    what happens? In that case, Scala converts them, as a vector of integer also called
    immutable is a feature of Scala collection, as shown in *Figure 9*. We will look
    at the details on Scala collection API in [Chapter 4](part0117.html#3FIHQ1-21aec46d8593429cacea59dbdcd64e1c),
    *Collections APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Both static and instance methods of objects are also available. For example,
    if you declare `x` as a string `hello` and then try to access both the static
    and instance methods of objects `x`, they are available. In the Scala shell, type
    `x` then `.` and `<tab>` and then you will find the available methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is all accomplished on the fly via reflection, even anonymous classes
    you''ve only just defined are equally accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding two examples can be shown on the Scala shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00232.gif)**Figure 9:** Scala REPL example 2'
  prefs: []
  type: TYPE_NORMAL
- en: '"So it turns out that map yields different types depending on what the result
    type of the passed function argument is!"'
  prefs: []
  type: TYPE_NORMAL
- en: '- Odersky'
  prefs: []
  type: TYPE_NORMAL
- en: Nested functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why will you require a nested functions support in your programming language?
    Most of the time, we want to maintain our methods to be a few lines and avoid
    overly large functions. A typical solution for this in Java would be to define
    all these small functions on a class level, but any other method could easily
    refer and access them even though they are helper methods. The situation is different
    in Scala, so you can use define functions inside each other, and this way, prevent
    any external access to these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We are not expecting you to understand these code snippets, which show the difference
    between Scala and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Import statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, you can only import packages at the top of your code file, right after
    the packages statement. The situation is not the same in Scala; you can write
    your import statements almost anywhere inside your source file (for example, you
    can even write your import statements inside a class or a method). You just need
    to pay attention to the scope of your import statement, because it inherits the
    same scope of the members of your class or local variables inside your method.
    The `_` (underscore) in Scala is used for wildcard imports, which is similar to
    the `*` (asterisk) that you would use in java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also use these `{ }` to indicate a set of imports from the same parent
    package, just in one line of code. In Java, you would use multiple lines of code
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the Java, Scala does not have the concept of static imports. In other
    words, the concept of static doesn''t exist in Scala. However, as a developer,
    obviously, you can import a member or more than one member of an object using
    a regular import statement. The preceding example already shows this, where we
    import the methods sin and cos from the package object named math. To demonstrate
    an example, the preceding ;code snippet can be defined from the Java programmer''s
    perspective as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Another beauty of Scala is that, in Scala, you can rename your imported packages
    as well. Alternatively, you can rename your imported packages to avoid the type
    conflicting with packages that have similar members. The following statement is
    valid in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you may want to exclude a member of packages for collisions or other
    purposes. For this, you can use a wildcard to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Operators as methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's worth mentioning that Scala doesn't support the operator overloading. You
    might think that there are no operators at all in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative syntax for calling a method taking a single parameter is the
    use of the infix syntax. The infix syntax provides you with a flavor just like
    you are applying an operator overloading, as like what you did in C++. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following case, the `+` ;means a method in class `Int`. ; The following
    ;code is a non-conventional method calling syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'More formally, the same can be done using the infix syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, you can utilize the infix syntax. However, the method has only a
    single parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one special case when using the infix syntax. That is, if the method
    name ends with a `:` (colon), then the invocation or call will be right associative.
    This means that the method is called on the right argument with the expression
    on the left as the argument, instead of the other way around. For example, the
    following is valid in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding ;statement signifies that: `my_list.+:(5)` rather than `5.+:(my_list)`
    and more formally: ;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the preceding examples on Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the above, operators here are just methods, so that they can
    simply be overridden just like methods.
  prefs: []
  type: TYPE_NORMAL
- en: Methods and parameter lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, a method can have multiple parameter lists or even no parameter list
    at all. On the other hand, in Java, a method always has one parameter list, with
    zero or more parameters. For example, in Scala, the following is the valid method
    definition (written in `currie notation`) where a method has two parameter lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding ;method cannot be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A method, let''s say ;`sum2`, can have no parameter list at all, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can call the method `add2`, which returns a function taking one parameter.
    Then, it calls that function with the argument `5`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Methods inside methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you would like to make your applications, code modular by avoiding
    too long and complex methods. Scala provides you this facility to avoid your methods
    becoming overly large so that you can split them up into several smaller methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, Java allows you only to have the methods defined at class
    level. For example, suppose you have the following method definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can call the nested helper/auxiliary method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering the above, here''s the complete code segment which is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Constructor in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One surprising thing about Scala is that the body of a Scala class is itself
    a constructor. ; However, Scala does so; in fact, in a more explicit way. After
    that, a new instance of that class is created and executed. Moreover, you can
    specify the arguments of the constructor in the class declaration line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the constructor arguments are accessible from all of the methods
    defined in that class. For example, the following class and constructor definition
    is valid in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent Java class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Objects instead of static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, static does not exist in Scala. You cannot do static
    imports and neither can you cannot add static methods to classes. In Scala, when
    you define an object with the same name as the class and in the same source file,
    then the object is said to be the companion of that class*.* Functions that you
    define in this companion object of a class are like static methods of a class
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you can define a companion object for the class hello:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent class in Java would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'So, lot''s of verbose in this simple class, isn''t there? ; The apply method
    in Scala is treated in a different way, such that you can find a special shortcut
    syntax to call it. This is the familiar way of calling the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the shortcut syntax that is equivalent to the one earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that this only works if you used the apply method in your code because
    Scala treats methods that are named apply in this different way.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala provides a great functionality for you in order to extend and enrich
    your classes'' behaviors. These traits are similar to the interface in which you
    define the function prototypes or signatures. So, with this, you can have mix-ins
    of functionality coming from different traits and, in this way, you enriched your
    classes'' behavior. So, what''s so good about traits in Scala? They enable the
    composition of classes from these traits, with traits being the building blocks.
    As always, let''s look at in an example. This is how a conventional logging routine
    is set up in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, even though you can mix in any number of traits you want. Moreover,
    like Java, Scala does not have the support of multiple inheritances. However,
    in both Java and Scala, a subclass can only extend a single superclass. For example,
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For a more detailed discussion, refer to this URL [https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681](https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s different with traits. It''s very tiresome to always check for
    the log level being enabled. It would be good, if you could write this routine
    once and reuse it anywhere, in any class right away. Traits in Scala make this
    all possible. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the preceding code, you will see an example of using string starting
    with `s`. ; This way, Scala offers the mechanism to create strings from your data
    called **String Interpolation**. ;
  prefs: []
  type: TYPE_NORMAL
- en: 'String Interpolation, allows you to embed variable references directly in processed
    string literals. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: ; ; ;`scala> val name = "John Breslin"`
  prefs: []
  type: TYPE_NORMAL
- en: '`; ;scala> println(s"Hello, $name") ; // Hello, John Breslin`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can get an efficient logging routine in a more conventional style as
    a reusable block. To enable logging for any class, we just mix in our `Logging`
    trait! Fantastic! Now that''s all it takes to add a logging feature to your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It is even possible to mix-up multiple traits. For example, for the preceding
    ;trait (that is, `Logging`) you can keep extending in the following ;order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: However, it is noted that a Scala class can extend multiple traits at once,
    but JVM classes can extend only one parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to invoke the above traits and classes, use `new D()` from Scala REPL,
    as shown in the following ;figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00220.gif)**Figure 10**: Mixing multiple traits'
  prefs: []
  type: TYPE_NORMAL
- en: Everything has gone smoothly so far in this chapter. Now, let's move to a new
    section where we will discuss some topics for the beginner who wants to drive
    themselves into the realm of Scala programming.
  prefs: []
  type: TYPE_NORMAL
- en: Scala for the beginners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will find that we assume that you have a basic understanding
    of any previous programming language. If Scala is your first entry into the coding
    world, then you will find a large set of materials and even courses online that
    explain Scala for beginners. As mentioned, there are lots of tutorials, videos,
    and courses out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a whole Specialization, which contains this course, on Coursera: [https://www.coursera.org/specializations/scala](https://www.coursera.org/specializations/scala).
    Taught by the creator of Scala, Martin Odersky, this online class takes a somewhat
    academic approach to teaching the fundamentals of functional programming. You
    will learn a lot about Scala by solving the programming assignments. Moreover,
    this specialization includes a course on Apache Spark. Furthermore, Kojo ([http://www.kogics.net/sf:kojo](http://www.kogics.net/sf:kojo))
    is an interactive learning environment that uses Scala programming to explore
    and play with math, art, music, animations, and games.'
  prefs: []
  type: TYPE_NORMAL
- en: Your first line of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a first example, we will use the pretty common `Hello, world!` program in
    order to show you how to use Scala and its tools without knowing much about it.
    Let''s open your favorite editor (this example runs on Windows 7, but can be run
    similarly on Ubuntu or macOS), say Notepad++, and type the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save the code with a name, say `HelloWorld.scala`, as shown in the following
    figure: ;'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00235.jpeg)**Figure 11:** Saving your first Scala source code using
    Notepad++'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile the source file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: I'm ; the hello world program, explain me well!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program should be familiar to anyone who has some programming of experience.
    It has a main method which prints the string `Hello, world!` to your console.
    Next, to see how we defined the `main` function, we used the `def main()` strange
    syntax to define it. `def` is a Scala keyword to declare/define a method, and
    we will be covering more about methods and different ways of writing them in the
    next chapter. So, we have an `Array[String]` as an argument for this method, which
    is an array of strings that can be used for initial configurations of your program,
    and omit is valid. ;Then, we use the common `println()` method, which takes a
    string (or formatted one) and prints it to the console. A simple hello world has
    opened up many topics to learn; three in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: ● ; ; ;Methods (covered in a later chapter)
  prefs: []
  type: TYPE_NORMAL
- en: ● ; ; ;Objects and classes (covered in a later chapter)
  prefs: []
  type: TYPE_NORMAL
- en: ● ; ; ;Type inference - the reason why Scala is a statically typed language
    - explained earlier
  prefs: []
  type: TYPE_NORMAL
- en: Run Scala interactively!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scala` command starts the interactive shell for you, where you can interpret
    Scala expressions interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The shortcut `:q` stands for the internal shell command `:quit`, ;used to exit
    the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Compile it!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scalac` command, which is similar to `javac` command, compiles one or
    more Scala source files and generates a bytecode as output, which then can be
    executed on any Java Virtual Machine. To compile your hello world object, use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `scalac` generates the class files into the current working directory.
    You may specify a different output directory using the `-d` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: However, note that the directory called `classes` must be created before executing
    this command.
  prefs: []
  type: TYPE_NORMAL
- en: Execute it with Scala command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scala` command executes the bytecode that is generated by the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala allows us to specify command options, such as the `-classpath` (alias
    `-cp`) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using the `scala` command to execute your source file(s), you should
    have a main method that acts as an entry point for your application. Otherwise,
    you should have an `Object` that extends `Trait Scala.App`, then all the code
    inside this object will be executed by the command. The following is the same
    `Hello, world!` ;example, but using the `App` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding ;script can be run directly from the command shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: we assume here that the file `script.sh` has the execute permission:
    ;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Then, the search path for the `scala` command is specified in the `$PATH` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, you have learned the basics of the Scala programming
    language, its features, and available editor. We have also briefly discussed Scala
    and its syntax. We demonstrated the installation and setting up guidelines for
    beginners who are new to Scala programming. Later in the chapter, you learned
    how to write, compile, and execute a sample Scala code. Moreover, a comparative
    discussion about Scala and Java provided for those who are from a Java background.
    Here''s a short comparison between Scala and Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Scala is statically typed, but Python is dynamically typed. Scala (mostly) embraces
    the functional programming paradigm, while Python doesn't. Python has a unique
    syntax that lacks most of the parentheses, while Scala (almost) always requires
    them. In Scala, almost everything is an expression; while this isn't true in Python.
    However, there are a few points on the upside that are seemingly convoluted. The
    type complexity is mostly optional. Secondly, according to the documentation provided
    by [https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684](https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684),
    ; *Scala compiler is like free testing and documentation as cyclomatic complexity
    and lines of code escalate. When aptly implemented Scala can perform otherwise
    all but impossible operations behind consistent and coherent APIs.*
  prefs: []
  type: TYPE_NORMAL
- en: In next the chapter, we will discuss ;how to improve our experience on the basics
    to know how Scala implements the object oriented paradigm to allow building modular
    software systems.
  prefs: []
  type: TYPE_NORMAL
