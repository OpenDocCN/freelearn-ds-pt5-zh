- en: Building Your Technology Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technology choices have lasting consequences. A project's technology stack determines
    the functional and nonfunctional capabilities of your system, so it is critical
    to make thoughtful choices. The bidirectional link between technologies and requirements
    opens up an analytical approach for choosing between different technologies by
    matching their features against the project's needs. In this chapter, we will
    see how we can use software design practices to form project-specific technology
    stacks and see what technologies should constitute the core technology stack that's
    shared among all of your projects. We will also explore an approach that compares
    different technologies so that you can make a rational choice between apparently
    similar options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the elements of the technology stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between core- and project-specific technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing tools and products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the elements of a technology stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A technology stack is a set of tools that your team uses to deliver products
    and finish projects. When choosing technologies, you start by defining their goals
    and thoroughly documenting all the requirements. From there, you and your team
    can see what technologies will help you to reach the end goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaping a technology stack goes toe-to-toe with designing software architecture,
    so the engineers on your team should start by drafting a system design that will
    meet everyone''s requirements. Software architecture is a wide and deeply technical
    topic, so we won''t discuss it in depth in this chapter. Instead, we will present
    an overview of the necessary steps when it comes to choosing the best technologies
    for reaching specific goals. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect the requirements and define the goals clearly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose a set of architecture views for your project. An architecture view contains
    visual and textual descriptions of some of the aspects of the system. The most
    prominent examples of architecture views are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Infrastructure view**:Represents the physical parts of the system. Servers,
    storage arrays, and networks are documented inside this view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component view**: Represents the logical components of the software system
    that you are going to build. The component view should define the isolated parts
    of the system and the interfaces that they communicate through.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment view**: Matches the logical representation of the component view
    with the physical reality of the infrastructure view. The deployment view should
    describe how the system components will be delivered to the corresponding hardware.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other views**: Different methodologies for designing software architecture
    define many useful views. For example, the ArchiMate 2.1 specification defines
    18 architecture views that can be useful for different stakeholders. For the sake
    of brevity, we will cover only the main views that can affect the technology stack
    and omit the others.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a list of necessary functions for technologies that you will use for
    the development and operations of your system based on the requirements and software
    design that has been produced by your team. Don't forget to include cross-cutting
    technologies that will optimize the experimentation, development, delivery, and
    operations of your system. Cross-cutting technologies may not help you find any
    specific functional requirements but will be beneficial to the project in general.
    Experimental tracking frameworks, data version control systems, and **Continuous
    Integration**/**Continuous Deployment** (**CI**/**CD**) servers are all examples
    of cross-cutting technologies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, let''s build a technology stack for a customer churn prediction
    system. Our customer has defined the following list of requirements for the churn
    prediction module. We''ll omit the technical details so that we can focus on the
    overall process:'
  prefs: []
  type: TYPE_NORMAL
- en: Process the data from the marketing database. This contains customer information.
    The size of the dataset is under 5 GB of raw data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Train the churn prediction model on a weekly basis, every Monday. We should
    consider customers that have made no purchases for a month as churned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notify the team about the potential customer churn by using remote API calls.
    The service should be available on business days.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Decomposition classifies every requirement into two categories: **functional
    requirement** (**FR**) and **nonfunctional requirement** (**NFR**). FRs includes
    all the requirements that are related to the functions of the system that affect
    core use cases and end users. NFRs includes all the requirements that apply to
    the system in general and define a set of constraints in which the system will
    work. Service-level agreements and availability requirements are good examples
    of NFRs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The team has decomposed customer requirements into the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FR**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FR1**: The system must be integrated with the customer''s marketing database.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FR2**: The system must provide a customer churn prediction model. We can
    consider customers that have made no purchases for a month as churned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FR3**: The system must call a remote API to notify the marketing department
    about potential customer churn.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FR4**: The model should be executed every Monday.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NFR**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NFR1**: The system should handle processing 5 GB of data every week.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NFR2**: The API should be available on business days.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this requirements list, the team has come up with the following system
    design, which has been drawn in ArchiMate 2.1 notation using the Archi software
    ([https://www.archimatetool.com/](https://www.archimatetool.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ac1874f-587f-4e17-a53c-fc3f74c5f810.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram consists of two levels: the infrastructure and software
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The software level describes the relationships between different components
    and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raw customer data: **Represents the raw data that''s used by the churn prediction
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model training pipeline: **Represents a set of data processing and model
    training steps, grouped as a software component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model prediction pipeline: **Represents the component that''s responsible
    for taking trained models to make churn predictions and generate customer churn
    alerts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler: **Orchestrates the work of other components by running pipelines
    based on a schedule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer churn alerts:** Notification events about potential customer churn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marketing CRM system: **The customer''s CRM system, which has already been
    deployed and used in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification API: **A service that allows us to create notifications about
    customers inside the CRM system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The infrastructure level, which describes the physical allocation of software
    to specific hardware resources, has three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Marketing database server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CRM server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding software architecture diagram omits many technical details for
    the sake of simplicity since our goal is to demonstrate how to make technology
    choices. The core idea of the following text is not to deepen your knowledge of
    the vast area of software architecture, but to give you a general feel for the
    process where requirements flow into sound technology choices. Understanding this
    process can help you guide your team of experts toward an efficient technology
    stack choice. The project did not seem very complicated to the team, and the task
    was fairly standard for them. The team has decided to use a general set of cross-cutting
    technologies that they use for every project as a corporate standard:'
  prefs: []
  type: TYPE_NORMAL
- en: Python as a programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git for source version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data version control** (**DVC**) for data version control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab CI/CD as a CI/CD server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jupyter Notebook for data analysis and visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement FR, they have decided to use the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FR1**: The SQLAlchemy library for database access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FR2**: scikit-learn as a machine learning library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FR3**: Requests for API calls. The team has also decided to use a separate
    database to store prediction results and model execution logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FR4**: The team has decided to use cron (a popular Unix scheduler that can
    run commands based on a predefined scheduling table) as the main scheduling solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement NFR, they have decided to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NFR1**: Perform load tests and determine the minimum necessary server configuration
    for model training. From the team''s previous experience, a virtual server with
    8 CPU, 1 GB RAM, and 15 GB HDD should be sufficient, so they set this configuration
    as a baseline for tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NFR2**: The team has decided to request more detailed information on API
    usage and ask how many requests they can expect per day. It turns out that the
    API will be executed up to 10 times a day, so a single API server should suffice
    for this availability requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we have explored how to develop a project-specific technology
    stack. However, there is another important dimension where technology choice matters:
    your team''s expertise and skills. In the next section, we will look at the relationship
    between the team and project technology stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between core- and project-specific technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technology choices should help with project requirement realization, but it
    is also crucial to take your team''s expertise and capabilities into account,
    as well as the constraints. For example, if your team consists entirely of Python
    developers, choosing Julia as a primary programming language may be a bad idea,
    even if the team sees it as a better fit for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the team members will spend time learning a new language, practically
    destroying all productivity gains from using the technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team's conclusions may be over-optimistic because of their lack of experience
    with the new technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those two risks abate if your team pursues a growth mindset and gains new knowledge
    continuously, but they never vanish completely.
  prefs: []
  type: TYPE_NORMAL
- en: The core expertise in your team puts limits on what technologies you can use
    in projects. If you want more options, it is important to develop a team technology
    stack separately. Continuous internal research processes should keep your core
    technology step up to date. Project-specific technology stacks can be formed by
    adapting the core technology stack for your project's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the internal technology research process as a separate long-running
    project, which is best managed by using Kanban:'
  prefs: []
  type: TYPE_NORMAL
- en: Someone on the team spots a potentially useful technology.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The experienced team members do a quick review of this technology. If the technology
    looks promising, they put it into the internal research backlog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the team manager decides that some time can be invested in internal research
    processes, they start a backlog grooming session. There, the team prioritizes
    tasks in the backlog and enriches their definitions according to the **specific
    measurable achievable relevant time-bound** (**SMART**) criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assignee takes a single task from the backlog and tries to finish it as
    quickly as possible. If they encounter a blocking problem, it should be instantly
    reported and solved, preferably with the help of other team members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the research has been done, the assignee reports the results in the form
    of a document or a talk so that the team can decide on whether they will include
    the technology in the core technology stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the decision is positive, it is crucial to create an educational program
    for wider internal technology adoption. The main result of this task is to prepare
    a workshop, guide, instruction booklet, or some other educational material that
    new and existing team members can use to familiarize themselves with the technology.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The core technology stack should not include overly specific technologies that
    are applicable to only a small set of projects. The sole purpose of this content
    is to help your team form a technological basis that solves the majority of requirements
    that arise in your projects. The more widely focused your team is, the more general
    the core technology stack should be. If the entire team is building a specific
    product, then project-specific and core technology stacks start to merge into
    a single entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of adapting the core technology stack into a new project is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine a set of project requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See what requirements are satisfied by the core technology stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If some requirements are violated by the core technology stack, search for alternatives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If some requirements are not met by the core technology stack, search for additions
    that can be integrated into the core technology stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the project, evaluate the new technologies that were added to
    the project and decide whether they are a good fit for the core technology stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using these processes, you can turn often chaotic and desire-driven technology
    choices into a consistent and logical series of steps that lead to meaningful
    decisions. However, even the most deliberate requirement decompositions may leave
    your team wondering which technology to choose because there are many intersections
    and alternatives between different frameworks, libraries, and platforms. In the
    next section, we will explore how we can choose from a variety of technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing tools and products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Should we choose R or Python?* *What''s better, TensorFlow or PyTorch?* A
    list of endless quarrels about which is the best X for doing Y can be found all
    over the internet. Those discussions are ceaseless simply because there is no
    silver bullet in the technology world. Every team of professionals has their specific
    use cases, which makes a certain technology choice work for them. There is no
    technology that will equally satisfy everyone.'
  prefs: []
  type: TYPE_NORMAL
- en: X versus Y disputes often happen inside project teams, which is the most unproductive
    activity engineers can spend their time on. If you try to transition from X versus
    Y debates to searching for technologies that fit your specific needs (which are
    clearly stated, classified, and documented), you will get far more useful results
    in less time. Choosing the most modern or fashionable technologies is the closest
    analogy for playing Russian roulette for data scientists and software engineers.
    Let's explore how we can make thoughtful decisions about technology stacks.
  prefs: []
  type: TYPE_NORMAL
- en: To make meaningful technology choices, you need to make the process more systematic.
    First, you need to derive a set of comparison criteria that will allow you to
    benchmark different technologies and provide a template for research activities.
    These criteria should test different dimensions or groups of requirements that
    make the technology useful in your specific case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the specifics of comparing different technologies by looking at
    a case study.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – forecasting demand for a logistics company
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we need to choose a time series forecasting framework for
    our project. Our team works primarily in Python and has to provide a tool that
    will provide forecasts for time series data. The main goal of this system is to
    forecast demand on a set of given products that are shipped by the company. The
    team has discovered that there are many different forecasting frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To choose between these products, the team has created the following comparison
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **Requirement** **definition** | **Substantiation** | **Score**
    | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| **Ease of development** |'
  prefs: []
  type: TYPE_TB
- en: '| D1 | Compatible with Python | Python is the major programming language for
    the team. | 3 | Mandatory |'
  prefs: []
  type: TYPE_TB
- en: '| D2 | Compatible with scikit-learn interfaces | The team has good expertise
    in the `scikit-learn` library. It would be beneficial if the time-series forecasting
    library were compatible with `scikit-learn`. | 2 | Important |'
  prefs: []
  type: TYPE_TB
- en: '| D3 | Has good documentation |  | 1 | Supplementary |'
  prefs: []
  type: TYPE_TB
- en: '| D4 | Forecasting can be done in under 10 lines of code |  | 1 | Supplementary
    |'
  prefs: []
  type: TYPE_TB
- en: '| D5 | Can handle timeseries as a native data type | The framework should work
    with raw time series data so that the team doesn''t spend additional time on dataset
    preparation and feature engineering. | 2 | Important |'
  prefs: []
  type: TYPE_TB
- en: '| **Forecasting algorithm requirements** |'
  prefs: []
  type: TYPE_TB
- en: '| F1 | Does not require manual hyperparameter tuning | Since the library will
    be used with a large number of time series, manual model tuning is not practical.
    The tool should support automated hyperparameter tuning or be robust when it comes
    to which hyperparameter is chosen, thus providing good forecasts with the default
    settings. | 3 | Mandatory |'
  prefs: []
  type: TYPE_TB
- en: '| F2 | Provides several forecasting methods | The availability of several forecasting
    methods will allow us to evaluate several models and choose the one that fits
    the best for each specific time series. | 1 | Supplementary |'
  prefs: []
  type: TYPE_TB
- en: '| F3 | Works with seasonal time series | All the time series in the customer
    data have seasonal patterns. | 3 | Mandatory |'
  prefs: []
  type: TYPE_TB
- en: '| F4 | Provides confidence bounds, along with forecasts | Confidence intervals
    can be used to provide uncertainty bounds for each forecast, which the customer
    considers a useful feature. | 2 | Important |'
  prefs: []
  type: TYPE_TB
- en: '| **Performance and data requirements** |'
  prefs: []
  type: TYPE_TB
- en: '| P1 | Forecasts for time series with 100 data points can be done in under
    15 seconds | A large number of time series limits the total amount of time we
    can spend on a single time series. | 2 | Important |'
  prefs: []
  type: TYPE_TB
- en: '| P2 | Can handle time series with a variable length and empty data | Data
    quality is not ideal and some gaps are present in the data. Some items have more
    historical data than others. | 2 | Important |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding comparison table consists of the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID**: This can be used as a short identifier in the technology comparison
    table (provided next).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requirement definition**: This should describe the capability of interest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Substitution**: This should provide the motivation behind the requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Score**: This shows the relative importance of the requirement and will be
    used to summarize each requirement category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: This indicates the necessity of each requirement and will provide
    additional scores for each technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, the team has prepared a list of frameworks to compare, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pmdarima** ([https://www.alkaline-ml.com/pmdarima/](https://www.alkaline-ml.com/pmdarima/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**statsmodels.tsa** ([https://www.statsmodels.org/stable/tsa.html](https://www.statsmodels.org/stable/tsa.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prophet** ([https://github.com/facebook/prophet](https://github.com/facebook/prophet))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LightGBM** ([https://lightgbm.readthedocs.io/en/latest/](https://lightgbm.readthedocs.io/en/latest/))
    and **tsfresh** ([https://tsfresh.readthedocs.io/en/latest/](https://tsfresh.readthedocs.io/en/latest/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The team has also come up with the following comparison table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  | **Framework** | **D1 (M)** | **D2 (I)** | **D3 (S)** | **D4 (S)** | **D5
    (I)** | **F1 (M)** | **F2 (S)** | **F3 (M)** | **F4 (I)** | **P1 (I)** | **P2
    (I)** | **pmdarima** | 3 | 2 | 0 | 2 | 3 | 3 | 0 | 3 | 2 | 0 | 0 | **statsmodels.tsa**
    | 3 | 0 | 2 | 0 | 3 | 0 | 1 | 3 | 2 | 2 | 0 | **Prophet** | 3 | 0 | 2 | 2 | 3
    | 3 | 0 | 3 | 2 | 0 | 2 | **LightGBM** and **tsfresh** | 3 | 2 | 2 | 0 | 0 | 0
    | 0 | 3 | 0 | 2 | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'This table can be further summarized to give you the following final results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Framework** | **Ease of development score** | **Forecasting algorithm requirements
    score** | **Performance and data requirements score** | **Mandatory requirements
    satisfied** | **Important requirements satisfied** | **Supplementary requirements
    satisfied** |'
  prefs: []
  type: TYPE_TB
- en: '| **pmdarima** | 10/12 | 8/9 | 0/4 | 3/3 | 3/5 | 1/3 |'
  prefs: []
  type: TYPE_TB
- en: '| **statsmodels.tsa** | 8/12 | 6/9 | 2/4 | 2/3 | 3/5 | 2/3 |'
  prefs: []
  type: TYPE_TB
- en: '| **Prophet** | 10/12 | 8/9 | 2/4 | 3/3 | 3/5 | 2/3 |'
  prefs: []
  type: TYPE_TB
- en: '| **LightGBM** and **tsfresh** | 7/12 | 3/9 | 2/4 | 2/3 | 2/5 | 1/3 |'
  prefs: []
  type: TYPE_TB
- en: If you wish, you can use weighted averages to summarize each framework's score
    into a single number. However, remember that simplifying complex decisions into
    one number can lead to errors if this is done incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: These research results show that Prophet comes up as a better choice according
    to the initial requirements. However, the results do not mean that Prophet is
    the best choice for every application. Technology choices should be biased and
    opinionated since no technology can be the best fit for every project. For example,
    the ranking could be entirely different if the team took the desired average metric
    value into consideration. In this setting, other frameworks could have won because
    they provided more accurate models.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can choose a technology based on its requirements
    rather than the hype surrounding it. We also explored how to structure requirements
    and derive the main elements of a technology stack from software architecture.
    Finally, we discussed the difference between core and project-specific technology
    stacks and examined an analytical approach to comparing different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will conclude this book; congratulations on finishing it!
  prefs: []
  type: TYPE_NORMAL
