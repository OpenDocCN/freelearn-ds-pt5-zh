["```py\n# source_code/1/mary_and_temperature_preferences/knn_to_data.py # Applies the knn algorithm to the input data.\n# The input text file is assumed to be of the format with one line per\n# every data entry consisting of the temperature in degrees Celsius,\n# wind speed and then the classification cold/warm.\n\nimport sys\nsys.path.append('..')\nsys.path.append('../../common')\nimport knn # noqa\nimport common # noqa\n\n# Program start\n# E.g. \"mary_and_temperature_preferences.data\"\ninput_file = sys.argv[1]\n# E.g. \"mary_and_temperature_preferences_completed.data\"\noutput_file = sys.argv[2]\nk = int(sys.argv[3])\nx_from = int(sys.argv[4])\nx_to = int(sys.argv[5])\ny_from = int(sys.argv[6])\ny_to = int(sys.argv[7])\n\ndata = common.load_3row_data_to_dic(input_file)\nnew_data = knn.knn_to_2d_data(data, x_from, x_to, y_from, y_to, k)\ncommon.save_3row_data_from_dic(output_file, new_data)\n```", "```py\n# source_code/common/common.py # ***Library with common routines and functions*** def dic_inc(dic, key):\n    if key is None:\n        pass\n    if dic.get(key, None) is None:\n        dic[key] = 1\n    else:\n        dic[key] = dic[key] + 1\n```", "```py\n# source_code/1/knn.py\n# ***Library implementing knn algorithm***\n\ndef info_reset(info):\n    info['nbhd_count'] = 0\n    info['class_count'] = {}\n\n# Find the class of a neighbor with the coordinates x,y.\n# If the class is known count that neighbor.\ndef info_add(info, data, x, y):\n    group = data.get((x, y), None)\n    common.dic_inc(info['class_count'], group)\n    info['nbhd_count'] += int(group is not None)\n\n# Apply knn algorithm to the 2d data using the k-nearest neighbors with\n# the Manhattan distance.\n# The dictionary data comes in the form with keys being 2d coordinates\n# and the values being the class.\n# x,y are integer coordinates for the 2d data with the range\n# [x_from,x_to] x [y_from,y_to].\ndef knn_to_2d_data(data, x_from, x_to, y_from, y_to, k):\n    new_data = {}\n    info = {}\n    # Go through every point in an integer coordinate system.\n    for y in range(y_from, y_to + 1):\n        for x in range(x_from, x_to + 1):\n            info_reset(info)\n            # Count the number of neighbors for each class group for\n            # every distance dist starting at 0 until at least k\n            # neighbors with known classes are found.\n            for dist in range(0, x_to - x_from + y_to - y_from):\n                # Count all neighbors that are distanced dist from\n                # the point [x,y].\n                if dist == 0:\n                    info_add(info, data, x, y)\n                else:\n                    for i in range(0, dist + 1):\n                        info_add(info, data, x - i, y + dist - i)\n                        info_add(info, data, x + dist - i, y - i)\n                    for i in range(1, dist):\n                        info_add(info, data, x + i, y + dist - i)\n                        info_add(info, data, x - dist + i, y - i)\n                # There could be more than k-closest neighbors if the\n                # distance of more of them is the same from the point\n                # [x,y]. But immediately when we have at least k of\n                # them, we break from the loop.\n                if info['nbhd_count'] >= k:\n                    break\n            class_max_count = None\n            # Choose the class with the highest count of the neighbors\n            # from among the k-closest neighbors.\n            for group, count in info['class_count'].items():\n                if group is not None and (class_max_count is None or\n                   count > info['class_count'][class_max_count]):\n                    class_max_count = group\n            new_data[x, y] = class_max_count\n    return new_data\n```", "```py\n# source_code/1/mary_and_temperature_preferences/\nmarry_and_temperature_preferences.data\n10 0 cold\n25 0 warm\n15 5 cold\n20 3 warm\n18 7 cold\n20 10 cold\n22 5 warm\n24 6 warm\n```", "```py\n$ python knn_to_data.py mary_and_temperature_preferences.data mary_and_temperature_preferences_completed.data 1 5 30 0 10\n\n$ wc -l mary_and_temperature_preferences_completed.data \n286 mary_and_temperature_preferences_completed.data\n\n$ head -10 mary_and_temperature_preferences_completed.data \n7 3 cold\n6 9 cold\n12 1 cold\n16 6 cold\n16 9 cold\n14 4 cold\n13 4 cold\n19 4 warm\n18 4 cold\n15 1 cold\n```", "```py\n# source_code/common/common.py\n# returns a dictionary of 3 lists: 1st with x coordinates,\n# 2nd with y coordinates, 3rd with colors with numeric values\ndef get_x_y_colors(data):\n    dic = {}\n    dic['x'] = [0] * len(data)\n    dic['y'] = [0] * len(data)\n    dic['colors'] = [0] * len(data)\n    for i in range(0, len(data)):\n        dic['x'][i] = data[i][0]\n        dic['y'][i] = data[i][1]\n        dic['colors'][i] = data[i][2]\n    return dic\n```", "```py\n# source_code/1/mary_and_temperature_preferences/\nmary_and_temperature_preferences_draw_graph.py import sys\nsys.path.append('../../common')  # noqa\nimport common\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib\nmatplotlib.style.use('ggplot')\n\ndata_file_name = 'mary_and_temperature_preferences_completed.data'\ntemp_from = 5\ntemp_to = 30\nwind_from = 0\nwind_to = 10\n\ndata = np.loadtxt(open(data_file_name, 'r'),\n                  dtype={'names': ('temperature', 'wind', 'perception'),\n                         'formats': ('i4', 'i4', 'S4')})\n\n# Convert the classes to the colors to be displayed in a diagram.\nfor i in range(0, len(data)):\n    if data[i][2] == 'cold':\n        data[i][2] = 'blue'\n    elif data[i][2] == 'warm':\n        data[i][2] = 'red'\n    else:\n        data[i][2] = 'gray'\n# Convert the array into the format ready for drawing functions.\ndata_processed = common.get_x_y_colors(data)\n\n# Draw the graph.\nplt.title('Mary and temperature preferences')\nplt.xlabel('temperature in C')\nplt.ylabel('wind speed in kmph')\nplt.axis([temp_from, temp_to, wind_from, wind_to])\n# Add legends to the graph.\nblue_patch = mpatches.Patch(color='blue', label='cold')\nred_patch = mpatches.Patch(color='red', label='warm')\nplt.legend(handles=[blue_patch, red_patch])\nplt.scatter(data_processed['x'], data_processed['y'],\n            c=data_processed['colors'], s=[1400] * len(data))\nplt.show()\n```"]