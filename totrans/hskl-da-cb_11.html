<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Visualizing Data</h1></div></div></div><p>In this chapter, we will cover the following visualization techniques:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Plotting a line chart using Google's Chart API</li><li class="listitem" style="list-style-type: disc">Plotting a pie chart using Google's Chart API</li><li class="listitem" style="list-style-type: disc">Plotting bar graphs using Google's Chart API</li><li class="listitem" style="list-style-type: disc">Displaying a line graph using gnuplot</li><li class="listitem" style="list-style-type: disc">Displaying a scatter plot of two-dimensional points</li><li class="listitem" style="list-style-type: disc">Interacting with points in three-dimensional space</li><li class="listitem" style="list-style-type: disc">Visualizing a graph network</li><li class="listitem" style="list-style-type: disc">Customizing the looks of a graph network diagram</li><li class="listitem" style="list-style-type: disc">Rendering a bar graph in JavaScript using D3.js</li><li class="listitem" style="list-style-type: disc">Rendering a scatter plot in JavaScript using D3.js</li><li class="listitem" style="list-style-type: disc">Diagramming a path from a list of vectors</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec134"/>Introduction</h1></div></div></div><div><img src="img/ch11.jpg" alt="Introduction"/></div><p>Visualization is important in all steps of data analysis. Whether we are just getting acquainted with the data or have completed our analysis, it is always useful to have an intuitive understanding through a graphical aid. Fortunately, Haskell comes with a plethora of libraries to facilitate this endeavor.</p><p>In this chapter, we will cover recipes to produce line, pie, bar, and scatter plots using various APIs. Going beyond typical data visualization, we will also learn to draw network diagrams. Moreover, in the last recipe, we will describe navigation directions by drawing vectors on a blank canvas.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec135"/>Plotting a line chart using Google's Chart API</h1></div></div></div><p>We will use<a id="id648" class="indexterm"/> the convenient Google Chart API (<a class="ulink" href="https://developers.google.com/chart">https://developers.google.com/chart</a>) to <a id="id649" class="indexterm"/>render a line chart. This <a id="id650" class="indexterm"/>API produces a URL that points to a PNG image of the graph. This lightweight URL can be easier to handle than the actual image itself.</p><p>Our data will come from a text file that contains a list of numbers separated by lines. The code will generate a URL to present this data.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec370"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">GoogleChart</code> package as follows:</p><div><pre class="programlisting">
<strong>$ cabal install hs-gchart</strong>
</pre></div><p>Create a file called <code class="literal">input.txt</code> with numbers inserted line by line as follows:</p><div><pre class="programlisting">
<strong>$ cat input.txt </strong>
<strong>2</strong>
<strong>5</strong>
<strong>3</strong>
<strong>7</strong>
<strong>4</strong>
<strong>1</strong>
<strong>19</strong>
<strong>18</strong>
<strong>17</strong>
<strong>14</strong>
<strong>15</strong>
<strong>16</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec371"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <a id="id651" class="indexterm"/>Google Chart API library as follows:<div><pre class="programlisting">import Graphics.Google.Chart</pre></div></li><li class="listitem">Gather <a id="id652" class="indexterm"/>the input from the text file and parse it as a list of integers:<div><pre class="programlisting">main = do
  rawInput &lt;- readFile "input.txt"
  let nums = map (read :: String -&gt; Int) (lines rawInput)</pre></div></li><li class="listitem">Create a chart URL out of the image by setting the attributes appropriately, as shown in the following code snippet:<div><pre class="programlisting">  putStrLn $ chartURL $
    setSize 500 200 $
    setTitle "Example of Plotting a Chart in Haskell" $
    setData (encodeDataSimple [nums]) $
    setLegend ["Stock Price"] $
    newLineChart</pre></div></li><li class="listitem">Running the program will output a Google Chart URL as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
<strong>http://chart.apis.google.com/chart?chs=500x200&amp;chtt=Example+of+Plotting+a+Chart+in+Haskell&amp;chd=s:CFDHEBTSROPQ&amp;chdl=Stock+Price&amp;cht=lc</strong>
</pre></div></li></ol></div><p>Ensure an<a id="id653" class="indexterm"/> Internet connection exists and navigate to that URL to view the chart, as shown in the following screenshot:</p><div><img src="img/6331OS_11_01.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec372"/>How it works…</h2></div></div></div><p>Google encodes all <a id="id654" class="indexterm"/>graph data within the URL. The more complicated our graph, the longer the Google Chart URL. In this recipe, we use the <code class="literal">encodeDataSimple</code> function<a id="id655" class="indexterm"/> that creates a relatively shorter URL, but only accepts integers between 0 and 61 inclusive.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec373"/>There's more…</h2></div></div></div><p>To visualize a more detailed graph that allows data to have decimal places, we can use the <code class="literal">encodeDataText :: RealFrac a =&gt; [[a]] -&gt; ChartData</code> function instead. This function allows for decimal numbers between 0 and 100 inclusive.</p><p>To represent larger ranges of integers in a graph, we should <a id="id656" class="indexterm"/>use the <code class="literal">encodeDataExtended</code> function, which supports integers between 0 and 4095 inclusive.</p><p>More information about the Google Charts Haskell package can be found at <a class="ulink" href="https://hackage.haskell.org/package/hs-gchart">https://hackage.haskell.org/package/hs-gchart</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec374"/>See also</h2></div></div></div><p>This recipe required a connection to the Internet to view a graph. If we wish to perform all actions locally, refer to the <em>Displaying a line graph using gnuplot</em> recipe. Other Google API recipes can include <em>Plotting a pie chart using Google's Chart API</em> and <em>Plotting bar graphs using Google's Chart API</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec136"/>Plotting a pie chart using Google's Chart API</h1></div></div></div><p>The Google Chart API provides <a id="id657" class="indexterm"/>a very elegant-looking <a id="id658" class="indexterm"/>pie chart interface. We can generate images of well-designed pie charts by feeding our input and labels properly, as described in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec375"/>Getting ready</h2></div></div></div><p>Install the GoogleChart package as follows:</p><div><pre class="programlisting">
<strong>$ cabal install hs-gchart</strong>
</pre></div><p>Create a file called <code class="literal">input.txt</code> with numbers inserted line by line as follows:</p><div><pre class="programlisting">
<strong>$ cat input.txt </strong>
<strong>2</strong>
<strong>5</strong>
<strong>3</strong>
<strong>7</strong>
<strong>4</strong>
<strong>1</strong>
<strong>19</strong>
<strong>18</strong>
<strong>17</strong>
<strong>14</strong>
<strong>15</strong>
<strong>16</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec376"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the Google Chart API library as follows:<div><pre class="programlisting">import Graphics.Google.Chart</pre></div></li><li class="listitem">Gather the input from the text file and parse it as a list of integers, as shown in the following code snippet:<div><pre class="programlisting">main = do
  rawInput &lt;- readFile "input.txt"
  let nums = map (read :: String -&gt; Int) (lines rawInput)</pre></div></li><li class="listitem">Print out the Google Chart URL from the pie chart attributes shown in the following code:<div><pre class="programlisting">  putStrLn $ chartURL $
    setSize 500 400 $
    setTitle "Example of Plotting a Pie Chart in Haskell" $
    setData (encodeDataSimple [nums]) $
    setLabels (lines rawInput) $
    newPieChart Pie2D</pre></div></li><li class="listitem">Running the program will output a Google Chart URL as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
<strong>http://chart.apis.google.com/chart?chs=500x400&amp;chtt=Example+of+Plotting+a+Pie+Chart+in+Haskell&amp;chd=s:CFDHEBTSROPQ&amp;chl=2|5|3|7|4|1|19|18|17|14|15|16&amp;cht=p</strong>
</pre></div></li></ol></div><p>Ensure <a id="id659" class="indexterm"/>an<a id="id660" class="indexterm"/> Internet connection exists and navigate to that URL to view the chart shown in the following image:</p><div><img src="img/6331OS_11_02.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec377"/>How it works…</h2></div></div></div><p>Google encodes all graph data within the URL. The more complicated the graph, the longer the Google <a id="id661" class="indexterm"/>Chart URL. In this recipe, we use the <code class="literal">encodeDataSimple</code> function, which creates a relatively shorter URL, but only accepts integers between 0 and 61 inclusive. The legends of the pie chart are specified by the <code class="literal">setLabels :: [String] -&gt; PieChart -&gt; PieChart</code> function in the same order as the data.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec378"/>There's more…</h2></div></div></div><p>To <a id="id662" class="indexterm"/>visualize a more detailed graph that allows data to have decimal places, we can use the <code class="literal">encodeDataText :: RealFrac a =&gt; [[a]] -&gt; ChartData</code> function instead. This function allows decimal numbers between 0 and 100 inclusive.</p><p>To represent larger ranges of integers in a graph, we should use the <code class="literal">encodeDataExtended</code> function, which supports integers between 0 and 4095 inclusive.</p><p>More information about the Google Charts Haskell package can be found at <a class="ulink" href="https://hackage.haskell.org/package/hs-gchart">https://hackage.haskell.org/package/hs-gchart</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec379"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Plotting a line chart using Google's Chart API</em></li><li class="listitem" style="list-style-type: disc"><em>Plotting bar graphs using Google's Chart API</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec137"/>Plotting bar graphs using Google's Chart API</h1></div></div></div><p>The <a id="id663" class="indexterm"/>Google Chart API also has great support for bar graphs. In<a id="id664" class="indexterm"/> this recipe, we will produce a bar graph of two sets of inputs in the same diagram to show the usefulness of this API.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec380"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">GoogleChart</code> package as follows:</p><div><pre class="programlisting">
<strong>$ cabal install hs-gchart</strong>
</pre></div><p>Create two files called <code class="literal">input1.txt</code> and <code class="literal">input2.txt</code> with numbers inserted line by line as follows:</p><div><pre class="programlisting">
<strong>$ cat input1.txt </strong>
<strong>2</strong>
<strong>5</strong>
<strong>3</strong>
<strong>7</strong>
<strong>4</strong>
<strong>1</strong>
<strong>19</strong>
<strong>18</strong>
<strong>17</strong>
<strong>14</strong>
<strong>15</strong>
<strong>16</strong>

<strong>$ cat input2.txt</strong>
<strong>4</strong>
<strong>2</strong>
<strong>6</strong>
<strong>7</strong>
<strong>8</strong>
<strong>2</strong>
<strong>18</strong>
<strong>17</strong>
<strong>16</strong>
<strong>17</strong>
<strong>15</strong>
<strong>14</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec381"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import <a id="id665" class="indexterm"/>the Google Chart API library as follows:<div><pre class="programlisting">import Graphics.Google.Chart</pre></div></li><li class="listitem">Gather <a id="id666" class="indexterm"/>the two input values from both the text files and parse them as two separate lists of integers, as shown in the following code snippet:<div><pre class="programlisting">main = do
  rawInput1 &lt;- readFile "input1.txt"
  rawInput2 &lt;- readFile "input2.txt"
  let nums1 = map (read :: String -&gt; Int) (lines rawInput1)
  let nums2 = map (read :: String -&gt; Int) (lines rawInput2)</pre></div></li><li class="listitem">Set up the bar chart too and print out the Google Chart URL as follows:<div><pre class="programlisting">  putStrLn $ chartURL $
    setSize 500 400 $
    setTitle "Example of Plotting a Bar Chart in Haskell" $
    setDataColors ["00ff00", "ff0000"] $
    setLegend ["A", "B"] $
    setData (encodeDataSimple [nums1, nums2]) $
    newBarChart Horizontal Grouped</pre></div></li><li class="listitem">Running the program will output a Google Chart URL as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
<strong>http://chart.apis.google.com/chart?chs=500x400&amp;chtt=Example+of+Plotting+a+Bar+Chart+in+Haskell&amp;chco=00ff00,ff0000&amp;chdl=A|B&amp;chd=s:CFDHEBTSROPQ,ECGHICSRQRPO&amp;cht=bhg</strong>
</pre></div></li></ol></div><p>Ensure an<a id="id667" class="indexterm"/> Internet connection exists and navigate to that URL to view the following chart:</p><div><img src="img/6331OS_11_03.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec382"/>How it works…</h2></div></div></div><p>Google encodes <a id="id668" class="indexterm"/>all graph data within the URL. The more complicated the graph, the longer the Google Chart URL. In this recipe, we use the <code class="literal">encodeDataSimple</code> function, which creates a relatively shorter URL, but only accepts integers between 0 and 61 inclusive.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec383"/>There's more…</h2></div></div></div><p>To<a id="id669" class="indexterm"/> visualize a more detailed graph that allows data to have decimal places, we can use the <code class="literal">encodeDataText :: RealFrac a =&gt; [[a]] -&gt; ChartData</code> function instead. This function allows decimal numbers between 0 and 100 inclusive.</p><p>To represent larger ranges of integers in a graph, we should use the <code class="literal">encodeDataExtended</code> function, which supports integers between 0 and 4095 inclusive.</p><p>More information about the Google Charts Haskell package can be found at <a class="ulink" href="https://hackage.haskell.org/package/hs-gchart">https://hackage.haskell.org/package/hs-gchart</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec384"/>See also</h2></div></div></div><p>To use other Google Chart tools, refer to the <em>Plotting a pie chart using Google's Chart API</em> and <em>Plotting a line chart using Google's Chart API</em> recipes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec138"/>Displaying a line graph using gnuplot</h1></div></div></div><p>An<a id="id670" class="indexterm"/> Internet connection is typically unnecessary for plotting a<a id="id671" class="indexterm"/> graph. So, in this recipe, we will demonstrate how to make a line graph locally.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec385"/>Getting ready</h2></div></div></div><p>The library used in this recipe uses gnuplot to render the graph. We should first install gnuplot.</p><p>On Debian-based systems such as Ubuntu, we can install it using <code class="literal">apt-get</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install gnuplot-x11</strong>
</pre></div><p>The official place to download gnuplot is on its main website available at <a class="ulink" href="http://www.gnuplot.info">http://www.gnuplot.info</a>.</p><p>After gnuplot is set up, install the<a id="id672" class="indexterm"/> <code class="literal">EasyPlot</code> Haskell library using cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install easyplot</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec386"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">EasyPlot</code> library as follows:<div><pre class="programlisting">import Graphics.EasyPlot</pre></div></li><li class="listitem">Define a list of numbers to plot as follows:<div><pre class="programlisting">main = do
  let values = [4,5,16,15,14,13,13,17]</pre></div></li><li class="listitem">Plot the chart on the <code class="literal">X11</code> window as shown in the following code snippet. The <code class="literal">X11</code> X Window System terminal is used by many Linux-based machines. If running on Windows, we should instead use the <code class="literal">Windows</code> terminal. On Mac OS X, we should replace <code class="literal">X11</code> with <code class="literal">Aqua</code>:<div><pre class="programlisting">  plot X11 $ 
    Data2D [ Title "Line Graph"
           , Style Linespoints
           , Color Blue] 
    [] (zip [1..] values)</pre></div></li></ol></div><p>Running<a id="id673" class="indexterm"/> the code produces a <code class="literal">plot1.dat</code> datafile as well as a visual graph from the selected terminal, as shown in the following screenshot:</p><div><img src="img/6331OS_11_04.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec387"/>How it works…</h2></div></div></div><p>The <a id="id674" class="indexterm"/>
<code class="literal">EasyPlot</code> library<a id="id675" class="indexterm"/> translates all user-specified code into a language understood by gnuplot to graph the data.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec388"/>See also</h2></div></div></div><p>To use the Google Chart API instead of easy plot, refer to the <em>Plotting a line chart using Google's Chart API</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec139"/>Displaying a scatter plot of two-dimensional points</h1></div></div></div><p>This recipe <a id="id676" class="indexterm"/>covers a quick and easy way to visualize a list of 2D points as scattered dots within an image.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec389"/>Getting ready</h2></div></div></div><p>The library <a id="id677" class="indexterm"/>used in this recipe uses gnuplot to render the graph. We should first install gnuplot.</p><p>On Debian-based systems such as Ubuntu, we can install it using <code class="literal">apt-get</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install gnuplot-x11</strong>
</pre></div><p>The official place to download gnuplot is from its main website, <a class="ulink" href="http://www.gnuplot.info">http://www.gnuplot.info</a>.</p><p>After gnuplot is set up, install the <code class="literal">easyplot</code> Haskell library using cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install easyplot</strong>
</pre></div><p>Also, install a helper CSV package as follows:</p><div><pre class="programlisting">
<strong>$ cabal install csv</strong>
</pre></div><p>Also, create two comma-separated files, <code class="literal">input1.csv</code> and <code class="literal">input2.csv</code>, which represent two separate sets of points as follows:</p><div><pre class="programlisting">
<strong>$ cat input1.csv</strong>
<strong>1,2</strong>
<strong>3,2</strong>
<strong>2,3</strong>
<strong>2,2</strong>
<strong>3,1</strong>
<strong>2,2</strong>
<strong>2,1</strong>
</pre></div><div><pre class="programlisting">
<strong>$ cat input2.csv</strong>
<strong>7,4</strong>
<strong>8,4</strong>
<strong>6,4</strong>
<strong>7,5</strong>
<strong>7,3</strong>
<strong>6,4</strong>
<strong>7,6</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec390"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant packages as follows:<div><pre class="programlisting">import Graphics.EasyPlot

import Text.CSV</pre></div></li><li class="listitem">Define<a id="id678" class="indexterm"/> a helper function to convert a CSV record into a tuple of numbers as follows:<div><pre class="programlisting">convertRawCSV :: [[String]] -&gt; [(Double, Double)]
convertRawCSV csv = [ (read x, read y) | [x, y] &lt;- csv ]</pre></div></li><li class="listitem">Read the two CSV files as follows:<div><pre class="programlisting">main = do
  csv1Raw &lt;- parseCSVFromFile "input1.csv"
  csv2Raw &lt;- parseCSVFromFile "input2.csv"

  let csv1 = case csv1Raw of 
        Left err -&gt; []
        Right csv -&gt; convertRawCSV csv

  let csv2 = case csv2Raw of 
        Left err -&gt; []
        Right csv -&gt; convertRawCSV csv</pre></div></li><li class="listitem">Plot both<a id="id679" class="indexterm"/> the datasets alongside each other on the same graph with different colors. Use the <code class="literal">X11</code> terminal for the X Window System used by many Linux-based machines, as shown in the following lines of code. If running on Windows, the terminal to use is <code class="literal">Windows</code>. On Mac OS X, we should replace <code class="literal">X11</code> with <code class="literal">Aqua</code>:<div><pre class="programlisting">  plot X11 $ [ Data2D [Color Red] [] csv1
  , Data2D [Color Blue] [] csv2 ]</pre></div></li><li class="listitem">Run the program to display the graph shown in the following screenshot:<div><img src="img/6331OS_11_05.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec391"/>How it works…</h2></div></div></div><p>The <code class="literal">EasyPlot</code> library <a id="id680" class="indexterm"/>translates all user-specified code into language understood by gnuplot to graph the data. The last argument to plot can take in a list of many datasets to graph.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec392"/>See also</h2></div></div></div><p>To visualize 3D points, refer to the <em>Interacting with points in a three-dimensional space</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec140"/>Interacting with points in a three-dimensional space</h1></div></div></div><p>When <a id="id681" class="indexterm"/>visualizing points in 3D space, it is often very useful to rotate, zoom, and pan the representation interactively. This recipe demonstrates how to plot data in 3D and interact with it in real time.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec393"/>Getting ready</h2></div></div></div><p>The library used in this recipe uses gnuplot to render the graph. We should first install gnuplot.</p><p>On Debian-based systems such as Ubuntu, we can install it using <code class="literal">apt-get</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install gnuplot-x11</strong>
</pre></div><p>The official place to download gnuplot is from its main website available at <a class="ulink" href="http://www.gnuplot.info">http://www.gnuplot.info</a>.</p><p>After gnuplot is set up, install the <code class="literal">easyplot</code> Haskell library using Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install easyplot</strong>
</pre></div><p>Also, install a helper CSV package as follows:</p><div><pre class="programlisting">
<strong>$ cabal install csv</strong>
</pre></div><p>Also, create two comma-separated files, <code class="literal">input1.csv</code> and <code class="literal">input2.csv</code>, which represent two separate sets of points as follows:</p><div><pre class="programlisting">
<strong>$ cat input1.csv</strong>
<strong>1,1,1</strong>
<strong>1,2,1</strong>
<strong>0,1,1</strong>
<strong>1,1,0</strong>
<strong>2,1,0</strong>
<strong>2,1,1</strong>
<strong>1,0,1</strong>
</pre></div><div><pre class="programlisting">
<strong>$ cat input2.csv</strong>
<strong>4,3,2</strong>
<strong>3,3,2</strong>
<strong>3,2,3</strong>
<strong>4,4,3</strong>
<strong>5,4,2</strong>
<strong>4,2,3</strong>
<strong>3,4,3</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec394"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <a id="id682" class="indexterm"/>relevant packages as follows:<div><pre class="programlisting">import Graphics.EasyPlot

import Text.CSV</pre></div></li><li class="listitem">Define a helper function to convert a CSV record into a tuple of numbers as follows:<div><pre class="programlisting">convertRawCSV :: [[String]] -&gt; [(Double, Double, Double)]

convertRawCSV csv = [ (read x, read y, read z) 
                    | [x, y, z] &lt;- csv ]</pre></div></li><li class="listitem">Read the two CSV files as follows:<div><pre class="programlisting">main = do
  csv1Raw &lt;- parseCSVFromFile "input1.csv"
  csv2Raw &lt;- parseCSVFromFile "input2.csv"

  let csv1 = case csv1Raw of
        Left err -&gt; []
        Right csv -&gt; convertRawCSV csv

  let csv2 = case csv2Raw of
        Left err -&gt; []
        Right csv -&gt; convertRawCSV csv</pre></div></li><li class="listitem">Plot the <a id="id683" class="indexterm"/>data using the <code class="literal">plot'</code> function, which leaves gnuplot running to allow for an <code class="literal">Interactive</code> option. Use the <code class="literal">X11</code> terminal for the X Window System used by many Linux-based machines, as shown in the following lines of code. If running on Windows, the terminal to use is <code class="literal">Windows</code>. On Mac OS X, we should replace <code class="literal">X11</code> with <code class="literal">Aqua</code>:<div><pre class="programlisting">  plot' [Interactive] X11 $ 
    [ Data3D [Color Red] [] csv1
    , Data3D [Color Blue] [] csv2]</pre></div><div><img src="img/6331OS_11_06.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec395"/>How it works…</h2></div></div></div><p>The<a id="id684" class="indexterm"/> <code class="literal">EasyPlot</code> library<a id="id685" class="indexterm"/> translates all user-specified code into a language understood by gnuplot to graph the data. The last argument to plot can take in a list of many datasets to graph. By using the <code class="literal">plot'</code> function, we leave gnuplot running so that we can interact with the graph by rotating, zooming, and panning the three-dimensional visual.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec396"/>See also</h2></div></div></div><p>To visualize 2D points, refer to the <em>Displaying a scatter plot of two-dimensional points</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec141"/>Visualizing a graph network</h1></div></div></div><p>Graphical networks of edges and nodes can be<a id="id686" class="indexterm"/> difficult to debug or comprehend, and thus, visualization helps tremendously. In this recipe, we will convert a graph data structure into an image of nodes and edges.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec397"/>Getting ready</h2></div></div></div><p>To use Graphviz, the graph <a id="id687" class="indexterm"/>visualization library, we must first install it on the machine. The official website of Graphviz contains the download and<a id="id688" class="indexterm"/> installation instructions (<a class="ulink" href="http://www.graphviz.org">http://www.graphviz.org</a>). On Debian-based operating systems, Graphviz can be installed using <code class="literal">apt-get</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install graphviz-dev graphviz</strong>
</pre></div><p>Next, we need to <a id="id689" class="indexterm"/>install the Graphviz Haskell bindings from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install graphviz</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec398"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries as follows:<div><pre class="programlisting">import Data.Text.Lazy (Text, empty, unpack)
import Data.Graph.Inductive (Gr, mkGraph)
import Data.GraphViz (GraphvizParams, nonClusteredParams, graphToDot)
import Data.GraphViz.Printing (toDot, renderDot)</pre></div></li><li class="listitem">Create a graph defined by identifying the pairs of nodes that form edges using the following lines of code:<div><pre class="programlisting">myGraph :: Gr Text Text
myGraph = mkGraph [ (1, empty)
                  , (2, empty)
                  , (3, empty) ]
          [ (1, 2, empty) 
          , (1, 3, empty) ]</pre></div></li><li class="listitem">Set the graph to use the default parameters as follows:<div><pre class="programlisting">myParams :: GraphvizParams n Text Text () Text
myParams = nonClusteredParams</pre></div></li><li class="listitem">Print <a id="id690" class="indexterm"/>out the dot representation of the graph to the terminal as follows:<div><pre class="programlisting">main :: IO ()
main = putStr $ unpack $ renderDot $ toDot $ 
       graphToDot myParams myGraph</pre></div></li><li class="listitem">Run the code to obtain a dot representation of the graph, which can be saved in a separate file as follows:<div><pre class="programlisting">$ runhaskell Main.hs &gt; graph.dot</pre></div></li><li class="listitem">Run the <code class="literal">dot</code> command provided by Graphviz on this file to render an image as follows:<div><pre class="programlisting">$ dot -Tpng graph.dot &gt; graph.png</pre></div></li><li class="listitem">We can now view the resulting <code class="literal">graph.png</code> file shown in the following screenshot:<div><img src="img/6331OS_11_07.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec399"/>How it works…</h2></div></div></div><p>The <code class="literal">graphToDot</code> function <a id="id691" class="indexterm"/>converts a graph into the DOT language for describing graphs. This is a text serialization for a graph, which can be read by the Graphviz <code class="literal">dot</code> command and converted into a viewable image.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec400"/>There's more…</h2></div></div></div><p>In this recipe, we used the <code class="literal">dot</code> command. The Graphviz website also describes other commands that convert DOT language text into viewable images:</p><p><em>dot - "hierarchical" or layered drawings of directed graphs. This is the default tool to use if edges have directionality.</em></p><p><em>neato - "spring model'' layouts. This is the default tool to use if the graph is not too large (about 100 nodes) and you don't know anything else about it. Neato attempts to minimize a global energy function, which is equivalent to statistical multidimensional scaling.</em></p><p><em>fdp - "spring model'' layouts similar to those of neato, but does this by reducing forces rather than working with energy.</em></p><p><em>sfdp - multiscale version of fdp for the layout of large graphs.</em></p><p><em>twopi - radial layouts, after Graham Wills 97. Nodes are placed on concentric circles depending their distance from a given root node.</em></p><p><em>circo - circular layout, after Six and Tollis 99, Kauffman and Wiese 02. This is suitable for certain diagrams of multiple cyclic structures, such as certain telecommunications networks.</em></p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec401"/>See also</h2></div></div></div><p>To further change the look and feel of a graph, refer to the <em>Customizing the looks of a graph network diagram</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec142"/>Customizing the looks of a graph network diagram</h1></div></div></div><p>To better<a id="id692" class="indexterm"/> present the data, we will cover how to customize the design of a graphical network diagram.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec402"/>Getting ready</h2></div></div></div><p>To use Graphviz, the graph visualization library, we must first install it on the machine. The official website of Graphviz contains the download and installation instructions available at <a class="ulink" href="http://www.graphviz.org">http://www.graphviz.org</a>. On Debian-based operating systems, Graphviz can be installed using <code class="literal">apt-get</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install graphviz-dev graphviz</strong>
</pre></div><p>Next, we need to install the Graphviz Haskell bindings from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install graphviz</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec403"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant functions and libraries to customize a Graphviz graph as follows:<div><pre class="programlisting">import Data.Text.Lazy (Text, pack, unpack)
import Data.Graph.Inductive (Gr, mkGraph)
import Data.GraphViz (
  GraphvizParams(..),
  GlobalAttributes(
    GraphAttrs,
    NodeAttrs,
    EdgeAttrs
    ),
  X11Color(Blue, Orange, White),
  nonClusteredParams,
  globalAttributes,
  fmtNode,
  fmtEdge,
  graphToDot
  )
import Data.GraphViz.Printing (toDot, renderDot)
import Data.GraphViz.Attributes.Complete</pre></div></li><li class="listitem">Define our custom graph by first specifying all the nodes, and then specifying which pairs of nodes form edges, as shown in the following code snippet:<div><pre class="programlisting">myGraph :: Gr Text Text
myGraph = mkGraph [ (1, pack "Haskell")
                  , (2, pack "Data Analysis") 
                  , (3, pack "Haskell Data Analysis")
                  , (4, pack "Profit!")] 
         [ (1, 3, pack "learn") 
         , (2, 3, pack "learn")
         , (3, 4, pack "???")]</pre></div></li><li class="listitem">Define our <a id="id693" class="indexterm"/>own custom graph parameters as follows:<div><pre class="programlisting">myParams :: GraphvizParams n Text Text () Text
myParams = nonClusteredParams { </pre></div></li><li class="listitem">Let the graphing engine know that we want the edges to be directed arrows as follows:<div><pre class="programlisting">    isDirected       = True</pre></div></li><li class="listitem">Set our own global attributes for a graph, node, and edge appearance as follows:<div><pre class="programlisting">  , globalAttributes = [myGraphAttrs, myNodeAttrs, myEdgeAttrs]</pre></div></li><li class="listitem">Format nodes in our own way as follows:<div><pre class="programlisting">  , fmtNode          = myFN</pre></div></li><li class="listitem">Format edges in our own way as follows:<div><pre class="programlisting">  , fmtEdge          = myFE
  }</pre></div></li><li class="listitem">Define the customizations as shown in the following code snippet:<div><pre class="programlisting"> where myGraphAttrs = 
                 GraphAttrs [ RankDir FromLeft
                                    , BgColor [toWColor Blue] ]
             myNodeAttrs = 
                  NodeAttrs [ Shape BoxShape
                                   , FillColor [toWColor Orange]
                                   , Style [SItem Filled []] ]
             myEdgeAttrs = 
                  EdgeAttrs [ Weight (Int 10) 
                                   , Color [toWColor White]
                                   , FontColor (toColor White) ]
             myFN (n,l) = [(Label . StrLabel) l]
             myFE (f,t,l) = [(Label . StrLabel) l]</pre></div></li><li class="listitem">Print the <a id="id694" class="indexterm"/>DOT language representation of the graph to the terminal.<div><pre class="programlisting">main :: IO ()
main = putStr $ unpack $ renderDot $ toDot $ graphToDot myParams myGraph</pre></div></li><li class="listitem">Run the code to obtain a <code class="literal">dot</code> representation of the graph, which can be saved in a separate file as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs &gt; graph.dot</strong>
</pre></div></li><li class="listitem">Run the <code class="literal">dot</code> command provided by Graphviz on this file to render an image as follows:<div><pre class="programlisting">
<strong>$ dot -Tpng graph.dot &gt; graph.png</strong>
</pre></div></li></ol></div><p>We can now view the resulting <code class="literal">graph.png</code> file, as shown in the following screenshot:</p><div><img src="img/6331OS_11_08.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec404"/>How it works…</h2></div></div></div><p>The <code class="literal">graphToDot</code> function<a id="id695" class="indexterm"/> converts a graph into the DOT language to describe graphs. This is a text serialization for a graph that can be read by the Graphviz <code class="literal">dot</code> command and converted into a viewable image.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec405"/>There's more…</h2></div></div></div><p>Every possible customization option for the graph, nodes, and edges can be found on the <code class="literal">Data.GraphViz.Attributes.Complete</code> package documentation available at <a class="ulink" href="http://hackage.haskell.org/package/graphviz-2999.12.0.4/docs/Data-GraphViz-Attributes-Complete.html">http://hackage.haskell.org/package/graphviz-2999.12.0.4/docs/Data-GraphViz-Attributes-Complete.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec143"/>Rendering a bar graph in JavaScript using D3.js</h1></div></div></div><p>We will use <a id="id696" class="indexterm"/>the portable JavaScript library called <a id="id697" class="indexterm"/>
<code class="literal">D3.js</code> to draw a bar graph. This allows us to easily create a web page that contains a graph from the Haskell code.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec406"/>Getting ready</h2></div></div></div><p>An Internet connection is necessary for the setup.</p><p>Install the <code class="literal">d3js</code> Haskell library as follows:</p><div><pre class="programlisting">
<strong>$ cabal install d3js</strong>
</pre></div><p>Create a website template to hold the generated JavaScript code as follows:</p><div><pre class="programlisting">
<strong>$ cat index.html</strong>
</pre></div><p>The JavaScript code will be as follows:</p><div><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Chart&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id='myChart'&gt;&lt;/div&gt;
    &lt;script charset='utf-8' src='http://d3js.org/d3.v3.min.js'&gt;&lt;/script&gt;
    &lt;script charset='utf-8' src='generated.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec407"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant packages as follows:<div><pre class="programlisting">import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import D3JS</pre></div></li><li class="listitem">Create a bar chart using the <code class="literal">bars</code> function. Feed the specified values and number of bars to draw, as shown in the following code snippet:<div><pre class="programlisting">myChart nums numBars = do
  let dim = (300, 300)
  elem &lt;- box (T.pack "#myChart") dim
  bars numBars 300 (Data1D nums) elem
  addFrame (300, 300) (250, 250) elem</pre></div></li><li class="listitem">Define the values and number of bars to draw as follows:<div><pre class="programlisting">main = do
  let nums = [10, 40, 100, 50, 55, 156, 80, 74, 40, 10]
  let numBars = 5</pre></div></li><li class="listitem">Use the <code class="literal">reify</code> function to generate the JavaScript <code class="literal">D3.js</code> text out of the data. Write the JavaScript to a file named <code class="literal">generated.js</code> as follows:<div><pre class="programlisting">  let js = reify $ myChart nums numBars
  TIO.writeFile "generated.js" js</pre></div></li><li class="listitem">With <a id="id698" class="indexterm"/>both the <code class="literal">index.html</code> file and the <code class="literal">generated.js</code> file existing alongside each other, we can open the <code class="literal">index.html</code> web page using a browser that supports JavaScript, and see the resulting graph shown as follows:<div><img src="img/6331OS_11_09.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec408"/>How it works…</h2></div></div></div><p>The <code class="literal">D3.js</code> library <a id="id699" class="indexterm"/>is a JavaScript library used for creating elegant visuals and graphs. We use our browser to run the JavaScript code, and it also acts as our graph-rendering engine.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec409"/>See also</h2></div></div></div><p>For another use of <code class="literal">D3.js</code>, refer to the <em>Rendering a scatter plot in JavaScript using D3.js</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec144"/>Rendering a scatter plot in JavaScript using D3.js</h1></div></div></div><p>We will <a id="id700" class="indexterm"/>use the portable JavaScript library called <code class="literal">D3.js</code> to draw a scatter plot. This allows us to easily create a web page that contains a graph from the Haskell code.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec410"/>Getting ready</h2></div></div></div><p>An Internet connection is necessary to perform this setup.</p><p>Install the <code class="literal">d3js</code> Haskell library as follows:</p><div><pre class="programlisting">
<strong>$ cabal install d3js</strong>
</pre></div><p>Create a website template to hold the generated JavaScript code as follows:</p><div><pre class="programlisting">
<strong>$ cat index.html</strong>
</pre></div><p>The JavaScript code will be as follows:</p><div><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Chart&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id='myChart'&gt;&lt;/div&gt;
    &lt;script charset='utf-8' src='http://d3js.org/d3.v3.min.js'&gt;&lt;/script&gt;
    &lt;script charset='utf-8' src='generated.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec411"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries as follows:<div><pre class="programlisting">import D3JS
import qualified Data.Text as T
import qualified Data.Text.IO as TIO</pre></div></li><li class="listitem">Define the scatter plot and feed in the list of points as follows:<div><pre class="programlisting">myPlot points = do
  let dim = (300, 300)
  elem &lt;- box (T.pack "#myChart") dim
  scatter (Data2D points) elem
  addFrame (300, 300) (250, 250) elem   </pre></div></li><li class="listitem">Define a list of points to plot as follows:<div><pre class="programlisting">main = do
  let points = [(1,2), (5,10), (139,138), (140,150)]</pre></div></li><li class="listitem">Use the <code class="literal">reify</code> function to generate the JavaScript <code class="literal">D3.js</code> text out of the data. Write the JavaScript to a file named <code class="literal">generated.js</code> as follows:<div><pre class="programlisting">  let js = reify $ myPlot points
  TIO.writeFile "generated.js" js</pre></div></li><li class="listitem">With <a id="id701" class="indexterm"/>both the <code class="literal">index.html</code> and <code class="literal">generated.js</code> files existing alongside each other, we can open the <code class="literal">index.html</code> web page using a browser that supports JavaScript, and see the resulting graph shown as follows:<div><img src="img/6331OS_11_10.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec412"/>How it works…</h2></div></div></div><p>The <code class="literal">graphToDot</code> function<a id="id702" class="indexterm"/> converts a graph into the DOT language to describe graphs. This is a text serialization for a graph, which can be read by the Graphviz <code class="literal">dot</code> command and be converted into a viewable image.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec413"/>See also</h2></div></div></div><p>For another use of <code class="literal">D3.js</code>, refer to the <em>Rendering a bar graph in JavaScript using D3.js</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec145"/>Diagramming a path from a list of vectors</h1></div></div></div><p>In this<a id="id703" class="indexterm"/> recipe, we will use the <code class="literal">diagrams</code> package to draw a path from driving directions. We simply categorize all possible travel headings into eight cardinal directions with an associated distance. We use directions provided by Google Maps in the following screenshot and reconstruct the directions from a text file:</p><div><img src="img/6331OS_11_12.jpg" alt="Diagramming a path from a list of vectors"/></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec414"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">diagrams</code> library as follows:</p><div><pre class="programlisting">
<strong>$ cabal install diagrams</strong>
</pre></div><p>Create a text file called <code class="literal">input.txt</code> that contains one of the eight cardinal directions followed by the distance, with each step separated by a new line:</p><div><pre class="programlisting">
<strong>$ cat input.txt</strong>

<strong>N 0.2</strong>
<strong>W 0.1</strong>
<strong>S 0.6</strong>
<strong>W 0.05</strong>
<strong>S 0.3</strong>
<strong>SW 0.1</strong>
<strong>SW 0.2</strong>
<strong>SW 0.3</strong>
<strong>S 0.3</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec415"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import<a id="id704" class="indexterm"/> the relevant libraries as follows:<div><pre class="programlisting">{-# LANGUAGE NoMonomorphismRestriction #-}
import Diagrams.Prelude
import Diagrams.Backend.SVG.CmdLine (mainWith, B)</pre></div></li><li class="listitem">Draw a line-connected path from a list of vectors as follows:<div><pre class="programlisting">drawPath :: [(Double, Double)] -&gt; Diagram B R2
drawPath vectors = fromOffsets . map r2 $ vectors</pre></div></li><li class="listitem">Read a list of directions, represent it as a list of vectors, and draw the path as follows:<div><pre class="programlisting">main = do
  rawInput &lt;- readFile "input.txt"
  let vs = [ makeVector dir (read dist)
           | [dir, dist] &lt;- map words (lines rawInput)]
  print vs
  mainWith $ drawPath vs</pre></div></li><li class="listitem">Define a helper function to create a vector out of a direction and its corresponding distance as follows:<div><pre class="programlisting">makeVector :: String -&gt; Double -&gt; (Double, Double)
makeVector "N" dist = (0, dist)
makeVector "NE" dist = (dist / sqrt 2, dist / sqrt 2)
makeVector "E" dist = (dist, 0)
makeVector "SE" dist = (dist / sqrt 2, -dist / sqrt 2)
makeVector "S" dist = (0, -dist)
makeVector "SW" dist = (-dist / sqrt 2, -dist / sqrt 2)
makeVector "W" dist = (-dist, 0)
makeVector "NW" dist = (-dist / sqrt 2, dist / sqrt 2)
makeVector _ _ = (0, 0)</pre></div></li><li class="listitem">Compile the code and run it as follows:<div><pre class="programlisting">
<strong>$ ghc --make Main.hs</strong>
<strong>$ ./Main –o output.svg –w 400</strong>
</pre></div><div><img src="img/6331OS_11_11.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec416"/>How it works…</h2></div></div></div><p>The <code class="literal">mainWith</code> functions takes in a <code class="literal">Diagram</code> type and generates the corresponding image file when invoked in the terminal. We obtain the <code class="literal">Diagram</code> from our <code class="literal">drawPath</code> function, which glues together vectors by their offsets.</p></div></div></body></html>