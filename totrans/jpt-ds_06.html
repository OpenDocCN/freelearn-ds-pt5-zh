<html><head></head><body><div><h1 class="header-title">Data Wrangling</h1>
                
            
            
                
<p class="calibre5">In this chapter, we look at data in several different forms and pry useful statistics. The tools to access the data have been well developed and allow for data to be missing headings or data points in some of the records.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading a CSV file</h1>
                
            
            
                
<p class="calibre5">One of the standards for file formats is CSV. In this section, we will walk through the process of reading a CSV and adjusting the dataset to arrive at some conclusions about the data. The data I am using is from the Heating System Choice in California Houses dataset, found at <a href="https://vincentarelbundock.github.io/Rdatasets/datasets.html" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9">https://vincentarelbundock.github.io/Rdatasets/datasets.html</a>:</p>
<pre class="commandlinepackt"><strong class="calibre3">#read in the CSV file as available on the site</strong>
<strong class="calibre3">heating &lt;- read.csv(file="Documents/heating.csv", header=TRUE, sep=",")</strong>
<strong class="calibre3"># make sure the data is laid out the way we expect</strong>
<strong class="calibre3">head(heating)</strong>  </pre>
<div><img class="image-border87" src="img/6d82a49c-9ad3-48b7-9da1-26d3d294e172.png"/></div>
<p class="calibre5">The data appears to be as expected; however, a number of the columns have acronym names and are somewhat duplicated. Let us change the names of interest that we want to be more readable and remove the extras we are not going to use:</p>
<pre class="commandlinepackt"><strong class="calibre3"># change the column names to be more readable</strong>
<strong class="calibre3">colnames(heating)[colnames(heating)=="depvar"] &lt;- "system"</strong>
<strong class="calibre3">colnames(heating)[colnames(heating)=="ic.gc"] &lt;- "install_cost"</strong>
<strong class="calibre3">colnames(heating)[colnames(heating)=="oc.gc"] &lt;- "annual_cost"</strong>
<strong class="calibre3">colnames(heating)[colnames(heating)=="pb.gc"] &lt;- "ratio_annual_install"</strong>

<strong class="calibre3"># remove columns which are not used</strong>
<strong class="calibre3">heating$idcase &lt;- NULL</strong>
<strong class="calibre3">heating$ic.gr &lt;- NULL</strong>
<strong class="calibre3">heating$ic.ec &lt;- NULL</strong>
<strong class="calibre3">heating$ic.hp &lt;- NULL</strong>
<strong class="calibre3">heating$ic.er &lt;- NULL</strong>
<strong class="calibre3">heating$oc.gr &lt;- NULL</strong>
<strong class="calibre3">heating$oc.ec &lt;- NULL</strong>
<strong class="calibre3">heating$oc.hp &lt;- NULL</strong>
<strong class="calibre3">heating$oc.er &lt;- NULL</strong>
<strong class="calibre3">heating$pb.gr &lt;- NULL</strong>
<strong class="calibre3">heating$pb.ec &lt;- NULL</strong>
<strong class="calibre3">heating$pb.er &lt;- NULL</strong>
<strong class="calibre3">heating$pb.hp &lt;- NULL</strong>

<strong class="calibre3"># check the data layout again now that we have made changes</strong>
<strong class="calibre3">head(heating)</strong>  </pre>
<div><div><img class="image-border88" src="img/55a0112e-f23a-4b20-9c5d-0b88e9672645.png"/></div>
</div>
<p class="calibre5">Now that we have a tighter dataset, let us start to look over the data:</p>
<pre class="commandlinepackt"><strong class="calibre3"># get rough statistics on the data</strong>
<strong class="calibre3">summary(heating)</strong>  </pre>
<div><div><img class="image-border89" src="img/ee0b06ea-9bad-4384-9e73-c865a9f8ab4d.png"/></div>
</div>
<p class="calibre5">Some points pop out from the summary:</p>
<ul class="calibre19">
<li class="calibre20">There are five different types of heating systems, gas cooling being most prevalent</li>
<li class="calibre20">Costs vary much more than expected</li>
<li class="calibre20">The data covers four large regions of California</li>
<li class="calibre20">The ration of the annual cost versus the initial cost varies much more than expected</li>
</ul>
<p class="calibre5">It is not obvious what the data relationships might be, but we can use the R <kbd class="calibre21">plot()</kbd> function to provide a quick snapshot that shows anything significant:</p>
<pre class="commandlinepackt"><strong class="calibre3">plot(heating)</strong>  </pre>
<div><div><img class="image-border90" src="img/9d1ba861-4bb7-4d37-a9c8-de91513f3153.png"/></div>
</div>
<p class="calibre5">Again, several interesting facts jump out:</p>
<ul class="calibre19">
<li class="calibre20">The initial cost varies widely within the type of system</li>
<li class="calibre20">The annual cost varies within the type of system as well</li>
<li class="calibre20">Costs vary widely within the ranges of customer income, age, number of rooms in the house, and region</li>
</ul>
<p class="calibre5">The only direct relationship between variables appears to be the initial cost of system and the annual cost. With covariance, we are looking for a measure of how much two variables change in relation to each other. If we run a covariance between the install and annual cost, we get:</p>
<pre class="commandlinepackt"><strong class="calibre3">cov(heating$install_cost, heating$annual_cost) </strong>
<strong class="calibre3">2131</strong>  </pre>
<p class="calibre5">I am not sure I have seen a higher covariance result.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading another CSV file</h1>
                
            
            
                
<p class="calibre5">We can look at another CSV in the same dataset to see what kind of issues we run across. Using the yearly batting records for all Major League Baseball players that we previously downloaded from the same site, we can use coding like the following to start analyzing the data:</p>
<pre class="commandlinepackt"><strong class="calibre3">players &lt;- read.csv(file="Documents/baseball.csv", header=TRUE, sep=",")</strong><strong class="calibre3">head(players)</strong> </pre>
<p class="calibre5">This produces the following head display:</p>
<div><img class="image-border91" src="img/9fd09754-548d-4d37-b6c0-d87bcfbedd60.png"/></div>
<p class="calibre5">There are many statistics for baseball players in this dataset. There are also many <kbd class="calibre21">NA</kbd> values. R is pretty good at ignoring <kbd class="calibre21">NA</kbd> values. Let us first look at the statistics for the data using:</p>
<pre class="commandlinepackt"><strong class="calibre3">summary(players)</strong></pre>
<p class="calibre5">This generates statistics on all the fields involved (there are several more that are not in this display):</p>
<div><img class="image-border92" src="img/9c6d3adf-d3dd-4208-a297-fb4e3a883cf0.png"/></div>
<p class="calibre5">A number of interesting points are visible in the preceding display that are worth noting:</p>
<ul class="calibre19">
<li class="calibre20">We have about 30 data points per player</li>
<li class="calibre20">It is interesting that the player data goes back to 1871</li>
<li class="calibre20">There are about 1,000 data points per team</li>
<li class="calibre20">American League and National League are clearly more popular</li>
<li class="calibre20">The range of some of the data points is surprising:
<ul class="calibre19">
<li class="calibre20">At bats range from 0 to 700</li>
<li class="calibre20">Runs (r) range from 0 to 177</li>
<li class="calibre20">Hits (h) range from 0 to 257</li>
</ul>
</li>
</ul>
<p class="calibre5">If we just plot some of the dominant data points, we can see the following:</p>
<pre class="commandlinepackt"><strong class="calibre3">plot(players$h, type="l", col="blue")<br class="calibre2"/></strong><strong class="calibre3"> <br class="calibre2"/></strong><strong class="calibre3"># doubles<br class="calibre2"/></strong><strong class="calibre3">lines(players$X2b, type="l", col="yellow")<br class="calibre2"/></strong><strong class="calibre3"> <br class="calibre2"/></strong><strong class="calibre3"># home runs<br class="calibre2"/></strong><strong class="calibre3">lines(players$hr, type="l", col="green")<br class="calibre2"/></strong><strong class="calibre3"> <br class="calibre2"/></strong><strong class="calibre3"># triples<br class="calibre2"/></strong><strong class="calibre3">lines(players$X3b, type="l", col="red")<br class="calibre2"/></strong><strong class="calibre3"> <br class="calibre2"/></strong><strong class="calibre3"># Create a title with a red, bold/italic font<br class="calibre2"/></strong><strong class="calibre3">title(main="Hits", font.main=4)#, xlab="Players", ylab="Hits and Home Runs")</strong></pre>
<p>The statistic graphs are displayed in this order so that smaller values are not overwritten by larger values (for example, the hits (largest numbers) are displayed first and the triples (smallest numbers) are displayed last on top of the previous numbers).</p>
<p class="calibre5">We have a display of the types of hits made by players over time as follows.</p>
<div><img class="image-border93" src="img/b4df2ed3-24c6-46fa-b6d0-bff059c68eb1.png"/></div>
<p class="calibre5">I thought it was interesting that so few triples were hit. Also, since the data is organized somewhat chronologically, the number of triples that are hit has been decreasing for some time. Maybe there is an emphasis on batting to go for the home run over batting to get a triple.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Manipulating data with dplyr</h1>
                
            
            
                
<p class="calibre5">The <kbd class="calibre21">dplyr</kbd> package for R is described as a package providing a grammar for data manipulation. It has the entry points you would expect for wrangling your data frame in one package. We will use the <kbd class="calibre21">dplyr</kbd> package against the baseball player statistics we used earlier in this chapter.</p>
<p class="calibre5">We read in the player data and show the first few rows:</p>
<pre class="commandlinepackt"><strong class="calibre3">players &lt;- read.csv(file="Documents/baseball.csv", header=TRUE, sep=",")<br class="calibre2"/></strong><strong class="calibre3">head(players)</strong></pre>
<div><img class="image-border94" src="img/344ae5cd-7bf7-4991-a635-54c400946447.png"/></div>
<p class="calibre5">We will be using the <kbd class="calibre21">dplyr</kbd> package, so we need to pull the package into our notebook:</p>
<pre class="commandlinepackt"><strong class="calibre3">library(dplyr)</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting a data frame to a dplyr table</h1>
                
            
            
                
<p class="calibre5">The <kbd class="calibre21">dplyr</kbd> package has functions to convert your data object into a <kbd class="calibre21">dplyr</kbd> table. A <kbd class="calibre21">dplyr</kbd> table stores data in a compact format using much less memory. Most of the other <kbd class="calibre21">dplyr</kbd> functions can operate directly on the table as well.</p>
<p class="calibre5">We can convert our data frame to a table using:</p>
<pre class="commandlinepackt"><strong class="calibre3">playerst &lt;- tbl_df(players)</strong> <strong class="calibre3">playerst</strong>  </pre>
<p class="calibre5">This results in a very similar display pattern:</p>
<div><img class="image-border95" src="img/74e65b8e-b129-4e02-8c27-e95eab88d1a0.png"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting a quick overview of the data value ranges</h1>
                
            
            
                
<p class="calibre5">Another function available in <kbd class="calibre21">dplyr</kbd> is the <kbd class="calibre21">glimpse()</kbd> function. It takes every column and displays the range of values present for that variable. We use the function in the following way:</p>
<pre class="commandlinepackt"><strong class="calibre3">glimpse(playerst)</strong>  </pre>
<p class="calibre5">This has the following display:</p>
<div><img class="image-border96" src="img/432954bc-562d-4a2a-9545-e367f7f5654e.png"/></div>
<p class="calibre5">I think I like this, in addition to the set of <kbd class="calibre21">summary</kbd>/<kbd class="calibre21">head</kbd> displays, as you get a feel for the variables involved rather than the rows involved, inverting the dataset.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Sampling a dataset</h1>
                
            
            
                
<p class="calibre5">The <kbd class="calibre21">dplyr</kbd> package has a function to gather a sample from your dataset, <kbd class="calibre21">sample()</kbd>. You pass in the dataset to operate against and how many samples you want drawn, <kbd class="calibre21">sample_n()</kbd>, and the fraction percentage, <kbd class="calibre21">sample_frac()</kbd>, as in this example:</p>
<pre class="commandlinepackt"><strong class="calibre3">data &lt;- sample_n(players, 30)</strong> <strong class="calibre3">glimpse(data)</strong></pre>
<p class="calibre5">We see the results as shown in the following screenshot:</p>
<p class="packt_figure1"><img class="image-border97" src="img/5278664c-08a9-43fb-b4d1-44f5621aaafa.png"/></p>
<p class="calibre5">Note that there are 30 observations in the results set, as requested.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Filtering rows in a data frame</h1>
                
            
            
                
<p class="calibre5">Another function we can use is the <kbd class="calibre21">filter</kbd> function. The <kbd class="calibre21">filter</kbd> function takes a data frame as an argument and a filtering statement. The function passes over each row of the data frame and returns those rows that meet the filtering statement:</p>
<pre class="commandlinepackt"><strong class="calibre3">#filter only players with over 200 hits in a season<br class="calibre2"/></strong><strong class="calibre3">over200 &lt;- filter(players, h &gt; 200)<br class="calibre2"/></strong><strong class="calibre3">head(over200)<br class="calibre2"/></strong><strong class="calibre3">nrow(over200)</strong></pre>
<p class="packt_figure1"><img class="image-border98" src="img/35016582-6cf7-4a2b-8fb2-fd3686bd0918.png"/></p>
<p class="calibre5">it looks like many players were capable of 200 hits a season. How about if we look at those players that could also get over 40 home runs in a season?</p>
<pre class="commandlinepackt"><strong class="calibre3">over200and40hr &lt;- filter(players, h &gt; 200 &amp; hr &gt; 40)<br class="calibre2"/></strong><strong class="calibre3">head(over200and40hr)<br class="calibre2"/></strong><strong class="calibre3">nrow(over200and40hr)</strong></pre>
<p class="packt_figure1"><img class="image-border99" src="img/7a05a0ac-505e-45b1-9a7a-74d3dbb572f4.png"/></p>
<p class="calibre5">It's a very small list. I know that player names are somewhat mangled, but you can recognize a few, such as Babe Ruth.</p>
<p class="calibre5">I wonder if any of the players hit over 300 times in a season.</p>
<pre class="commandlinepackt"><strong class="calibre3">filter(players, h &gt; 300)</strong></pre>
<p class="packt_figure1"><img class="image-border100" src="img/d42cbf4f-24fc-450f-b567-4371a9f56c67.png"/></p>
<p class="calibre5">It's interesting that no records met our <kbd class="calibre21">filter</kbd>, but the results handler requires a number of columns, and throws an error, as in this case there are none. Usually, errors in R are due to programming errors. It is unusual for R to generate an error for what I think would be normal no result data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding a column to a data frame</h1>
                
            
            
                
<p class="calibre5">The <kbd class="calibre21">mutate</kbd> function can be used to add a column to a data frame using the familiar R programming syntax you have seen elsewhere. In this case, we are adding a column to the data frame that has the percentage of time the player got a hit when at bat:</p>
<pre class="commandlinepackt"><strong class="calibre3">pct &lt;- mutate(players, hitpct = h / ab)</strong> <strong class="calibre3">head(pct)</strong></pre>
<p class="packt_figure1"><img class="image-border101" src="img/8137e49a-8240-409f-9537-93270d4f2fe9.png"/></p>
<p class="calibre5">You can see the new column on the right in the preceding display. If we run a <kbd class="calibre21">summary</kbd>, we will get a summary of all fields (including the new <kbd class="calibre21">hitpct</kbd>):</p>
<pre class="commandlinepackt"><strong class="calibre3">summary(pct)</strong></pre>
<p class="packt_figure1"><img class="image-border102" src="img/95a85481-9c45-430c-a92d-75106f42aced.png"/></p>
<p class="calibre5">With the max at <kbd class="calibre21">1.0</kbd>, that would mean some players got a hit every time they were at bat. Similarly, those with <kbd class="calibre21">0.0</kbd> never got a hit. It looks like a narrow range in the 20% area. Assume the <kbd class="calibre21">1.0</kbd> is one at bat and one hit, as all the other values are measured in multiple decimal points.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Obtaining a summary on a calculated field</h1>
                
            
            
                
<p class="calibre5">We can arrive more directly at the summary value for the column using the <kbd class="calibre21">summarize</kbd> function. The function takes a data frame and a singular calculated result. We can see the same result using the script as follows:</p>
<pre class="commandlinepackt"><strong class="calibre3">summarize(pct, mean(hitpct, na.rm = TRUE))</strong></pre>
<p class="packt_figure1"><img class="image-border103" src="img/e62ff202-0a34-42e0-be83-16cd0b7abfa5.png"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Piping data between functions</h1>
                
            
            
                
<p class="calibre5">We can obtain the same results by <em class="calibre18">piping</em> the data between functions. Piping is denoted using the symbols <kbd class="calibre21">%&gt;%</kbd> in R programming. It is available from the <kbd class="calibre21">magrittr</kbd> package. The piping symbols are normally thought of as synonyms for <em class="calibre18">then</em> in English. For example, the R statement <kbd class="calibre21">data %&gt;% function()</kbd> means take the data object and then pass it along to the <kbd class="calibre21">function()</kbd>, just as if we had entered the statement <kbd class="calibre21">function(data)</kbd>.</p>
<p class="calibre5">To produce the same summary on a calculated field using piping, we would write the following (meaning take the <kbd class="calibre21">pct</kbd> dataset and then pipe it into the <kbd class="calibre21">summarize</kbd> function, and take the <kbd class="calibre21">hitpct</kbd> field and pipe it into the mean function):</p>
<pre class="commandlinepackt"><strong class="calibre3">library(magrittr)</strong> <strong class="calibre3">pct %&gt;% summarize(hitpct %&gt;% mean(na.rm = TRUE))</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Obtaining the 99% quantile</h1>
                
            
            
                
<p class="calibre5">We can look at the cut-off for the 99% mark using the <kbd class="calibre21">quantile()</kbd> function. Using the same sample data, we could use:</p>
<pre class="commandlinepackt"><strong class="calibre3">quantile(pct$hitpct, probs = 0.99, na.rm = TRUE)</strong></pre>
<p class="calibre5">This would have corresponding output:</p>
<pre class="commandlinepackt"><strong class="calibre3">99%: 0.470588235294118</strong></pre>
<p class="calibre5">So, the hit percentage of 47% is the cutoff for the 99% level of the data. Given that the three-quarter percentile was at 28% (as in the preceding <kbd class="calibre21">hitpct</kbd> graphic), there is quite a range of performance for that last quarter of data pointsâ€”that is, there are some great baseball players.</p>
<p class="calibre5">We could get a list of those players in the top 25% of the hit percentage using:</p>
<pre class="commandlinepackt"><strong class="calibre3">top_players &lt;- filter(pct, hitpct &gt; 0.47)<br class="calibre2"/></strong><strong class="calibre3">top_players &lt;- top_players[order(top_players$hitpct) , ]<br class="calibre2"/></strong><strong class="calibre3">head(top_players)<br class="calibre2"/></strong><strong class="calibre3">nrow(top_players)<br class="calibre2"/></strong><strong class="calibre3">198</strong></pre>
<p>If the players are arranged by hit percentage in descending order, then the players with perfect hit ratios are displayed, but they all had under 10 at bats.</p>
<p class="calibre5">We can see the data points as follows:</p>
<div><img class="image-border104" src="img/9d3a65bd-f463-49e1-89d2-0411916ac7a9.png"/></div>
<p class="calibre5">So, we have 200 (<kbd class="calibre21">198</kbd>) players in the top 25% of our dataset, meaning that 1% of the players are in the top 25% of hit performance. I did not think the data would be that lopsided.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Obtaining a summary on grouped data</h1>
                
            
            
                
<p class="calibre5">Okay, the preceding steps tell us something about individual players. There is always the argument that team <em class="calibre18">X</em> is always better than everyone else. What if we could get a hit percentage by team and compare the results?</p>
<p class="calibre5">In this example, we are grouping the players by team and then computing an average hit percentage for the entire team:</p>
<pre class="commandlinepackt"><strong class="calibre3">teamhitpct &lt;- summarize(group_by(pct, team), mean(hitpct, na.rm = TRUE))<br class="calibre2"/></strong><strong class="calibre3">names(teamhitpct) &lt;- c("team", "hitpct")<br class="calibre2"/></strong><strong class="calibre3">summary(teamhitpct)</strong></pre>
<p class="packt_figure1"><img class="image-border105" src="img/15ab6c7a-dc74-475b-aa0a-0c77147d12db.png"/></p>
<p class="calibre5">So, who were the best teams ever? We can order the data by the teams' hit percentages (the <kbd class="calibre21">-teamhitpct</kbd> clause means that the results should be arranged in descending order) using:</p>
<pre class="commandlinepackt"><strong class="calibre3">teamhitpct &lt;- teamhitpct[order(-teamhitpct$hitpct) , ]</strong> <strong class="calibre3">head(teamhitpct)</strong></pre>
<p class="packt_figure1"><img class="image-border106" src="img/2198b3f7-9cc5-46e7-b314-9f0187ea0d5c.png"/></p>
<p class="calibre5">I'm not sure what the CNU team is; I assume it is an earlier Chicago team. The others are recognizable as Philadelphia, Toronto, and Boston.</p>
<p class="calibre5">We can find the top percentile of teams using the <kbd class="calibre21">quantile</kbd> function that we used previously for player hit performance:</p>
<pre class="commandlinepackt"><strong class="calibre3">quantile(teamhitpct$hitpct, probs = 0.99)</strong> </pre>
<p class="calibre5">This gives us the following result:</p>
<pre class="commandlinepackt"><strong class="calibre3">99%: 0.340577141193618</strong></pre>
<p class="calibre5">Comparing this to the previous table, we can see that only two teams (out of 130) are in the top performance group (which is about the 1% mark).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Tidying up data with tidyr</h1>
                
            
            
                
<p class="calibre5">The <kbd class="calibre21">tidyr</kbd> package is available to clean up/tidy your dataset. The use of <kbd class="calibre21">tidyr</kbd> is to rearrange your data so that:</p>
<ul class="calibre19">
<li class="calibre20">Each column is a variable</li>
<li class="calibre20">Each row is an observation</li>
</ul>
<p class="calibre5">When your data is arranged in this manner, it becomes much easier to analyze. There are many datasets published that mix columns and rows with values. You then must adjust them accordingly if you use the data in situ.</p>
<p class="calibre5"><kbd class="calibre21">tidyr</kbd> provides three functions for cleaning up your data:</p>
<ul class="calibre19">
<li class="calibre20"><kbd class="calibre21">gather</kbd></li>
<li class="calibre20"><kbd class="calibre21">separate</kbd></li>
<li class="calibre20"><kbd class="calibre21">spread</kbd></li>
</ul>
<p class="calibre5">The <kbd class="calibre21">gather()</kbd> function takes your data and arranges the data into key-value pairs, much like the Hadoop database model. Let's use the standard example of stock prices for a date using the following:</p>
<pre class="commandlinepackt"><strong class="calibre3">library(tidyr)<br class="calibre2"/>stocks &lt;- data_frame(<br class="calibre2"/></strong><strong class="calibre3">  time = as.Date('2017-08-05') + 0:9,<br class="calibre2"/></strong><strong class="calibre3">  X = rnorm(10, 20, 1), #how many numbers, mean, std dev<br class="calibre2"/></strong><strong class="calibre3">  Y = rnorm(10, 20, 2),<br class="calibre2"/></strong><strong class="calibre3">  Z = rnorm(10, 20, 4)<br class="calibre2"/></strong><strong class="calibre3">)</strong></pre>
<p class="calibre5">This will generate data that looks like this:</p>
<p class="packt_figure1"><img class="image-border107" src="img/b3cb9fa5-88a7-4fe6-b012-2a5bfc4c1fb5.png"/></p>
<p class="calibre5">Every row has a timestamp and the prices of the three stocks at that time.</p>
<p class="calibre5">We first use <kbd class="calibre21">gather()</kbd> to split out key-value pairs for the stocks. The <kbd class="calibre21">gather()</kbd> function is called with the data frame that it will work with, the output column names, and the columns to ignore (<kbd class="calibre21">-time</kbd>). So we get a row with the distinct time, stock, and prices using the following:</p>
<pre class="commandlinepackt"><strong class="calibre3">stocksg &lt;- gather(stocks, stock, price, -time)<br class="calibre2"/></strong><strong class="calibre3">head(stocksg)</strong>  </pre>
<p class="calibre5">This will generate the following <kbd class="calibre21">head()</kbd> display:</p>
<p class="packt_figure1"><img class="image-border108" src="img/feff73a6-bc34-4586-8b17-f14f3d07d910.png"/></p>
<p class="calibre5">The <kbd class="calibre21">separate()</kbd> function is used to split apart values that are in the same entry points.</p>
<p class="calibre5">We will use Dow Jones Index history about industrial prices from UCI (<a href="https://archive.ics.uci.edu/ml/datasets/Dow+Jones+Index" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9">https://archive.ics.uci.edu/ml/datasets/Dow+Jones+Index</a>):</p>
<pre class="commandlinepackt"><strong class="calibre3">dji &lt;- read.csv("Documents/dow_jones_index.data")<br class="calibre2"/></strong><strong class="calibre3">dj &lt;- dji[,c("stock","date","close")]<br class="calibre2"/></strong><strong class="calibre3">summary(dj)<br class="calibre2"/></strong><strong class="calibre3">head(dj)</strong></pre>
<p>We are only interested in the <kbd class="calibre21">stock</kbd>, <kbd class="calibre21">date</kbd>, and <kbd class="calibre21">close</kbd> columns.</p>
<p class="packt_figure1"><img class="image-border109" src="img/0aee2ec6-dd2c-4bac-b243-7abf360b1b6b.png"/></p>
<p class="calibre5">So, we have the date already gathered to start with (if we had disorganized data to start with, we would have used <kbd class="calibre21">gather</kbd> to organize it up to this point).</p>
<p class="calibre5">The <kbd class="calibre21">spread()</kbd> function will take the key-value pairs (from the <kbd class="calibre21">gather()</kbd> function) and separate out the values into multiple columns. We call <kbd class="calibre21">spread()</kbd> using the data frame containing our source date, the values to use for our columns, and the data points for each date/column. Continuing with our example, we can spread out all of the securities by date using:</p>
<pre class="commandlinepackt"><strong class="calibre3">prices &lt;- dj %&gt;% spread(stock, close)<br class="calibre2"/></strong><strong class="calibre3">summary(prices)<br class="calibre2"/></strong><strong class="calibre3">head(prices)</strong>  </pre>
<p class="calibre5">This results in the following <kbd class="calibre21">summary</kbd> display (shortened to just the first few securities):</p>
<p class="packt_figure1"><img class="image-border110" src="img/4a4ba21d-98c7-4247-bdf4-fa386875bdb8.png"/></p>
<p class="calibre5">It also results in the following <kbd class="calibre21">head</kbd> display, showing the prices of all the securities by date:</p>
<p class="packt_figure1"><img class="image-border111" src="img/5aeb3b09-73c3-4a90-b704-84af48fdc495.png"/></p>
<p class="calibre5">We can also similarly reorganize the data by listing all prices for a stock per row using:</p>
<pre class="commandlinepackt"><strong class="calibre3">times &lt;- dj %&gt;% spread(date, close)<br class="calibre2"/></strong><strong class="calibre3">summary(times)<br class="calibre2"/></strong><strong class="calibre3">head(times)</strong>  </pre>
<p class="calibre5">Here, our row driver is the stock, the column heading is the date value, and the data point for each stock/date is the closing price of the security on that date.</p>
<p class="calibre5">From the <kbd class="calibre21">summary</kbd> (abbreviated), we can see the following:</p>
<p class="packt_figure1"><img class="image-border112" src="img/0f5399d2-b45a-4445-839c-c6d8d1bce274.png"/></p>
<p class="calibre5">The following is the <kbd class="calibre21">head</kbd> sample showing the data in our desired format:</p>
<p class="packt_figure1"><img class="image-border113" src="img/49bff9b4-ab28-452a-9dd5-ec2150a54cde.png"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p class="calibre5">In this chapter, we read in CSV files and performed a quick analysis of the data, including visualizations to help understand the data. Next, we considered some of the functions available in the <kbd class="calibre21">dplyr</kbd> package, including drawing a glimpse of the ranges of the data items, sampling a dataset, filtering out data, adding columns using mutate, and producing a summary. While doing so, we also started to use piping to more easily transfer the results of one operation into another operation. Lastly, we looked into the <kbd class="calibre21">tidyr</kbd> package to clean or tidy up our data into distinct columns and observations using the associated gather, separate, and spread functions.</p>
<p class="calibre5">In the next chapter, we will look at producing a dashboard under Jupyter.</p>
<p class="calibre5"/>
<p class="calibre5"/>


            

            
        
    </div>



  </body></html>