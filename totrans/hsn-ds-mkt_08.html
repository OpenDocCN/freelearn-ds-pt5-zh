<html><head></head><body>
        

                            
                    <h1 class="header-title">Product Analytics</h1>
                
            
            
                
<p>From this chapter on, we are going to switch gears from conducting analyses on customer behaviors and start discussing how we can use data science for more granular, product-level analytics. There has been increasing interest and demand from various companies, especially among e-commerce businesses, for utilizing data to understand how customers engage and interact with different products. It has also been proven that rigorous product analytics can help businesses to improve user engagements and conversions that ultimately leads to higher profits. In this chapter, we are going to discuss what product analytics is and how it can be employed for different use cases.</p>
<p>Once we familiarize ourselves with the concept of product analytics, we are going to use the <em>Online Retail Data Set</em> from the UCI Machine Learning Repository for our programming exercises. We are going to start by analyzing the overall time series trends we can observe from the dataset. Then, we will look into how the customer engagements and interactions with individual products change over time with the goal of being able to build a simple product recommendation logic or algorithm in the end. For Python exercises, we will mainly utilize the <kbd>pandas</kbd> and <kbd>matplotlib</kbd> libraries for data analyses and visualizations. For R exercises, we will mainly use the <kbd>dplyr</kbd> and <kbd>ggplot2</kbd> libraries and introduce two other R libraries, <kbd>readxl</kbd> and <kbd>lubridate</kbd>.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The importance of product analytics</li>
<li>Product analytics using Python</li>
<li>Product analytics using R</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The importance of product analytics</h1>
                
            
            
                
<p><strong>Product analytics</strong> is a way to draw insights from data on how customers engage and interact with products offered, how different products perform, and what some of the observable weaknesses and strengths in a business are. However, product analytics does not just stop at analyzing the data. The ultimate goal of product analytics is really to build actionable insights and reports that can further help optimize and improve product performance and generate new marketing or product ideas based on the findings of product analytics.</p>
<p>Product analytics starts by tracking events. These events can be customer website visits, page views, browser histories, purchases, or any other actions that customers can take with the products that you offer. Then, you can start analyzing and visualizing any observable patterns in these events with the goal of creating actionable insights or reports. Some of the common goals with product analytics are as follows:</p>
<ul>
<li><strong>Improve customer and product retention</strong>: By analyzing what customers viewed and purchased, you can identify what items customers repeatedly purchase and who those repeat customers are. On the other hand, you can also identify what items customers do not buy and the customers who are at risk of churning. Analyzing and understanding the common attributes of the repeatedly purchased items and repeat customers can help you improve your retention strategy.</li>
<li><strong>Identify popular and trending products</strong>: As a marketer for retail businesses, it is important to have a good understanding of popular and trending products. These best-selling products are key revenue drivers for the business and provide new selling opportunities, such as cross-sells or bundle sales. With product analytics, you should be able to identify and track these popular and trending products easily and generate new strategies to explore different opportunities using these best-selling products.</li>
<li><strong>Segment customers and products based on their key attributes</strong>: With the customer profile and product data, you can segment your customer base and products based on their attributes using product analytics. Some of the ways to segment your product data are based on their profitability, volumes of sales, volumes of reorders, and numbers of refunds. With these segmentations, you can draw actionable insights on which product or customer segments to target next.</li>
<li><strong>Develop marketing strategies with higher ROI</strong>: Product analytics can also be used to analyze the <strong>return on investment</strong> (<strong>ROI</strong>) of your marketing strategies. By analyzing the marketing dollars spent on promoting certain items and the revenue generated from those products, you can understand what works and what does not. Using product analytics for marketing ROI analyses can help you create more efficient marketing strategies.</li>
</ul>
<p>With what we have discussed here about product analytics, we are going to discuss how to achieve some of these product analytics goals using retail business data in the following programming exercises. We are going to discuss how we can use the data to analyze the patterns of repeat customers and their contributions to overall revenue. Also, we will be covering how we can use product analytics to analyze the behaviors of best-selling products. More specifically, we are going to discuss how to track the trends of popular items over time and then briefly discuss how we can utilize this trending item data for product recommendations in your marketing strategies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Product analytics using Python</h1>
                
            
            
                
<p>In this section, we are going to discuss how to conduct product analytics using the <kbd>pandas</kbd> and <kbd>matplotlib</kbd> packages in Python. For those readers who would like to use R, instead of Python, for this exercise, you can skip to the next section. We will start this section by analyzing the overall time series trends in the revenue and numbers of purchases, and the purchase patterns of repeat purchase customers, and then we will move on to analyze the trends in products being sold.</p>
<p>For this exercise, we will be using one of the publicly available datasets from the UCI Machine Learning Repository, which can be found using this link: <a href="http://archive.ics.uci.edu/ml/datasets/online+retail#">http://archive.ics.uci.edu/ml/datasets/online+retail#</a>. From this link, you can download the data in Microsoft Excel format, named <kbd>Online Retail.xlsx</kbd>. Once you have downloaded this data, you can load it into your Jupyter Notebook by running the following command:</p>
<pre>%matplotlib inline<br/><br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/><br/>df = pd.read_excel(io='../data/Online Retail.xlsx', sheet_name='Online Retail')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Similar to the other Python exercises in previous chapters, we use the <kbd>%matplotlib inline</kbd> command to display plots on the Jupyter Notebook. Then, we can import the <kbd>matplotlib</kbd> and <kbd>pandas</kbd> packages that we will be using for further product analytics. One thing to note in this code snippet is the new function in the <kbd>pandas</kbd> package that we are using here, <kbd>read_excel</kbd>. This function lets you load any Excel file into your <kbd>pandas</kbd> <kbd>DataFrame</kbd>. As you can see from this code, we are passing two arguments to the <kbd>read_excel</kbd> function—<kbd>io</kbd>, for the path to the data file, and <kbd>sheet_name</kbd>, for the name of the Excel sheet that we want to load the data from.</p>
<p>Once you have loaded this data into a <kbd>pandas</kbd> <kbd>DataFrame</kbd>, it should look as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1096 image-border" src="img/096f311a-dc65-4cc1-9982-e1b9e9611777.png" style="width:150.00em;height:50.50em;"/></p>
<p>Before we move on to the next step, there is one data-cleaning step we need to take. Let's look quickly at the distribution of the <kbd>Quantity</kbd> column. We will visualize the distributions of <kbd>Quantity</kbd> by using the following code:</p>
<pre>ax = df['Quantity'].plot.box(<br/>    showfliers=False,<br/>    grid=True,<br/>    figsize=(10, 7)<br/>)<br/><br/>ax.set_ylabel('Order Quantity')<br/>ax.set_title('Quantity Distribution')<br/><br/>plt.suptitle("")<br/>plt.show()</pre>
<p>As you can see from this code, we are visualizing the distribution of the <kbd>Quantity</kbd> column, in a box plot, by using <kbd>pandas</kbd> <kbd>DataFrame</kbd>'s <kbd>plot.box</kbd> function. The resulting box plot looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1097 image-border" src="img/54de30b6-5883-437f-a6e5-bc5c570d2da6.png" style="width:40.00em;height:27.67em;"/></p>
<p>As you can see from this plot, some orders have negative quantities. This is because the cancelled or refunded orders are recorded with negative values in the <kbd>Quantity</kbd> column of our dataset. For illustration purposes in this exercise, we are going to disregard the cancelled orders. We can filter out all the cancelled orders in our <kbd>DataFrame</kbd> by using the following code:</p>
<pre>df = df.loc[df['Quantity'] &gt; 0]</pre>
<p>Now, we are ready to conduct further analyses and dive into our data.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Time series trends</h1>
                
            
            
                
<p>Before we look at product-level data, as a marketer for an e-commerce business, it will be beneficial to have a better understanding of the overall time series trends in the revenue and the numbers of orders or purchases. This will help us understand whether the business is growing or shrinking in terms of both the overall revenue and the numbers of orders we receive over time.</p>
<p>First, we are going to look into the numbers of orders received over time. Take a look at the following code:</p>
<pre>monthly_orders_df = df.set_index('InvoiceDate')['InvoiceNo'].resample('M').nunique()</pre>
<p>As you can see from this code, we are using the <kbd>resample</kbd> and <kbd>nunique</kbd> functions that we have not used in the previous chapters. The <kbd>resample</kbd> function resamples and converts time series data into the frequency we desire. In our example, we are resampling our time series data into monthly time series data, by using <kbd>'M'</kbd> as our target frequency and counting the number of distinct or unique invoice numbers. This way, we can get the number of unique purchases or orders month-on-month. The resulting DataFrame looks like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1335 image-border" src="img/48e37c4a-56ab-46ef-ba29-ebe5e0f740bc.png" style="width:22.33em;height:17.17em;"/></p>
<p>Often, time series data is better visualized using line charts. Let's take a look at the following code to see how we can visualize this monthly data in a line chart:</p>
<pre>ax = pd.DataFrame(monthly_orders_df.values).plot(<br/>    grid=True,<br/>    figsize=(10,7),<br/>    legend=False<br/>)<br/><br/>ax.set_xlabel('date')<br/>ax.set_ylabel('number of orders/invoices')<br/>ax.set_title('Total Number of Orders Over Time')<br/><br/>plt.xticks(<br/>    range(len(monthly_orders_df.index)), <br/>    [x.strftime('%m.%Y') for x in monthly_orders_df.index], <br/>    rotation=45<br/>)<br/><br/>plt.show()</pre>
<p>As you can see from this code, we are using the <kbd>plot</kbd> function of a <kbd>pandas</kbd> <kbd>DataFrame</kbd>. Using the <kbd>xticks</kbd> function of the <kbd>matplotlib</kbd> package, we can customize the labels of the <em>x</em>-ticks. Let's take a look at the following plot first:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1099 image-border" src="img/ad4f12ae-d753-49b2-ac9f-a60d18a5c2c3.png" style="width:43.75em;height:32.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you may notice from this plot, the tick labels in the <em>x </em>axis are formatted by month and year. If you look back at the previous code, we formatted them using <kbd>x.strftime('%m.%Y')</kbd>, where <kbd>x</kbd> is the <kbd>Python</kbd> <kbd>date</kbd> object, <kbd>%m</kbd> is the placeholder for the month value, and <kbd>%Y</kbd> is the placeholder for the year value. The <kbd>strftime</kbd> function of the <kbd>Python</kbd> <kbd>date</kbd> object formats the date into the given format.</p>
<p>One thing that is noticeable from this chart is that there is a sudden radical drop in the number of orders in December 2011. If you look closely at the data, this is simply because we do not have the data for the full month of December 2011. We can verify this by using the following code:</p>
<pre>invoice_dates = df.loc[<br/>    df['InvoiceDate'] &gt;= '2011-12-01',<br/>    'InvoiceDate'<br/>]<br/><br/>print('Min date: %s\nMax date: %s' % (invoice_dates.min(), invoice_dates.max()))</pre>
<p>In this code, we get a series of all invoice dates from December 1, 2011. Then, we print out the minimum and maximum dates. When you run this code, you will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1100 image-border" src="img/01decec3-7868-42e0-9104-b2ef6c8cbd2b.png" style="width:130.83em;height:14.17em;"/></p>
<p>As you can see from this output, we only have the data from December 1, to December 9, 2011. It would be a misrepresentation if we use this data for analyzing December sales and revenue. For further analyses, we will disregard any data from December 1, 2011. You can use the following code to remove those data points:</p>
<pre>df = df.loc[df['InvoiceDate'] &lt; '2011-12-01']</pre>
<p>Now that we have filtered out incomplete data for December 2011, we can redraw the line chart using the previous codes. After removing those data points from December 2011, the line chart looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1091 image-border" src="img/c5682d30-7659-4fa2-8bcf-1f6078448ba5.png" style="width:43.25em;height:32.92em;"/></p>
<p class="mce-root">Let's take a closer look at this chart. The monthly number of orders seems to float around 1,500 from December 2010 to August 2011, and then increases significantly from September 2011, and almost doubles by November 2011. One explanation for this could be that the business is actually growing significantly from September 2011. Another explanation could be seasonal effects. In e-commerce businesses, it is not rare to see spikes in sales as it approaches the end of the year. Typically, sales rise significantly from October to January for many e-commerce businesses, and without the data from the previous year, it is difficult to conclude whether this spike in sales is due to a growth in business or due to seasonal effects. When you are analyzing your data, we advise you to compare the current year's data against the previous year's data.</p>
<p class="mce-root"/>
<p class="mce-root">Let's take a quick look at the monthly revenue data by looking at the following code:</p>
<pre>df['Sales'] = df['Quantity'] * df['UnitPrice']<br/><br/>monthly_revenue_df = df.set_index('InvoiceDate')['Sales'].resample('M').sum()</pre>
<p>As you can see from this code, the first thing we do here is to calculate the aggregate sales amount from each order, which is simply the <kbd>UnitPrice</kbd> multiplied by the <kbd>Quantity</kbd>. Once we have computed and created this <kbd>Sales</kbd> column, we can use the <kbd>resample</kbd> function with an <kbd>'M'</kbd> flag to resample and convert our time series data into monthly data. Then, using <kbd>sum</kbd> as the aggregate function, we can get the monthly sales revenue data. The resulting data looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1101 image-border" src="img/b829132b-f558-48b6-8f00-3c740fdbf9db.png" style="width:25.83em;height:19.42em;"/></p>
<p>We can visualize this data into a line plot, using the following code:</p>
<pre>ax = pd.DataFrame(monthly_revenue_df.values).plot(<br/>    grid=True,<br/>    figsize=(10,7),<br/>    legend=False<br/>)<br/><br/>ax.set_xlabel('date')<br/>ax.set_ylabel('sales')<br/>ax.set_title('Total Revenue Over Time')<br/><br/>ax.set_ylim([0, max(monthly_revenue_df.values)+100000])<br/><br/>plt.xticks(<br/>    range(len(monthly_revenue_df.index)), <br/>    [x.strftime('%m.%Y') for x in monthly_revenue_df.index], <br/>    rotation=45<br/>)<br/><br/>plt.show()</pre>
<p>As previously discussed, we can use the <kbd>pandas</kbd> <kbd>DataFrame</kbd> plot function to build a line chart and the <kbd>xticks</kbd> function of the <kbd>matplotlib</kbd> package to rename the labels of the ticks on the <em>x </em>axis. The line plot looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1102 image-border" src="img/37e02fa6-0a42-46e8-8506-1809d6509d55.png" style="width:41.42em;height:30.33em;"/></p>
<p>We see a similar pattern to the previous monthly Total Number of Orders Over Time chart in this monthly revenue chart. The monthly revenue floats around 700,000 from December 2010 to August 2011 and then it increases significantly from September 2011. As discussed before, to verify whether this significant increase in sales and revenue is due to a growth in business or due to seasonal effects, we need to look further back in the sales history and compare the current year's sales against the previous year's sales.</p>
<p>These types of general and broad time series analyses can help marketers gain a better understanding of the overall performance of the business and identify any potential problems that might be occurring within the business. It is generally a good idea to start with broader analyses, and then drill down into more granular and specific parts of the business for further product analytics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Repeat customers</h1>
                
            
            
                
<p>Another important factor of a successful business is how well it is retaining customers and how many repeat purchases and customers it has. In this section, we are going to analyze the number of monthly repeat purchases and how much of the monthly revenue is attributable to these repeat purchases and customers. A typical strong and stable business has a steady stream of sales from existing customers. Let's see how much of the sales are from repeat and existing customers of the online retail business that we are currently analyzing in this chapter.</p>
<p>We are going to look at the number of monthly repeat purchases. This means a customer placed more than one order within a given month. Let's take a quick look at the data we have:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1103 image-border" src="img/c5276037-522c-44b8-a7ac-1da03529ebb4.png" style="width:159.50em;height:37.17em;"/></p>
<p>As you might have noticed from this snapshot of the data, there are multiple records for one purchase order (<kbd>InvoiceNo</kbd>). However, what we need is the aggregate data for each order, so that one record in the <kbd>DataFrame</kbd> represents one purchase order. We can aggregate this raw data for each <kbd>InvoiceNo</kbd> by using the following code:</p>
<pre>invoice_customer_df = df.groupby(<br/>    by=['InvoiceNo', 'InvoiceDate']<br/>).agg({<br/>    'Sales': sum,<br/>    'CustomerID': max,<br/>    'Country': max,<br/>}).reset_index()</pre>
<p>As you can see from this code, we are grouping the <kbd>DataFrame</kbd>, <kbd>df</kbd>, by <kbd>InvoiceNo</kbd> and <kbd>InvoiceDate</kbd> and summing up all the <kbd>Sales</kbd>. This way, our new <kbd>DataFrame</kbd>, <kbd>invoice_customer_df</kbd>, has one record for each purchase order. The resulting <kbd>DataFrame</kbd> looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1104 image-border" src="img/d1fa9422-1138-414c-979b-596795fa74d1.png" style="width:37.00em;height:16.50em;"/></p>
<p>As you can see here, each record in the <kbd>DataFrame</kbd> now has all the information we need for each order. Now, we need to aggregate this data per month and compute the number of customers who made more than one purchase in a given month. Take a look at the following code:</p>
<pre>monthly_repeat_customers_df = invoice_customer_df.set_index('InvoiceDate').groupby([<br/>    pd.Grouper(freq='M'), 'CustomerID'<br/>]).filter(lambda x: len(x) &gt; 1).resample('M').nunique()['CustomerID']</pre>
<p>Let's take a closer look at the <kbd>groupby</kbd> function in this code. Here, we group by two conditions—<kbd>pd.Grouper(freq='M')</kbd> and <kbd>CustomerID</kbd>. The first <kbd>groupby</kbd> condition, <kbd>pd.Grouper(freq='M')</kbd>, groups the data by the index, <kbd>InvoiceDate</kbd>, into each month. Then, we group this data by each <kbd>CustomerID</kbd>. Using the <kbd>filter</kbd> function, we can subselect the data by a custom rule. Here, the filtering rule, <kbd>lambda x: len(x) &gt; 1</kbd>, means we want to retrieve those with more than one record in the group. In other words, we want to retrieve only those customers with more than one order in a given month. Lastly, we resample and aggregate by each month and count the number of unique customers in each month by using <kbd>resample('M')</kbd> and <kbd>nunique</kbd>.</p>
<p>The resulting data looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1105 image-border" src="img/f6eae90f-fb10-4aab-a8ed-29eec5ede24a.png" style="width:31.08em;height:21.58em;"/></p>
<p>Let's now compare these numbers against the total number of monthly customers. You can use the following code to compute the total number of monthly customers:</p>
<pre>monthly_unique_customers_df = df.set_index('InvoiceDate')['CustomerID'].resample('M').nunique()</pre>
<p>And the resulting data looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1106 image-border" src="img/cd010434-9dd1-41b3-8215-0e8369e318c6.png" style="width:29.58em;height:18.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If you compare these two sets of numbers, roughly about 20 to 30% of the customers are repeat customers. You can use the following code to calculate the percentages of repeat customers for each month:</p>
<pre>monthly_repeat_percentage = monthly_repeat_customers_df/monthly_unique_customers_df*100.0</pre>
<p>Let's visualize all of this data in one chart:</p>
<pre>ax = pd.DataFrame(monthly_repeat_customers_df.values).plot(<br/>    figsize=(10,7)<br/>)<br/><br/>pd.DataFrame(monthly_unique_customers_df.values).plot(<br/>    ax=ax,<br/>    grid=True<br/>)<br/><br/>ax2 = pd.DataFrame(monthly_repeat_percentage.values).plot.bar(<br/>    ax=ax,<br/>    grid=True,<br/>    secondary_y=True,<br/>    color='green',<br/>    alpha=0.2<br/>)<br/><br/>ax.set_xlabel('date')<br/>ax.set_ylabel('number of customers')<br/>ax.set_title('Number of All vs. Repeat Customers Over Time')<br/><br/>ax2.set_ylabel('percentage (%)')<br/><br/>ax.legend(['Repeat Customers', 'All Customers'])<br/>ax2.legend(['Percentage of Repeat'], loc='upper right')<br/><br/>ax.set_ylim([0, monthly_unique_customers_df.values.max()+100])<br/>ax2.set_ylim([0, 100])<br/><br/>plt.xticks(<br/>    range(len(monthly_repeat_customers_df.index)), <br/>    [x.strftime('%m.%Y') for x in monthly_repeat_customers_df.index], <br/>    rotation=45<br/>)<br/><br/>plt.show()</pre>
<p class="mce-root"/>
<p>In this code, you will notice a new flag, <kbd>secondary_y=True</kbd>, to the <kbd>plot</kbd> function. As the name suggests, if you set this <kbd>secondary_y</kbd> flag to <kbd>True</kbd>, then it will create a new <em>y </em>axis on the right side of the chart. This is especially useful when you want to visualize two sets of data with different scales. In our case, the scale for one set of our data is the number of users, and the scale for another set of our data is the percentage. Using this <kbd>secondary_y</kbd> flag, we can easily visualize data with different scales in one plot.</p>
<p>Once you run this code, you will see the following chart:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1107 image-border" src="img/1daa0094-575f-461e-996d-0e0d3589a170.png" style="width:49.67em;height:35.67em;"/></p>
<p>As you can see from this chart, the numbers of both repeat and all customers start to rise significantly from September 2011. The percentage of Repeat Customers seems to stay pretty consistent at about 20 to 30%. This online retail business will benefit from this steady stream of Repeat Customers, as they will help the business to generate a stable stream of sales. Let's now analyze how much of the monthly revenue comes from these Repeat Customers.</p>
<p>The following code shows how to compute the monthly revenue from Repeat Customers:</p>
<pre>monthly_rev_repeat_customers_df = invoice_customer_df.set_index('InvoiceDate').groupby([<br/>    pd.Grouper(freq='M'), 'CustomerID'<br/>]).filter(lambda x: len(x) &gt; 1).resample('M').sum()['Sales']<br/><br/>monthly_rev_perc_repeat_customers_df = monthly_rev_repeat_customers_df/monthly_revenue_df * 100.0</pre>
<p>The only difference between this code and the previous code is the aggregate function, <kbd>sum</kbd>, that follows <kbd>resample('M')</kbd>. In the previous case, when we were computing the number of monthly repeat customers, we used the <kbd>nunique</kbd> function. However, this time we are using the <kbd>sum</kbd> function to add all the sales from repeat customers for a given month. For visualization, you can use the following code:</p>
<pre>ax = pd.DataFrame(monthly_revenue_df.values).plot(figsize=(12,9))<br/><br/>pd.DataFrame(monthly_rev_repeat_customers_df.values).plot(<br/>    ax=ax,<br/>    grid=True,<br/>)<br/><br/>ax.set_xlabel('date')<br/>ax.set_ylabel('sales')<br/>ax.set_title('Total Revenue vs. Revenue from Repeat Customers')<br/><br/>ax.legend(['Total Revenue', 'Repeat Customer Revenue'])<br/><br/>ax.set_ylim([0, max(monthly_revenue_df.values)+100000])<br/><br/>ax2 = ax.twinx()<br/><br/>pd.DataFrame(monthly_rev_perc_repeat_customers_df.values).plot(<br/>    ax=ax2,<br/>    kind='bar',<br/>    color='g',<br/>    alpha=0.2<br/>)<br/><br/>ax2.set_ylim([0, max(monthly_rev_perc_repeat_customers_df.values)+30])<br/>ax2.set_ylabel('percentage (%)')<br/>ax2.legend(['Repeat Revenue Percentage'])<br/><br/>ax2.set_xticklabels([<br/>    x.strftime('%m.%Y') for x in monthly_rev_perc_repeat_customers_df.index<br/>])<br/><br/>plt.show()</pre>
<p>One thing to note in this code is the line, <kbd>ax2 = ax.twinx()</kbd>. This essentially does the same job as the <kbd>secondary_y</kbd> flag that we discussed previously. The <kbd>twinx</kbd> function simply creates a twin <em>y </em>axis that shares the same <em>x </em>axis and has the same effect as the <kbd>secondary_y</kbd> flag. The resulting graph looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1108 image-border" src="img/26e29621-d7e2-4383-bb6e-0777fac54591.png" style="width:65.17em;height:45.83em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We see a similar pattern as before, where there is a significant increase in the revenue from September 2011. One interesting thing to notice here is the percentage of the monthly revenue from repeat customers. We have seen that roughly 20-30% of the customers who made purchases are repeat customers. However, in this graph, we can see that roughly 40-50% of the Total Revenue is from repeat customers. In other words, roughly half of the revenue was driven by the 20-30% of the customer base who are repeat customers. This shows how important it is to retain existing customers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trending items over time</h1>
                
            
            
                
<p>So far, we have analyzed the overall time series patterns and how customers engage with the overall business, but not how customers engage with individual products. In this section, we are going to explore and analyze how customers interact with individual products that are sold. More specifically, we will take a look at the trends of the top five best-sellers over time.</p>
<p>For time series trending-item analysis, let's count the number of items sold for each product for each period. Take a look at the following code:</p>
<pre>date_item_df = df.set_index('InvoiceDate').groupby([<br/>    pd.Grouper(freq='M'), 'StockCode'<br/>])['Quantity'].sum()</pre>
<p>As you can see from this code snippet, we are grouping the DataFrame, <kbd>df</kbd>, by month with <kbd>StockCode</kbd>, which is the unique code for each product, and then summing up the quantities sold for each month and <kbd>StockCode</kbd>. The first nine records of the result look like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1109 image-border" src="img/41652208-aee7-4f48-849e-ec662d3c34de.png" style="width:16.17em;height:18.50em;"/></p>
<p class="mce-root"/>
<p class="mce-root">With this data in <kbd>data_item_df</kbd>, let's see what items were sold the most on November 30, 2011. Take a look at the following code:</p>
<pre># Rank items by the last month sales<br/>last_month_sorted_df = date_item_df.loc['2011-11-30'].sort_values(<br/>    by='Quantity', ascending=False<br/>).reset_index()</pre>
<p>As you can see from this code, we can use the <kbd>sort_values</kbd> function to sort a <kbd>pandas</kbd> <kbd>DataFrame</kbd> by any column we want by providing the column name in the input argument, <kbd>by</kbd>. Here, we are sorting the data by the column, <kbd>Quantity</kbd>, in descending order, by setting the <kbd>ascending</kbd> flag to <kbd>False</kbd>. The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/56cd63bf-2140-4d12-91cd-dca5bb456e73.png" style="width:17.83em;height:19.75em;"/></p>
<p>As you can see from this result, the products with the codes 23084, 84826, 22197, 22086, and 85099B were the top five best-sellers in the month of November 2011. </p>
<p>Now that we know what the top five best-sellers were in November 2011, let's aggregate the monthly sales data for these five products again. Take a look at the following code:</p>
<pre>date_item_df = df.loc[<br/>    df['StockCode'].isin([23084, 84826, 22197, 22086, '85099B'])<br/>].set_index('InvoiceDate').groupby([<br/>    pd.Grouper(freq='M'), 'StockCode'<br/>])['Quantity'].sum()</pre>
<p>As you can see from this code, we are still grouping the data by each month and <kbd>StockCode</kbd>, and summing up the quantities sold. However, one thing to note here is the <kbd>isin</kbd> operator. The <kbd>isin</kbd> operator within the <kbd>loc</kbd> operator checks whether each record matches with one of the elements in the array. In our case, we are checking if the <kbd>StockCode</kbd> of each record matches with the top five best-sellers' item codes. Using this code, we can aggregate the data by month and product just for the top five best-sellers in November 2011. The first few records of the result look like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b714e195-cc81-4279-a650-21e4021dd6ec.png" style="width:15.92em;height:26.00em;"/></p>
<p>Now that we have this monthly sales data for the top five products, we need to transform this data into a tabular format, where the columns are the individual item codes, the row indexes are the invoice dates, and the values are the number of items sold, so that we can visualize this data as a time series chart. The following code shows you how you can transform this data into a tabular format:</p>
<pre>trending_itmes_df = date_item_df.reset_index().pivot('InvoiceDate','StockCode').fillna(0)<br/><br/>trending_itmes_df = trending_itmes_df.reset_index()<br/>trending_itmes_df = trending_itmes_df.set_index('InvoiceDate')<br/>trending_itmes_df.columns = trending_itmes_df.columns.droplevel(0)</pre>
<p>As you can see in this code, we are using the <kbd>pivot</kbd> function to <kbd>pivot</kbd> this <kbd>DataFrame</kbd>, where the index is the <kbd>InvoiceDate</kbd> and the columns are individual codes in the <kbd>StockCode</kbd> column. The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/aad00b6d-60e1-45c8-b128-16da0503822a.png" style="width:22.83em;height:24.17em;"/></p>
<p>With this time series data, we can now visualize the trends over time. You can use the following code to build a time series plot for trending items:</p>
<pre>ax = pd.DataFrame(trending_itmes_df.values).plot(<br/>    figsize=(10,7),<br/>    grid=True,<br/>)<br/><br/>ax.set_ylabel('number of purchases')<br/>ax.set_xlabel('date')<br/>ax.set_title('Item Trends over Time')<br/><br/>ax.legend(trending_itmes_df.columns, loc='upper left')<br/><br/>plt.xticks(<br/>    range(len(trending_itmes_df.index)), <br/>    [x.strftime('%m.%Y') for x in trending_itmes_df.index], <br/>    rotation=45<br/>)<br/><br/>plt.show()</pre>
<p>When you run this code, you should see the following chart:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1085 image-border" src="img/844eee16-fbd5-4e66-b64c-a2cc6599bf4b.png" style="width:41.08em;height:30.25em;"/></p>
<p>Let's take a closer look at this time series plot. The sales of these five products spiked in November 2011, especially, the sales of the product with the stock code, 85099B, which were close to 0 from February 2011 to October 2011. Then, it suddenly spiked in November 2011. It might be worth taking a closer look into what might have driven this spike. It could be an item that is highly sensitive to seasonality, such that this item becomes very popular during November, or it could also be due to a genuine change in trends that led this item to become suddenly more popular than before.</p>
<p>The popularity of the rest of the top five products, 22086, 22197, 23084, and 84826, seem to have built up in the few months prior to November 2011. As a marketer, it would be worthwhile taking a closer look at the potential drivers behind this buildup of rising popularity for these items. You could look at whether these items are typically more popular in colder seasons or whether there is a rising trend for these specific items in the market.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Analyzing the trends and changes in the popularity of products not only helps you understand what your customers like and purchase the most, but also helps you tailor your marketing messages. For example, you can recommend these items with rising popularity in your marketing emails, calls, or advertisements to improve customer engagement. As it has been shown that your customers are more interested and more likely to purchase these items, you might get higher marketing engagement from your customers when you market these items more and you might eventually get higher conversion rates when you target your customers with these trending items. Using these popular and trending items is one way to build a product recommendation engine, which we are going to expand on and experiment with thoroughly in the next chapter.</p>
<p>The full code for Python exercises in this section can be found at: <a href="https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.5/python/Product%20Analytics.ipynb">https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.5/python/Product%20Analytics.ipynb</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Product analytics using R</h1>
                
            
            
                
<p>In this section, we are going to discuss how to conduct product analytics using the <kbd>dplyr</kbd> and <kbd>ggplot2</kbd> libraries in R. For those readers who would like to use Python, instead of R, you can ignore this section and move to the following section. We will start this section by analyzing the overall time series trends in the revenue, numbers of purchases, and purchasing patterns of repeat purchase customers, and then we will move on to analyzing the trends in products being sold.</p>
<p>For this exercise, we will be using one of the publicly available datasets from the UCI Machine Learning Repository, which can be found at: <a href="http://archive.ics.uci.edu/ml/datasets/online+retail#">http://archive.ics.uci.edu/ml/datasets/online+retail#</a>. You can follow this link and download the data in Microsoft Excel format, named <kbd>Online Retail.xlsx</kbd>. Once you have downloaded this data, you can load it by running the following code:</p>
<pre># install.packages("readxl")<br/>library(readxl)<br/><br/>#### 1. Load Data ####<br/>df &lt;- read_excel(<br/>  path="~/Documents/research/data-science-marketing/ch.5/data/Online Retail.xlsx", <br/>  sheet="Online Retail"<br/>)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you may notice from this code, one thing we are doing differently here from previous chapters is using the <kbd>readxl</kbd> library and the <kbd>read_excel</kbd> function. Since our data is in Excel format, we cannot use the <kbd>read.csv</kbd> function that we have been using so far. In order to load a dataset in Excel format, we need to use the <kbd>readxl</kbd> library that you can install using the <kbd>install.packages("readxl")</kbd> command in your RStudio. In the <kbd>readxl</kbd> library, there is a function named <kbd>read_excel</kbd>, which helps you load an Excel file easily.</p>
<p>Once you have loaded this data into a <kbd>DataFrame</kbd>, it should look like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/759e7e8c-3724-4802-92e6-3c2abf2cafbb.png"/></p>
<p>Before we move on to the next step, there is one data-cleaning step we need to take. Let's look quickly at the distribution of the <kbd>Quantity</kbd> column. We will visualize the distributions of <kbd>Quantity</kbd> by using the following code:</p>
<pre>ggplot(df, aes(x="", y=Quantity)) + <br/>  geom_boxplot(outlier.shape = NA) +<br/>  ylim(c(-15, 25))+<br/>  ylab("order quantity") +<br/>  xlab("") +<br/>  ggtitle("Quantity Distribution") +<br/>  theme(plot.title=element_text(hjust=0.5))</pre>
<p>As you can see from this code, we are visualizing the distribution of the <kbd>Quantity</kbd> column, in a box plot, using <kbd>geom_boxplot</kbd>.</p>
<p>The resulting box plot looks like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1086 image-border" src="img/6fcd6fd9-4bd1-4cf8-a8d8-d243b895a16b.png" style="width:32.67em;height:20.92em;"/></p>
<p>As you can see from this plot, some orders have negative quantities. This is because the cancelled or refunded orders are recorded with negative values in the <kbd>Quantity</kbd> column of our dataset. For illustration purposes in this exercise, we are going to disregard the cancelled orders. We can filter out all the cancelled orders in our <kbd>DataFrame</kbd> by using the following code:</p>
<pre># filter out orders with negative quantity (cancel orders)<br/>df &lt;- df[which(df$Quantity &gt; 0),]</pre>
<p>Now, we are ready to conduct further analyses and dive into our data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time series trends</h1>
                
            
            
                
<p>Before we look at product-level data, as a marketer for an e-commerce business, it will be beneficial to have a better understanding of the overall time series trends in the revenue and the numbers of orders or purchases. This will help us understand whether the business is growing or shrinking in terms of both its overall revenue and the numbers of orders it receives over time.</p>
<p>First, we are going to look into the number of orders over time. Take a look at the following code:</p>
<pre># install.packages("lubridate")<br/>library(lubridate)<br/><br/>timeSeriesNumInvoices &lt;- df %&gt;%<br/>  group_by(InvoiceDate=floor_date(InvoiceDate, "month")) %&gt;%<br/>  summarise(NumOrders=n_distinct(InvoiceNo))</pre>
<p>In this code, we are using the <kbd>group_by</kbd> function first to group the data by each month. In order to group by each month, we are using the <kbd>floor_date</kbd> function in the <kbd>lubridate</kbd> library. If you do not have this library installed already, you can install it using the <kbd>install.packages("lubridate")</kbd> command. The <kbd>floor_date</kbd> function simply takes the date and rounds it down by the provided unit. In our case, we are rounding down the <kbd>InvoiceDate</kbd> column to the first day of the month. Then, for each month, we are counting the number of unique purchase orders by using the <kbd>n_distinct</kbd> function on the <kbd>InvoiceNo</kbd> column. The resulting <kbd>DataFrame</kbd> looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1087 image-border" src="img/466de2a6-6a41-4d1f-8e65-953dd19b0a2e.png" style="width:15.58em;height:22.75em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Often, time series data is better visualized using line charts. Let's take a look at the following code to see how we can visualize this monthly data as a line chart:</p>
<pre>ggplot(timeSeriesNumInvoices, aes(x=InvoiceDate, y=NumOrders)) +<br/>  geom_line() +<br/>  ylim(c(0, max(timeSeriesNumInvoices$NumOrders) + 1000)) +<br/>  ylab("number of orders") +<br/>  xlab("date") +<br/>  ggtitle("Number of Orders over Time") +<br/>  theme(plot.title=element_text(hjust=0.5))</pre>
<p>As you can see from this code, we are using the <kbd>ggplot</kbd> function in the <kbd>ggplot2</kbd> library with the <kbd>geom_line</kbd> function to display the data using a line plot. Let's take a look at the following plot first:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3f00ecf3-7fdf-4548-95d6-d32d0e75e68e.png" style="width:41.25em;height:27.75em;"/></p>
<p class="mce-root"/>
<p>One thing that is noticeable from this chart is that there is a sudden, radical drop in the number of orders in December 2011. If you look closely at the data, this is simply because we do not have the data for the full month of December 2011. We can verify this by using the following code:</p>
<pre>summary(df[which(df$InvoiceDate &gt;= as.Date("2011-12-01")),"InvoiceDate"])</pre>
<p>In this code, we get a summary of all invoice dates from December 1, 2011 that looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/445b9553-e46b-4fdf-b0dc-3178b24e0695.png" style="width:33.92em;height:8.33em;"/></p>
<p>As you can see from this output, we only have the data from December 1, to December 9, 2011. It would be a misrepresentation if we used this data for analyzing December sales and revenue, as we cannot get the full picture of this month from the dataset we have. For further analyses, we will disregard any data from December 1, 2011. You can use the following code to remove those data points:</p>
<pre>df &lt;- df[which(df$InvoiceDate &lt; as.Date("2011-12-01")),]</pre>
<p>Now that we have filtered out incomplete data for December 2011, we can redraw the line chart using the previous codes. After removing those data points in December 2011, the line chart looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f2deaff8-b0ae-4547-be91-bd45f2a96dd3.png" style="width:39.25em;height:26.42em;"/></p>
<p class="mce-root">Let's take a closer look at this chart. The monthly number of orders seems to float around 1,500 from December 2010 to August 2011, then increases significantly from September 2011, and almost doubles by November 2011. One explanation for this could be that the business is actually growing significantly from September 2011. Another explanation could be seasonal effects. In e-commerce businesses, it is not rare to see spikes in sales as it approaches the end of the year. Typically, sales rise significantly from October to January for many e-commerce businesses and, without the data from the previous year, it is difficult to conclude whether this spike in sales is due to a growth in business or due to seasonal effects. When you are analyzing your data, we advise you to compare the current year's data against the previous year's data.</p>
<p>Similar to the monthly number of orders, let's take a quick look at the monthly revenue data. Take a look at the following code:</p>
<pre>df$Sales &lt;- df$Quantity * df$UnitPrice<br/><br/>timeSeriesRevenue &lt;- df %&gt;%<br/>  group_by(InvoiceDate=floor_date(InvoiceDate, "month")) %&gt;%<br/>  summarise(Sales=sum(Sales))</pre>
<p>As you can see from this code, the first thing we do here is calculate the aggregate sales amount from each order, which is simply the <kbd>UnitPrice</kbd> multiplied by the <kbd>Quantity</kbd>. Once we have computed and created this <kbd>Sales</kbd> column, we can use the <kbd>group_by</kbd> function with the <kbd>floor_date</kbd> function to group our data into monthly sales data. Using <kbd>sum</kbd> as the aggregate function in the <kbd>summarise</kbd> function, we can get the monthly sales revenue data. The resulting data looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1088 image-border" src="img/d788593f-0669-48c2-9956-1b99694f979b.png" style="width:13.42em;height:21.50em;"/></p>
<p>We can visualize this data as a line plot, using the following code:</p>
<pre>ggplot(timeSeriesRevenue, aes(x=InvoiceDate, y=Sales)) +<br/>  geom_line() +<br/>  ylim(c(0, max(timeSeriesRevenue$Sales) + 10000)) +<br/>  ylab("sales") +<br/>  xlab("date") +<br/>  ggtitle("Revenue over Time") +<br/>  theme(plot.title=element_text(hjust=0.5))</pre>
<p>As we have seen in previous chapters, we can use the <kbd>geom_line</kbd> function to build a line chart. The line plot for the monthly revenue data looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cbc487fe-11c3-4f57-8724-57ce72ef34fe.png" style="width:34.42em;height:23.17em;"/></p>
<p>We see a similar pattern to the previous monthly Number of Orders over Time chart in this monthly Revenue over Time chart. The monthly revenue floats around 700,000 from December 2010 to August 2011 and then it increases significantly from September 2011. As discussed before, to verify whether this significant increase in sales and revenue is due to a growth in business or due to seasonal effects, we need to look further back in the sales history and compare the current year's sales against the previous year's sales.</p>
<p>These types of general and broad time series analyses can help marketers have a better understanding of the overall performance of the business and identify any potential problems that might be occurring within the business. It is generally a good idea to start with broader analyses and then drill down into more granular and specific parts of the business for further product analytics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Repeat customers</h1>
                
            
            
                
<p>Another important factor of a successful business is how well it is retaining customers and how many repeat purchases and customers it has. In this section, we are going to analyze the number of monthly repeat purchases and how much of the monthly revenue is attributable to these repeat purchases and customers. A typical strong and stable business has a steady stream of sales from existing customers. Let's see how many of the sales are from repeat and existing customers for the online retail business that we are currently analyzing in this chapter.</p>
<p>We are going to look at the number of monthly repeat purchases. This means a customer has placed more than one order within a given month. Let's take a quick look at the data we have:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e40dda22-7885-4f36-be9f-2a2d26ce3030.png"/></p>
<p>As is noticeable from this snapshot of the data, there are multiple records for one purchase order (<kbd>InvoiceNo</kbd>). However, what we need is the aggregate data for each order, so that one record in the <kbd>DataFrame</kbd> represents one purchase order. We can aggregate this raw data for each <kbd>InvoiceNo</kbd> by using the following code:</p>
<pre>invoiceCustomerDF &lt;- df %&gt;%<br/>  group_by(InvoiceNo, InvoiceDate) %&gt;%<br/>  summarise(CustomerID=max(CustomerID), Sales=sum(Sales))</pre>
<p>As you can see from this code, we are grouping the <kbd>DataFrame</kbd>, <kbd>df</kbd>, by <kbd>InvoiceNo</kbd> and <kbd>InvoiceDate</kbd> and summing up all the <kbd>Sales</kbd>, while taking one value for <kbd>CustomerID</kbd>. This way, the new <kbd>DataFrame</kbd>, <kbd>invoiceCustomerDf</kbd>, has one record for each purchase order. The resulting <kbd>DataFrame</kbd> looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1089 image-border" src="img/a7d7cdf1-4af7-45c3-bf69-835ba2d1596b.png" style="width:29.83em;height:20.08em;"/></p>
<p>As you can see here, each record in the <kbd>DataFrame</kbd> represents all the information we need for each order. Now, we need to aggregate this data for each month and compute the number of customers who made more than one purchase in a given month. Take a look at the following code:</p>
<pre>timeSeriesCustomerDF &lt;- invoiceCustomerDF %&gt;%<br/>  group_by(InvoiceDate=floor_date(InvoiceDate, "month"), CustomerID) %&gt;%<br/>  summarise(Count=n_distinct(InvoiceNo), Sales=sum(Sales))</pre>
<p>Similarly to the previous section, we are using the <kbd>group_by</kbd> and <kbd>floor_date</kbd> functions to aggregate the data into each month. We are also grouping by <kbd>CustomerID</kbd>, so that we can count how many orders and how many sales each customer has brought in for each month. This data now looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1090 image-border" src="img/9c3b3484-606e-4214-98f8-e722a9ca9d86.png" style="width:21.33em;height:17.33em;"/></p>
<p>Now, in order to get the number of repeat customers, all we need to do is filter out customers who only have 1 in the Count column in this data. The code to perform this operation looks like the following:</p>
<pre>repeatCustomers &lt;- na.omit(timeSeriesCustomerDF[which(timeSeriesCustomerDF$Count &gt; 1),])</pre>
<p>The newly created <kbd>DataFrame</kbd>, <kbd>reapeatCustomers</kbd>, now contains all the customers who have made more than one purchase in each month. In order to get the aggregate monthly repeat customer counts, we are going to run the following code:</p>
<pre>timeSeriesRepeatCustomers &lt;- repeatCustomers %&gt;%<br/>  group_by(InvoiceDate) %&gt;%<br/>  summarise(Count=n_distinct(CustomerID), Sales=sum(Sales))</pre>
<p>As you can see from this code, we are simply grouping by <kbd>InvoiceDate</kbd>, which is a date that is rounded down to the first day of each month, and then we are counting the number of unique or distinct customers and summing up the total sales. The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1093 image-border" src="img/70e4dda2-93ee-41fb-8765-d0782633bb98.png" style="width:15.25em;height:19.00em;"/></p>
<p>Let's now compare these repeat customer numbers against the total number of monthly customers. You can use the following code to compute the total number of monthly customers:</p>
<pre># Unique Customers<br/>timeSeriesUniqCustomers &lt;- df %&gt;%<br/>  group_by(InvoiceDate=floor_date(InvoiceDate, "month")) %&gt;%<br/>  summarise(Count=n_distinct(CustomerID))</pre>
<p>The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1094 image-border" src="img/5f505e4a-9681-4d6f-9b79-ed91705df7dc.png" style="width:11.25em;height:18.67em;"/></p>
<p>Lastly, we are going to analyze the percentage of monthly revenue that can be attributed to the repeat customers. Take a look at the following code:</p>
<pre>timeSeriesRepeatCustomers$Perc &lt;- timeSeriesRepeatCustomers$Sales / timeSeriesRevenue$Sales*100.0<br/>timeSeriesRepeatCustomers$Total &lt;- timeSeriesUniqCustomers$Count</pre>
<p>As you can see from this code, we are simply dividing the <kbd>Sales</kbd> column in the <kbd>timeSeriesRepeatCustomers</kbd> <kbd>DataFrame</kbd> by the <kbd>Sales</kbd> column in the <kbd>timeSeriesRevenue</kbd> <kbd>DataFrame</kbd> that we created in the previous section. Then, we are appending the number of monthly unique customers to the new column, <kbd>Total</kbd>, of the <kbd>timeSeriesRepeatCustomers</kbd> <kbd>DataFrame</kbd>.</p>
<p>Let's visualize all of this data in one chart, using the following code:</p>
<pre>ggplot(timeSeriesRepeatCustomers) + <br/>  geom_line(aes(x=InvoiceDate, y=Total), stat="identity", color="navy") +<br/>  geom_line(aes(x=InvoiceDate, y=Count), stat="identity", color="orange") +<br/>  geom_bar(aes(x=InvoiceDate, y=Perc*20), stat="identity", fill='gray', alpha=0.5) +<br/>  scale_y_continuous(sec.axis = sec_axis(~./20, name="Percentage (%)")) +<br/>  ggtitle("Number of Unique vs. Repeat &amp; Revenue from Repeat Customers") +<br/>  theme(plot.title=element_text(hjust=0.5))</pre>
<p>As you can see from this code, we are creating two line plots and one bar plot by using the <kbd>geom_line</kbd> and <kbd>geom_bar</kbd> functions in the <kbd>ggplot2</kbd> library. The first line plot represents the total number of monthly customers, <kbd>Total</kbd>, and will be drawn with a <kbd>navy</kbd> color. The second line plot is the number of monthly repeat customers, <kbd>Count</kbd>, which will be drawn with an <kbd>orange</kbd> color. Lastly, we are drawing a bar plot with a <kbd>gray</kbd> color for the percentage of revenue from repeat customers, <kbd>Perc</kbd>. One thing to note here is the scaling factor, <kbd>20</kbd>, for the secondary <em>y </em>axis. The <kbd>sec_axis</kbd> function defines the formula for the scale of the secondary <em>y </em>axis. Here, we are using <kbd>~./20</kbd>, which means the secondary <em>y </em>axis ranges from 0 to 1/20th of the maximum value of the first axis. Since we are scaling down the secondary <em>y </em>axis by a factor of <kbd>20</kbd>, we are multiplying this number to <kbd>Perc</kbd> in the <kbd>geom_bar</kbd> function to match the scale of our data to the range of the secondary <em>y </em>axis. The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1092 image-border" src="img/59b61f5e-851b-4449-8427-9e81ff8c9cda.png" style="width:35.92em;height:24.83em;"/></p>
<p>As discussed from the code, we see three plots in this chart: a line of a navy color that represents the total number of monthly customers, a line of an orange color that represents the number of monthly repeat customers, and bars of a gray color that represent the percentage of revenue from the repeat customers. As you can see from this chart, the secondary <em>y </em>axis, labeled as Percentage (%), ranges from 0 to 1/20th of the maximum of the primary <em>y </em>axis, labeled as Total, which matches with our scaling factor of <kbd>20</kbd>.</p>
<p>Let's now take a closer look at the chart. There seems to be an upward trend in both the number of monthly customers and the number of repeat customers from September 2011, and repeat customers are roughly 20-30% of the total monthly customers. However, if you look at the percentage of revenue from these repeat customers, you can see that roughly 40-50% of the total revenue comes from repeat customers. In other words, roughly half of the revenue is driven by the 20-30% of the customer base who are repeat customers. As this online retail business has a large portion of revenue from repeat customers, this business will benefit from this steady stream of revenue from repeat customers. This shows how important it is to retain existing customers. As a marketer, it will be important to keep in mind how to retain existing customers and build up your repeat customer base.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trending items over time</h1>
                
            
            
                
<p>So far, we have analyzed the overall time series patterns and how customers engage with the overall business, but not how customers engage with individual products. In this section, we are going to explore and analyze how customers interact with individual products that are sold. More specifically, we will take a look at the trends of the top five best-sellers over time.</p>
<p>The first task for analyzing the time series trending items is to count the number of items sold for each product for each period. Take a look at the following code:</p>
<pre>popularItems &lt;- df %&gt;%<br/>  group_by(InvoiceDate=floor_date(InvoiceDate, "month"), StockCode) %&gt;%<br/>  summarise(Quantity=sum(Quantity))</pre>
<p>As you can notice from this code, we are grouping the data by the month and the <kbd>StockCode</kbd>, which is the unique code for each product. Then, we are adding up all the quantities, <kbd>Quantity</kbd>, sold for the given month and product, by using the <kbd>sum</kbd> function in the <kbd>summarise</kbd> function.</p>
<p>Since we are only interested in the top five best-sellers, we will need to subselect those top five products from this <kbd>DataFrame</kbd>, <kbd>popularItems</kbd>. Take a look at the following code:</p>
<pre>top5Items &lt;- popularItems[<br/>    which(popularItems$InvoiceDate == as.Date("2011-11-01")),<br/>  ] %&gt;%<br/>  arrange(desc(Quantity)) %&gt;%<br/>  head(5)<br/><br/>timeSeriesTop5 &lt;- popularItems[<br/>  which(popularItems$StockCode %in% top5Items$StockCode),<br/>]</pre>
<p class="mce-root"/>
<p>Here, we first sort the items in descending order by the number of items sold, <kbd>Quantity</kbd>, in November 2011. Using the <kbd>which</kbd> function, we can subselect the data from <kbd>popularItems</kbd> for November 2011 and then with the <kbd>arrange</kbd> function, we can sort the data by the column we want, <kbd>Quantity</kbd>. By having <kbd>desc</kbd> in the <kbd>arrange</kbd> function, we can sort the data in descending order. Lastly, we are taking the top five items by using the <kbd>head</kbd> function. The newly created variable, <kbd>top5Items</kbd>, now has the top five best-sellers in November 2011. The last thing we need to do is retrieve the time series data for these five items. By using the <kbd>which</kbd> function and the <kbd>%in%</kbd> operator, we can subselect the data for those items with <kbd>StockCode</kbd> in <kbd>top5Items</kbd>.</p>
<p>To visualize the time series trends of these five products, we can use the following code:</p>
<pre>ggplot(timeSeriesTop5, aes(x=InvoiceDate, y=Quantity, color=StockCode)) +<br/>  geom_line() +<br/>  ylab("number of purchases") +<br/>  xlab("date") +<br/>  ggtitle("Top 5 Popular Items over Time") +<br/>  theme(plot.title=element_text(hjust=0.5))</pre>
<p>The chart looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1095 image-border" src="img/a6bbc0a6-89c8-411d-a4e4-3ec349679e21.png" style="width:40.00em;height:24.92em;"/></p>
<p class="mce-root"/>
<p>Let's take a closer look at this time series plot. The sales of these five products spiked in November 2011, especially the sales of the product with stock code, 85099B, which were close to 0 from February 2011 to October 2011. Then, it suddenly spiked in November 2011. It might be worth taking a closer look into what might have driven this spike. It could be an item that is highly sensitive to seasonality, becoming very popular during November, or it could also be that there was a genuine change in trends, which led to this item becoming more popular than before.</p>
<p>The popularity of the other top five products, 22086, 22197, 23084, and 84826, seems to have built up in the few months prior to November 2011. As a marketer, it would also be worthwhile taking a closer look at the potential drivers behind this buildup and the rising popularity of these items. You could look at whether these items are typically more popular in colder seasons, or whether there is a growing trend for these specific items in the market.</p>
<p>Analyzing the trends and changes in the popularity of products not only helps you understand what your customers like and purchase the most, but it also helps you tailor your marketing messages. For example, you can recommend these items with rising popularity in your marketing emails, calls, or advertisements to improve customer engagement. As your customers are more interested and more likely to purchase these items, you might get higher marketing engagement from your customers when you market these items more, and you might eventually get higher conversion rates when you target your customers with these trending items. Using these popular and trending items is one way to build a product recommendation engine, which we are going to expand on and experiment with thoroughly in the next chapter.</p>
<p>The full code for the R exercise in this section can be found at: <a href="https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.5/R/ProductAnalytics.R">https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.5/R/ProductAnalytics.R</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed the concepts and importance of product analytics. We briefly discussed how product analytics starts from tracking events and customer actions, such as website or app visits, page views, and purchases. Then, we discussed some of the common goals of product analytics and how it should be used to generate actionable insights and reports. With these discussions on product analytics, we explored how we can utilize product analytics for customer and product retention in our programming exercises, using e-commerce business data. First, we analyzed the time series trends in the revenue and the numbers of purchase orders. Then, we drilled down to identify the patterns of monthly repeat customers. We have seen from the data that even though monthly repeat customers represent a relatively small portion of the overall customer base, they drive roughly half of the total monthly revenue. This shows the importance of retaining customers and how developing a retention strategy should be taken seriously. Lastly, we discussed how to analyze popular and trending items over time. In this section, we have discussed the potential effects of seasonality and how the analysis of trending items can be used in marketing strategies and in product recommendations.</p>
<p>In the next chapter, we are going to expand and apply our knowledge gained from this chapter to build product recommendation engines. We will learn about the collaborative filtering algorithm and how it can be used for product recommendations. </p>


            

            
        
    </body></html>