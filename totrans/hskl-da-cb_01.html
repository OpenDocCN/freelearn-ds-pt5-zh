<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. The Hunt for Data</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Harnessing data from various sources</li><li class="listitem" style="list-style-type: disc">Accumulating text data from a file path</li><li class="listitem" style="list-style-type: disc">Catching I/O code faults</li><li class="listitem" style="list-style-type: disc">Keeping and representing data from a CSV file</li><li class="listitem" style="list-style-type: disc">Examining a JSON file with the aeson package</li><li class="listitem" style="list-style-type: disc">Reading an XML file using the HXT package</li><li class="listitem" style="list-style-type: disc">Capturing table rows from an HTML page</li><li class="listitem" style="list-style-type: disc">Understanding how to perform HTTP GET requests</li><li class="listitem" style="list-style-type: disc">Learning how to perform HTTP POST requests</li><li class="listitem" style="list-style-type: disc">Traversing online directories for data</li><li class="listitem" style="list-style-type: disc">Using MongoDB queries in Haskell</li><li class="listitem" style="list-style-type: disc">Reading from a remote MongoDB server</li><li class="listitem" style="list-style-type: disc">Exploring data from a SQLite database</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><div><img src="img/ch01.jpg" alt="Introduction"/></div><p>Data is everywhere, logging is cheap, and analysis is inevitable. One of the most fundamental concepts of this chapter is based on gathering useful data. After building a large collection of usable text, which we call the corpus, we must learn to represent this content in code. The primary focus will be first on obtaining data and later on enumerating ways of representing it.</p><p>Gathering data is <a id="id0" class="indexterm"/>arguably as important as analyzing it to extrapolate results and form valid generalizable claims. It is a scientific pursuit; therefore, great care must and will be taken to ensure unbiased and representative sampling. We recommend following along closely in this chapter because the remainder of the book depends on having a source of data to work with. Without data, there isn't much to analyze, so we should carefully observe the techniques laid out to build our own formidable corpus.</p><p>The first recipe enumerates various sources to start gathering data online. The next few recipes deal with using local data of different file formats. We then learn how to download data from the Internet using our Haskell code. Finally, we finish this chapter with a couple of recipes on using databases in Haskell.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Harnessing data from various sources</h1></div></div></div><p>Information can be described as structured, unstructured, or sometimes a mix of the two—semi-structured.</p><p>In a <a id="id1" class="indexterm"/>very general sense, structured data is anything that can be parsed by an algorithm. Common examples include JSON, CSV, and XML. If given structured data, we can design a piece of code to dissect the underlying format and easily produce useful results. As mining structured data is a deterministic process,  it allows us to  automate the parsing. This in effect lets us gather more input to feed our data analysis algorithms.</p><p>Unstructured data is everything else. It is data not defined in a specified manner. Written languages such as English are often regarded as unstructured because of the difficulty in parsing a data model out of a natural sentence.</p><p>In our search for good data, we will often find a mix of structured and unstructured text. This is called semi-structured text.</p><p>This recipe will primarily focus on obtaining structured and semi-structured data from the following sources.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>Unlike most recipes in this book, this recipe does not contain any code. The best way to read this book is by skipping around to the recipes that interest you.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>How to do it...</h2></div></div></div><p>We will browse through the links provided in the following sections to build up a list of sources to harness interesting data in usable formats. However, this list is not at all exhaustive.</p><p>Some of these sources have an<a id="id2" class="indexterm"/> <strong>Application Programming Interface</strong> (<strong>API</strong>) that allows more sophisticated access to interesting data. An API specifies the interactions and defines how data is communicated.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>News</h3></div></div></div><p>The New York Times <a id="id3" class="indexterm"/>has one of the most polished API documentation to access anything from real-estate data to article search results. This documentation can be found at <a class="ulink" href="http://developer.nytimes.com">http://developer.nytimes.com</a>.</p><p>The Guardian also <a id="id4" class="indexterm"/>supports a massive datastore with over a million articles at <a class="ulink" href="http://www.theguardian.com/data">http://www.theguardian.com/data</a>.</p><p>USA TODAY <a id="id5" class="indexterm"/>provides<a id="id6" class="indexterm"/> some interesting resources on books, movies, and music reviews. The technical documentation can be found at <a class="ulink" href="http://developer.usatoday.com">http://developer.usatoday.com</a>.</p><p>The BBC <a id="id7" class="indexterm"/>features some interesting API endpoints including information on BBC programs, and music located at <a class="ulink" href="http://www.bbc.co.uk/developer/technology/apis.html">http://www.bbc.co.uk/developer/technology/apis.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Private</h3></div></div></div><p>Facebook, Twitter, Instagram, Foursquare, Tumblr, SoundCloud, Meetup, and many other social networking sites<a id="id8" class="indexterm"/> support APIs to access some degree of social information.</p><p>For specific APIs such as weather or sports, Mashape is a <a id="id9" class="indexterm"/>centralized search engine to narrow down the search to some lesser-known sources. Mashape is located <a id="id10" class="indexterm"/>at <a class="ulink" href="https://www.mashape.com/">https://www.mashape.com/</a>
</p><p>Most data sources can be visualized using the<a id="id11" class="indexterm"/> Google Public Data search located at <a class="ulink" href="http://www.google.com/publicdata">http://www.google.com/publicdata</a>.</p><p>For a list of all countries with names in various data formats, refer to the repository located at <a class="ulink" href="https://github.com/umpirsky/country-list">https://github.com/umpirsky/country-list</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Academic</h3></div></div></div><p>Some<a id="id12" class="indexterm"/> data sources are hosted openly by universities around the world for research purposes.</p><p>To analyze health care data, the University of Washington has published Institute for Health Metrics and Evaluation (IHME) to collect rigorous and comparable measurement of the world's most important health problems. Navigate to <a class="ulink" href="http://www.healthdata.org">http://www.healthdata.org</a> for more information.</p><p>The MNIST database of handwritten digits from NYU, Google Labs, and Microsoft Research is a training set of normalized and centered samples for handwritten digits. Download the data from <a class="ulink" href="http://yann.lecun.com/exdb/mnist">http://yann.lecun.com/exdb/mnist</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Nonprofits</h3></div></div></div><p>Human Development Reports publishes annual <a id="id13" class="indexterm"/>updates ranging from international data about adult literacy to the number of people owning personal computers. It describes itself as having a variety of public international sources and represents the most current statistics available for those indicators. More information is available at <a class="ulink" href="http://hdr.undp.org/en/statistics">http://hdr.undp.org/en/statistics</a>.</p><p>The World Bank<a id="id14" class="indexterm"/> is the source for poverty and world development data. It regards itself as a free source that enables open access to<a id="id15" class="indexterm"/> data about development in countries around the globe. Find more information at <a class="ulink" href="http://data.worldbank.org/">http://data.worldbank.org/</a>.</p><p>The World Health Organization<a id="id16" class="indexterm"/> provides data and analyses for monitoring the global health situation. See more information at <a class="ulink" href="http://www.who.int/research/en">http://www.who.int/research/en</a>.</p><p>UNICEF<a id="id17" class="indexterm"/> also releases interesting statistics, as the quote from their website suggests:</p><div><blockquote class="blockquote"><p><em>"The UNICEF database contains statistical tables for child mortality, diseases, water sanitation, and more vitals. UNICEF claims to play a central role in monitoring the situation of children and women—assisting countries in collecting and analyzing data, helping them develop methodologies and indicators, maintaining global databases, disseminating and publishing data. Find the resources at <a class="ulink" href="http://www.unicef.org/statistics">http://www.unicef.org/statistics</a>."</em></p></blockquote></div><p>The United Nations<a id="id18" class="indexterm"/> hosts interesting publicly available political statistics at <a class="ulink" href="http://www.un.org/en/databases">http://www.un.org/en/databases</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>The United States government</h3></div></div></div><p>If we crave the urge<a id="id19" class="indexterm"/> to discover patterns in the United States (U.S.) government like Nicholas Cage did in the feature film National Treasure (2004), then <a class="ulink" href="http://www.data.gov/">http://www.data.gov/</a> is our go-to source. It's the U.S. government's active effort to provide useful data. It is described as a place to increase "public access to high-value, machine-readable datasets generated by the executive branch of the Federal Government". Find more information at <a class="ulink" href="http://www.data.gov">http://www.data.gov</a>.</p><p>The United States Census Bureau<a id="id20" class="indexterm"/> releases population counts, housing statistics, area measurements, and more. These can be found at <a class="ulink" href="http://www.census.gov">http://www.census.gov</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Accumulating text data from a file path</h1></div></div></div><p>One of the easiest <a id="id21" class="indexterm"/>ways to get started with processing input is by reading raw text from a local file. In this recipe, we will be extracting all the<a id="id22" class="indexterm"/> text from a specific file path. Furthermore, to do something interesting with the data, we will count the number of words per line.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Haskell is a purely functional programming language, right? Sure, but obtaining input from outside the code introduces impurity. For elegance and reusability, we must carefully separate pure from impure code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Getting ready</h2></div></div></div><p>We will first create an <code class="literal">input.txt</code> text file with a couple of lines of text to be read by the program. We keep <a id="id23" class="indexterm"/>this file in an easy-to-access directory because it will be referenced later. For example, the <a id="id24" class="indexterm"/>text file we're dealing with contains a seven-line quote by Plato. Here's what our terminal prints when we issue the following command:</p><div><pre class="programlisting">
<strong>$ cat input.txt</strong>

<strong>And how will you inquire, Socrates,</strong>
<strong>into that which you know not? </strong>
<strong>What will you put forth as the subject of inquiry? </strong>
<strong>And if you find what you want, </strong>
<strong>how will you ever know that </strong>
<strong>this is what you did not know?</strong>
</pre></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you. The code will also be hosted on GitHub at <a class="ulink" href="https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook">https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How to do it...</h2></div></div></div><p>Create a new file to start coding. We call our file Main.hs.</p><div><ol class="orderedlist arabic"><li class="listitem">As with all executable Haskell programs, start by defining and implementing the <code class="literal">main</code> function, as follows:<div><pre class="programlisting">
<strong>main :: IO ()</strong>
<strong>main = do</strong>
</pre></div></li><li class="listitem">Use Haskell's <code class="literal">readFile :: FilePath -&gt; IO String</code> function to extract data from an <code class="literal">input.txt</code> file path. Note that a file path is just a synonym for <code class="literal">String</code>. With the string in memory, pass it into a <code class="literal">countWords</code> function to count the number of words in each line, as shown in the following steps:<div><pre class="programlisting">
<strong>input &lt;- readFile "input.txt"</strong>
<strong>print $ countWords input</strong>
</pre></div></li><li class="listitem">Lastly, define our pure function, <code class="literal">countWords</code>, as follows:<div><pre class="programlisting">
<strong>countWords :: String -&gt; [Int]</strong>
<strong>countWords input = map (length.words) (lines input)</strong>
</pre></div></li><li class="listitem">The program will print out the number of words per line represented as a list of numbers as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>[6,6,10,7,6,7]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>How it works...</h2></div></div></div><p>Haskell provides <a id="id25" class="indexterm"/>useful input and output (I/O) capabilities for reading input and writing output in different ways. In our case, we use <code class="literal">readFile</code> to specify a path <a id="id26" class="indexterm"/>of a file to be read. Using the <code class="literal">do</code> keyword in <code class="literal">main</code> suggests that we are joining several IO actions together. The output of <code class="literal">readFile</code> is an I/O string, which means it is an I/O action that returns a <code class="literal">String</code> type.</p><p>Now we're about to get a bit technical. Pay close attention. Alternatively, smile and nod. In Haskell, the I/O data type is an instance of something called a Monad. This allows us to use the <code class="literal">&lt;-</code> notation to draw the string out of this I/O action. We then make use of the string by feeding it into our <code class="literal">countWords</code> function that counts the number of words in each line. Notice how we separated the <code class="literal">countWords</code> function apart from the impure <code class="literal">main</code> function.</p><p>Finally, we print the output of <code class="literal">countWords</code>. The <code class="literal">$</code> notation means we are using a function application to avoid excessive parenthesis in our code. Without it, the last line of <code class="literal">main</code> would look like <code class="literal">print (countWords input)</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>See also</h2></div></div></div><p>For simplicity's sake, this code is easy to read but very fragile. If an <code class="literal">input.txt</code> file does not exist, then running the code will immediately crash the program. For example, the following command will generate the error message:</p><div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>Main.hs: input.txt: openFile: does not exist…</strong>
</pre></div><p>To make this code fault tolerant, refer to the <em>Catching I/O code faults</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Catching I/O code faults</h1></div></div></div><p>Making sure our <a id="id27" class="indexterm"/>code doesn't crash in the process of data mining or analysis is a substantially genuine concern. Some computations may take hours, if not days. Haskell gifts us with type safety and strong checks to help ensure a program will not fail, but we must also take care to double-check edge cases where faults may occur.</p><p>For instance, a program may crash ungracefully if the local file path is not found. In the previous recipe, there was a strong dependency on the existence of <code class="literal">input.txt</code> in our code. If the program is unable to find the file, it will produce the following error:</p><div><pre class="programlisting">
<strong>mycode: input.txt: openFile: does not exist (No such file or directory)</strong>
</pre></div><p>Naturally, we should decouple the file path dependency by enabling the user to specify his/her file path as well as by not crashing in the event that the file is not found.</p><p>Consider the following revision of the source code.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it…</h2></div></div></div><p>Create a <a id="id28" class="indexterm"/>new file, name it <code class="literal">Main.hs</code>, and perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, import a library to catch fatal errors as follows:<div><pre class="programlisting">import Control.Exception (catch, SomeException)</pre></div></li><li class="listitem">Next, import a library to get command-line arguments so that the file path is dynamic. We use the following line of code to do this:<div><pre class="programlisting">import System.Environment (getArgs)</pre></div></li><li class="listitem">Continuing as before, define and implement <code class="literal">main</code> as follows:<div><pre class="programlisting">main :: IO ()
main = do</pre></div></li><li class="listitem">Define a <code class="literal">fileName</code> string depending on the user-provided argument, defaulting to <code class="literal">input.txt</code> if there is no argument. The argument is obtained by retrieving an array of strings from the library function, <code class="literal">getArgs :: IO [String]</code>, as shown in the following steps:<div><pre class="programlisting">args &lt;- getArgs
  let filename = case args of
    (a:_) -&gt; a
        _ -&gt; "input.txt"</pre></div></li><li class="listitem">Now apply <code class="literal">readFile</code> on this path, but catch any errors using the library's <code class="literal">catch :: Exception e =&gt; IO a -&gt; (e -&gt; IO a) -&gt; IO a</code> function. The first argument to catch is the computation to run, and the second argument is the handler to invoke if an exception is raised, as shown in the following commands:<div><pre class="programlisting">  input &lt;- catch (readFile fileName)
    $ \err -&gt; print (err::SomeException) &gt;&gt; return ""</pre></div></li><li class="listitem">The <code class="literal">input</code> string will be empty if there were any errors reading the file. We can now use <code class="literal">input</code> for any purpose using the following command:<div><pre class="programlisting">  print $ countWords input</pre></div></li><li class="listitem">Don't forget to define the <code class="literal">countWords</code> function as follows:<div><pre class="programlisting">countWords input = map (length.words) (lines input)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works…</h2></div></div></div><p>This recipe demonstrates two ways to catch errors, listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, we use a case expression that pattern matches against any argument passed in. Therefore, if no arguments are passed, the <code class="literal">args</code> list is empty, and the last pattern, <code class="literal">"_"</code>, is caught, resulting in a default filename of <code class="literal">input.txt</code>.</li><li class="listitem" style="list-style-type: disc">Secondly, we use the catch function to handle an error if something goes wrong. When having trouble reading a file, we allow the code to continue running by setting <code class="literal">input</code> to an empty string.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>There's more…</h2></div></div></div><p>Conveniently, Haskell also comes with a <code class="literal">doesFileExist :: FilePath -&gt; IO Bool</code> function from the <code class="literal">System.Directory</code> module. <a id="id29" class="indexterm"/>We can simplify the preceding code by modifying the <code class="literal">input &lt;- …</code> line. It can be replaced with the following snippet of code:</p><div><pre class="programlisting">exists &lt;- doesFileExist filename
input &lt;- if exists then readFile filename else return ""</pre></div><p>In this case, the code reads the file as an input only if it exists. Do not forget to add the following <code class="literal">import</code> line at the top of the source code:</p><div><pre class="programlisting">import System.Directory (doesFileExist)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Keeping and representing data from a CSV file</h1></div></div></div><p>
<strong>Comma Separated Value</strong> (<strong>CSV</strong>) is a<a id="id30" class="indexterm"/> format to<a id="id31" class="indexterm"/> represent a table of values in plain text. It's often used<a id="id32" class="indexterm"/> to <a id="id33" class="indexterm"/>interact with data from spreadsheets. The specifications for CSV are described in RFC 4180, available at <a class="ulink" href="http://tools.ietf.org/html/rfc4180">http://tools.ietf.org/html/rfc4180</a>.</p><p>In this recipe, <a id="id34" class="indexterm"/>we will read a local CSV file called <code class="literal">input.csv</code> consisting of various names and their corresponding ages. Then, to do something useful with the data, we will find the oldest person.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Getting ready</h2></div></div></div><p>Prepare a simple<a id="id35" class="indexterm"/> CSV file with a list of names and their corresponding ages. This can be done using a text<a id="id36" class="indexterm"/> editor or by exporting from a spreadsheet, as shown in the following figure:</p><div><img src="img/6331OS_01_01.jpg" alt="Getting ready"/></div><p>The raw <code class="literal">input.csv</code> file contains the following text:</p><div><pre class="programlisting">
<strong>$ cat input.csv </strong>

<strong>name,age</strong>
<strong>Alex,22</strong>
<strong>Anish,22</strong>
<strong>Becca,23</strong>
<strong>Jasdev,22</strong>
<strong>John,21</strong>
<strong>Jonathon,21</strong>
<strong>Kelvin,22</strong>
<strong>Marisa,19</strong>
<strong>Shiv,22</strong>
<strong>Vinay,22</strong>
</pre></div><p>The <a id="id37" class="indexterm"/>code also<a id="id38" class="indexterm"/> depends on the <code class="literal">csv</code> library. We may install the library through Cabal using the following command:</p><div><pre class="programlisting">
<strong>$ cabal install csv</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">csv</code> library using the following line of code:<div><pre class="programlisting">import Text.CSV</pre></div></li><li class="listitem">Define and implement <code class="literal">main</code>, where we will read and parse the CSV file, as shown in the following code:<div><pre class="programlisting">main :: IO ()
main = do
  let fileName = "input.csv"
  input &lt;- readFile fileName</pre></div></li><li class="listitem">Apply <code class="literal">parseCSV</code> to the filename to obtain a list of rows, representing the tabulated data. <a id="id39" class="indexterm"/>The output of <code class="literal">parseCSV</code> is <code class="literal">Either ParseError CSV</code>, so ensure that we consider both the <code class="literal">Left</code> and <code class="literal">Right</code> cases:<div><pre class="programlisting">  let csv = parseCSV fileName input
  either handleError doWork csv
handleError csv = putStrLn "error parsing"
doWork csv = (print.findOldest.tail) csv</pre></div></li><li class="listitem">Now we<a id="id40" class="indexterm"/> can <a id="id41" class="indexterm"/>work with the CSV data. In this example, we<a id="id42" class="indexterm"/> find and print the row containing the oldest person, as shown in the following code snippet:<div><pre class="programlisting">findOldest :: [Record] -&gt; Record
findOldest [] = []
findOldest xs = foldl1
          (\a x -&gt; if age x &gt; age a then x else a) xs

age [a,b] = toInt a
                               
toInt :: String -&gt; Int                               
toInt = read</pre></div></li><li class="listitem">After running <code class="literal">main</code>, the code should produce the following output:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>["Becca", "23"]</strong>
</pre></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>We can also use the <code class="literal">parseCSVFromFile</code> function to directly get the CSV representation from a filename instead of using <code class="literal">readFile</code> followed <code class="literal">parseCSV</code>.</p></div></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How it works...</h2></div></div></div><p>The CSV data structure in <a id="id43" class="indexterm"/>Haskell is represented as a list of records. <code class="literal">Record</code> is merely a list of <code class="literal">Fields</code>, and <code class="literal">Field</code> is a type <a id="id44" class="indexterm"/>synonym for <code class="literal">String</code>. In other words, it is a collection of rows representing a table, as shown in the following figure:</p><div><img src="img/6331OS_01_02.jpg" alt="How it works..."/></div><p>The <code class="literal">parseCSV</code> library <a id="id45" class="indexterm"/>function returns an <code class="literal">Either</code> type, with the <code class="literal">Left</code> side being a <code class="literal">ParseError</code> and the <code class="literal">Right</code> side<a id="id46" class="indexterm"/> being the list of lists. The <code class="literal">Either l r</code> data type is very similar to the <code class="literal">Maybe a</code> type which has the <code class="literal">Just a</code> or <code class="literal">Nothing</code> constructor.</p><p>We use the <code class="literal">either</code> function<a id="id47" class="indexterm"/> to handle the <code class="literal">Left</code> and <code class="literal">Right</code> cases. The <code class="literal">Left</code> case<a id="id48" class="indexterm"/> handles the error, and the <code class="literal">Right</code> case handles <a id="id49" class="indexterm"/>the actual work to be done on the data. In <a id="id50" class="indexterm"/>this recipe, the <code class="literal">Right</code> side is a <code class="literal">Record</code>. The fields in <code class="literal">Record</code> are accessible through any list operations such as <code class="literal">head</code>, <code class="literal">last</code>, <code class="literal">!!</code>, and so on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Examining a JSON file with the aeson package</h1></div></div></div><p>
<strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) is a <a id="id51" class="indexterm"/>way<a id="id52" class="indexterm"/> to represent key-value pairs in plain text. The format is described extensively in RFC 4627 (<a class="ulink" href="http://www.ietf.org/rfc/rfc4627">http://www.ietf.org/rfc/rfc4627</a>).</p><p>In this recipe, we will parse a JSON description about a person. We often encounter JSON in APIs from web applications.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">aeson</code> library from hackage using Cabal.</p><p>Prepare an <code class="literal">input.json</code> file representing data about a mathematician, such as the one in the following code snippet:</p><div><pre class="programlisting">
<strong>$ cat input.json</strong>

<strong>{"name":"Gauss", "nationality":"German", "born":1777, "died":1855}</strong>
</pre></div><p>We will be parsing this JSON and representing it as a usable data type in Haskell.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">OverloadedStrings</code> language extension to represent strings as <code class="literal">ByteString</code>, as shown in the following line of code:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}</pre></div></li><li class="listitem">Import <code class="literal">aeson</code> as well as some helper functions as follows:<div><pre class="programlisting">import Data.Aeson
import Control.Applicative
import qualified Data.ByteString.Lazy as B</pre></div></li><li class="listitem">Create the data type corresponding to the JSON structure, as shown in the following code:<div><pre class="programlisting">data Mathematician = Mathematician 
                     { name :: String
                     , nationality :: String
                     , born :: Int
                     , died :: Maybe Int
                     } </pre></div></li><li class="listitem">Provide an instance for the <code class="literal">parseJSON</code> function, as shown in the following code snippet:<div><pre class="programlisting">instance FromJSON Mathematician where
  parseJSON (Object v) = Mathematician
                         &lt;$&gt; (v .: "name")
                         &lt;*&gt; (v .: "nationality")
                         &lt;*&gt; (v .: "born")
                         &lt;*&gt; (v .:? "died")</pre></div></li><li class="listitem">Define<a id="id53" class="indexterm"/> and implement <code class="literal">main</code> as follows:<div><pre class="programlisting">main :: IO ()
main = do</pre></div></li><li class="listitem">Read <a id="id54" class="indexterm"/>the input and decode the JSON, as shown in the following code snippet:<div><pre class="programlisting">  input &lt;- B.readFile "input.json"

  let mm = decode input :: Maybe Mathematician

  case mm of
    Nothing -&gt; print "error parsing JSON"
    Just m -&gt; (putStrLn.greet) m</pre></div></li><li class="listitem">Now we will do something interesting with the data as follows:<div><pre class="programlisting">greet m = (show.name) m ++ 
          " was born in the year " ++ 
          (show.born) m</pre></div></li><li class="listitem">We can run the code to see the following output:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>"Gauss" was born in the year 1777</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>Aeson takes care of the complications in representing JSON. It creates native usable data out of a structured text. In this recipe, we use the <code class="literal">.:</code> and <code class="literal">.:?</code> functions provided by the <code class="literal">Data.Aeson</code> module.</p><p>As the <code class="literal">Aeson</code> package uses <code class="literal">ByteStrings</code> instead of <code class="literal">Strings</code>, it is very helpful to tell the compiler that characters between quotation marks should be treated as the proper data type. This is done in the first line of the code which invokes the <code class="literal">OverloadedStrings</code> language extension.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Language extensions such as <code class="literal">OverloadedStrings</code> are currently supported only by the <a id="id55" class="indexterm"/>
<strong>Glasgow Haskell Compiler</strong> (<strong>GHC</strong>).</p></div></div><p>We use the <code class="literal">decode</code> function provided by Aeson to transform a string into a data type. It has the type <code class="literal">FromJSON a =&gt; B.ByteString -&gt; Maybe a</code>. Our <code class="literal">Mathematician</code> data type must implement an <a id="id56" class="indexterm"/>instance of the <code class="literal">FromJSON</code> typeclass to properly use this function. Fortunately, the only required function for implementing <code class="literal">FromJSON</code> is <code class="literal">parseJSON</code>. The syntax used in this recipe for implementing <code class="literal">parseJSON</code> is a little strange, but this is because we're leveraging applicative functions and lenses, which are more advanced Haskell topics.</p><p>The <code class="literal">.:</code> function has <a id="id57" class="indexterm"/>two arguments, <code class="literal">Object</code> and <code class="literal">Text</code>, and returns a <code class="literal">Parser a</code> data type. As per the documentation, it retrieves the value associated with the given key of an object. This function is used if the key and the value exist in the JSON document. The <code class="literal">:?</code> function also retrieves the associated value from the given key of an object, but the existence of the key and value are not mandatory. So, we use <code class="literal">.:?</code> for optional key value pairs in a JSON document.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>There's more…</h2></div></div></div><p>If the implementation of the <code class="literal">FromJSON</code> typeclass is too involved, we can easily let GHC automatically fill it out using the <code class="literal">DeriveGeneric</code> language extension. The following is a simpler rewrite of the code:</p><div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
import Data.Aeson
import qualified Data.ByteString.Lazy as B
import GHC.Generics

data Mathematician = Mathematician { name :: String
                                   , nationality :: String
                                   , born :: Int
                                   , died :: Maybe Int
                                   } <strong>deriving Generic</strong>

instance FromJSON Mathematician

main = do
  input &lt;- B.readFile "input.json"
  let mm = decode input :: Maybe Mathematician
  case mm of
    Nothing -&gt; print "error parsing JSON"
    Just m -&gt; (putStrLn.greet) m
    
greet m = (show.name) m ++" was born in the year "++ (show.born) m</pre></div><p>Although Aeson is powerful and generalizable, it may be an overkill for some simple JSON interactions. Alternatively, if we wish to use a very minimal JSON parser and printer, we can use Yocto, which can be downloaded from <a class="ulink" href="http://hackage.haskell.org/package/yocto">http://hackage.haskell.org/package/yocto</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Reading an XML file using the HXT package</h1></div></div></div><p>
<strong>Extensible Markup Language</strong> (<strong>XML</strong>) is an <a id="id58" class="indexterm"/>encoding <a id="id59" class="indexterm"/>of plain text<a id="id60" class="indexterm"/> to provide machine-readable annotations on a document. The standard is specified by W3C (<a class="ulink" href="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</a>).</p><p>In this recipe, we will parse an XML document representing an e-mail conversation and extract all the dates.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Getting ready</h2></div></div></div><p>We will first set up an XML file called <code class="literal">input.xml</code> with the following values, representing an e-mail thread between Databender and Princess on December 18, 2014 as follows:</p><div><pre class="programlisting">$ cat input.xml

&lt;thread&gt;
    &lt;email&gt;
        &lt;to&gt;Databender&lt;/to&gt;
        &lt;from&gt;Princess&lt;/from&gt;
        &lt;date&gt;Thu Dec 18 15:03:23 EST 2014&lt;/date&gt;
        &lt;subject&gt;Joke&lt;/subject&gt;
        &lt;body&gt;Why did you divide sin by tan?&lt;/body&gt;
    &lt;/email&gt;
    &lt;email&gt;
        &lt;to&gt;Princess&lt;/to&gt;
        &lt;from&gt;Databender&lt;/from&gt;
        &lt;date&gt;Fri Dec 19 3:12:00 EST 2014&lt;/date&gt;
        &lt;subject&gt;RE: Joke&lt;/subject&gt;
        &lt;body&gt;Just cos.&lt;/body&gt;
    &lt;/email&gt;
&lt;/thread&gt;</pre></div><p>Using Cabal, install the HXT library which we use for manipulating XML documents:</p><div><pre class="programlisting">
<strong>$ cabal install hxt</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We only <a id="id61" class="indexterm"/>need one import, which will be for parsing XML, using the following line of code:<div><pre class="programlisting">import Text.XML.HXT.Core</pre></div></li><li class="listitem">Define and implement <code class="literal">main</code> and specify the XML location. For this recipe, the file is retrieved from <code class="literal">input.xml</code>. Refer to the following code:<div><pre class="programlisting">main :: IO ()
main = do
    input &lt;- readFile "input.xml"</pre></div></li><li class="listitem">Apply<a id="id62" class="indexterm"/> the <code class="literal">readString</code> function to the input and extract all the date documents. We filter items with a specific name using the <code class="literal">hasName :: String -&gt; a XmlTree XmlTree</code> function. Also, we extract the text using the <code class="literal">getText :: a XmlTree String</code> function, as shown in the following code snippet:<div><pre class="programlisting">    dates &lt;- runX $ readString [withValidate no] input 
        //&gt; hasName "date" 
        //&gt; getText</pre></div></li><li class="listitem">We can now use the list of extracted dates as follows:<div><pre class="programlisting">    print dates</pre></div></li><li class="listitem">By running the code, we print the following output:<div><pre class="programlisting">
<strong> $ runhaskell Main.hs</strong>

<strong>["Thu Dec 18 15:03:23 EST 2014", "Fri Dec 19 3:12:00 EST 2014"]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>The library function, <code class="literal">runX</code>, takes in an <a id="id63" class="indexterm"/>
<strong>Arrow</strong>. Think of an Arrow as a more powerful version of a Monad. Arrows allow for stateful global XML processing. Specifically, the <code class="literal">runX</code> function in this recipe takes in <code class="literal">IOSArrow XmlTree String</code> and returns an <code class="literal">IO</code> action of the <code class="literal">String</code> type. We generate this <code class="literal">IOSArrow</code> object using the <code class="literal">readString</code> function, which performs a series of operations to the XML data.</p><p>For a deep insight into the XML document, <code class="literal">//&gt;</code> should be used whereas <code class="literal">/&gt;</code> only looks at the current level. We use the <code class="literal">//&gt;</code> function to look up the date attributes and display all the associated text.</p><p>As defined in the documentation, the <code class="literal">hasName</code> function tests whether a node has a specific name, and the <code class="literal">getText</code> function <a id="id64" class="indexterm"/>selects the text of a text node. Some other functions include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isText</code>: This<a id="id65" class="indexterm"/> is used to test for text nodes</li><li class="listitem" style="list-style-type: disc"><code class="literal">isAttr</code>: This is <a id="id66" class="indexterm"/>used to test for an attribute tree</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasAttr</code>: This is used<a id="id67" class="indexterm"/> to test whether an element node has an attribute node with a specific name</li><li class="listitem" style="list-style-type: disc"><code class="literal">getElemName</code>: This is <a id="id68" class="indexterm"/>used to select the name of an element node</li></ul></div><p>All the Arrow functions<a id="id69" class="indexterm"/> can be found on the <code class="literal">Text.XML.HXT.Arrow.XmlArrow</code> documentation at <a class="ulink" href="http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html">http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Capturing table rows from an HTML page</h1></div></div></div><p>Mining <strong>Hypertext Markup Language</strong> (<strong>HTML</strong>)<a id="id70" class="indexterm"/> is often a <a id="id71" class="indexterm"/>feat of identifying and parsing only its<a id="id72" class="indexterm"/> structured segments. Not all text in an HTML file may be useful, so we find ourselves only focusing on a specific subset. For instance, HTML tables and lists provide a strong and commonly used structure to extract data whereas a paragraph in an article may be too unstructured and complicated to process.</p><p>In this recipe, we will find a table on a web page and gather all rows to be used in the program.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Getting ready</h2></div></div></div><p>We will be extracting the values from an HTML table, so start by creating an <code class="literal">input.html</code> file containing a table as shown in the following figure:</p><div><img src="img/6331OS_01_03.jpg" alt="Getting ready"/></div><p>The HTML behind this table is as follows:</p><div><pre class="programlisting">$ cat input.html

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;Course Listing&lt;/h1&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th&gt;Course&lt;/th&gt;
                &lt;th&gt;Time&lt;/th&gt;
                &lt;th&gt;Capacity&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;CS 1501&lt;/td&gt;
                &lt;td&gt;17:00&lt;/td&gt;
                &lt;td&gt;60&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;MATH 7600&lt;/td&gt;
                &lt;td&gt;14:00&lt;/td&gt;
                &lt;td&gt;25&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;PHIL 1000&lt;/td&gt;
                &lt;td&gt;9:30&lt;/td&gt;
                &lt;td&gt;120&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>If not already<a id="id73" class="indexterm"/> installed, <a id="id74" class="indexterm"/>use Cabal to set up the HXT library and the split library, as shown in the following command lines:</p><div><pre class="programlisting">
<strong>$ cabal install hxt</strong>
<strong>$ cabal install split</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We will need the <code class="literal">htx</code> package for XML manipulations and the <code class="literal">chunksOf</code> function from the split package, as presented in the following code snippet:<div><pre class="programlisting">import Text.XML.HXT.Core
import Data.List.Split (chunksOf)</pre></div></li><li class="listitem">Define and implement <code class="literal">main</code> to read the <code class="literal">input.html</code> file.<div><pre class="programlisting">main :: IO ()
main = do
  input &lt;- readFile "input.html"</pre></div></li><li class="listitem">Feed the HTML data into <code class="literal">readString</code>, thereby setting <code class="literal">withParseHTML</code> to <code class="literal">yes</code> and optionally turning off warnings. Extract all the <code class="literal">td</code> tags and obtain the remaining text, as shown in the following code:<div><pre class="programlisting">  texts &lt;- runX $ readString 
           [withParseHTML yes, withWarnings no] input 
    //&gt; hasName "td"
    //&gt; getText</pre></div></li><li class="listitem">The <a id="id75" class="indexterm"/>data is <a id="id76" class="indexterm"/>now usable as a list of strings. It can be converted into a list of lists similar to how CSV was presented in the previous CSV recipe, as shown in the following code:<div><pre class="programlisting">  let rows = chunksOf 3 texts
  print $ findBiggest rows</pre></div></li><li class="listitem">By folding through the data, identify the course with the largest capacity using the following code snippet:<div><pre class="programlisting">findBiggest :: [[String]] -&gt; [String]
findBiggest [] = []
findBiggest items = foldl1 
                    (\a x -&gt; if capacity x &gt; capacity a 
                             then x else a) items

capacity [a,b,c] = toInt c
capacity _ = -1

toInt :: String -&gt; Int
toInt = read</pre></div></li><li class="listitem">Running the code will display the class with the largest capacity as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>{"PHIL 1000", "9:30", "120"}</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How it works...</h2></div></div></div><p>This is very similar to XML parsing, except we adjust the options of <code class="literal">readString</code> to <code class="literal">[withParseHTML yes, withWarnings no]</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Understanding how to perform HTTP GET requests</h1></div></div></div><p>One of the most <a id="id77" class="indexterm"/>resourceful places to find good data is online. <strong>GET requests</strong> are <a id="id78" class="indexterm"/>common methods of communicating with an HTTP web server. In this recipe, we will grab all the links from a Wikipedia article and print them to the terminal. To easily grab all the links, we will use a helpful library called <code class="literal">HandsomeSoup</code>, which lets us easily manipulate and traverse a webpage through CSS selectors.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Getting ready</h2></div></div></div><p>We will be collecting all links from a Wikipedia web page. Make sure to have an Internet connection before running this recipe.</p><p>Install the <code class="literal">HandsomeSoup</code> CSS selector package, and also install the HXT library if it is not already installed. To do this, use the following commands:</p><div><pre class="programlisting">
<strong>$ cabal install HandsomeSoup</strong>
<strong>$ cabal install hxt</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">This recipe requires <code class="literal">hxt</code> for parsing HTML and requires <code class="literal">HandsomeSoup</code> for the easy-to-use CSS selectors, as shown in the following code snippet:<div><pre class="programlisting">import Text.XML.HXT.Core
import Text.HandsomeSoup</pre></div></li><li class="listitem">Define and implement <code class="literal">main</code> as follows:<div><pre class="programlisting">main :: IO ()
main = do</pre></div></li><li class="listitem">Pass in the URL as a string to HandsomeSoup's <code class="literal">fromUrl</code> function:<div><pre class="programlisting">    let doc = fromUrl "http://en.wikipedia.org/wiki/Narwhal"</pre></div></li><li class="listitem">Select all links within the <code class="literal">bodyContent</code> field of the Wikipedia page as follows:<div><pre class="programlisting">    links &lt;- runX $ doc &gt;&gt;&gt; css "#bodyContent a" ! "href"
    print links</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How it works…</h2></div></div></div><p>The <code class="literal">HandsomeSoup</code> package allows easy CSS selectors. In this recipe, we run the <code class="literal">#bodyContent a</code> selector <a id="id79" class="indexterm"/>on a Wikipedia article web page. This finds all link tags that are descendants of an element with the <code class="literal">bodyContent</code> ID.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>See also…</h2></div></div></div><p>Another common way to obtain data online is through POST requests. To find out more, refer to the <em>Learning how to perform HTTP POST requests</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Learning how to perform HTTP POST requests</h1></div></div></div><p>A <strong>POST request</strong> is another <a id="id80" class="indexterm"/>very common HTTP server request used by many APIs. We will be mining the University of Virginia directory search. When sending a POST request for a search query, the <a id="id81" class="indexterm"/>
<strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>) server replies with a web page of search results.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>For this recipe, access to the Internet is necessary.</p><p>Install the <code class="literal">HandsomeSoup</code> CSS selector package, and also install the HXT library if it is not already installed:</p><div><pre class="programlisting">
<strong>$ cabal install HandsomeSoup</strong>
<strong>$ cabal install hxt</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the following libraries:<div><pre class="programlisting">import Network.HTTP
import Network.URI (parseURI)
import Text.XML.HXT.Core
import Text.HandsomeSoup
import Data.Maybe (fromJust)</pre></div></li><li class="listitem">Define the POST request specified by the directory search website. Depending on the server, the following POST request details would be different. Refer to the following code snippet:<div><pre class="programlisting">myRequestURL = "http://www.virginia.edu/cgi-local/ldapweb"

myRequest :: String -&gt; Request_String
myRequest query = Request { 
    rqURI = fromJust $ parseURI myRequestURL
  , rqMethod = POST
  , rqHeaders = [ mkHeader HdrContentType "text/html"
                , mkHeader HdrContentLength $ show $ length body ]
  , rqBody = body
  }
  where body = "whitepages=" ++ query</pre></div></li><li class="listitem">Define and implement <code class="literal">main</code> to run the POST request on a query as follows:<div><pre class="programlisting">main :: IO ()
main = do
  response &lt;- simpleHTTP $ myRequest "poon"</pre></div></li><li class="listitem">Gather the HTML and parse it:<div><pre class="programlisting">  html &lt;- getResponseBody response
  let doc = readString [withParseHTML yes, withWarnings no] html</pre></div></li><li class="listitem">Find the table rows and print it out using the following:<div><pre class="programlisting">  rows &lt;- runX $ doc &gt;&gt;&gt; css "td" //&gt; getText
  print rows</pre></div></li></ol></div><p>Running the<a id="id82" class="indexterm"/> code will display all search results relating to <code class="literal">"poon"</code>, such as "Poonam" or "Witherspoon".</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works...</h2></div></div></div><p>A POST request needs the specified URI, headers, and body. By filling out a <code class="literal">Request</code> data type, it can be used to establish a server request.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>See also</h2></div></div></div><p>Refer to the <em>Understanding how to perform HTTP GET requests</em> recipe for details on how to perform a GET request instead.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Traversing online directories for data</h1></div></div></div><p>A <a id="id83" class="indexterm"/>directory search <a id="id84" class="indexterm"/>typically provides names and contact information per query. By brute forcing many of these search queries, we can obtain all data stored in the directory listing database. This recipe runs thousands of search queries to obtain as much data as possible from a directory search. This recipe is provided only as a learning tool to see the power and simplicity of data gathering in Haskell.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>Getting ready</h2></div></div></div><p>Make sure<a id="id85" class="indexterm"/> to have a strong Internet connection.</p><p>Install the <code class="literal">hxt</code> and <code class="literal">HandsomeSoup</code> packages using Cabal:</p><div><pre class="programlisting">
<strong>$ cabal install hxt</strong>
<strong>$ cabal install HandsomeSoup</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Set up the following dependencies:<div><pre class="programlisting">import Network.HTTP
import Network.URI
import Text.XML.HXT.Core
import Text.HandsomeSoup</pre></div></li><li class="listitem">Define a <code class="literal">SearchResult</code> type, which may either fault in an error or result in a success, as presented in the following code:<div><pre class="programlisting">type SearchResult = Either SearchResultErr [String]
data SearchResultErr = NoResultsErr 
                     | TooManyResultsErr 
                     | UnknownErr     
                     deriving (Show, Eq)</pre></div></li><li class="listitem">Define the POST request specified by the directory search website. Depending on the server, the POST request will be different. Instead of rewriting code, we use the <code class="literal">myRequest</code> function defined in the previous recipe.</li><li class="listitem">Write <a id="id86" class="indexterm"/>a helper function to obtain the document from a HTTP POST request, as shown in the following code:<div><pre class="programlisting">getDoc query = do  
    rsp &lt;- simpleHTTP $ myRequest query
    html &lt;- getResponseBody rsp
    return $ readString [withParseHTML yes, withWarnings no] html</pre></div></li><li class="listitem">Scan the HTML document and return whether there is an error or provide the resulting data. The code in this function is dependent on the error messages produced by the web page. In our case, the error messages are the following:<div><pre class="programlisting">scanDoc doc = do
    errMsg &lt;- runX $ doc &gt;&gt;&gt; css "h3" //&gt; getText

    case errMsg of 
        [] -&gt; do 
            text &lt;- runX $ doc &gt;&gt;&gt; css "td" //&gt; getText 
            return $ Right text
        "Error: Sizelimit exceeded":_ -&gt; 
            return $ Left TooManyResultsErr
        "Too many matching entries were found":_ -&gt; 
            return $ Left TooManyResultsErr
        "No matching entries were found":_ -&gt; 
            return $ Left NoResultsErr
        _ -&gt; return $ Left UnknownErr</pre></div></li><li class="listitem">Define and <a id="id87" class="indexterm"/>implement <code class="literal">main</code>. We will use a helper function, <code class="literal">main'</code>, as shown in the following code snippet, to recursively brute force the directory listing:<div><pre class="programlisting">main :: IO ()
main = main' "a"</pre></div></li><li class="listitem">Run a search<a id="id88" class="indexterm"/> of the query and then recursively again on the next query:<div><pre class="programlisting">main' query = do
    print query
    doc &lt;- getDoc query
    searchResult &lt;- scanDoc doc
    print searchResult
    case searchResult of
        Left TooManyResultsErr -&gt; 
            main' (nextDeepQuery query)
        _ -&gt; if (nextQuery query) &gt;= endQuery 
              then print "done!" else main' (nextQuery query)</pre></div></li><li class="listitem">Write helper functions to define the next logical query as follows:<div><pre class="programlisting">nextDeepQuery query = query ++ "a"

nextQuery "z" = endQuery
nextQuery query = if last query == 'z'
                  then nextQuery $ init query
                  else init query ++ [succ $ last query]
endQuery = [succ 'z']</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How it works...</h2></div></div></div><p>The code starts by searching for "a" in the directory lookup. This will most likely fault in an error as there are too many results. So, in the next iteration, the code will refine its search by querying for "aa", then "aaa", until there is no longer <code class="literal">TooManyResultsErr :: SearchResultErr</code>.</p><p>Then, it will enumerate to the next logical search query "aab", and if that produces no result, it will search for "aac", and so on. This brute force prefix search will obtain all items <a id="id89" class="indexterm"/>in the database. We can gather the mass of data, such as names and department types, to perform interesting clustering or analysis later on. The following figure shows how the program starts:</p><div><img src="img/6331OS_01_04.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Using MongoDB queries in Haskell</h1></div></div></div><p>MongoDB is a<a id="id90" class="indexterm"/> nonrelational schemaless database. In this recipe, we will obtain all data from MongoDB into Haskell.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>Getting ready</h2></div></div></div><p>We need<a id="id91" class="indexterm"/> to install <a id="id92" class="indexterm"/>MongoDB on our local machine and have a database instance running in the background while we run the code in this recipe.</p><p>MongoDB installation<a id="id93" class="indexterm"/> instructions are located at <a class="ulink" href="http://www.mongodb.org">http://www.mongodb.org</a>. On Debian-based operating systems, we can use <code class="literal">apt-get</code> to install MongoDB, using the following command line:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install mongodb</strong>
</pre></div><p>Run the database daemon by specifying the database file path as follows:</p><div><pre class="programlisting">
<strong>$ mkdir ~/db</strong>
<strong>$ mongod --dbpath ~/db</strong>
</pre></div><p>Fill up a <code class="literal">"people"</code> collection with dummy data as follows:</p><div><pre class="programlisting">
<strong>$ mongo</strong>
<strong>&gt; db.people.insert( {first: "Joe", last: "Shmoe"} )</strong>
</pre></div><p>Install the MongoDB package from Cabal using the following command:</p><div><pre class="programlisting">
<strong>$ cabal install mongoDB</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec40"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Use <a id="id94" class="indexterm"/>the <code class="literal">OverloadedString</code> and <code class="literal">ExtendedDefaultRules</code> language extensions to make the MongoDB library easier to use:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings, ExtendedDefaultRules #-}
import Database.MongoDB</pre></div></li><li class="listitem">Define <a id="id95" class="indexterm"/>and implement <code class="literal">main</code> to set up a connection to the locally hosted database. Run MongoDB queries defined in the <code class="literal">run</code> function as follows:<div><pre class="programlisting">main :: IO ()
main = do
    let db = "test"
    pipe &lt;- runIOE $ connect (host "127.0.0.1")
    e &lt;- access pipe master db run
    close pipe
    print e</pre></div></li><li class="listitem">In <code class="literal">run</code>, we can combine multiple operations. For this recipe, <code class="literal">run</code> will only perform one task, that is, gather data from the <code class="literal">"people"</code> collection:<div><pre class="programlisting">run = getData

getData = rest =&lt;&lt; find (select [] "people") {sort=[]}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec41"/>How it works...</h2></div></div></div><p>A pipe is established by the driver between the running program and the database. This allows running MongoDB operations to bridge the program with the database. The <code class="literal">find</code> function takes a query, which we construct by evoking the <code class="literal">select :: Selector -&gt; Collection -&gt; aQueryOrSelection</code> function.</p><p>Other functions can be found in the documentation at <a class="ulink" href="http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html">http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec42"/>See also</h2></div></div></div><p>If the MongoDB database is on a remote server, refer to the <em>Reading from a remote MongoDB server</em> recipe to set up a connection with remote databases.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Reading from a remote MongoDB server</h1></div></div></div><p>In many <a id="id96" class="indexterm"/>cases, it <a id="id97" class="indexterm"/>may be<a id="id98" class="indexterm"/> more feasible to set up a MongoDB instance on a remote machine. This recipe will cover how to obtain data from a MongoDB hosted remotely.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec43"/>Getting ready</h2></div></div></div><p>We should create a remote <a id="id99" class="indexterm"/>database. MongoLab (<a class="ulink" href="https://mongolab.com">https://mongolab.com</a>) and MongoHQ (<a class="ulink" href="http://www.mongohq.com">http://www.mongohq.com</a>) offer MongoDB as a service and have free options to set up a small development database.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>These services will require us to accept their terms and conditions. For some of us, it may be best to host the database in our own remote server.</p></div></div><p>Install the MongoDB package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install mongoDB</strong>
</pre></div><p>Also, install the helper following helper libraries as follows:</p><div><pre class="programlisting">
<strong>$ cabal install split</strong>
<strong>$ cabal install uri</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">OverloadedString</code> and <code class="literal">ExtendedDefaultRules</code> language extensions required by the library. Import helper functions as follows:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings, ExtendedDefaultRules #-}
import Database.MongoDB
import Text.URI
import Data.Maybe
import qualified Data.Text as T
import Data.List.Split</pre></div></li><li class="listitem">Specify the remote URI for the database connection as follows:<div><pre class="programlisting">mongoURI = "mongodb://user:pass@ds12345.mongolab.com:53788/mydb"</pre></div></li><li class="listitem">The username, password, hostname, port address number, and database name must be extracted from the URI, as presented in the following code snippet:<div><pre class="programlisting">uri = fromJust $ parseURI mongoURI

getUser = head $ splitOn ":" $ fromJust $ uriUserInfo uri

getPass = last $ splitOn ":" $ fromJust $ uriUserInfo uri

getHost = fromJust $ uriRegName uri

getPort = case uriPort uri of 
    Just port -&gt; show port 
    Nothing -&gt; (last.words.show) defaultPort

getDb = T.pack $ tail $ uriPath uri</pre></div></li><li class="listitem">Create a<a id="id100" class="indexterm"/> database connection by reading the host port of the remote URI as follows:<div><pre class="programlisting">main :: IO ()
main = do
    let hostport = getHost ++ ":" ++ getPort
    pipe &lt;- runIOE $ connect (readHostPort hostport)
    e &lt;- access pipe master getDb run
    close pipe
    print e</pre></div></li><li class="listitem">Optionally <a id="id101" class="indexterm"/>authenticate <a id="id102" class="indexterm"/>to the database and obtain data from the <code class="literal">"people"</code> collection as follows:<div><pre class="programlisting">run = do
  auth (T.pack getUser) (T.pack getPass)
  getData

getData = rest =&lt;&lt; find (select [] "people") {sort=[]}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec45"/>See also</h2></div></div></div><p>If the database is on a local machine, refer to the <em>Using MongoDB queries in Haskell</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Exploring data from a SQLite database</h1></div></div></div><p>SQLite<a id="id103" class="indexterm"/> is a relational <a id="id104" class="indexterm"/>database that enforces a strict schema. It is simply a file on a machine that we can interact with through <a id="id105" class="indexterm"/>
<strong>Structured Query Language</strong> (<strong>SQL</strong>). There<a id="id106" class="indexterm"/> is an easy-to-use Haskell library to send these SQL commands to our database.</p><p>In this recipe, we will use such a library to extract all data from a SQLite database.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec46"/>Getting ready</h2></div></div></div><p>We need to install the SQLite database if it isn't already set up. It can be obtained from <a class="ulink" href="http://www.sqlite.org">http://www.sqlite.org</a>. On Debian systems, we can get it from <code class="literal">apt-get</code> using the following command:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install sqlite3</strong>
</pre></div><p>Now create a <a id="id107" class="indexterm"/>simple database to test our code, using the following commands:</p><div><pre class="programlisting">
<strong>$ sqlite3 test.db "CREATE TABLE test \</strong>
<strong>(id INTEGER PRIMARY KEY, str text); \</strong>
<strong>INSERT INTO test (str) VALUES ('test string');"</strong>
</pre></div><p>We must also install the SQLite Haskell package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install sqlite-simple</strong>
</pre></div><p>This recipe will dissect the example code presented on the library's documentation page available at <a class="ulink" href="http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html">http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec47"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Use<a id="id108" class="indexterm"/> the <code class="literal">OverloadedStrings</code> language extension and import the relevant libraries, as shown in the following code:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}

import Control.Applicative
import Database.SQLite.Simple
import Database.SQLite.Simple.FromRow</pre></div></li><li class="listitem">Define a data type for each SQLite table field. Provide it with an instance of the <code class="literal">FromRow</code> typeclass so that we may easily parse it from the table, as shown in the following code snippet:<div><pre class="programlisting">data TestField = TestField Int String deriving (Show)

instance FromRow TestField where
  fromRow = TestField &lt;$&gt; field &lt;*&gt; field</pre></div></li><li class="listitem">And lastly, open the database to import everything as follows:<div><pre class="programlisting">main :: IO ()
main = do
  conn &lt;- open "test.db"
  r &lt;- query_ conn "SELECT * from test" :: IO [TestField]
  mapM_ print r
  close conn</pre></div></li></ol></div></div></div></body></html>