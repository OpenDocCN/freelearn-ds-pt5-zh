- en: 'Chapter 9. Analytics Study: Graph Algorithms - US Domestic Flight Data Analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"It is a capital mistake to theorize before one has data."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – *Sherlock Holmes*
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we focus on a fundamental computer science data model called
    graphs and the different types of algorithm commonly used on them. As a data scientist
    or developer, it is very important to be familiar with graphs and quickly recognize
    when they provide the right solution to solve a particular data problem. For example,
    graphs are very well suited to GPS-based applications such as Google Maps, to
    find the best route from point A to point B, taking into account all kinds of
    parameters, including whether the user is driving, walking or taking public transport,
    or whether the user wants the shortest route or one that maximizes the use of
    highways regardless of overall distance. Some of these parameters can also be
    real-time parameters, such as traffic conditions, and the weather. Another important
    class of applications that uses graphs is social networks, such as Facebook or
    Twitter, where vertices represent individuals and edges represent relationships,
    such as *is a friend*, and *follows*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start this chapter with a high-level introduction to graphs and associated
    graph algorithms. We''ll then introduce `networkx` which is a Python library that
    makes it easy to load, manipulate, and visualize graph data structures as well
    as provide a rich set of graph algorithms. We''ll continue the discussion by building
    sample analytics that analyzes US flight data using various graph algorithms where
    airports are used as vertices and flights as edges. As always, we''ll also operationalize
    these analytics by building a simple dashboard PixieApp. We''ll finish this chapter
    by building a forecasting model applying time series techniques we''ve learned
    in [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting"), *Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting* to historical flight data.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of graphs and the associated graph theory is widely attributed
    to Leonhard Euler in 1736 when he worked on the problem of the *Seven Bridges
    of Königsberg* ([https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg)).
  prefs: []
  type: TYPE_NORMAL
- en: The city was divided by the Pregel river which at some point formed two islands,
    and seven bridges were built according to the layout shown in the following diagram.
    The problem was to find a way for a person to walk across each and every bridge
    once and only once and come back to the starting point. Euler proved that there
    was no solution to this problem and while doing this gave birth to graph theory.
    The fundamental idea was to transform the city diagram into a graph where each
    land mass is a vertex, and each bridge is an edge that linked two vertices (that
    is, land mass). The problem was then reduced to finding a path, which is a continuous
    sequence of edges and vertices, that contains each and every bridge only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how Euler simplified the *Seven Bridges of Königsberg*
    problem into a graph problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to graphs](img/B09699_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simplifying the Seven Bridges of Königsberg problem into a graph problem
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a more formal definition, **graphs** are the data structures that represent
    pairwise relationships (called **edges**) between objects (called **vertices**
    or **nodes**). It is common to use the following notation to represent a graph:
    *G = (V, E)* where *V* is the set of vertices and *E* is the set of edges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly two broad categories of graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directed graphs (called digraphs)**: The order in the pairwise relationship
    matters, that is, the edge (A-B) going from vertex **A** to vertex **B** is different
    from the edge (B-A) going from vertex **B** to vertex **A**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undirected graphs**: The order in the pairwise relationship doesn''t matter,
    that is, edge (A-B) is the same as an edge (B-A).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the representation of a sample graph both as undirected
    (edges have no arrows) and directed (edges have arrows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to graphs](img/B09699_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graph representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are mainly two ways of representing a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjacency matrix**: Represents the graph using an *n* by *n* matrix (we''ll
    call it *A*), where *n* is the number of vertices in the graph. The vertices are
    indexed using 1 to *n* integers. We use ![Graph representations](img/B09699_09_37.jpg)
    to denote that an edge exists between vertex *i* and vertex *j* and ![Graph representations](img/B09699_09_38.jpg)
    to denote that no edge exists between vertex *i* and vertex *j*. In the case of
    undirected graphs, we would always have ![Graph representations](img/B09699_09_39.jpg)![Graph
    representations](img/B09699_09_40.jpg) because the order doesn''t matter. However,
    in the case of digraphs where order matters, *A**[i,j]* may be different from
    *A**[j,i]*. The following example shows how to represent a sample graph in an adjacency
    matrix both directed and undirected:![Graph representations](img/B09699_09_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjacency matrix representation of a graph (both directed and undirected)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to note that the adjacency matrix representation has a constant
    space complexity which is ![Graph representations](img/B09699_09_41.jpg) where
    *n* is the number of vertices, but it has a time complexity of *O(1)* which is
    constant time to compute whether two vertices are connected with an edge between
    them. The high space complexity might be OK when the graph is dense (lots of edges)
    but could be a waste of space when the graph is sparse, in which case we might
    prefer the following adjacency list representation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The big O notation ([https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation))
    is commonly used in code analysis to represent the performance of an algorithm
    by evaluating its behavior as the input size grows. It is used both for evaluating
    running time (number of instructions needed to run the algorithm) and space requirements
    (how much storage will it need over time).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Adjacency list**: For each vertex, we maintain a list of all the vertices
    connected by an edge. In the case of an undirected graph, each edge is represented
    twice, one for each endpoint, which is not the case for a digraph where the order
    matters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the adjacency list representation of a graph, both directed
    and undirected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graph representations](img/B09699_09_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Adjacency list representation of a graph (both directed and undirected)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Contrary to the adjacency matrix representation, the adjacency list representation
    has a smaller space complexity which is *O (m + n)* where *m* is the number of
    edges and *n* is the number of vertices. However, the time complexity increases
    to *O(m)* compared to *O(1)* for the adjacency matrix. For these reasons, it is
    preferable to use the adjacency list representation when the graph is sparsely
    connected (that is, doesn't have a lot of edges).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As hinted in the preceding discussion, which graph representation to use depends
    heavily on the graph density but also on the type of algorithms we are planning
    to use. In the next section, we discuss the most commonly used graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Graph algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of the most commonly used graph algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Search**: In the context of the graph, searching means finding paths between
    two vertices. A path is defined as a continuous sequence of edges and vertices.
    The motivation for searching paths in a graph can be multiple; it could be that
    you''re interested in finding the shortest path according to some predefined distance
    criteria, such as the minimum number of edges (for example, GPS route mapping)
    or you simply want to know that a path between two vertices exists (for example,
    ensure that every machine in a network is reachable from any other machine). A
    generic algorithm to search for a path is to start from the given vertex, *discover*
    all the vertices that are connected to it, mark the discovered vertices as explored
    (so we don''t find them twice) and continue the same exploration for each discovered
    vertex until we find the target vertex, or we run out of vertices. There are two
    commonly used flavors of this search algorithm: Breadth First Search and Depth
    First Search, each having their own use cases for which they are better suited.
    The difference between these two algorithms consists of the way we find the unexplored
    vertices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breadth First Search (BFS)**: The unexplored nodes that are immediate neighbors
    are explored first. When the immediate neighborhood has been explored, start exploring
    the neighborhood of each node in the layer, until the end of the graph is reached.
    Because we are exploring all vertices that are directly connected first, this
    algorithm guarantees to find the shortest path which corresponds to the number
    of neighborhoods found. An extension to BFS is the famous Dijkstra shortest path
    algorithm where each edge is associated with a non-negative weight. In this case,
    the shortest path may not be the one with the least number of hops but rather
    a path that minimizes the sum of all weights. One example application of the Dijkstra
    shortest path is to find the shortest route between two points on a map.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth First Search (DFS)**: For each immediate neighbor vertex, aggressively
    explore its neighbors first going as deeply as you can and then start backtracking
    when you run out of neighbors. Example of applications for DFS include finding
    the topological sort and strongly connected components of a digraph. For reference,
    a topological sort is a linear ordering of the vertices such that each vertex
    in the linear order follows the edge direction of the next one (that is, it doesn''t
    move backward). See [https://en.wikipedia.org/wiki/Topological_sorting](https://en.wikipedia.org/wiki/Topological_sorting)
    for more information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates the differences in finding the unexplored
    nodes between BFS and DFS:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graph algorithms](img/B09699_09_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Order of finding unexplored vertices in BFS and DFS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Connected components and strongly connected components**: Connected components
    of a graph are groups of vertices where there is a path between any two vertices.
    Note that the definition only specifies that a path must exist which means that
    two vertices do not have to have an edge between them as long as a path exists.
    In the case of a digraph, the connected component is called a **strongly connected
    component** because of the additional direction constraint that requires that
    not only should any vertex A have a path to any other vertex B, but that B must
    also have a path to A.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the strongly connected components or a sample directed
    graph:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graph algorithms](img/B09699_09_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Strongly connected components of a directed graph
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Centrality**: The centrality indicator of a vertex provides an indication
    of how important the vertex is with regard to the other vertices in the graph.
    There are multiple important applications for these centrality indices. For example,
    identifying the most influential person in a social network or ranking a web search
    by pages that are the most important, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple indices of centrality, but we''ll focus on the following
    four that we''ll use later in this chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Degree**: The degree of a vertex is the number of edges for which the vertex
    is one of the endpoints. In the case of a digraph, it''s the number of edges for
    which the vertex is either a source or a target, and we call **indegree** the
    number of edges for which the vertex is a target and **outdegree** the number
    of edges for which the vertex is a source.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PageRank**: This is the famous algorithm developed by the founders of Google,
    Larry Page, and Sergey Brin. PageRank is used to rank the search results by providing
    a measure of importance for a given website that includes counting the number
    of links to that website from other websites. It also factors in an estimation
    of the quality of these links (that is, how trustworthy is the site linking to
    yours).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closeness**: Closeness centrality is inversely proportional to the average
    length of the shortest path between the given vertex and all the other vertices
    in the graph. The intuition is that the closer a vertex is to all the other nodes,
    the more important it is.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The closeness centrality can be calculated with the following simple equation:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graph algorithms](img/B09699_09_42.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '(Source: https://en.wikipedia.org/wiki/Centrality#Closeness_centrality)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Where *d(y,x)* is the length of the edge between node *x* and *y*.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Shortest path betweenness**: Measure based on how many times the given vertex
    is part of the shortest path between any two nodes. The intuition is that the
    more a vertex contributes to shortest paths, the more important it is. The mathematical
    equation for shortest path betweenness is provided here:![Graph algorithms](img/B09699_09_46.jpg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Source: https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Where ![Graph algorithms](img/B09699_09_43.jpg) is the total number of shortest
    paths from vertex *s* to vertex *t* and ![Graph algorithms](img/B09699_09_44.jpg)
    is the subset of ![Graph algorithms](img/B09699_09_45.jpg) that pass through *v*.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: More information on centrality can be found here:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Centrality](https://en.wikipedia.org/wiki/Centrality)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Graph and big data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our graph discussion has so far focused on data that can fit into a single machine,
    but what happens when we have very large graphs with billions of vertices and
    edges where loading the entire data into memory would not be possible? A natural
    solution would be to distribute the data across a cluster of multiple nodes which
    process the data in parallel and have the individual results merged to form the
    final answer. Fortunately, there are multiple frameworks that provide such graph-parallel
    capabilities, and they pretty much all include the implementation for most of
    the commonly-used graph algorithms. Examples of popular open-source frameworks
    are Apache Spark GraphX ([https://spark.apache.org/graphx](https://spark.apache.org/graphx))
    and Apache Giraph ([http://giraph.apache.org](http://giraph.apache.org)) which
    is currently used by Facebook to analyze its social network.
  prefs: []
  type: TYPE_NORMAL
- en: Without diving into too much detail, it's important to know that these frameworks
    are all inspired from the **bulk synchronous parallel** (**BSP**) model of distributed
    computation ([https://en.wikipedia.org/wiki/Bulk_synchronous_parallel](https://en.wikipedia.org/wiki/Bulk_synchronous_parallel))
    which uses messages between machines to find vertices across the cluster. The
    key point to remember is that these frameworks are usually very easy to use, for example,
    it would have been fairly easy to write this chapter's analytics using Apache
    Spark GraphX.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've reviewed only a fraction of all the graph algorithms
    available and going deeper would be beyond the scope of this book. Implementing
    these algorithms yourself would take a considerable amount of time, but fortunately,
    there are plenty of open source libraries that provide fairly complete implementations
    of the graph algorithms and that are easy to use and integrate into your application.
    In the rest of this chapter, we'll use the `networkx` open source Python library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the networkx graph library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, if not already done, we need to install the `networkx` library
    using the `pip` tool. Execute the following code in its own cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: As always, don''t forget to restart the kernel after the installation
    is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the algorithms provided by `networkx` are directly callable from the
    main module. Therefore a user will only need the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a starting point, let''s review the different types of graphs supported
    by `networkx` and the constructors that create empty graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Graph`: An undirected graph with only one edge between vertices allowed. Self-loop
    edges are permitted. Constructor example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Digraph`: Subclass of `Graph` that implements a directed graph. Constructor
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MultiGraph`: Undirected graph that allows multiple edges between vertices.
    Constructor example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MultiDiGraph`: Directed graph that allows multiples edges between vertices.
    Constructor example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Graph` class provides many methods for adding and removing vertices and
    edges. Here is a subset of the available methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_edge(u_of_edge, v_of_edge, **attr)`: Add an edge between vertex `u` and
    vertex `v`, with optional additional attributes that will be associated with the
    edge. The vertices u and v will automatically be created if they don''t already
    exist in the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_edge(u, v)`: Remove the edge between `u` and `v`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_node(self, node_for_adding, **attr)`: Add a node to the graph with optional
    additional attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_node(n)`: Remove the node identified by the given argument `n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_edges_from(ebunch_to_add, **attr)`: Add multiple edges in bulk with optional
    additional attributes. The edges must be given as a list of two-tuples `(u,v)`
    or three-tuples `(u,v,d)` where `d` is the dictionary that contains edge data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_nodes_from(self, nodes_for_adding, **attr)`: Add multiple nodes in bulk
    with optional additional attributes. The nodes can be provided as a list, dict,
    set, array, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an exercise, let''s build the directed graph we''ve been using as a sample
    from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a graph](img/B09699_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sample graph to be created programmatically using networkx
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code starts by creating a `DiGraph()` object, adds all the nodes
    in one call using the `add_nodes_from()` method, and then starts adding the edges
    using, for illustration, a combination of `add_edge()` and `add_edges_from()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Graph` class also provides easy access to its properties through variable
    class views. For example, you can iterate over the vertices and edges of a graph
    using `G.nodes` and `G.edges`, but also access an individual edge with the following
    notation: `G.edges[u,v]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code iterates over the nodes of a graph and prints them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `networkx` library also provides a rich set of prebuilt graph generators
    that can be useful for testing your algorithms. For example, you can easily generate
    a complete graph using the `complete_graph()` generator as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find a complete list of all the available graph generators here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators](https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators)'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing a graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NetworkX supports multiple rendering engines including Matplotlib, Graphviz
    AGraph ([http://pygraphviz.github.io](http://pygraphviz.github.io)) and Graphviz
    with pydot ([https://github.com/erocarrera/pydot](https://github.com/erocarrera/pydot)).
    Even though Graphviz provides very powerful drawing capabilities, I found it very
    hard to install. Matplotlib, however, is already preinstalled in Jupyter Notebooks
    which gets you started very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core drawing function is called `draw_networkx` which takes a graph as
    an argument and a bunch of optional keyword arguments that let you style the graph,
    such as color, width, and the label font of the nodes and edges. The overall layout
    of the graph drawing is configured by passing the `GraphLayout` object through
    the `pos` keyword argument. The default layout is `spring_layout` (which uses
    a force-directed algorithm), but NetworkX supports many others, including `circular_layout`,
    `random_layout`, and `spectral_layout`. You can find a list of all the available
    layouts here: [https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout](https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout).'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, `networkx` encapsulates each of these layouts into its own
    high-level drawing methods that call reasonable default values so that the caller
    doesn't have to deal with the intricacies of each of these layouts. For example,
    the `draw()` method will draw the graph with a `sprint_layout`, `draw_circular()`
    with a `circular_layout`, and `draw_random()`with a `random_layout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample code, we use the `draw()` method to visualize the `G_complete`
    graph we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing a graph](img/B09699_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing of a complete graph with 10 nodes
  prefs: []
  type: TYPE_NORMAL
- en: Drawing graphs with `networkx` is both easy and fun, and because it's using
    Matplotlib, you can beautify them even further using the Matplotlib drawing capabilities.
    I encourage the reader to experiment further by visualizing different graphs in
    a Notebook. In the next section, we'll start implementing a sample application
    that analyzes flight data using graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 – Loading the US domestic flight data into a graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initialize the Notebook, let''s run the following code, in its own cell,
    to import the packages which we''ll be using quite heavily in the rest of this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also be using the *2015 Flight Delays and Cancellations* dataset available
    on the Kaggle website at this location: [https://www.kaggle.com/usdot/datasets](https://www.kaggle.com/usdot/datasets).
    The dataset is composed of three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`airports.csv`: List of all U.S. airports including their **IATA** code (**International
    Air Transport Association**: [https://openflights.org/data.html](https://openflights.org/data.html)),
    city, state, longitude, and latitude.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`airlines.csv`: List of U.S. airlines including their IATA code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flights.csv`: List of flights that occurred in 2015\. This data includes date,
    origin and destination airports, scheduled and actual times, and delays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flights.csv` file contains close to 6 million records, which need to be
    cleaned up to remove all flights that do not have an IATA three letter code in
    the origin or destination airport. We also want to remove the rows that have a
    missing value in the `ELAPSED_TIME` column. Failure to do so would cause problems
    when we load the data into a graph structure. Another issue is that the dataset
    contains a few time columns, such as `DEPARTURE_TIME`, and `ARRIVAL_TIME`, and
    to save space, these columns only store the time in `HHMM` format, while the actual
    date is stored in the `YEAR`, `MONTH`, and `DAY` column. One of the analyses we
    will do in this chapter will need a complete datetime for the `DEPARTURE_TIME`,
    and since it is a time-consuming operation to do this transformation, we do it
    now and store it in the processed version of `flights.csv` that we'll store on
    GitHub. This operation uses the pandas `apply()` method that is called with the
    `to_datetime()` function and `axis=1` (indicating that the transformation is applied
    on each row).
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that we want to store the files on GitHub, but there is a maximum
    file size limitation of 100 M. So, to make the file smaller than 100 M, we also
    remove some of the columns that won't be needed in the analysis we're trying to
    build and then zip the file before storing it on GitHub. Of course, another benefit
    is that the DataFrame will load faster with a smaller file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the files from the Kaggle website, we run the following code
    which first loads the CSV file into a pandas DataFrame, remove the unwanted rows and
    columns, and write the data back to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The original data is stored in a file called `flights.raw.csv`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the following code may take some time due to the large size of the file
    which contains 6 million records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: As documented in the `pandas.read_csv` documentation ([http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html](http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html)),
    we use the keyword argument `low_memory=False` to make sure the data is not loaded
    in chunks which could cause problems with type inference, especially with very
    large files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, the three files are stored at the following GitHub location:
    [https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis](https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `pixiedust.sampleData()` method to load the data
    into three pandas DataFrames corresponding to `airlines`, `airports`, and `flights`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: The GitHub URL uses the `/raw/` segment which indicates that we want
    to download the raw file as opposed to the HTML for the corresponding GitHub page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to load the data into a `networkx` directed weighted graph
    object using the `flights` DataFrame as the `edge` list and the values from the
    `ELAPSED_TIME` column as the weight. We first deduplicate all the flights that
    have the same airports as origin and destination, by grouping them using the `pandas.groupby()`
    method with a multi-index that has `ORIGIN_AIRPORT` and `DESTINATION_AIRPORT`
    as the keys. We then select the `ELAPSED_TIME` column from the `DataFrameGroupBy`
    object and aggregate the results using the `mean()` method. This will give us
    a new DataFrame that has the mean average `ELAPSED_TIME` for each flight with
    the same origin and destination airport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flights grouped by origin and destination with mean average ELAPSED_TIME
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using this DataFrame to create the directed graph, we need to reset
    the index from a multi-index to a regular single index converting the index columns
    into regular columns. For that, we simply use the `reset_index()` method as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a DataFrame with the right shape, ready to be used to create the
    directed graph, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flights grouped by origin and destination with mean average ELAPSED_TIME and
    a single index
  prefs: []
  type: TYPE_NORMAL
- en: To create the directed weighted graph, we use the NetworkX `from_pandas_edgelist()`
    method which takes a pandas DataFrame as the input source. We also specify the
    source and target columns, as well as the weight column (in our case `ELAPSED_TIME`).
    Finally, we tell NetworkX that we want to create a directed graph by using the
    `create_using` keyword arguments, passing an instance of `DiGraph` as a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to call the `from_pandas_edgelist()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py)
    **Note**: NetworkX supports the creation of graphs by converting from multiple
    formats including dictionaries, lists, NumPy and SciPy matrices and of course
    pandas. You can find more information about these conversion capabilities here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://networkx.github.io/documentation/networkx-2.1/reference/convert.html](https://networkx.github.io/documentation/networkx-2.1/reference/convert.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly validate that our graph has the right values by directly printing
    its nodes and edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which produces the following output (truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can also create better visualization by using the built-in drawing APIs available
    in `networkx` which support multiple rendering engines including Matplotlib, Graphviz
    AGraph ([http://pygraphviz.github.io](http://pygraphviz.github.io)) and Graphviz
    with pydot ([https://github.com/erocarrera/pydot](https://github.com/erocarrera/pydot)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, we''ll use the NetworkX `draw()` method which uses the readily
    available Matplotlib engine. To beautify the visualization, we configure it with
    proper width and height `(12, 12)` and add a colormap with vivid color (we use
    the `cool` and `spring` colormap from `matplolib.cm`, see: [https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html](https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the graph visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Quick visualization of our directed graph using Matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding chart, the nodes are positioned using a default graph layout
    called `spring_layout`, which is a force-directed layout. One benefit of this
    layout is that it quickly reveals the nodes with the most edge connections which
    are located at the center of the graph. We can change the graph layout by using
    the `pos` keyword argument when calling the `draw()` method. `networkx` supports
    other types of layout including `circular_layout`, `random_layout`, `shell_layout`,
    and `spectral_layout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using a `random_layout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 1 – Loading the US domestic flight data into a graph](img/B09699_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flight data graph using a random_layout
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: You can find more information about these layouts here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html](https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Graph centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next interesting thing to analyze about the graph is its centrality indices
    which allow us to discover which nodes are the most important vertices. As an
    exercise, we''ll compute four types of centrality index: **degree**, **PageRank**,
    **closeness**, and **shortest path betweenness**. We''ll then augment the airports
    DataFrame to add a column for each of the centrality indices and visualize the
    results in a Mapbox map using PixieDust `display()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing the degree of the digraph is very easy with `networkx`; simply use
    the `degree` property of the `flight_graph` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs an array of tuples with the airport code and the degree index
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to add a `DEGREE` column to the airport DataFrame that contains
    the degree value from the preceding array for each of the airport rows. To do
    that, we''ll need to create a new DataFrame that has two columns: `IATA_CODE`
    and `DEGREE` and perform a pandas `merge()` operation on the `IATA_CODE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The merge operation is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph centrality](img/B09699_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Merging the degree DataFrame to the airports DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to implement the aforementioned steps. We first
    create a JSON payload by iterating over the `flight_path.degree` output and use
    the `pd.DataFrame()` constructor to create the DataFrame. We then use `pd.merge()`
    using `airports` and `degree_df` as arguments. We also use the `on` argument with
    value `IATA_CODE` which is the key column we''ll want to do the join on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph centrality](img/B09699_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Airport DataFrame augmented with the DEGREE column
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize the data in a Mapbox map, we simply use `PixieDust.display()`
    on the `airport_centrality` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the options dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph centrality](img/B09699_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mapbox options for displaying the airports
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking **OK** on the options dialog, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph centrality](img/B09699_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Showing the airport with degree centrality
  prefs: []
  type: TYPE_NORMAL
- en: For the other centrality indices, we can notice that the corresponding computation
    functions all return a JSON output (as opposed to an array for the degree attribute)
    with the `IATA_CODE` airport code as key and the centrality index as value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we are computing the PageRank using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this in mind, instead of repeating the same steps as we did for `degree`,
    we can implement a generic function called `compute_centrality()` that takes the
    function that computes the centrality and a column name as arguments, create a
    temporary DataFrame that contains the computed centrality values, and merge it
    with the `airports_centrality` DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation for `compute_centrality()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now simply call the `compute_centrality()` method with the three compute
    functions `nx.pagerank()`, `nx.closeness_centrality()`, and `nx.betweenness_centrality()`
    with the columns `PAGE_RANK`, `CLOSENESS`, and `BETWEENNESS` respectively as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `airports_centrality` DataFrame now has the extra columns as shown in the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph centrality](img/B09699_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Airports DataFrame augmented with PAGE_RANK, CLOSENESS and BETWEENNESS values
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, we can verify that the four centrality indices provide consistent
    results for the top airports. Using the pandas `nlargest()` method, we can get
    the top 10 airports for the four indices as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Atlanta airport comes up as the top airport for all centrality
    indices. As an exercise, let's create a generic method called `visualize_neighbors()`
    that visualizes all the neighbors of a given node and call it with the Atlanta
    node. In this method, we create a subgraph centered around the parent node by
    adding an edge from itself to all its neighbors. We use the NetworkX `neighbors()`
    method to get all the neighbors of a specific node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `visualize_neighbors()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the `visualize_neighbors()` method on the `ATL` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Which produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph centrality](img/B09699_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visualization of the top node ATL and its neighbors
  prefs: []
  type: TYPE_NORMAL
- en: We complete this *Part 1* section by computing the shortest path between two
    nodes using the famous Dijkstra algorithm ([https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)).
    We'll experiment with different weight attributes to check if we are getting different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's compute the shortest path between Boston Logan Airport
    in Massachusetts (`BOS`) and Pasco Tri-Cities Airport in Washington (`PSC`) using
    the NetworkX `dijkstra_path()` method ([https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html](https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use the `ELAPSED_TIME` column as the weight attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: As a reminder, `ELAPSED_TIME` is the average flight time for each of
    the flights with the same origin and destination airports that we computed earlier
    in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Which returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the centrality indices we computed earlier are not part of the
    `flight_graph` DataFrame, so using it as the column name for the `weight` attribute
    won't work. However, the `dijkstra_path()` also allows us to use a function to dynamically
    compute the weight. Since we want to try for different centrality indices, we
    need to create a factory method ([https://en.wikipedia.org/wiki/Factory_method_pattern](https://en.wikipedia.org/wiki/Factory_method_pattern))
    that will create a function for a given centrality index passed as an argument.
    This argument is used as a closure for a nested wrapper function that conforms
    to the `dijkstra_path()` method's `weight` argument. We also use a `cache` dictionary
    to remember the computed weights for a given airport, since the algorithm will
    call the function multiple times for the same airport. If the weight is not in
    the cache, we look it up in the `airports_centrality` DataFrame using the `centrality_indice_col`
    parameter. The final weight is computed by getting the inverse of the centrality
    value, since the Dijkstra algorithm favors paths with shorter distances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `compute_weight` factory
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py)'
  prefs: []
  type: TYPE_NORMAL
- en: We can now call the NetworkX `dijkstra_path()` method for each of the centrality
    indices. Note that we don't use BETWEENNESS because some of the values are equal
    to zero which can't be used as a weight. We also need to clear the cache before
    calling the `dijkstra_path()` method because using different centrality indices
    will produce different values for each airport.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to compute the shortest path for each centrality
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following result is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It is interesting to note that, as expected, the computed shortest path is the
    same for the three centrality indices, going through Denver airport which is a
    top central airport. However, it is not the same as the one computed using the
    `ELAPSED_TIME` weight which would have us go through Minneapolis instead.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have shown how to load US flight data into a graph data
    structure, compute different centrality indices and use them to compute the shortest
    path between airports. We also discussed different ways of visualizing the graph
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The complete Notebook for *Part 1* can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll create the `USFlightsAnalysis` PixieApp that operationalizes
    these analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Creating the USFlightsAnalysis PixieApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first iteration of our `USFlightsAnalysis`, we want to implement a
    simple user story that leverages the analytics created in *Part 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: The welcome screen will show two drop-down controls for selecting an origin
    and a destination airport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an airport is selected, we show a graph showing the selected airports and
    its immediate neighbors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When both airports are selected, the user clicks on the **Analyze** button to show
    a Mapbox map with all the airports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can select one of the centrality indices available as checkboxes to show
    the shortest flight path according to the selected centrality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first look at the implementation for the welcome screen which is implemented
    in the default route of the `USFlightsAnalysis` PixieApp. The following code defines
    the `USFlightsAnalysis` class which is decorated with the `@PixieApp` decorator
    to make it a PixieApp. It contains a `main_screen()` method that is decorated
    with the `@route()` decorator to make it the default route. This method returns
    an HTML fragment that will be used as the welcome screen when the PixieApp starts.
    The HTML fragment is composed of two parts: one that shows the drop-down control
    for selecting the origin airport and one that contains the drop-down control for
    selecting the destination airport. We use a Jinja2 `{%for...%}` loop that goes
    over each of the airports (returned by the `get_airports()` method) to generate
    a set of `<options>` elements. Under each of these controls, we add a placeholder
    `<div>` element that will host the graph visualization when an airport is selected.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: As always, we use the `[[USFlightsAnalysis]]` notation to denote
    that the code shows only a partial implementation and therefore the reader should
    not attempt to run it as is until the full implementation is provided.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll explain later on why the `USFlightsAnalysis` class inherits from the `MapboxBase`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user selects the origin airport, a `pd_refresh` targetted at the placeholder
    `<div>` element with ID `origin_graph{{prefix}}`, is triggered. In turn, this
    `<div>` element triggers a route using the state: `visualize_graph=$val(origin_airport{{prefix}}`.
    As a reminder, the `$val()` directive is resolved at runtime by fetching the airport
    value of the `origin_airport{{prefix}}` drop-down element. A similar implementation
    is used for the destination airport.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `visualize_graph` route is provided here. It simply calls
    the `visualize_neighbors()` method that we implemented in *Part 1*, which we slightly
    change in *Part 2* to add an optional figure size parameter to accommodate the
    size of the host `<div>` element. As a reminder, we also use the `@captureOutput`
    decorator since the `visualize_neighbors()` method is directly writing to the
    output of the selected cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Analyze` button is triggering the `compute_path_screen()` route which is
    associated with the `org_airport` and `dest_airport` state parameters. We also
    want to make sure that both airports are selected before allowing the `compute_path_screen()`
    route to proceed. To do that, we use a `<pd_script>` child element with `type="preRun"`
    that contains JavaScript code that will be executed before the route is triggered.
    The contract is for this code to return the Boolean `true` if we want to let the
    route proceed, or to return `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Analyze` button we check that both drop-downs have a value and return
    `true` if that''s the case or else raise an error message and return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the end results when selecting BOS as the origin
    airport and PSC as the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 2 – Creating the USFlightsAnalysis PixieApp](img/B09699_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Welcome screen with both airports selected
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at the implementation of the `compute_path_screen()` route which
    is responsible for showing the Mapbox map of all the airports and the shortest
    path based on the selected centrality index as a layer which is an extra visualization
    superimposed on the overall map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The central `<div>` element of this screen is the Mapbox map which by default
    shows the Mapbox map of all the airports. As shown in the code above, the `<pd_options>`
    child element is taken directly from the corresponding cell metadata where we
    configured the map in *Part 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left-hand side, we generate a set of checkboxes corresponding to each
    centrality index, using a Jinja2 `{%for …%}` loop over the `centrality_indices`
    variable. We initialize this variable in the `setup()` method of the `USFlightsAnalysis`
    PixieApp which is guaranteed to be called when the PixieApp starts. This variable
    is an OrderedDict ([https://docs.python.org/3/library/collections.html#collections.OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict))
    with keys as the centrality index and values as a color scheme that will be used
    in the Mapbox rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the analysis screen with no centrality index selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 2 – Creating the USFlightsAnalysis PixieApp](img/B09699_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Analysis screen with no centrality index selected
  prefs: []
  type: TYPE_NORMAL
- en: We now arrive at the step where the user selects a centrality index to trigger
    a shortest path search. Each of the checkboxes have a `pd_script` attribute that
    calls the `compute_toggle_centrality_layer()` method. This method is responsible
    for calling the NetworkX `dijkastra_path()` method with a `weight` argument generated
    by calling the `compute_weight()` method that we discussed in *Part 1*. This method
    returns an array with each airport that constitutes the shortest path. Using this
    path, we then create a JSON object that contains the GeoJSON payload as a set
    of lines to be displayed on the map.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it's worth pausing to discuss what a layer is. A **layer** is
    defined using the GeoJSON format ([http://geojson.org](http://geojson.org)) which
    we briefly discussed in [Chapter 5](ch05.xhtml "Chapter 5. Python and PixieDust
    Best Practices and Advanced Concepts"), *Python and PixieDust Best Practices and
    Advanced Concepts*. As a reminder, a GeoJSON payload is a JSON object with a specific
    schema that includes among other things a `geometry` element that defines the
    shape of the object being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define a line using the `LineString` type and an array
    of longitude and latitude coordinates for both ends of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we can generate this GeoJSON payload from the shortest path, we may
    wonder how to pass it to the PixieDust Mapbox renderer so that it can be displayed.
    Well, the mechanism is pretty simple: the Mapbox renderer will introspect the
    host PixieApp for any class variable that conforms to a specific format and use
    it to generate the Mapbox layer to be displayed. To help with conforming with
    this mechanism, we use the `MapboxBase` utility class that we briefly introduced
    earlier. This class has a `get_layer_index()` method that takes a unique name
    (we use the `centrality` index) as an argument and returns its index. It also
    takes an extra optional argument that creates the layer in case it doesn''t already
    exist. We then call the `toggleLayer()` method passing the layer index as an argument
    to turn the layer on and off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `compute_toggle_centrality_layer()`
    method that implements the aforementioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates in the geometry object are computed using the `get_airport_location()`
    method that queries the `airports_centrality` DataFrame that we created in *Part
    1*, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The layer object passed to the `get_layer_index()` method has the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: String that uniquely identifies the layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geojson`: GeoJSON object that defines the features and geometry of the layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: Used only if `geojson` is not present. Points at a URL that returns
    a GeoJSON payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paint`: Optional extra properties specific to Mapbox specification that defines
    how the layer data is styled, for example, color, width, and opacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout`: Optional extra properties specific to Mapbox specification that defines
    how the layer data is drawn, for example, fill, visibility, and symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: You can find more information about Mapbox layout and paint properties
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.mapbox.com/mapbox-gl-js/style-spec/#layers](https://www.mapbox.com/mapbox-gl-js/style-spec/#layers)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we specify extra `paint` properties to configure the
    `line-width` and the `line-color` which we take from the `centrality_indices`
    JSON object defined in the `setup()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the shortest path for a flight from `BOS` to `PSC`
    using the **ELAPSED_TIME** (in red) and the **DEGREE** (in green) centrality indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 2 – Creating the USFlightsAnalysis PixieApp](img/B09699_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the shortest path from BOS to PSC using the ELAPSED_TIME and DEGREE
    centrality indices
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've built a PixieApp that provides visualization of the shortest
    path between two airports using the PixieDust Mapbox renderer. We've shown how
    to create a new layer to enrich the map with extra information using the `MapboxBase`
    utility class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the completed Notebook for *Part 2* here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll add additional data exploration related to flight
    delays and associated airlines.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we want to extend the route analysis screen of the `USFlightsAnalysis`
    PixieApp to add two charts showing the historical arrival delay for each airline
    that flies out of the selected origin airport: one for all the flights coming
    out of the origin airport and one for all the flights regardless of airport. This
    will give us a way to compare visually whether the delay for a particular airport
    is better or worse than for all the other airports.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by implementing a method that selects the flights for a given airline.
    We also add an optional airport argument that can be used to control whether we include
    all flights or only the one that originates from this airport. The returned DataFrame
    should have two columns: `DATE` and `ARRIVAL_DELAY`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the preceding code by using it with Delta flights from Boston.
    We can then call the PixieDust `display()` method to create a line chart that
    we''ll use in the PixieApp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the PixieDust output we select the **Line Chart** menu and configure the
    options dialog as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The options dialog for generating an arrival delay line chart for Delta flights
    out of Boston
  prefs: []
  type: TYPE_NORMAL
- en: 'When clicking **OK**, we get the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chart delay for all Delta flights coming out of Boston
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are going to use this chart in the PixieApp, it is a good idea to copy
    the JSON configuration from the **Edit Cell Metadata** dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PixieDust display() configuration for the delay chart that needs to be copied
    for the PixieApp
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to generate a delay chart, we can start designing the
    PixieApp. We start by changing the layout of the main screen to use the `TemplateTabbedApp`
    helper class that gives us the tabbed layout for free. The overall analysis screen
    is now driven by the `RouteAnalysisApp` child PixieApp that contains two tabs:
    the `Search Shortest Route` tab associated with the `SearchShortestRouteApp` child
    PixieApp and the `Explore Airlines` tab associated with the `AirlinesApp` child
    PixieApp.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a high-level flow of all the classes involved
    in the new layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New tabbed layout class diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation for the `RouteAnalysisApp` is pretty straightforward using
    the `TemplateTabbedApp` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SearchShortestRouteApp` child PixieApp is basically a copy of the main
    PixieApp class we created in *Part 2*. The only difference is that it is a child
    PixieApp of the `RouteAnalysisApp` which itself is a child PixieApp of the `USFlightsAnalysis`
    main PixieApp. Therefore, we need a mechanism for passing the origin and destination
    airport down to the respective child PixieApps. To achieve this, we use the `pd_options`
    attribute when instantiating the `RouteAnalysisApp` child PixieApp.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `USFlightAnalysis` class, we change the `analyze_route` method to return
    a simple `<div>` element that triggers the `RouteAnalysisApp`. We also add a `pd_options`
    attribute with the `org_airport` and `dest_airport`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, in the `setup()` method of the `SearchShortestRouteApp` child PixieApp,
    we read the values for `org_airport` and `dest_airport` from the options dictionary
    of the `parent_pixieapp`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: The rest of the implementation of the `SearchShortestRouteApp` has
    been ommitted for brevity since it''s exactly the same as in *Part 2*. To access
    the implementation, please refer to the completed *Part 3* Notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last PixieApp class to implement is the `AirlinesApp`, which that will
    display all the delay charts. Similar to the `SearchShortestRouteApp`, we store
    `org_airport` and `dest_airport` from the `parent_pixieapp` options dictionary.
    We also compute a list of tuples (code and name) for all the airlines that have
    flights out of the given `org_airport`. To do that, we use the pandas `groupby()`
    method on the `AIRLINE` column and get a list of the index values as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main screen of the `AirlinesApp`, we generate a set of rows for each
    of the airlines using the Jinja2 `{%for...%}` loop. In each row, we add two `<div>`
    elements that will hold the delay line chart for the given airline: one for flights
    coming out of the origin airport and one for all the flights for this airline.
    Each `<div>` element has a `pd_options attribute,` with the `org_airport` and
    `dest_airport` as state attributes, which triggers the `delay_airline_screen`
    route. We also add a `delay_org_airport` Boolean state attribute to denote which
    type of delay chart we want to display. To make sure the `<div>` element is rendered
    immediately, we add the `pd_render_onload` attribute as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `AirlinesApp` default route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delay_airline_screen()` route has three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`delay_org_airport`: `true` if we only want the flights coming out of the origin
    airport, and `false` if we want all the flights for the given airline. We use
    this flag to build the mask for filtering the data out of the flights DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`airline_code`: The IATA code for the given airline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`airline_name`: The full name of the airline. We''ll use this when building
    the UI in the Jinja2 template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the body of the `delay_airline_screen()` method, we also compute the average
    delay for the selected data in the `average_delay` local variable. As a reminder,
    in order to use this variable in the Jinja2 template, we use the `@templateArgs`
    decorator, which automatically makes all local variables available in the Jinja2
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<div>` element that holds the chart has a `pd_entity` attribute that uses
    the `compute_delay_airline_df()` method that we created at the beginning of this
    section. However, we needed to rewrite this method as a member of the class since
    the arguments have changed: `org_airport` is now a class variable, and `delay_org_airport`
    is now a String Boolean. We also add a `<pd_options>` child element with the PixieDust
    `display()` JSON configuration that we copied from the **Edit Cell Metadata**
    dialog.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `delay_airline_screen()`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compute_delay_airline_df()` method has two arguments: airlines that correspond
    to the IATA code and the `delay_org_airport` String Boolean. We already covered
    implementation of this method, but the new adapted code is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Running the `USFlightsAnalysis` PixieApp with BOS and PSC as the origin and destination
    airports respectively, we click on the **Explore Airlines** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp](img/B09699_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delay line charts for all the airlines that provide services from Boston airport
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we provide another example of how to use the PixieApp programming
    model to build powerful dashboards that provide visualization and insights into
    the output of the analytics developed in the Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The completed Notebook for *Part 3* of the `USFlightsAnalysis` PixieApp can
    be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll build an ARIMA model that tries to predict flight
    delays.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4 – Creating an ARIMA model for predicting flight delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting"), *Analytics Study: Prediction - Financial
    Time Series Analysis and Forecasting*, we used time series analysis to build a
    forecasting model for predicting financial stocks. We can actually use the same
    technique in flight delays since, after all, we are also dealing here with time
    series, and so in this section, we''ll follow the exact same steps. For each destination
    airport and optional airline, we''ll build a pandas DataFrame that contains matching
    flight information.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: We''ll use the `statsmodels` library again. Make sure to install
    it if you haven''t done so already and refer to [Chapter 8](ch08.xhtml "Chapter 8. Analytics
    Study: Prediction - Financial Time Series Analysis and Forecasting"), *Analytics
    Study: Prediction - Financial Time Series Analysis and Forecasting* for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s focus on all the Delta (`DL`) flights with `BOS` as the
    destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `ARRIVAL_DELAY` column as a value for our time series, we plot the
    ACF and PACF plots to identify trends and seasonality as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Autocorrelation function for the ARRIVAL_DELAY data
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we also plot the partial autocorrelation function using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partial Autocorrelation for the ARRIVAL_DELAY data
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding charts, we can hypothesize that the data has a trend and/or
    seasonality, and that it is not stationary. Using the log difference technique
    that we explained in [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting"), *Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting*, we transform the series and
    visualize it with the PixieDust `display()` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: We also make sure to remove the rows with NA and Infinite values
    by first calling the `replace()` method to replace `np.inf` and `-np.inf` with
    `np.nan`, and then call the `dropna()` method to remove all the rows with the
    `np.nan` value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the PixieDust option dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Options dialog for the log difference of the ARRIVAL_DELAY data
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking **OK**, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: When running the preceding code, you may not get the exact same chart
    as shown in the following screenshot. This is because we configure the **# of
    Rows to Display** in the options dialog to be `100` which means that PixieDust
    will take a sample of size 100 before creating the chart.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Log difference line chart of the ARRIVAL_DELAY data
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding chart looks stationary; we can reinforce this hypothesis by plotting
    the ACF and PACF again on the log difference as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ACF chart for the log difference of the ARRIVAL_DELAY data
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we do the same thing for the PACF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PACF chart for the log difference of the ARRIVAL_DELAY data
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder from [Chapter 8](ch08.xhtml "Chapter 8. Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting"), *Analytics Study: Prediction
    - Financial Time Series Analysis and Forecasting*, an ARIMA model is composed
    of three orders: *p*, *d*, and *q*. From the preceding two charts, we can infer
    these orders for the ARIMA model we want to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoregression order p is 1**: Corresponds to the first time the ACF crosses
    the significance level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration order d is 1**: We had to do a log difference once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moving average order q is 1**: Corresponds to the first time the PACF crosses
    the significance level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these hypotheses, we can build an ARIMA model using the `statsmodels`
    package and get information about its residual error, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the mean error is only 0.003 which is pretty good, so we're ready
    to run the model with values from the `train_set` and visualize the discrepencies
    with the actual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the ARIMA `plot_predict()` method to create the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Forecast versus actual
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding chart, we can clearly see that the forecast line is much smoother
    than the actual values. This makes sense since, in reality, there are always unexpected
    reasons for delays that can be treated as outliers and therefore hard to model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to use the `test_set` to validate the model with data not yet
    seen by the model. The following code creates a `compute_test_set_predictions()`
    method to compare forecast and test data and visualize the results using the PixieDust
    `display()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PixieDust options dialog is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Options dialog for the forecast versus test comparison line chart
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking **OK**, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Forecast versus Test Data line chart
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to integrate this model into our `USFlightsAnalysis` PixieApp,
    by adding a third tab to the `RouteAnalysisApp` main screen called `Flight Delay
    Prediction`. This tab will be driven by a new child PixieApp called `PredictDelayApp`
    that will let the user select a flight segment of the shortest path computed using
    the Dijkstra shortest path algorithm with `DEGREE` as the centrality index. The
    user will also be able to select an airline, in which case the training data will
    be limited to flights operated by the selected airline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we create the `PredictDelayApp` child PixieApp and implement
    the `setup()` method that computes the Dijkstra shortest path for the selected
    origin and destination airports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the default route of the `PredictDelayApp`, we use the Jinja2 `{%for..%}`
    loop to build two drop-down boxes that display the flight segment and the airlines,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The two drop-downs have a `pd_refresh` attribute that points to the `<div>`
    element with ID `prediction_graph{{prefix}}`. When triggered, this `<div>` element
    invokes the `predict_screen()` route using the `flight_segment` and `airline`
    state attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In the `predict_screen()` route, we use the `flight_segment` and `airline` arguments
    to create the training dataset, build an ARIMA model that forecasts the model,
    and visualize the results in a line chart that compares the forecast and the actual
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Time series forecast models are limited to predictions that are close to the
    actual data, and since we only have data from 2015, we can't really use this model
    to predict more recent data. Of course, in a production application, it is assumed
    that we have flight data that is current and therefore this wouldn't be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `predict_screen()` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py)'
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we also wanted to make sure that the dataset index is
    deduplicated to avoid errors when plotting the results. This is done by filtering
    the duplicated indices using `df = df[~df.index.duplicated(keep='first')]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing left to do is to wire the `PredictDelayApp` child PixieApp to
    the `RouteAnalysisApp` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py)'
  prefs: []
  type: TYPE_NORMAL
- en: When we run the `USFlightsAnalysis` PixieApp using BOS and PSC as we did in
    the previous sections. In the **Flight Delay Prediction** tab, we select the **BOS->DEN**
    flight segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Part 4 – Creating an ARIMA model for predicting flight delays](img/B09699_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Forecast for the Boston to Denver flight segment
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've shown how to use time series forecasting models to predict
    flight delays based on historical data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the complete Notebook here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, while this is only a sample application which has a lot of room
    for improvement, the techniques for operationalizing data analytics using the
    PixieApp programming model would apply just the same in any other project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed graphs and its associated graph theory, exploring
    its data structure and algorithms. We've also briefly introduced the `networkx`
    Python library that provides a rich set of APIs for manipulating and visualizing
    graphs. We then applied these techniques toward building a sample application
    that analyzes flight data by treating it as a graph problem with airports being
    the vertices and flights the edges. As always, we've also shown how to operationalize
    these analytics into a simple yet powerful dashboard that can run directly in
    the Jupyter Notebook and then optionally be deployed as a web analytics application
    with the PixieGateway microservice.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter completes the series of sample applications that cover many important
    industry use cases. In the next chapter, I offer some final thoughts about the
    theme of this book which is to bridge the gap between data science and engineering
    by making working with data simple and accessible to all.
  prefs: []
  type: TYPE_NORMAL
