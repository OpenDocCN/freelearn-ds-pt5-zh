- en: Chapter 11. Visualizing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following visualization techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a line chart using Google's Chart API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting a pie chart using Google's Chart API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting bar graphs using Google's Chart API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a line graph using gnuplot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a scatter plot of two-dimensional points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with points in three-dimensional space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing a graph network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the looks of a graph network diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a bar graph in JavaScript using D3.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a scatter plot in JavaScript using D3.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagramming a path from a list of vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Introduction](img/ch11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visualization is important in all steps of data analysis. Whether we are just
    getting acquainted with the data or have completed our analysis, it is always
    useful to have an intuitive understanding through a graphical aid. Fortunately,
    Haskell comes with a plethora of libraries to facilitate this endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover recipes to produce line, pie, bar, and scatter
    plots using various APIs. Going beyond typical data visualization, we will also
    learn to draw network diagrams. Moreover, in the last recipe, we will describe
    navigation directions by drawing vectors on a blank canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a line chart using Google's Chart API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the convenient Google Chart API ([https://developers.google.com/chart](https://developers.google.com/chart))
    to render a line chart. This API produces a URL that points to a PNG image of
    the graph. This lightweight URL can be easier to handle than the actual image
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Our data will come from a text file that contains a list of numbers separated
    by lines. The code will generate a URL to present this data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `GoogleChart` package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `input.txt` with numbers inserted line by line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the Google Chart API library as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather the input from the text file and parse it as a list of integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a chart URL out of the image by setting the attributes appropriately,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the program will output a Google Chart URL as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure an Internet connection exists and navigate to that URL to view the chart,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google encodes all graph data within the URL. The more complicated our graph,
    the longer the Google Chart URL. In this recipe, we use the `encodeDataSimple`
    function that creates a relatively shorter URL, but only accepts integers between
    0 and 61 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To visualize a more detailed graph that allows data to have decimal places,
    we can use the `encodeDataText :: RealFrac a => [[a]] -> ChartData` function instead.
    This function allows for decimal numbers between 0 and 100 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: To represent larger ranges of integers in a graph, we should use the `encodeDataExtended`
    function, which supports integers between 0 and 4095 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the Google Charts Haskell package can be found at [https://hackage.haskell.org/package/hs-gchart](https://hackage.haskell.org/package/hs-gchart).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe required a connection to the Internet to view a graph. If we wish
    to perform all actions locally, refer to the *Displaying a line graph using gnuplot*
    recipe. Other Google API recipes can include *Plotting a pie chart using Google's
    Chart API* and *Plotting bar graphs using Google's Chart API*.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a pie chart using Google's Chart API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Chart API provides a very elegant-looking pie chart interface. We
    can generate images of well-designed pie charts by feeding our input and labels
    properly, as described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the GoogleChart package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `input.txt` with numbers inserted line by line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the Google Chart API library as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather the input from the text file and parse it as a list of integers, as
    shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the Google Chart URL from the pie chart attributes shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the program will output a Google Chart URL as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure an Internet connection exists and navigate to that URL to view the chart
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Google encodes all graph data within the URL. The more complicated the graph,
    the longer the Google Chart URL. In this recipe, we use the `encodeDataSimple`
    function, which creates a relatively shorter URL, but only accepts integers between
    0 and 61 inclusive. The legends of the pie chart are specified by the `setLabels
    :: [String] -> PieChart -> PieChart` function in the same order as the data.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To visualize a more detailed graph that allows data to have decimal places,
    we can use the `encodeDataText :: RealFrac a => [[a]] -> ChartData` function instead.
    This function allows decimal numbers between 0 and 100 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: To represent larger ranges of integers in a graph, we should use the `encodeDataExtended`
    function, which supports integers between 0 and 4095 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the Google Charts Haskell package can be found at [https://hackage.haskell.org/package/hs-gchart](https://hackage.haskell.org/package/hs-gchart).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Plotting a line chart using Google''s Chart API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Plotting bar graphs using Google''s Chart API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting bar graphs using Google's Chart API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Chart API also has great support for bar graphs. In this recipe,
    we will produce a bar graph of two sets of inputs in the same diagram to show
    the usefulness of this API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `GoogleChart` package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two files called `input1.txt` and `input2.txt` with numbers inserted
    line by line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the Google Chart API library as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather the two input values from both the text files and parse them as two
    separate lists of integers, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the bar chart too and print out the Google Chart URL as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the program will output a Google Chart URL as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure an Internet connection exists and navigate to that URL to view the following
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google encodes all graph data within the URL. The more complicated the graph,
    the longer the Google Chart URL. In this recipe, we use the `encodeDataSimple`
    function, which creates a relatively shorter URL, but only accepts integers between
    0 and 61 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To visualize a more detailed graph that allows data to have decimal places,
    we can use the `encodeDataText :: RealFrac a => [[a]] -> ChartData` function instead.
    This function allows decimal numbers between 0 and 100 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: To represent larger ranges of integers in a graph, we should use the `encodeDataExtended`
    function, which supports integers between 0 and 4095 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the Google Charts Haskell package can be found at [https://hackage.haskell.org/package/hs-gchart](https://hackage.haskell.org/package/hs-gchart).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use other Google Chart tools, refer to the *Plotting a pie chart using Google's
    Chart API* and *Plotting a line chart using Google's Chart API* recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a line graph using gnuplot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Internet connection is typically unnecessary for plotting a graph. So, in
    this recipe, we will demonstrate how to make a line graph locally.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library used in this recipe uses gnuplot to render the graph. We should
    first install gnuplot.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian-based systems such as Ubuntu, we can install it using `apt-get` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The official place to download gnuplot is on its main website available at [http://www.gnuplot.info](http://www.gnuplot.info).
  prefs: []
  type: TYPE_NORMAL
- en: 'After gnuplot is set up, install the `EasyPlot` Haskell library using cabal
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `EasyPlot` library as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a list of numbers to plot as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the chart on the `X11` window as shown in the following code snippet.
    The `X11` X Window System terminal is used by many Linux-based machines. If running
    on Windows, we should instead use the `Windows` terminal. On Mac OS X, we should
    replace `X11` with `Aqua`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the code produces a `plot1.dat` datafile as well as a visual graph
    from the selected terminal, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EasyPlot` library translates all user-specified code into a language understood
    by gnuplot to graph the data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the Google Chart API instead of easy plot, refer to the *Plotting a line
    chart using Google's Chart API* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a scatter plot of two-dimensional points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers a quick and easy way to visualize a list of 2D points as
    scattered dots within an image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library used in this recipe uses gnuplot to render the graph. We should
    first install gnuplot.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian-based systems such as Ubuntu, we can install it using `apt-get` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The official place to download gnuplot is from its main website, [http://www.gnuplot.info](http://www.gnuplot.info).
  prefs: []
  type: TYPE_NORMAL
- en: 'After gnuplot is set up, install the `easyplot` Haskell library using cabal
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, install a helper CSV package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create two comma-separated files, `input1.csv` and `input2.csv`, which
    represent two separate sets of points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to convert a CSV record into a tuple of numbers as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the two CSV files as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot both the datasets alongside each other on the same graph with different
    colors. Use the `X11` terminal for the X Window System used by many Linux-based
    machines, as shown in the following lines of code. If running on Windows, the
    terminal to use is `Windows`. On Mac OS X, we should replace `X11` with `Aqua`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program to display the graph shown in the following screenshot:![How
    to do it…](img/6331OS_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EasyPlot` library translates all user-specified code into language understood
    by gnuplot to graph the data. The last argument to plot can take in a list of
    many datasets to graph.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To visualize 3D points, refer to the *Interacting with points in a three-dimensional
    space* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with points in a three-dimensional space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When visualizing points in 3D space, it is often very useful to rotate, zoom,
    and pan the representation interactively. This recipe demonstrates how to plot
    data in 3D and interact with it in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library used in this recipe uses gnuplot to render the graph. We should
    first install gnuplot.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian-based systems such as Ubuntu, we can install it using `apt-get` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The official place to download gnuplot is from its main website available at
    [http://www.gnuplot.info](http://www.gnuplot.info).
  prefs: []
  type: TYPE_NORMAL
- en: 'After gnuplot is set up, install the `easyplot` Haskell library using Cabal
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, install a helper CSV package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create two comma-separated files, `input1.csv` and `input2.csv`, which
    represent two separate sets of points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to convert a CSV record into a tuple of numbers as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the two CSV files as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the data using the `plot''` function, which leaves gnuplot running to
    allow for an `Interactive` option. Use the `X11` terminal for the X Window System
    used by many Linux-based machines, as shown in the following lines of code. If
    running on Windows, the terminal to use is `Windows`. On Mac OS X, we should replace
    `X11` with `Aqua`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/6331OS_11_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EasyPlot` library translates all user-specified code into a language understood
    by gnuplot to graph the data. The last argument to plot can take in a list of
    many datasets to graph. By using the `plot'` function, we leave gnuplot running
    so that we can interact with the graph by rotating, zooming, and panning the three-dimensional
    visual.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To visualize 2D points, refer to the *Displaying a scatter plot of two-dimensional
    points* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing a graph network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphical networks of edges and nodes can be difficult to debug or comprehend,
    and thus, visualization helps tremendously. In this recipe, we will convert a
    graph data structure into an image of nodes and edges.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Graphviz, the graph visualization library, we must first install it
    on the machine. The official website of Graphviz contains the download and installation
    instructions ([http://www.graphviz.org](http://www.graphviz.org)). On Debian-based
    operating systems, Graphviz can be installed using `apt-get` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to install the Graphviz Haskell bindings from Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a graph defined by identifying the pairs of nodes that form edges using
    the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the graph to use the default parameters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the dot representation of the graph to the terminal as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to obtain a dot representation of the graph, which can be saved
    in a separate file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `dot` command provided by Graphviz on this file to render an image
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now view the resulting `graph.png` file shown in the following screenshot:![How
    to do it…](img/6331OS_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `graphToDot` function converts a graph into the DOT language for describing
    graphs. This is a text serialization for a graph, which can be read by the Graphviz
    `dot` command and converted into a viewable image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used the `dot` command. The Graphviz website also describes
    other commands that convert DOT language text into viewable images:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dot - "hierarchical" or layered drawings of directed graphs. This is the default
    tool to use if edges have directionality.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*neato - "spring model'''' layouts. This is the default tool to use if the
    graph is not too large (about 100 nodes) and you don''t know anything else about
    it. Neato attempts to minimize a global energy function, which is equivalent to
    statistical multidimensional scaling.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*fdp - "spring model'''' layouts similar to those of neato, but does this by
    reducing forces rather than working with energy.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*sfdp - multiscale version of fdp for the layout of large graphs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*twopi - radial layouts, after Graham Wills 97\. Nodes are placed on concentric
    circles depending their distance from a given root node.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*circo - circular layout, after Six and Tollis 99, Kauffman and Wiese 02\.
    This is suitable for certain diagrams of multiple cyclic structures, such as certain
    telecommunications networks.*'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To further change the look and feel of a graph, refer to the *Customizing the
    looks of a graph network diagram* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the looks of a graph network diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better present the data, we will cover how to customize the design of a graphical
    network diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Graphviz, the graph visualization library, we must first install it
    on the machine. The official website of Graphviz contains the download and installation
    instructions available at [http://www.graphviz.org](http://www.graphviz.org).
    On Debian-based operating systems, Graphviz can be installed using `apt-get` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to install the Graphviz Haskell bindings from Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant functions and libraries to customize a Graphviz graph as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our custom graph by first specifying all the nodes, and then specifying
    which pairs of nodes form edges, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our own custom graph parameters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the graphing engine know that we want the edges to be directed arrows as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set our own global attributes for a graph, node, and edge appearance as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Format nodes in our own way as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Format edges in our own way as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the customizations as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Print the DOT language representation of the graph to the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to obtain a `dot` representation of the graph, which can be saved
    in a separate file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `dot` command provided by Graphviz on this file to render an image
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now view the resulting `graph.png` file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `graphToDot` function converts a graph into the DOT language to describe
    graphs. This is a text serialization for a graph that can be read by the Graphviz
    `dot` command and converted into a viewable image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every possible customization option for the graph, nodes, and edges can be found
    on the `Data.GraphViz.Attributes.Complete` package documentation available at
    [http://hackage.haskell.org/package/graphviz-2999.12.0.4/docs/Data-GraphViz-Attributes-Complete.html](http://hackage.haskell.org/package/graphviz-2999.12.0.4/docs/Data-GraphViz-Attributes-Complete.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a bar graph in JavaScript using D3.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the portable JavaScript library called `D3.js` to draw a bar graph.
    This allows us to easily create a web page that contains a graph from the Haskell
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Internet connection is necessary for the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `d3js` Haskell library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a website template to hold the generated JavaScript code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a bar chart using the `bars` function. Feed the specified values and
    number of bars to draw, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the values and number of bars to draw as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `reify` function to generate the JavaScript `D3.js` text out of the
    data. Write the JavaScript to a file named `generated.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With both the `index.html` file and the `generated.js` file existing alongside
    each other, we can open the `index.html` web page using a browser that supports
    JavaScript, and see the resulting graph shown as follows:![How to do it…](img/6331OS_11_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `D3.js` library is a JavaScript library used for creating elegant visuals
    and graphs. We use our browser to run the JavaScript code, and it also acts as
    our graph-rendering engine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For another use of `D3.js`, refer to the *Rendering a scatter plot in JavaScript
    using D3.js* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a scatter plot in JavaScript using D3.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the portable JavaScript library called `D3.js` to draw a scatter
    plot. This allows us to easily create a web page that contains a graph from the
    Haskell code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Internet connection is necessary to perform this setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `d3js` Haskell library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a website template to hold the generated JavaScript code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the scatter plot and feed in the list of points as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a list of points to plot as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `reify` function to generate the JavaScript `D3.js` text out of the
    data. Write the JavaScript to a file named `generated.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With both the `index.html` and `generated.js` files existing alongside each
    other, we can open the `index.html` web page using a browser that supports JavaScript,
    and see the resulting graph shown as follows:![How to do it…](img/6331OS_11_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `graphToDot` function converts a graph into the DOT language to describe
    graphs. This is a text serialization for a graph, which can be read by the Graphviz
    `dot` command and be converted into a viewable image.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For another use of `D3.js`, refer to the *Rendering a bar graph in JavaScript
    using D3.js* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Diagramming a path from a list of vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the `diagrams` package to draw a path from driving
    directions. We simply categorize all possible travel headings into eight cardinal
    directions with an associated distance. We use directions provided by Google Maps
    in the following screenshot and reconstruct the directions from a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagramming a path from a list of vectors](img/6331OS_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `diagrams` library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a text file called `input.txt` that contains one of the eight cardinal
    directions followed by the distance, with each step separated by a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw a line-connected path from a list of vectors as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read a list of directions, represent it as a list of vectors, and draw the
    path as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to create a vector out of a direction and its corresponding
    distance as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code and run it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/6331OS_11_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mainWith` functions takes in a `Diagram` type and generates the corresponding
    image file when invoked in the terminal. We obtain the `Diagram` from our `drawPath`
    function, which glues together vectors by their offsets.
  prefs: []
  type: TYPE_NORMAL
