["```py\n    import Data.Graph\n    ```", "```py\n    myGraph :: Graph\n\n    myGraph= buildG bounds edges  \n      where  bounds = (1,4)\n          edges = [ (1,3), (1,4)\n                  , (2,3), (2,4) \n                  , (3,4) ]\n    ```", "```py\n    main = do\n      print $ \"The edges are \" ++ (show.edges) myGraph\n      print $ \"The vertices are \" ++ (show.vertices) myGraph\n    ```", "```py\n    import Data.Graph\n    ```", "```py\n    myGraph :: Graph\n\n    myGraph = fst $ graphFromEdges'   [ (\"Node 1\", 1, [3, 4] )\n                                      , (\"Node 2\", 2, [3, 4]) \n                                      , (\"Node 3\", 3, [4])\n                                      , (\"Node 4\", 4, []) ]\n    ```", "```py\n    main = do\n      putStrLn $ \"The edges are \"++ (show.edges) myGraph \n      putStrLn $ \"The vertices are \"++ (show.vertices) myGraph \n    ```", "```py\n    $ runhaskell Main.hs\n\n    The edges are [(0,2), (0,3), (1,2), (1,3), (2,3)]\n    The vertices are [0, 1, 2, 3]\n\n    ```", "```py\n$ cat input.txt\n\nunderstand Haskell\ndo Haskell data analysis\nunderstand data analysis\ndo Haskell data analysis\ndo Haskell data analysis\nfind patterns in big data\n\n```", "```py\n    import Data.Graph\n    import Data.Map (Map, (!), fromList)\n    import Data.List (nub)\n    ```", "```py\n    main = do\n      ls <- fmap lines getContents\n      let g = graph ls\n      putStrLn $ showTopoSort ls g\n    ```", "```py\n    graph :: Ord k => [k] -> Graph\n\n    graph ls = buildG bounds edges\n      where bounds = (1, (length.nub) ls)\n        edges = tuples $ map (mappingStrToNum !) ls\n        mappingStrToNum = fromList $ zip (nub ls) [1..]\n        tuples (a:b:cs) = (a, b) : tuples cs\n        tuples _ = []\n    ```", "```py\n    showTopoSort :: [String] -> Graph -> String\n\n    showTopoSort ls g = \n      unlines $ map (mappingNumToStr !) (topSort g)\n      where mappingNumToStr = fromList $ zip [1..] (nub ls)\n    ```", "```py\n    $ runhaskell Main.hs < input.txt\n\n    understand data analysis\n    understand Haskell\n    do Haskell data analysis\n    find patterns in big data\n\n    ```", "```py\n    import Data.Graph\n    import Data.Array ((!))\n    ```", "```py\n    graph :: (Graph, Vertex -> (Int, Int, [Int]))\n\n    graph = graphFromEdges'  [ (1, 1, [3, 4] )\n                             , (2, 2, [3, 4]) \n                             , (3, 3, [4])\n                             , (4, 4, []) ]\n    ```", "```py\n    depth g i = depth' g [] i\n    depth' g2(gShape, gMapping) seen i = \n      key : concat (map goDeeper adjacent)\n      where goDeeper v = if v `elem` seen \n                          then [] \n                          else depth' g (i:seen) v\n             adjacent = gShape ! i\n             (_, key, _) = gMapping i\n    ```", "```py\n    main = print $ depth graph 0\n    ```", "```py\n    $ runhaskell Main.hs\n    [1, 3, 4, 4]\n\n    ```", "```py\n    import Data.Graph\n    import Data.Array ((!))\n    ```", "```py\n    graph :: Graph\n    graph = buildG bounds edges\n      where  bounds = (1,7)\n             edges = [ (1,2), (1,5)\n                     , (2,3), (2,4) \n                     , (5,6), (5,7) \n                     , (3,1) ]\n    ```", "```py\n    breadth g i = bf [] [i]\n      where bf :: [Int] -> [Int] -> [Int]\n            bf seen forest | null forest = []\n                           | otherwise   = forest ++ \n                                           bf (forest ++ seen) \n                                 (concat (map goDeeper forest))\n              where goDeeper v = if elem v seen \n                                  then [] else (g ! v)\n    ```", "```py\n    main = do\n      print $ breadth graph 1\n    ```", "```py\n    $ runhaskell Main.hs\n    [1, 5, 2, 7, 6, 4, 3, 1]\n\n    ```", "```py\n$ cabal install graphviz\n\n```", "```py\n    import Data.GraphViz\n    ```", "```py\n    graph :: DotGraph Int\n\n    graph = graphElemsToDot graphParams nodes edges\n    ```", "```py\n    graphParams :: GraphvizParams Int String Bool () String\n\n    graphParams = defaultParams\n    ```", "```py\n    nodes :: [(Int, String)]\n\n    nodes = map (\\x -> (x, \"\")) [1..4]\n\n    edges:: [(Int, Int, Bool)]\n\n    edges= [ (1, 3, True)\n           , (1, 4, True) \n        , (2, 3, True)\n        , (2, 4, True)\n        , (3, 4, True)]\n    ```", "```py\n    main = addExtension (runGraphviz graph) Png \"graph\"\n    ```", "```py\n$ cabal install dawg\n\n```", "```py\n    import qualified Data.DAWG.Static as D\n    import Network.HTTP ( simpleHTTP, getRequest,  \n                          getResponseBody)\n    import Data.Char (toLower, isAlphaNum, isSpace)\n    import Data.Maybe (isJust)\n    ```", "```py\n    main = do\n      let url = \"http://norvig.com/big.txt\"\n      body <- simpleHTTP (getRequest url) >>= getResponseBody\n    ```", "```py\n      let corp = corpus body\n      print $ isJust $ D.lookup \"hello\" corp\n      print $ isJust $ D.lookup \"goodbye\" corp\n    ```", "```py\n    getWords :: String -> [String]\n\n    getWords str = words $ map toLower wordlike\n      where wordlike = \n               filter (\\x -> isAlphaNum x || isSpace x) str\n    ```", "```py\n    corpus :: String -> D.DAWG Char () ()\n\n    corpus str = D.fromLang $ getWords str\n    ```", "```py\n    $ runhaskell Main.hs\n\n    True\n    True\n\n    ```", "```py\n$ cabal install grid\n\n```", "```py\n    import Math.Geometry.Grid (indices, neighbours)\n    import Math.Geometry.Grid.Hexagonal (hexHexGrid)\n    import Math.Geometry.Grid.Square (rectSquareGrid)\n    import Math.Geometry.GridMap ((!))\n    import Math.Geometry.GridMap.Lazy (lazyGridMap)\n    ```", "```py\n    main = do\n      let putStrLn' str = putStrLn ('\\n':str)\n      putStrLn' \"Indices of hex grid:\"\n      print $ indices hex\n      putStrLn' \"Neighbors around (1,1) of hex grid:\"\n      print $ neighbours hex (1,1)\n      putStrLn' \"Indices of rect grid:\"\n      print $ indices rect\n      putStrLn' \"Neighbors around (1,1) of rect grid:\"\n      print $ neighbours rect (1,1)\n      putStrLn' \"value of hex at index (1,1)\"\n      print $ hexM ! (1,1)\n    ```", "```py\n    hex = hexHexGrid 4\n    ```", "```py\n    rect = rectSquareGrid 3 5\n    ```", "```py\n    hexM = lazyGridMap hex [1..]\n    ```", "```py\n$ cabal install maximal-cliques\n\n```", "```py\n    import Data.Algorithm.MaximalCliques\n    ```", "```py\n    main = print $ getMaximalCliques edges nodes\n    ```", "```py\n    edges 1 5 = True  \n    edges 1 2 = True\n    edges 2 3 = True\n    edges 2 5 = True\n    edges 4 5 = True\n    edges 3 4 = True\n    edges 4 6 = True\n    edges _ _ = False\n    ```", "```py\n    nodes = [1..6]\n    ```", "```py\n$ cabal install hgal\n\n```", "```py\n    import Data.Graph\n    import Data.Graph.Automorphism\n    ```", "```py\n    graph = buildG (0,4) [ (1, 3), (1, 4) \n                         , (1, 2), (2, 3)\n                         , (2, 4), (3, 4) ]\n    ```", "```py\n    graph' = buildG (0,4) [ (3, 1), (3, 2) \n                          , (3, 4), (4, 1)\n                          , (4, 2), (1, 2) ]\n    ```", "```py\n    main = print $ isIsomorphic graph graph'\n    ```"]