- en: Data Wrangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look at data in several different forms and pry useful statistics.
    The tools to access the data have been well developed and allow for data to be
    missing headings or data points in some of the records.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the standards for file formats is CSV. In this section, we will walk
    through the process of reading a CSV and adjusting the dataset to arrive at some
    conclusions about the data. The data I am using is from the Heating System Choice
    in California Houses dataset, found at [https://vincentarelbundock.github.io/Rdatasets/datasets.html](https://vincentarelbundock.github.io/Rdatasets/datasets.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6d82a49c-9ad3-48b7-9da1-26d3d294e172.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The data appears to be as expected; however, a number of the columns have acronym
    names and are somewhat duplicated. Let us change the names of interest that we
    want to be more readable and remove the extras we are not going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/55a0112e-f23a-4b20-9c5d-0b88e9672645.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a tighter dataset, let us start to look over the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ee0b06ea-9bad-4384-9e73-c865a9f8ab4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some points pop out from the summary:'
  prefs: []
  type: TYPE_NORMAL
- en: There are five different types of heating systems, gas cooling being most prevalent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs vary much more than expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data covers four large regions of California
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ration of the annual cost versus the initial cost varies much more than
    expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is not obvious what the data relationships might be, but we can use the
    R `plot()` function to provide a quick snapshot that shows anything significant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9d1ba861-4bb7-4d37-a9c8-de91513f3153.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, several interesting facts jump out:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial cost varies widely within the type of system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The annual cost varies within the type of system as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Costs vary widely within the ranges of customer income, age, number of rooms
    in the house, and region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only direct relationship between variables appears to be the initial cost
    of system and the annual cost. With covariance, we are looking for a measure of
    how much two variables change in relation to each other. If we run a covariance
    between the install and annual cost, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I am not sure I have seen a higher covariance result.
  prefs: []
  type: TYPE_NORMAL
- en: Reading another CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can look at another CSV in the same dataset to see what kind of issues we
    run across. Using the yearly batting records for all Major League Baseball players
    that we previously downloaded from the same site, we can use coding like the following
    to start analyzing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following head display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fd09754-548d-4d37-b6c0-d87bcfbedd60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many statistics for baseball players in this dataset. There are also
    many `NA` values. R is pretty good at ignoring `NA` values. Let us first look
    at the statistics for the data using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates statistics on all the fields involved (there are several more
    that are not in this display):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c6d3adf-d3dd-4208-a297-fb4e3a883cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A number of interesting points are visible in the preceding display that are
    worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: We have about 30 data points per player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting that the player data goes back to 1871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are about 1,000 data points per team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: American League and National League are clearly more popular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The range of some of the data points is surprising:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At bats range from 0 to 700
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs (r) range from 0 to 177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hits (h) range from 0 to 257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we just plot some of the dominant data points, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The statistic graphs are displayed in this order so that smaller values are
    not overwritten by larger values (for example, the hits (largest numbers) are
    displayed first and the triples (smallest numbers) are displayed last on top of
    the previous numbers).
  prefs: []
  type: TYPE_NORMAL
- en: We have a display of the types of hits made by players over time as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4df2ed3-24c6-46fa-b6d0-bff059c68eb1.png)'
  prefs: []
  type: TYPE_IMG
- en: I thought it was interesting that so few triples were hit. Also, since the data
    is organized somewhat chronologically, the number of triples that are hit has
    been decreasing for some time. Maybe there is an emphasis on batting to go for
    the home run over batting to get a triple.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating data with dplyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dplyr` package for R is described as a package providing a grammar for
    data manipulation. It has the entry points you would expect for wrangling your
    data frame in one package. We will use the `dplyr` package against the baseball
    player statistics we used earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We read in the player data and show the first few rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/344ae5cd-7bf7-4991-a635-54c400946447.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will be using the `dplyr` package, so we need to pull the package into our
    notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Converting a data frame to a dplyr table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dplyr` package has functions to convert your data object into a `dplyr`
    table. A `dplyr` table stores data in a compact format using much less memory.
    Most of the other `dplyr` functions can operate directly on the table as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert our data frame to a table using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a very similar display pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74e65b8e-b129-4e02-8c27-e95eab88d1a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting a quick overview of the data value ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another function available in `dplyr` is the `glimpse()` function. It takes
    every column and displays the range of values present for that variable. We use
    the function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the following display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/432954bc-562d-4a2a-9545-e367f7f5654e.png)'
  prefs: []
  type: TYPE_IMG
- en: I think I like this, in addition to the set of `summary`/`head` displays, as
    you get a feel for the variables involved rather than the rows involved, inverting
    the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling a dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dplyr` package has a function to gather a sample from your dataset, `sample()`.
    You pass in the dataset to operate against and how many samples you want drawn,
    `sample_n()`, and the fraction percentage, `sample_frac()`, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the results as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5278664c-08a9-43fb-b4d1-44f5621aaafa.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that there are 30 observations in the results set, as requested.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering rows in a data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another function we can use is the `filter` function. The `filter` function
    takes a data frame as an argument and a filtering statement. The function passes
    over each row of the data frame and returns those rows that meet the filtering
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/35016582-6cf7-4a2b-8fb2-fd3686bd0918.png)'
  prefs: []
  type: TYPE_IMG
- en: it looks like many players were capable of 200 hits a season. How about if we
    look at those players that could also get over 40 home runs in a season?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7a05a0ac-505e-45b1-9a7a-74d3dbb572f4.png)'
  prefs: []
  type: TYPE_IMG
- en: It's a very small list. I know that player names are somewhat mangled, but you
    can recognize a few, such as Babe Ruth.
  prefs: []
  type: TYPE_NORMAL
- en: I wonder if any of the players hit over 300 times in a season.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d42cbf4f-24fc-450f-b567-4371a9f56c67.png)'
  prefs: []
  type: TYPE_IMG
- en: It's interesting that no records met our `filter`, but the results handler requires
    a number of columns, and throws an error, as in this case there are none. Usually,
    errors in R are due to programming errors. It is unusual for R to generate an
    error for what I think would be normal no result data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a column to a data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `mutate` function can be used to add a column to a data frame using the
    familiar R programming syntax you have seen elsewhere. In this case, we are adding
    a column to the data frame that has the percentage of time the player got a hit
    when at bat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8137e49a-8240-409f-9537-93270d4f2fe9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the new column on the right in the preceding display. If we run
    a `summary`, we will get a summary of all fields (including the new `hitpct`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/95a85481-9c45-430c-a92d-75106f42aced.png)'
  prefs: []
  type: TYPE_IMG
- en: With the max at `1.0`, that would mean some players got a hit every time they
    were at bat. Similarly, those with `0.0` never got a hit. It looks like a narrow
    range in the 20% area. Assume the `1.0` is one at bat and one hit, as all the
    other values are measured in multiple decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a summary on a calculated field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can arrive more directly at the summary value for the column using the `summarize`
    function. The function takes a data frame and a singular calculated result. We
    can see the same result using the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e62ff202-0a34-42e0-be83-16cd0b7abfa5.png)'
  prefs: []
  type: TYPE_IMG
- en: Piping data between functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can obtain the same results by *piping* the data between functions. Piping
    is denoted using the symbols `%>%` in R programming. It is available from the
    `magrittr` package. The piping symbols are normally thought of as synonyms for
    *then* in English. For example, the R statement `data %>% function()` means take
    the data object and then pass it along to the `function()`, just as if we had
    entered the statement `function(data)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce the same summary on a calculated field using piping, we would write
    the following (meaning take the `pct` dataset and then pipe it into the `summarize`
    function, and take the `hitpct` field and pipe it into the mean function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining the 99% quantile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can look at the cut-off for the 99% mark using the `quantile()` function.
    Using the same sample data, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This would have corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, the hit percentage of 47% is the cutoff for the 99% level of the data. Given
    that the three-quarter percentile was at 28% (as in the preceding `hitpct` graphic),
    there is quite a range of performance for that last quarter of data pointsâ€”that
    is, there are some great baseball players.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could get a list of those players in the top 25% of the hit percentage using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the players are arranged by hit percentage in descending order, then the
    players with perfect hit ratios are displayed, but they all had under 10 at bats.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the data points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d3a65bd-f463-49e1-89d2-0411916ac7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have 200 (`198`) players in the top 25% of our dataset, meaning that
    1% of the players are in the top 25% of hit performance. I did not think the data
    would be that lopsided.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a summary on grouped data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, the preceding steps tell us something about individual players. There
    is always the argument that team *X* is always better than everyone else. What
    if we could get a hit percentage by team and compare the results?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are grouping the players by team and then computing an
    average hit percentage for the entire team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/15ab6c7a-dc74-475b-aa0a-0c77147d12db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, who were the best teams ever? We can order the data by the teams'' hit
    percentages (the `-teamhitpct` clause means that the results should be arranged
    in descending order) using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2198b3f7-9cc5-46e7-b314-9f0187ea0d5c.png)'
  prefs: []
  type: TYPE_IMG
- en: I'm not sure what the CNU team is; I assume it is an earlier Chicago team. The
    others are recognizable as Philadelphia, Toronto, and Boston.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the top percentile of teams using the `quantile` function that
    we used previously for player hit performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this to the previous table, we can see that only two teams (out of
    130) are in the top performance group (which is about the 1% mark).
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up data with tidyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tidyr` package is available to clean up/tidy your dataset. The use of
    `tidyr` is to rearrange your data so that:'
  prefs: []
  type: TYPE_NORMAL
- en: Each column is a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row is an observation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your data is arranged in this manner, it becomes much easier to analyze.
    There are many datasets published that mix columns and rows with values. You then
    must adjust them accordingly if you use the data in situ.
  prefs: []
  type: TYPE_NORMAL
- en: '`tidyr` provides three functions for cleaning up your data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gather`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`separate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spread`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `gather()` function takes your data and arranges the data into key-value
    pairs, much like the Hadoop database model. Let''s use the standard example of
    stock prices for a date using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate data that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3cb9fa5-88a7-4fe6-b012-2a5bfc4c1fb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Every row has a timestamp and the prices of the three stocks at that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use `gather()` to split out key-value pairs for the stocks. The `gather()`
    function is called with the data frame that it will work with, the output column
    names, and the columns to ignore (`-time`). So we get a row with the distinct
    time, stock, and prices using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following `head()` display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feff73a6-bc34-4586-8b17-f14f3d07d910.png)'
  prefs: []
  type: TYPE_IMG
- en: The `separate()` function is used to split apart values that are in the same
    entry points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Dow Jones Index history about industrial prices from UCI ([https://archive.ics.uci.edu/ml/datasets/Dow+Jones+Index](https://archive.ics.uci.edu/ml/datasets/Dow+Jones+Index)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are only interested in the `stock`, `date`, and `close` columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0aee2ec6-dd2c-4bac-b243-7abf360b1b6b.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have the date already gathered to start with (if we had disorganized
    data to start with, we would have used `gather` to organize it up to this point).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spread()` function will take the key-value pairs (from the `gather()`
    function) and separate out the values into multiple columns. We call `spread()`
    using the data frame containing our source date, the values to use for our columns,
    and the data points for each date/column. Continuing with our example, we can
    spread out all of the securities by date using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following `summary` display (shortened to just the first
    few securities):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a4ba21d-98c7-4247-bdf4-fa386875bdb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It also results in the following `head` display, showing the prices of all
    the securities by date:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aeb3b09-73c3-4a90-b704-84af48fdc495.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also similarly reorganize the data by listing all prices for a stock
    per row using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, our row driver is the stock, the column heading is the date value, and
    the data point for each stock/date is the closing price of the security on that
    date.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `summary` (abbreviated), we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f5399d2-b45a-4445-839c-c6d8d1bce274.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the `head` sample showing the data in our desired format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49bff9b4-ab28-452a-9dd5-ec2150a54cde.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we read in CSV files and performed a quick analysis of the
    data, including visualizations to help understand the data. Next, we considered
    some of the functions available in the `dplyr` package, including drawing a glimpse
    of the ranges of the data items, sampling a dataset, filtering out data, adding
    columns using mutate, and producing a summary. While doing so, we also started
    to use piping to more easily transfer the results of one operation into another
    operation. Lastly, we looked into the `tidyr` package to clean or tidy up our
    data into distinct columns and observations using the associated gather, separate,
    and spread functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at producing a dashboard under Jupyter.
  prefs: []
  type: TYPE_NORMAL
