- en: Classification Using K-Nearest Neighbors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nearest neighbor algorithm classifies a data instance based on its neighbors.
    The class of a data instance determined by the *k*-nearest neighbors algorithm
    is the class with the highest representation among the *k*-closest neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement the basics of the k-NN algorithm using the example of Mary
    and her temperature preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose a correct *k* value so that the algorithm can perform correctly
    and with the highest degree of accuracy using the example of a map of Italy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to rescale values and prepare them for the k-NN algorithm using the example
    of house preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose a good metric to measure distances between data points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to eliminate irrelevant dimensions in higher-dimensional space to ensure
    that the algorithm performs accurately using the text classification example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mary and her temperature preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example, if we know that our friend, Mary, feels cold when it is 10°C,
    but warm when it is 25°C, then in a room where it is 22°C, the nearest neighbor
    algorithm would guess that our friend would feel warm, because 22 is closer to
    25 than to 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we would like to know when Mary feels warm and when she feels
    cold, as in the previous example, but in addition, wind speed data is also available
    when Mary is asked whether she feels warm or cold:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Temperature in °C** | **Wind speed in km/h** | **Mary''s perception** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 0 | Cold |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | 0 | Warm |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 5 | Cold |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 3 | Warm |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 7 | Cold |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 10 | Cold |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | 5 | Warm |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | 6 | Warm |'
  prefs: []
  type: TYPE_TB
- en: 'We could represent the data in a graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32fcee24-5625-4abb-9ff4-48c0f241fca5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, suppose we would like to find out how Mary feels when the temperature
    is 16°C with a wind speed of 3 km/h by using the *1*-NN algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1ef3a61-29f6-4395-9904-a8fd36dfcff9.png)'
  prefs: []
  type: TYPE_IMG
- en: For simplicity, we will use a Manhattan metric to measure the distance between
    the neighbors on the grid. The Manhattan distance *d[Man]* of the neighbor *N[1]=(x[1],y[1])*
    from the neighbor *N[2]=(x[2],y[2])* is defined as *d[Man]=|x[1]**-* *x[2]|+|y[1]**-*
    *y[2]|*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s label the grid with distances around the neighbors to see which neighbor
    with a known class is closest to the point we would like to classify:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b41d305d-64c1-4f53-aa2e-2146b7586056.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the closest neighbor with a known class is the one with a temperature
    of 15°C (blue) and a wind speed of 5 km/h. Its distance from the point in question
    is three units. Its class is blue (cold). The closest red (warm) neighbour is
    at a distance of four units from the point in question. Since we are using the
    1-nearest neighbor algorithm, we just look at the closest neighbor and, therefore,
    the class of the point in question should be blue (cold).
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying this procedure to every data point, we can complete the graph,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fadf736f-c76e-4d57-9868-ba3d12a30639.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that, sometimes, a data point might be the same distance away from two
    known classes: for example, 20°C and 6 km/h. In such situations, we could prefer
    one class over the other, or ignore these boundary cases. The actual result depends
    on the specific implementation of an algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the k-nearest neighbors algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will implement the k-NN algorithm in Python to find Mary''s temperature
    preference. At the end of this section, we will also implement the visualization
    of the data produced in the previous section, that is, *Mary and her temperature
    preferences*. The full, compilable code, with the input files, can be found in
    the source code provided with this book. The most important parts have been extracted
    and presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Input**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding program will use the following file as the source of the input
    data. The file contains the table with the known data about Mary''s temperature
    preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the preceding implementation on the `mary_and_temperature_preferences.data` input
    file by using the k-NN algorithm for `k=1` neighbors. The algorithm classifies
    all the points with integer coordinates in the rectangle with a size of `(30-5=25)
    by (10-0=10)`, hence, with a size of `(25+1) * (10+1) = 286` integer points (adding
    one to count points on boundaries). Using the `wc` command, we find out that the
    output file contains exactly 286 lines—one data item per point. Using the `head`
    command, we display the first 10 lines from the output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Visualization**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the visualization depicted earlier in this chapter, the `matplotlib` library
    was used. A data file is loaded, and then displayed in a scatter diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Map of Italy example – choosing the value of k
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our data, we are given some points (about 1 percent) from the map of Italy
    and its surroundings. The blue points represent water, and the green points represent
    land; the white points are unknown. From the partial information that we have
    been given, we would like to predict whether there is water or land in the white
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing only 1% of the map data in the picture would make it almost invisible.
    If we were given about 33 times more data from the map of Italy and its surroundings,
    and drew it in the picture instead, it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d1458c9-b445-498b-81df-26d1aa0aed5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this problem, we will use the k-NN algorithm—*k* here means that we will
    look at *k*-closest neighbors. Given a white point, it will be classified as an
    area of water if the majority of its *k*-closest neighbors are in an area of water
    and classified as land if the majority of its *k*-closest neighbors are an area
    of land. We will use the Euclidean metric for the distance: given two points, *X=[x[0],x[1]]*
    and *Y=[y[0],y[1]]*, their Euclidean distance is defined as *d[Euclidean] = sqrt((x[0]-y[0])²+(x[1]-y[1])²)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euclidean distance is the most common metric. Given two points on a piece
    of paper, their Euclidean distance is just the length between the two points,
    as measured by a ruler, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/438d455d-c50a-4050-ad3c-8cc3c04594ae.png)'
  prefs: []
  type: TYPE_IMG
- en: To apply the k-NN algorithm to an incomplete map, we have to choose the value
    of *k*. Since the resulting class of a point is the class of the majority of the
    *k*-closest neighbors of that point, *k* should be odd. Let's apply this algorithm
    to the values of *k=1,3,5,7,9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this algorithm to every white point on the incomplete map will result
    in the following complete maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e30176a-ac73-4bfc-bc22-ad4e9582f5c6.png)'
  prefs: []
  type: TYPE_IMG
- en: k=1
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3ba0c09-c93a-42c0-946d-008ef6dfa6fc.png)'
  prefs: []
  type: TYPE_IMG
- en: k=3
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2adcc17-bafc-4e20-aaa0-c43d020f6745.png)'
  prefs: []
  type: TYPE_IMG
- en: k=5
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00da5203-291f-40de-906e-8f24897be3d2.png)'
  prefs: []
  type: TYPE_IMG
- en: k=7
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89bc78d7-4053-4586-83e2-49c105cf71bd.png)'
  prefs: []
  type: TYPE_IMG
- en: k=9
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, the highest value of *k* results in a complete map
    with smoother boundaries. An actual complete map of Italy is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/822d8fb1-cae0-4f08-8fce-a4ed19eb02a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use this real, complete map to calculate the percentage of incorrectly
    classified points for the various values of *k* to determine the accuracy of the
    k-NN algorithm for different values of *k*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **k** | **Precentage of incorrectly classified points** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2.97 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3.24 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 3.29 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 3.40 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 3.57 |'
  prefs: []
  type: TYPE_TB
- en: Thus, for this particular type of classification problem, the k-NN algorithm
    achieves the highest accuracy (least error rate) for *k=1*.
  prefs: []
  type: TYPE_NORMAL
- en: However, in real life, the problem is that we wouldn't usually have complete
    data or a solution. In such scenarios, we need to choose a value of *k* that is
    appropriate to the data that is partially available. For this, consult *Problem
    4* at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: House ownership – data rescaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For each person, we are given their age, yearly income, and whether or not
    they own a house:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Age** | **Annual income in USD** | **House ownership status** |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | 50,000 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | 34,000 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 48 | 40,000 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 52 | 30,000 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 28 | 95,000 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | 78,000 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 35 | 130,000 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | 105,000 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 100,000 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 40 | 60,000 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 80,000 | Peter |'
  prefs: []
  type: TYPE_TB
- en: '![](img/dca3b7cb-d007-4325-8adc-6da7a4c97381.png)'
  prefs: []
  type: TYPE_IMG
- en: House ownership and annual income
  prefs: []
  type: TYPE_NORMAL
- en: The aim is to predict whether Peter, aged 50, with an income of $80,000 per
    year, owns a house and could be a potential customer for our insurance company.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, we could try to apply the 1-NN algorithm. However, we should
    be careful about how we measure the distances between the data points, since the
    income range is much wider than the age range. Income levels of USD 115 k and
    USD 116 k are USD 1,000 apart. The two data points for these incomes would be
    very far apart. However, relative to each other, the difference between these
    data points isn''t actually that big. Because we consider both measures (age and
    yearly income) to be about as important as each other, we would scale both from
    0 to 1 according to the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7f80a4f-06bb-4927-95df-4173f07c1cf3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our particular case, this reduces to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce5dc1b8-a7ce-4089-b54b-3974f5cf909a.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/1d4d1412-e788-4d98-8880-3ebf69fc1b26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After scaling, we get the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Age** | **Scaled age** | **Annual income in USD** | **Scaled annual income**
    | **House ownership status** |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | 0.09375 | 50,000 | 0.2 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | 0.53125 | 34,000 | 0.04 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 48 | 0.875 | 40,000 | 0.1 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 52 | 1 | 30,000 | 0 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 28 | 0.25 | 95,000 | 0.65 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | 0.15625 | 78,000 | 0.48 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 35 | 0.46875 | 130,000 | 1 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | 0.375 | 105,000 | 0.75 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 0 | 100,000 | 0.7 | Non-owner |'
  prefs: []
  type: TYPE_TB
- en: '| 40 | 0.625 | 60,000 | 0.3 | Owner |'
  prefs: []
  type: TYPE_TB
- en: '| 50 | 0.9375 | 80,000 | 0.5 | ? |'
  prefs: []
  type: TYPE_TB
- en: Now, if we apply the 1-NN algorithm with the Euclidean metric, we will find
    out that Peter more than likely owns a house. Note that, without rescaling, the
    algorithm would yield a different result. Refer to *Exercise 1.5* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Text classification – using non-Euclidean distances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are given the following word counts relating to the keywords **algorithm**
    and **computer**, for documents of the classes, in the informatics and mathematics
    subject classifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm words per 1,000** | **Computer words per 1,000** | **Subject
    classification** |'
  prefs: []
  type: TYPE_TB
- en: '| 153 | 150 | Informatics |'
  prefs: []
  type: TYPE_TB
- en: '| 105 | 97 | Informatics |'
  prefs: []
  type: TYPE_TB
- en: '| 75 | 125 | Informatics |'
  prefs: []
  type: TYPE_TB
- en: '| 81 | 84 | Informatics |'
  prefs: []
  type: TYPE_TB
- en: '| 73 | 77 | Informatics |'
  prefs: []
  type: TYPE_TB
- en: '| 90 | 63 | Informatics |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 0 | Mathematics |'
  prefs: []
  type: TYPE_TB
- en: '| 33 | 0 | Mathematics |'
  prefs: []
  type: TYPE_TB
- en: '| 105 | 10 | Mathematics |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0 | Mathematics |'
  prefs: []
  type: TYPE_TB
- en: '| 84 | 2 | Mathematics |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 0 | Mathematics |'
  prefs: []
  type: TYPE_TB
- en: '| 41 | 42 | ? |'
  prefs: []
  type: TYPE_TB
- en: Those documents having a high incidence of the words **algorithm** and **computer**
    are in the `informatics` class. The `mathematics` class happens to contain documents
    with a high incidence of the word **algorithm** in some cases, for example, a
    document concerned with the Euclidean algorithm from the field of number theory.
    But, since the `mathematics` class tends to be applied less than `informatics`
    in the area of algorithms, the word **computer** comes up less frequently in the
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to classify a document that has 41 instances of the word **algorithm**
    per 1,000 words, and 42 instances of the word **computer** per 1,000 words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d58149ae-c5d9-458e-b369-b2c2249c17dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using, for example, the 1-NN algorithm and the Manhattan or Euclidean distance
    would result in the document in question being assigned to the `mathematics` class.
    However, intuitively, we should instead use a different metric to measure the
    distance, as the document in question has a much higher incidence of the word
    **computer** than other known documents in the class of `mathematics`.
  prefs: []
  type: TYPE_NORMAL
- en: Another candidate metric for this problem is a metric that would measure the
    proportion of the for the words or the angle between the instances in documents.
    Instead of the angle, you could take the cosine of the angle, *cos(θ)*, and then
    use the well-known dot product formula to calculate *cos(θ)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use *a=(a[x],a[y]), b=(b[x],b[y])*. Use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec9b933f-2f8c-4aaa-89f8-f8a64ddcbe2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will derive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39906b59-4478-4f29-82d0-66365f6a52bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the cosine distance metric, you could classify the document in question
    to the `informatics` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c0a52f7-1e42-4cff-8f2c-d1ebc92ae0ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Text classification – k-NN in higher dimensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we are given documents and would like to classify other documents based
    on their word frequency counts. For example, the 120 most frequently occurring
    words found in the Project Gutenberg e-book of the King James Bible are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e554f3ad-cab2-4a87-8abe-af4546dde5c2.png)'
  prefs: []
  type: TYPE_IMG
- en: The task is to design a metric that, given the word frequencies for each document,
    would accurately determine how semantically close those documents are. Consequently,
    such a metric could be used by the k-NN algorithm to classify the unknown instances
    in the new documents based on the existing documents.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that we consider, for example, *N* most frequent words in our corpus
    of documents. Then, we count the word frequencies for each of the *N* words in
    a given document and put them in an *N*-dimensional vector that will represent
    that document. Then, we define a distance between two documents to be the distance
    (for example, Euclidean) between the two-word frequency vectors of those documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this solution is that only certain words represent the actual
    content of the book, and others need to be present in the text because of grammar
    rules or their general basic meaning. For example, out of the 120 most frequently
    encountered words in the Bible, each word is of different importance. In the following
    table, we have highlighted the words that have both a high frequency in the Bible
    and an important meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: lord - used 1.00%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: god - 0.56%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Israel - 0.32%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: king - 0.32%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: David - 0.13%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jesus - 0.12%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: These words are less likely to be present in mathematical texts, for example,
    but more likely to be present in texts concerned with religion or Christianity.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we just look at the six most frequent words in the Bible, they
    happen to be less useful with regard to detecting the meaning of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: the - 8.07%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: and - 6.51%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: of - 4.37%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to - 1.72%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: that - 1.63%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: in - 1.60%
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Texts concerned with mathematics, literature, and other subjects will have similar
    frequencies for these words. Differences may result mostly from the writing style.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to determine a similarity distance between two documents, we only
    need to look at the frequency counts of the important words. Some words are less
    important—these dimensions are better reduced, as their inclusion can lead to
    misinterpretation of the results in the end. Thus, what we are left to do is choose
    the words (dimensions) that are important to classify the documents in our corpus.
    For this, consult *Problem 6*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that the *k*-nearest neighbor algorithm is a classification
    algorithm that assigns the majority class among the *k*-nearest neighbors to a
    given data point. The distance between two points is measured by a metric. We
    covered examples of distances, including the Euclidean distance, Manhattan distance,
    tangential distance, and cosine distance. We also discussed how experiments with
    various parameters and cross-validation can help to establish which parameter, *k*, and
    which metric should be used.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that the dimensionality and position of a data point are determined
    by its qualities. A large number of dimensions can result in low accuracy of the
    k-NN algorithm. Reducing the dimensions of qualities of lesser importance can
    increase accuracy. Similarly, to increase accuracy further, distances for each
    dimension should be scaled according to the importance of the quality of that
    dimension.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the Naive Bayes algorithm, which classifies
    an element based on probabilistic methods using Bayes' theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Mary and her temperature preference problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map of Italy – choosing the value of *k*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: House ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to learn from the material from this chapter in the best way possible,
    please analyze these problems on your own first before looking at the *Analysis*
    section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mary and her temperature preference problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem 1**: Imagine that you know that your friend Mary feels cold when
    it is -50°C, but she feels warm when it is 20°C. What would the 1-NN algorithm
    say about Mary? Would she feel warm or cold at temperatures of 22, 15, and -10?
    Do you think that the algorithm predicted Mary''s body''s perception of the temperature
    correctly? If not, please give your reasons and suggest why the algorithm did
    not give appropriate results and what would need to be improved for the algorithm
    to make a better classification.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 2**: Do you think that the 1-NN algorithm would yield better results
    than using the *k*-NN algorithm for *k*>1?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 3**: We collected more data and found out that Mary feels warm at 17°C,
    but cold at 18°C. Using our own common sense, Mary should feel warmer when the
    temperature is higher. Can you explain the possible cause of the discrepancies
    in the data? How could we improve the analysis of our data? Should we also collect some
    non-temperature data? Suppose that we have the only piece of temperature data
    available; do you think that the *1*-NN algorithm would still yield better results
    with data like this? How should we choose *k* for the *k*-NN algorithm to perform
    well?'
  prefs: []
  type: TYPE_NORMAL
- en: Map of Italy – choosing the value of k
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem 4**: We are given a partial map of Italy for the Map of Italy problem.
    However, suppose that the complete data is not available. Thus, we cannot calculate
    the error rate on all of the predicted points for different values of *k*. How
    should you choose the value of *k* for the *k*-NN algorithm, to complete the map
    of Italy with a view to maximizing its accuracy?'
  prefs: []
  type: TYPE_NORMAL
- en: House ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem 5**: Using the data from the section concerned with the problem of
    house ownership, find the closest neighbor to Peter by using the Euclidean metric:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Without rescaling the data
  prefs: []
  type: TYPE_NORMAL
- en: b) By using the scaled data
  prefs: []
  type: TYPE_NORMAL
- en: 'Is the closest neighbor in:'
  prefs: []
  type: TYPE_NORMAL
- en: a) The same as the neighbor in?
  prefs: []
  type: TYPE_NORMAL
- en: b) Which of the neighbors owns the house?
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 6**: Suppose you would like to find books or documents in Gutenberg''s
    corpus ([www.gutenberg.org](http://www.gutenberg.org/)) that are similar to a
    selected book from the corpus (for example, the Bible) by using a certain metric
    and the 1-NN algorithm. How would you design a metric measuring the similarity
    distance between the two books?'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Problem 1**: 8°C is closer to 20°C than to -50°C. So, the algorithm would
    classify Mary as feeling warm at -8°C. But this is not likely to be true if we
    use our common sense and knowledge. In more complex examples, we may be deluded
    by the results of the analysis and make false conclusions due to our lack of expertise.
    But remember that data science makes use of substantive and expert knowledge,
    not only data analysis. In order to draw sound conclusions, we should have a good
    understanding of the problem and our data.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm further says that at 22°C, Mary should feel warm, and there is
    no doubt in that, as 22°C is higher than 20°C, and a human being feels warmer
    with a higher temperature; again, a trivial use of our knowledge. For 15°C, the
    algorithm would deem Mary to feel warm, but if we use our common sense, we may
    not be that certain of this statement.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use our algorithm to yield better results, we should collect more
    data. For example, if we find out that Mary feels cold at 14°C, then we have a
    data instance that is very close to 15° and, thus, we can guess with a higher
    degree of certainty that Mary would feel cold at a temperature of 15°.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 2**: The data we are dealing with is just one-dimensional and is
    also partitioned into two parts, cold and warm, with the following property: the
    higher the temperature, the warmer a person feels. Also, even if we know how Mary
    feels at the temperatures -40, -39, …, 39, and 40, we still have a very limited
    amount of data instances – just one for around every degree Celsius. For these
    reasons, it is best to just look at one closest neighbor.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 3**: Discrepancies in the data can be caused by inaccuracies in the
    tests carried out. This could be mitigated by performing more experiments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from inaccuracy, there could be other factors that influence how Mary
    feels: for example, the wind speed, humidity, sunshine, how warmly Mary is dressed
    (whether she has a coat on with jeans, or just shorts with a sleeveless top, or
    even a swimming suit), and whether she is wet or dry. We could add these additional
    dimensions (wind speed and how she is dressed) into the vectors of our data points.
    This would provide more, and better quality, data for the algorithm and, consequently,
    better results could be expected.'
  prefs: []
  type: TYPE_NORMAL
- en: If we have only temperature data, but more of it (for example, 10 instances
    of classification for every degree Celsius), then we could increase the *k* value
    and look at more neighbors to determine the temperature more accurately. But this
    purely relies on the availability of the data. We could adapt the algorithm to
    yield the classification based on all the neighbors within a certain distance,
    *d*, rather than classifying based on the *k*-closest neighbors. This would make
    the algorithm work well in both cases when we have a lot of data within a close
    distance, and when we have just one data instance close to the instance that we
    want to classify.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 4**: For this purpose, you can use cross-validation (consult the
    *Cross-validation* section in *Appendix A – Statistics*) to determine the value
    of *k* with the highest accuracy. You could separate the available data from the
    partial map of Italy into learning and test data, for example, 80% of the classified
    pixels on the map would be given to a k-NN algorithm to complete the map. Then,
    the remaining 20% of the classified pixels from the partial map would be used
    to calculate the percentage of pixels with the correct classification according
    to the k-NN algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 5**:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Without data rescaling, Peter's closest neighbor has an annual income of
    USD 78,000 and is aged 25\. This neighbor does not own a house.
  prefs: []
  type: TYPE_NORMAL
- en: b) After data rescaling, Peter's closest neighbor has an annual income of USD
    60,000 and is aged 40\. This neighbor owns a house.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 6**: To design a metric that accurately measures the similarity distance
    between the two documents, we need to select important words that will form the
    dimensions of the frequency vectors for the documents. Words that do not determine
    the semantic meaning of documents tend to have an approximately similar frequency
    count across all documents. Thus, instead, we could produce a list with the relative
    word frequency counts for a document. For example, we could use the following
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53ecdce7-22e4-4db7-95d3-283325d8a832.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, the document could be represented by an *N*-dimensional vector consisting
    of the word frequencies for *N* words with the highest relative frequency count.
    Such a vector will tend to consist of more important words than a vector of *N*
    words with the highest frequency count.
  prefs: []
  type: TYPE_NORMAL
