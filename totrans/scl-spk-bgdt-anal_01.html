<html><head></head><body>
        <section id="KVCC1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to Scala</h1>
                
            
            <article>
                
<div class="packt_quote"><em class="calibre8">"I'm Scala. I'm a scalable, functional and object-oriented programming language. I can grow with you and you can play with me by typing one-line expressions and observing the results instantly"</em></div>
<p class="packt_quote1">- Scala Quote<em class="calibre8"><br class="title-page-name"/></em></p>
<p class="mce-root">In last few years, Scala has observed steady rise and wide adoption by developers and practitioners, especially in the fields of data science and analytics. On the other hand, Apache Spark which is ;written in Scala is a fast and general engine for large-scale data processing. Spark's success is due to many factors: easy-to-use API, clean programming model, performance, and so on. Therefore, naturally, Spark has more support for S<span>cala:</span> more APIs are available for S<span>cala</span> compared to P<span>ython</span> or <span>Java; a</span>lthough, new Scala APIs are available before those for Java, Python, and R.</p>
<p class="mce-root">Now that before we start writing your data analytics program using Spark and Scala (part II), we will first get familiar with Scala's functional programming concepts, object oriented features and the Scala collection APIs in detail (part I). As a starting point, we will provide a brief introduction to Scala in this chapter. We will cover some basic aspects of Scala including it's history and purposes. Then we will see how to install Scala on different platforms including Windows, Linux, and Mac OS so that your data analytics programs can be written on your favourite editors and IDEs. Later in this chapter, we will provide a comparative analysis between Java and Scala. Finally, we will dive into Scala programming with some examples.</p>
<p class="mce-root">In a nutshell, the following topics will be covered:</p>
<ul class="calibre9">
<li class="mce-root1">History and purposes of Scala</li>
<li class="mce-root1">Platforms and editors</li>
<li class="mce-root1">Installing and setting up Scala</li>
<li class="mce-root1">Scala: the scalable language</li>
<li class="mce-root1">Scala for Java programmers</li>
<li class="mce-root1">Scala for the beginners</li>
<li class="mce-root1">Summary</li>
</ul>


            </article>

            
        </section>
    

        <section id="LTSU1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">History and purposes of Scala</h1>
                
            
            <article>
                
<p class="mce-root">Scala is a general-purpose programming language that comes with support of <kbd class="calibre11">functional programming</kbd> and a strong <kbd class="calibre11">static type</kbd> system. The source code of Scala is intended to be compiled into <kbd class="calibre11">Java</kbd> bytecode, so that the resulting executable code can be run on <kbd class="calibre11">Java virtual machine</kbd> (JVM).</p>
<p class="mce-root">Martin Odersky started the design of Scala back in 2001 at the <strong class="calibre1">École Polytechnique Fédérale de Lausanne</strong> (<strong class="calibre1">EPFL</strong>). It was an extension of his work on Funnel, which is a programming language that uses functional programming and Petri nets. The first public release appears in 2004 but with only on the Java platform support. Later on, it was followed by .<kbd class="calibre11">NET</kbd> framework in June 2004.</p>
<p class="mce-root">Scala has become very popular and experienced wide adoptions because it not only supports the object-oriented programming paradigm, but it also embraces the functional programming concepts. In addition, although Scala's symbolic operators are hardly easy to read, compared to Java, most of the S<span>cala</span> codes are comparatively concise and easy to read -e.g. <span>Java</span> is too verbose.</p>
<p class="mce-root">Like any other programming languages, Scala was prosed and developed for specific purposes. Now, the question is, why was Scala created and what problems does it solve? To answer these questions, Odersky said in his blog: ;</p>
<div class="book-info-bottom-author-body">"The work on Scala stems from a research effort to develop better language support for component software. There are two hypotheses that we would like to validate with the Scala experiment. First, we postulate that a programming language for component software needs to be scalable in the sense that the same concepts can describe small as well as large parts. Therefore, we concentrate on mechanisms for abstraction, composition, and decomposition, rather than adding a large set of primitives, which might be useful for components at some level of scale but not at other levels. Second, we postulate that scalable support for components can be provided by a programming language which unifies and generalizes object-oriented and functional programming. For statically typed languages, of which Scala is an instance, these two paradigms were up to now largely separate."</div>
<p class="mce-root">Nevertheless, pattern matching and higher order functions, and so on, are also provided in Scala, not to fill the gap between FP and OOP, but because ;they are typical features of functional programming. For this, it has some incredibly powerful pattern-matching features, which are an actor-based concurrency framework. Moreover, it has the support of the first- and higher-order functions. In summary, the name "Scala" is a portmanteau of scalable language, signifying that it is designed to grow with the demands of its users.</p>


            </article>

            
        </section>
    

        <section id="MSDG1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Platforms and editors</h1>
                
            
            <article>
                
<p class="mce-root">Scala runs on <strong class="calibre1">Java Virtual Machine</strong> (<strong class="calibre1">JVM</strong>), which makes Scala a good choice for Java programmers too who would like to have a functional programming flavor in their codes. There are lots of options when it comes to editors. It's better for you to spend some time making some sort of a comparative study between the available editors because being comfortable with an IDE is one of the key factors for a successful programming experience. Following are some options to choose from:</p>
<ul class="calibre9">
<li class="mce-root1">Scala IDE</li>
<li class="mce-root1">Scala plugin for Eclipse</li>
<li class="mce-root1">IntelliJ IDEA</li>
<li class="mce-root1">Emacs</li>
<li class="mce-root1">VIM</li>
</ul>
<p class="mce-root">Scala support programming on Eclipse has several advantages using numerous beta plugins. Eclipse provides some exciting features such as local, remote, and high-level debugging facilities with semantic highlighting and code completion for Scala. You can use Eclipse for Java as well as Scala application development with equal ease. However, I would also suggest Scala IDE (<a href="http://scala-ide.org/" class="calibre10">http://scala-ide.org/</a>)--it's a full-fledged Scala editor based on Eclipse and customized with a set of interesting features (for example, Scala worksheets, ScalaTest support, Scala refactoring, and so on). ;</p>
<p class="mce-root">The second best option, in my view, is the IntelliJ IDEA. The first release came in 2001 as the first available Java IDEs with advanced code navigation and refactoring capabilities integrated. According to the InfoWorld report (see at <a href="http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html" class="calibre10">http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html</a>), out of the four top Java programming IDE (that is, Eclipse, IntelliJ IDEA, NetBeans, and JDeveloper), IntelliJ received the highest test center score of 8.5 out of 10.</p>
<p class="mce-root">The corresponding scoring is shown in the following figure:</p>
<div class="cdpaligncenter"><img class="image-border" src="../images/00172.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 1:</strong> Best IDEs for Scala/Java developers</div>
<p class="mce-root">From the preceding ;figure, you may be interested in using other IDEs such as NetBeans and JDeveloper too. Ultimately, the choice is an everlasting debate among the developers, which means the final choice is yours.</p>


            </article>

            
        </section>
    

        <section id="NQU21-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing and setting up Scala</h1>
                
            
            <article>
                
<p class="mce-root">As we have already mentioned, Scala uses JVM, therefore make sure you have Java installed ;on your machine. If not, refer to the next subsection, which shows how to install Java on Ubuntu. In this section, at first, we will show you how to install Java 8 on Ubuntu. Then, we will see how to install Scala on Windows, Mac OS, and Linux.</p>


            </article>

            
        </section>
    

        <section id="OPEK1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing Java</h1>
                
            
            <article>
                
<p class="mce-root">For simplicity, we will show how to install Java 8 on an Ubuntu 14.04 LTS 64-bit machine. But for Windows and Mac OS, it would be better to invest some time on Google to know how. For a minimum clue for the Windows users: refer to this link for details <a href="https://java.com/en/download/help/windows_manual_download.xml" class="calibre10">https://java.com/en/download/help/windows_manual_download.xml</a><a href="https://java.com/en/download/help/windows_manual_download.xml." class="calibre10">.</a></p>
<p class="mce-root">Now, let's see how to install Java 8 on Ubuntu with step-by-step commands and instructions. At first, check whether ;Java is already installed:</p>
<pre class="calibre19">
<strong class="calibre1">$ java -version<br class="title-page-name"/></strong>
</pre>
<p class="mce-root">If it returns <kbd class="calibre11">The program java cannot be found in the following packages</kbd>, Java hasn't been installed yet. Then you would like to execute the following command to get rid of:</p>
<pre class="calibre19">
<strong class="calibre1"> $ sudo apt-get install default-jre </strong>
</pre>
<p class="mce-root">This will install the <strong class="calibre1">Java Runtime Environment</strong> (<strong class="calibre1">JRE</strong>). However, if you may instead need the <strong class="calibre1">Java Development Kit</strong> (<strong class="calibre1">JDK</strong>), which is usually needed to compile Java applications on Apache Ant, Apache Maven, Eclipse, and IntelliJ IDEA.</p>
<p class="mce-root">The Oracle JDK is the official JDK, however, it is no longer provided by Oracle as a default installation for Ubuntu. You can still install it using apt-get. To install any version, first execute the following commands:</p>
<pre class="calibre19">
<strong class="calibre1">$ sudo apt-get install python-software-properties<br class="title-page-name"/>$ sudo apt-get update<br class="title-page-name"/>$ sudo add-apt-repository ppa:webupd8team/java<br class="title-page-name"/>$ sudo apt-get update<br class="title-page-name"/></strong>
</pre>
<p class="mce-root">Then, depending on the version you want to install, execute one of the following commands:</p>
<pre class="calibre19">
<strong class="calibre1">$ sudo apt-get install oracle-java8-installer</strong>
</pre>
<p class="mce-root">After installing, don't forget to set the Java home environmental variable. Just apply the following ;commands (for the simplicity, we assume that Java is installed at <kbd class="calibre11">/usr/lib/jvm/java-8-oracle</kbd>):</p>
<pre class="calibre19">
<strong class="calibre1">$ echo "export JAVA_HOME=/usr/lib/jvm/java-8-oracle" &gt;&gt; ~/.bashrc  <br class="title-page-name"/>$ echo "export PATH=$PATH:$JAVA_HOME/bin" &gt;&gt; ~/.bashrc<br class="title-page-name"/>$ source ~/.bashrc </strong>
</pre>
<p class="mce-root">Now, let's see the <kbd class="calibre11">Java_HOME</kbd> as follows:</p>
<pre class="calibre19">
<strong class="calibre1">$ echo $JAVA_HOME</strong>
</pre>
<p class="mce-root">You should observe the following result on Terminal:</p>
<pre class="calibre19">
<strong class="calibre1"> /usr/lib/jvm/java-8-oracle</strong>
</pre>
<p class="mce-root">Now, let's check to make sure that Java has been installed successfully by issuing the following command (you might see the latest version!):</p>
<pre class="calibre19">
<strong class="calibre1">$ java -version</strong>
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">java version "1.8.0_121"</strong><br class="title-page-name"/><strong class="calibre1">Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</strong><br class="title-page-name"/><strong class="calibre1">Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</strong>
</pre>
<p class="mce-root">Excellent! Now you have Java installed on your machine, thus you're ready Scala codes once it is installed. Let's do this in the next few subsections.</p>


            </article>

            
        </section>
    

        <section id="PNV61-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Windows</h1>
                
            
            <article>
                
<p class="mce-root">This part will focus on installing Scala on the PC with Windows 7, but in the end, it won't matter which version of Windows you to run at the moment:</p>
<ol class="calibre14">
<li value="1" class="mce-root1">The first step is to download a zipped file of Scala from the official site. You will find it at <a href="https://www.scala-lang.org/download/all.html" class="calibre10">https://www.Scala-lang.org/download/all.html</a>. Under the other resources section of this page, you will find a list of the archive files from which you can install Scala. We will choose to download the zipped file for Scala 2.11.8, as shown in the following figure:</li>
</ol>
<div class="cdpaligncenter"><img class="image-border1" src="../images/00174.gif"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 2:</strong> Scala installer for Windows</div>
<ol start="2" class="calibre14">
<li value="2" class="mce-root1">After the downloading has finished, unzip the file and place it in your favorite folder. You can also rename the file Scala for navigation flexibility. Finally, a <kbd class="calibre11">PATH</kbd> variable needs to be created for Scala to be globally seen on your OS. For this, navigate to <span>Computer</span> | <span>Properties</span>, as shown in the following figure:</li>
</ol>
<div class="cdpaligncenter"><img class="image-border2" src="../images/00176.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 3:</strong> Environmental variable tab on windows</div>
<ol start="3" class="calibre14">
<li value="3" class="mce-root1">Select <span>Environment Variables</span> from there and get the location of the <kbd class="calibre11">bin</kbd> folder of Scala; then, append it to the <kbd class="calibre11">PATH</kbd> environment variable. Apply the changes and then press <span>OK</span>, ;as shown in the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img class="image-border3" src="../images/00178.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 4:</strong> Adding environmental variables for Scala</div>
<ol start="4" class="calibre14">
<li value="4" class="mce-root1">Now, you are ready to go for the Windows installation. Open the CMD and just type <kbd class="calibre11">scala</kbd>. If you were successful in the installation process, then you should see an output similar to the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img class="image-border4" src="../images/00182.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 5:</strong> Accessing Scala from "Scala shell"</div>


            </article>

            
        </section>
    

        <section id="QMFO1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mac OS</h1>
                
            
            <article>
                
<p class="mce-root">It's time now to install Scala on your Mac. There are lots of ways in which you can install Scala on your Mac, and here, we are going to mention two of them:</p>


            </article>

            
        </section>
    

        <section id="RL0A1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Homebrew installer</h1>
                
            
            <article>
                
<ol class="calibre14">
<li value="1" class="mce-root1">At first, check your system to see whether it has Xcode installed or not because it's required in this step. You can install it from the Apple App Store free of charge.</li>
<li value="2" class="mce-root1">Next, you need to install <kbd class="calibre11">Homebrew</kbd> from the terminal by running the following command in your terminal:</li>
</ol>
<pre class="calibre19">
<strong class="calibre1">$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</strong>"
</pre>
<div class="packt_infobox">
<p class="calibre20">Note: The preceding ;command is changed by the Homebrew guys from time to time. If the command doesn't seem to be working, check the Homebrew website for the latest incantation: <a href="http://brew.sh/" class="calibre21">http://brew.sh/</a>.</p>
</div>
<ol start="3" class="calibre14">
<li value="3" class="mce-root1">Now, you are ready to go and install Scala by typing this command <kbd class="calibre11">brew install scala</kbd> ;in the terminal.</li>
<li value="4" class="mce-root1">Finally, you are ready to go by simply typing Scala in your terminal (the second line) and you will observe the following on your terminal: ;</li>
</ol>
<div class="cdpaligncenter1"><img class="image-border5" src="../images/00226.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 6</strong>: Scala shell on macOS</div>


            </article>

            
        </section>
    

        <section id="SJGS1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing manually</h1>
                
            
            <article>
                
<p class="mce-root">Before installing Scala manually, choose your preferred version of Scala and download the corresponding <kbd class="calibre11">.tgz</kbd> file of that version <kbd class="calibre11">Scala-verion.tgz</kbd> from <a href="http://www.scala-lang.org/download/" class="calibre10">http://www.Scala-lang.org/download/</a>. After downloading your preferred version of Scala, extract it as follows:</p>
<pre class="calibre19">
<strong class="calibre1">$ tar xvf scala-2.11.8.tgz</strong>
</pre>
<p class="mce-root">Then, move it to <kbd class="calibre11">/usr/local/share</kbd> as follows:</p>
<pre class="calibre19">
<strong class="calibre1">$ sudo mv scala-2.11.8 /usr/local/share</strong>
</pre>
<p class="mce-root">Now, to make the installation permanent, execute the following commands:</p>
<pre class="calibre19">
<strong class="calibre1">$ echo "export SCALA_HOME=/usr/local/share/scala-2.11.8" &gt;&gt; ~/.bash_profile<br class="title-page-name"/>$ echo "export PATH=$PATH: $SCALA_HOME/bin" &gt;&gt; ~/.bash_profile </strong>
</pre>
<p class="mce-root">That's it. Now, let's see how it can be done on Linux distributions like Ubuntu in the next subsection.</p>


            </article>

            
        </section>
    

        <section id="TI1E1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linux</h1>
                
            
            <article>
                
<p class="mce-root">In this subsection, we will show you the installation procedure of Scala on the Ubuntu distribution of Linux. Before starting, let's check to make sure Scala is installed properly. Checking this is straightforward using the following command:</p>
<pre class="calibre19">
<strong class="calibre1">$ scala -version</strong>
</pre>
<p class="mce-root">If Scala is already installed on your system, you should get the following message on your terminal:</p>
<pre class="calibre19">
<strong class="calibre1">Scala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL</strong>
</pre>
<p class="mce-root">Note that, during the writing of this installation, we used the latest version of Scala, that is, 2.11.8. If you do not have Scala installed on your system, make sure you install it before proceeding to the next step. ; You can download the latest version of Scala from the Scala website at <a href="http://www.scala-lang.org/download/" class="calibre10">http://www.scala-lang.org/download/</a> (for a clearer view, refer to <em class="calibre8">Figure 2</em>). For ease, let's download Scala 2.11.8, as follows: ;</p>
<pre class="calibre19">
<strong class="calibre1">$ cd Downloads/</strong><br class="title-page-name"/><strong class="calibre1">$ wget https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz</strong>
</pre>
<p class="mce-root">After the download has been finished, you should find the Scala tar file in the download folder.</p>
<div class="packt_infobox">The user should first go into the <kbd class="calibre22">Download</kbd> directory with the following command: <kbd class="calibre22">$ cd /Downloads/</kbd>. Note that the name of the downloads folder may change depending on the system's selected language.</div>
<p class="mce-root">To extract the Scala <kbd class="calibre11">tar</kbd> file from its location or more, type the following command. Using this, the Scala tar file can be extracted from the Terminal:</p>
<pre class="calibre19">
<strong class="calibre1">$ tar -xvzf scala-2.11.8.tgz</strong>
</pre>
<p class="mce-root">Now, move the Scala distribution to the user's perspective (for example, <kbd class="calibre11">/usr/local/scala/share</kbd>) by typing the following command or doing it manually:</p>
<pre class="calibre19">
 <strong class="calibre1">$ sudo mv scala-2.11.8 /usr/local/share/</strong>
</pre>
<p class="mce-root">Move to your home directory issue using the following command:</p>
<pre class="calibre19">
<strong class="calibre1">$ cd ~</strong>
</pre>
<p class="mce-root">Then, set the Scala home using the following commands:</p>
<pre class="calibre19">
<strong class="calibre1">$ echo "export SCALA_HOME=/usr/local/share/scala-2.11.8" &gt;&gt; ~/.bashrc       </strong><br class="title-page-name"/><strong class="calibre1">$ echo "export PATH=$PATH:$SCALA_HOME/bin" &gt;&gt; ~/.bashrc</strong>
</pre>
<p class="mce-root">Then, make the change permanent for the session by using the following command:</p>
<pre class="calibre19">
<strong class="calibre1">$ source ~/.bashrc</strong>
</pre>
<p class="mce-root">After the installation has been completed, you should better to verify it using the following command:</p>
<pre class="calibre19">
<strong class="calibre1">$ scala -version</strong>
</pre>
<p class="mce-root">If Scala has successfully been configured on your system, you should get the following message on your terminal:</p>
<pre class="calibre19">
<strong class="calibre1">Scala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL</strong>
</pre>
<p class="mce-root">Well done! Now, let's enter into the Scala shell by typing the ;<kbd class="calibre11">scala</kbd> command on the terminal, as shown in the following figure:</p>
<div class="cdpaligncenter"><strong class="calibre1"><img class="image-border6" src="../images/00033.jpeg"/></strong></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 7:</strong> Scala shell on Linux (Ubuntu distribution)</div>
<div class="cdpalignleft">
<p class="mce-root">Finally, you can also install Scala using the apt-get command, as follows:</p>
<pre class="calibre19">
<strong class="calibre1">$ sudo apt-get install scala</strong>
</pre>
<p class="mce-root">This command will download the latest version of Scala (that is, 2.12.x). However, Spark does not have support for Scala 2.12 yet (at least when we wrote this chapter). Therefore, we would recommend the manual installation described earlier.</p>
</div>


            </article>

            
        </section>
    

        <section id="UGI01-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala: the scalable language</h1>
                
            
            <article>
                
<p class="mce-root">The name Scala comes from a scalable language because Scala's concepts scale well to large programs. Some programs in other languages will take tens of lines to be coded, but in Scala, you will get the power to express the general patterns and concepts of programming in a concise and effective manner. In this section, we will describe some exciting features of Scala that Odersky has created for us:</p>


            </article>

            
        </section>
    

        <section id="VF2I1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala is object-oriented</h1>
                
            
            <article>
                
<p class="mce-root">Scala is a very good example of an object-oriented language. To define a type or behavior for your objects you need to use the notion of classes and traits, which will be explained later, in the next chapter. Scala doesn't support direct multiple inheritances, but to achieve this structure, you need to use Scala's extension of the <strong class="calibre1">subclassing</strong> and <strong class="calibre1">mixing-based composition</strong>. This will be discussed in later chapters.<strong class="calibre1"><br class="title-page-name"/></strong></p>


            </article>

            
        </section>
    

        <section id="10DJ41-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala is functional</h1>
                
            
            <article>
                
<p class="mce-root">Functional programming treats functions like first-class citizens. In Scala, this is achieved with syntactic sugar and objects that extend traits (like <em class="calibre8">Function2</em>), but this is how functional programming is achieved in Scala. Also, Scala defines a simple and easy way to define <strong class="calibre1">anonymous</strong> <strong class="calibre1">functions</strong> (functions without names). It also supports higher-order functions and it allows nested functions<strong class="calibre1">.</strong> The syntax of these concepts will be explained in deeper details in the coming chapters.</p>
<p class="mce-root">Also, it helps you to code in an immutable way, and by this, you can easily apply it to parallelism with synchronization and concurrency.</p>


            </article>

            
        </section>
    

        <section id="11C3M1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala is statically typed</h1>
                
            
            <article>
                
<p class="mce-root">Unlike the other statically typed languages like Pascal, Rust, and so on, Scala does not expect you to provide redundant type information. You don't have to specify the type in most cases. Most importantly, you don't even need to repeat them again.</p>
<div class="packt_infobox">A programming language is called statically typed if the type of a variable is known at compile time: this also means that, as a programmer, you must specify what the type of each variable is. For example, Scala, Java, C, OCaml, Haskell, and C++, and so on. On the other hand, Perl, Ruby, Python, and so on are dynamically typed languages, where the type is not associated with the variables or fields, but with the runtime values.</div>
<p class="mce-root">The statically typed nature of Scala ensures that all kinds of checking are done by the compiler. This extremely powerful feature of Scala helps you find/catch most trivial bugs and errors at a very early stage, before being executed.</p>


            </article>

            
        </section>
    

        <section id="12AK81-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala runs on the JVM</h1>
                
            
            <article>
                
<p class="mce-root">Just like Java, Scala is also compiled into bytecode which can easily be executed by the JVM. This means that the runtime platforms of Scala and Java are the same because both generate bytecodes as the compilation output. So, you can easily switch from Java to Scala, you can ;and also easily integrate both, or even use Scala in your Android application to add a functional flavor. ;</p>
<div class="packt_tip">Note that, while using Java code in a Scala program is quite easy, the opposite is very difficult, mostly because of Scala's syntactic sugar.</div>
<p class="mce-root">Also, just like the <kbd class="calibre11">javac</kbd> command, which compiles Java code into bytecode, Scala has the <kbd class="calibre11">scalas</kbd> command, which compiles the Scala code into bytecode.</p>


            </article>

            
        </section>
    

        <section id="1394Q1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala can execute Java code</h1>
                
            
            <article>
                
<p class="mce-root">As mentioned earlier, Scala can also be used to execute your Java code. Not just installing your Java code; it also enables you to use all the available classes from the Java SDK, and even your own predefined classes, projects, and packages right in the Scala environment.</p>


            </article>

            
        </section>
    

        <section id="147LC1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala can do concurrent and ;synchronized processing</h1>
                
            
            <article>
                
<p class="mce-root">Some programs in other languages will take tens of lines to be coded, but in Scala, you will get the power to express the general patterns and concepts of programming in a concise and effective manner. Also, it helps you to code in an immutable way, and by this, you can easily apply it to parallelism with synchronization and concurrency.</p>


            </article>

            
        </section>
    

        <section id="1565U1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala for Java programmers</h1>
                
            
            <article>
                
<p class="mce-root">Scala has a set of features that completely differ from Java. In this section, we will discuss some of these features. This section will be helpful for those who are from a Java background or are at least familiar with basic Java syntax and semantics.</p>


            </article>

            
        </section>
    

        <section id="164MG1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">All types are objects</h1>
                
            
            <article>
                
<p class="mce-root">As mentioned earlier, every value in Scala will look like an object. This statement means everything looks like an object, but some of them do not actually object and you will see the interpretation of this in the coming chapters (for example, ;the difference between the reference types and the primitive types still exists in Scala, but it hides it for the most part). For example, in Scala, strings are implicitly converted to collections of characters, but not in Java!</p>


            </article>

            
        </section>
    

        <section id="173721-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type inference</h1>
                
            
            <article>
                
<p class="mce-root">If you are not familiar with the term, it is nothing but the deduction of types at compile time. Hold on, isn't that what dynamic typing means? Well, no. Notice that I said deduction of types; this is drastically different from what dynamically typed languages do, and another thing is, it is done at compile time and not runtime. Many languages have this built in, but the implementation varies from one language to another. This might be confusing at the beginning, but it will become clearer with code examples. Let's jump into the Scala REPL for some experimentation.</p>


            </article>

            
        </section>
    

        <section id="181NK1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala REPL</h1>
                
            
            <article>
                
<p class="mce-root">The Scala REPL is a powerful feature that makes it more straightforward and concise to write Scala code on ;the Scala shell. <strong class="calibre1">REPL</strong> stands for <strong class="calibre1">Read-Eval-Print-Loop</strong> also called <strong class="calibre1">the Interactive Interpreter</strong>. This means it is a program for:</p>
<ol class="calibre14">
<li value="1" class="mce-root1">;Reading the expressions you type in.</li>
<li value="2" class="mce-root1">Evaluating the expression in step 1 using the Scala compiler.</li>
<li value="3" class="mce-root1">Printing out the result of the evaluation in step 2.</li>
<li value="4" class="mce-root1">Waiting (looping) for you to enter further expressions.</li>
</ol>
<div class="cdpaligncenter"><img class="image-border7" src="../images/00211.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 8:</strong> Scala REPL example 1</div>
<p class="mce-root">From the figure, it is evident that there is no magic, the variables are inferred automatically to the best types they deem fit at compile time. If you look even more carefully, when I tried to declare: ;</p>
<pre class="calibre19">
 i:Int = "hello"
</pre>
<p class="mce-root">Then, the Scala shell throws an error saying the following:</p>
<pre class="calibre19">
<strong class="calibre1">&lt;console&gt;:11: error: type mismatch;<br class="title-page-name"/>  found   : String("hello")<br class="title-page-name"/>  required: Int<br class="title-page-name"/>        val i:Int = "hello"<br class="title-page-name"/>                    ^</strong>
</pre>
<p class="mce-root">According to Odersky, <em class="calibre8">"Mapping a character to the character map over a RichString should again yield a RichString, as in the following interaction with the Scala REP"</em>. The preceding statement can be proved using the following line of code:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; "abc" map (x =&gt; (x + 1).toChar) </strong><br class="title-page-name"/><strong class="calibre1">res0: String = bcd</strong>
</pre>
<p class="mce-root">However, if someone applies a method from <kbd class="calibre11">Char</kbd> to <kbd class="calibre11">Int</kbd> to a <kbd class="calibre11">String</kbd>, then what happens? In that case, Scala converts them, as a vector of integer also called immutable is a feature of Scala collection, as shown in <em class="calibre8">Figure 9</em>. We will look at the details on Scala collection API in <a href="part0117.html#3FIHQ1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 4</a>, <em class="calibre8">Collections APIs</em>.</p>
<pre class="calibre19">
"abc" map (x =&gt; (x + 1)) <br class="title-page-name"/>res1: scala.collection.immutable.IndexedSeq[Int] = Vector(98, 99, 100)
</pre>
<p class="mce-root">Both static and instance methods of objects are also available. For example, if you declare <kbd class="calibre11">x</kbd> as a string <kbd class="calibre11">hello</kbd> and then try to access both the static and instance methods of objects <kbd class="calibre11">x</kbd>, they are available. In the Scala shell, type <kbd class="calibre11">x</kbd> then <kbd class="calibre11">.</kbd> and <kbd class="calibre11">&lt;tab&gt;</kbd> and then you will find the available methods:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val x = "hello"</strong><br class="title-page-name"/><strong class="calibre1">x: java.lang.String = hello</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; x.re&lt;tab&gt;</strong><br class="title-page-name"/><strong class="calibre1">reduce             reduceRight         replaceAll            reverse</strong><br class="title-page-name"/><strong class="calibre1">reduceLeft         reduceRightOption   replaceAllLiterally   reverseIterator</strong><br class="title-page-name"/><strong class="calibre1">reduceLeftOption   regionMatches       replaceFirst          reverseMap</strong><br class="title-page-name"/><strong class="calibre1">reduceOption       replace             repr</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; </strong>
</pre>
<p class="mce-root">Since this is all accomplished on the fly via reflection, even anonymous classes you've only just defined are equally accessible:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val x = new AnyRef{def helloWord = "Hello, world!"}</strong><br class="title-page-name"/><strong class="calibre1">x: AnyRef{def helloWord: String} = $anon$1@58065f0c</strong><br class="title-page-name"/><strong class="calibre1"> scala&gt; x.helloWord</strong><br class="title-page-name"/><strong class="calibre1">    def helloWord: String</strong><br class="title-page-name"/><strong class="calibre1"> scala&gt; x.helloWord</strong><br class="title-page-name"/><strong class="calibre1"> warning: there was one feature warning; re-run with -feature for details</strong><br class="title-page-name"/><strong class="calibre1"> res0: String = Hello, world!</strong>
</pre>
<p class="mce-root">The preceding two examples can be shown on the Scala shell, as follows:</p>
<div class="cdpaligncenter"><img class="image-border8" src="../images/00232.gif"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 9:</strong> Scala REPL example 2</div>
<div class="book-info-bottom-author-body">"So it turns out that map yields different types depending on what the result type of the passed function argument is!"</div>
<p class="cdpalignright">- Odersky</p>


            </article>

            
        </section>
    

        <section id="190861-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Nested functions</h1>
                
            
            <article>
                
<p class="mce-root">Why will you require a nested functions support in your programming language? Most of the time, we want to maintain our methods to be a few lines and avoid overly large functions. A typical solution for this in Java would be to define all these small functions on a class level, but any other method could easily refer and access them even though they are helper methods. The situation is different in Scala, so you can use define functions inside each other, and this way, prevent any external access to these functions:</p>
<pre class="calibre19">
def sum(vector: List[Int]): Int = {<br class="title-page-name"/>  // Nested helper method (won't be accessed from outside this function<br class="title-page-name"/>  def helper(acc: Int, remaining: List[Int]): Int = remaining match {<br class="title-page-name"/>    case Nil =&gt; acc<br class="title-page-name"/>    case _   =&gt; helper(acc + remaining.head, remaining.tail)<br class="title-page-name"/>  }<br class="title-page-name"/>  // Call the nested method<br class="title-page-name"/>  helper(0, vector)<br class="title-page-name"/>}
</pre>
<p class="mce-root">We are not expecting you to understand these code snippets, which show the difference between Scala and Java.</p>


            </article>

            
        </section>
    

        <section id="19UOO1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Import statements</h1>
                
            
            <article>
                
<p class="mce-root">In Java, you can only import packages at the top of your code file, right after the packages statement. The situation is not the same in Scala; you can write your import statements almost anywhere inside your source file (for example, you can even write your import statements inside a class or a method). You just need to pay attention to the scope of your import statement, because it inherits the same scope of the members of your class or local variables inside your method. The <kbd class="calibre11">_</kbd> (underscore) in Scala is used for wildcard imports, which is similar to the <kbd class="calibre11">*</kbd> (asterisk) that you would use in java:</p>
<pre class="calibre19">
// Import everything from the package math <br class="title-page-name"/>import math._
</pre>
<p class="mce-root">You may also use these <kbd class="calibre11">{ }</kbd> to indicate a set of imports from the same parent package, just in one line of code. In Java, you would use multiple lines of code to do so:</p>
<pre class="calibre19">
// Import math.sin and math.cos<br class="title-page-name"/>import math.{sin, cos}
</pre>
<p class="mce-root">Unlike the Java, Scala does not have the concept of static imports. In other words, the concept of static doesn't exist in Scala. However, as a developer, obviously, you can import a member or more than one member of an object using a regular import statement. The preceding example already shows this, where we import the methods sin and cos from the package object named math. To demonstrate an example, the preceding ;code snippet can be defined from the Java programmer's perspective as follows:</p>
<pre class="calibre19">
import static java.lang.Math.sin;<br class="title-page-name"/>import static java.lang.Math.cos;
</pre>
<p class="mce-root">Another beauty of Scala is that, in Scala, you can rename your imported packages as well. Alternatively, you can rename your imported packages to avoid the type conflicting with packages that have similar members. The following statement is valid in Scala:</p>
<pre class="calibre19">
// Import Scala.collection.mutable.Map as MutableMap <br class="title-page-name"/>import Scala.collection.mutable.{Map =&gt; MutableMap}
</pre>
<p class="mce-root">Finally, you may want to exclude a member of packages for collisions or other purposes. For this, you can use a wildcard to do so:</p>
<pre class="calibre19">
// Import everything from math, but hide cos <br class="title-page-name"/>import math.{cos =&gt; _, _}
</pre>


            </article>

            
        </section>
    

        <section id="1AT9A1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operators as methods</h1>
                
            
            <article>
                
<p class="mce-root">It's worth mentioning that Scala doesn't support the operator overloading. You might think that there are no operators at all in Scala.</p>
<p class="mce-root">An alternative syntax for calling a method taking a single parameter is the use of the infix syntax. The infix syntax provides you with a flavor just like you are applying an operator overloading, as like what you did in C++. For example:</p>
<pre class="calibre19">
val x = 45<br class="title-page-name"/>val y = 75
</pre>
<p class="mce-root">In the following case, the <kbd class="calibre11">+</kbd> ;means a method in class <kbd class="calibre11">Int</kbd>. ; The following ;code is a non-conventional method calling syntax:</p>
<pre class="calibre19">
val add1 = x.+(y)
</pre>
<p class="mce-root">More formally, the same can be done using the infix syntax, as follows:</p>
<pre class="calibre19">
val add2 = x + y
</pre>
<p class="mce-root">Moreover, you can utilize the infix syntax. However, the method has only a single parameter, as follows:</p>
<pre class="calibre19">
val my_result = List(3, 6, 15, 34, 76) contains 5
</pre>
<p class="mce-root">There's one special case when using the infix syntax. That is, if the method name ends with a <kbd class="calibre11">:</kbd> (colon), then the invocation or call will be right associative. This means that the method is called on the right argument with the expression on the left as the argument, instead of the other way around. For example, the following is valid in Scala:</p>
<pre class="calibre19">
val my_list = List(3, 6, 15, 34, 76)
</pre>
<p class="mce-root">The preceding ;statement signifies that: <kbd class="calibre11">my_list.+:(5)</kbd> rather than <kbd class="calibre11">5.+:(my_list)</kbd> and more formally: ;</p>
<pre class="calibre19">
val my_result = 5 +: my_list
</pre>
<p class="mce-root">Now, let's look at the preceding examples on Scala REPL:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val my_list = 5 +: List(3, 6, 15, 34, 76)</strong><br class="title-page-name"/><strong class="calibre1">  my_list: List[Int] = List(5, 3, 6, 15, 34, 76)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; val my_result2 = 5+:my_list</strong><br class="title-page-name"/><strong class="calibre1">  my_result2: List[Int] = List(5, 5, 3, 6, 15, 34, 76)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; println(my_result2)</strong><br class="title-page-name"/><strong class="calibre1">  List(5, 5, 3, 6, 15, 34, 76)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">In addition to the above, operators here are just methods, so that they can simply be overridden just like methods.</p>


            </article>

            
        </section>
    

        <section id="1BRPS1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Methods and parameter lists</h1>
                
            
            <article>
                
<p class="mce-root">In Scala, a method can have multiple parameter lists or even no parameter list at all. On the other hand, in Java, a method always has one parameter list, with zero or more parameters. For example, in Scala, the following is the valid method definition (written in <kbd class="calibre11">currie notation</kbd>) where a method has two parameter lists:</p>
<pre class="calibre19">
def sum(x: Int)(y: Int) = x + y     
</pre>
<p class="mce-root">The preceding ;method cannot be written as:</p>
<pre class="calibre19">
def sum(x: Int, y: Int) = x + y
</pre>
<p class="mce-root">A method, let's say ;<kbd class="calibre11">sum2</kbd>, can have no parameter list at all, as follows:</p>
<pre class="calibre19">
def sum2 = sum(2) _
</pre>
<p class="mce-root">Now, you can call the method <kbd class="calibre11">add2</kbd>, which returns a function taking one parameter. Then, it calls that function with the argument <kbd class="calibre11">5</kbd>, as follows:</p>
<pre class="calibre19">
val result = add2(5)
</pre>


            </article>

            
        </section>
    

        <section id="1CQAE1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Methods inside methods</h1>
                
            
            <article>
                
<p class="mce-root">Sometimes, you would like to make your applications, code modular by avoiding too long and complex methods. Scala provides you this facility to avoid your methods becoming overly large so that you can split them up into several smaller methods.</p>
<p class="mce-root">On the other hand, Java allows you only to have the methods defined at class level. For example, suppose you have the following method definition:</p>
<pre class="calibre19">
def main_method(xs: List[Int]): Int = {<br class="title-page-name"/>  // This is the nested helper/auxiliary method<br class="title-page-name"/>  def auxiliary_method(accu: Int, rest: List[Int]): Int = rest match {<br class="title-page-name"/>    case Nil =&gt; accu<br class="title-page-name"/>    case _   =&gt; auxiliary_method(accu + rest.head, rest.tail)<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, you can call the nested helper/auxiliary method as follows:</p>
<pre class="calibre19">
auxiliary_method(0, xs)
</pre>
<p class="mce-root">Considering the above, here's the complete code segment which is valid:</p>
<pre class="calibre19">
def main_method(xs: List[Int]): Int = {<br class="title-page-name"/>  // This is the nested helper/auxiliary method<br class="title-page-name"/>  def auxiliary_method(accu: Int, rest: List[Int]): Int = rest match {<br class="title-page-name"/>    case Nil =&gt; accu<br class="title-page-name"/>    case _   =&gt; auxiliary_method(accu + rest.head, rest.tail)<br class="title-page-name"/>  }<br class="title-page-name"/>   auxiliary_method(0, xs)<br class="title-page-name"/>}<br class="title-page-name"/> 
</pre>


            </article>

            
        </section>
    

        <section id="1DOR01-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor in Scala</h1>
                
            
            <article>
                
<p class="mce-root">One surprising thing about Scala is that the body of a Scala class is itself a constructor. ; However, Scala does so; in fact, in a more explicit way. After that, a new instance of that class is created and executed. Moreover, you can specify the arguments of the constructor in the class declaration line.</p>
<p class="mce-root">Consequently, the constructor arguments are accessible from all of the methods defined in that class. For example, the following class and constructor definition is valid in Scala:</p>
<pre class="calibre19">
class Hello(name: String) {<br class="title-page-name"/>  // Statement executed as part of the constructor<br class="title-page-name"/>  println("New instance with name: " + name)<br class="title-page-name"/>  // Method which accesses the constructor argument<br class="title-page-name"/>  def sayHello = println("Hello, " + name + "!")<br class="title-page-name"/>}
</pre>
<p class="mce-root">The equivalent Java class would look like this:</p>
<pre class="calibre19">
public class Hello {<br class="title-page-name"/>  private final String name;<br class="title-page-name"/>  public Hello(String name) {<br class="title-page-name"/>    System.out.println("New instance with name: " + name);<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void sayHello() {<br class="title-page-name"/>    System.out.println("Hello, " + name + "!");<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>


            </article>

            
        </section>
    

        <section id="1ENBI1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Objects instead of static methods</h1>
                
            
            <article>
                
<p class="mce-root">As mentioned earlier, static does not exist in Scala. You cannot do static imports and neither can you cannot add static methods to classes. In Scala, when you define an object with the same name as the class and in the same source file, then the object is said to be the companion of that class<em class="calibre8">.</em> Functions that you define in this companion object of a class are like static methods of a class in Java:</p>
<pre class="calibre19">
class HelloCity(CityName: String) {<br class="title-page-name"/>  def sayHelloToCity = println("Hello, " + CityName + "!") <br class="title-page-name"/>}
</pre>
<p class="mce-root">This is how you can define a companion object for the class hello:</p>
<pre class="calibre19">
object HelloCity { <br class="title-page-name"/>  // Factory method <br class="title-page-name"/>  def apply(CityName: String) = new Hello(CityName) <br class="title-page-name"/>}
</pre>
<p class="mce-root">The equivalent class in Java would look like this:</p>
<pre class="calibre19">
public class HelloCity { <br class="title-page-name"/>  private final String CityName; <br class="title-page-name"/>  public HelloCity(String CityName) { <br class="title-page-name"/>    this.CityName = CityName; <br class="title-page-name"/>  }<br class="title-page-name"/>  public void sayHello() {<br class="title-page-name"/>    System.out.println("Hello, " + CityName + "!"); <br class="title-page-name"/>  }<br class="title-page-name"/>  public static HelloCity apply(String CityName) { <br class="title-page-name"/>    return new Hello(CityName); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="mce-root">So, lot's of verbose in this simple class, isn't there? ; The apply method in Scala is treated in a different way, such that you can find a special shortcut syntax to call it. This is the familiar way of calling the method:</p>
<pre class="calibre19">
val hello1 = Hello.apply("Dublin")
</pre>
<p class="mce-root">Here's the shortcut syntax that is equivalent to the one earlier:</p>
<pre class="calibre19">
 val hello2 = Hello("Dublin")
</pre>
<p class="mce-root">Note that this only works if you used the apply method in your code because Scala treats methods that are named apply in this different way.</p>


            </article>

            
        </section>
    

        <section id="1FLS41-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traits</h1>
                
            
            <article>
                
<p class="mce-root">Scala provides a great functionality for you in order to extend and enrich your classes' behaviors. These traits are similar to the interface in which you define the function prototypes or signatures. So, with this, you can have mix-ins of functionality coming from different traits and, in this way, you enriched your classes' behavior. So, what's so good about traits in Scala? They enable the composition of classes from these traits, with traits being the building blocks. As always, let's look at in an example. This is how a conventional logging routine is set up in Java:</p>
<p class="mce-root">Note that, even though you can mix in any number of traits you want. Moreover, like Java, Scala does not have the support of multiple inheritances. However, in both Java and Scala, a subclass can only extend a single superclass. For example, in Java:</p>
<pre class="calibre19">
class SomeClass {<br class="title-page-name"/>  //First, to have to log for a class, you must initialize it<br class="title-page-name"/>  final static Logger log = LoggerFactory.getLogger(this.getClass());<br class="title-page-name"/>  ...<br class="title-page-name"/>  //For logging to be efficient, you must always check, if logging level for current message is enabled                <br class="title-page-name"/>  //BAD, you will waste execution time if the log level is an error, fatal, etc.<br class="title-page-name"/>  log.debug("Some debug message");<br class="title-page-name"/>  ...<br class="title-page-name"/>  //GOOD, it saves execution time for something more useful<br class="title-page-name"/>  if (log.isDebugEnabled()) { log.debug("Some debug message"); }<br class="title-page-name"/>  //BUT looks clunky, and it's tiresome to write this construct every time you want to log something.<br class="title-page-name"/>}
</pre>
<p class="mce-root">For a more detailed discussion, refer to this URL <a href="https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681" class="calibre10">https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681</a>.</p>
<p class="mce-root">However, it's different with traits. It's very tiresome to always check for the log level being enabled. It would be good, if you could write this routine once and reuse it anywhere, in any class right away. Traits in Scala make this all possible. For example:</p>
<pre class="calibre19">
trait Logging {<br class="title-page-name"/>  lazy val log = LoggerFactory.getLogger(this.getClass.getName)     <br class="title-page-name"/>  //Let's start with info level...<br class="title-page-name"/>  ...<br class="title-page-name"/>  //Debug level here...<br class="title-page-name"/>  def debug() {<br class="title-page-name"/>    if (log.isDebugEnabled) log.info(s"${msg}")<br class="title-page-name"/>  }<br class="title-page-name"/>  def debug(msg: =&gt; Any, throwable: =&gt; Throwable) {<br class="title-page-name"/>    if (log.isDebugEnabled) log.info(s"${msg}", throwable)<br class="title-page-name"/>  }<br class="title-page-name"/>  ...<br class="title-page-name"/>  //Repeat it for all log levels you want to use<br class="title-page-name"/>}
</pre>
<p class="mce-root">If you look at the preceding code, you will see an example of using string starting with <kbd class="calibre11">s</kbd>. ; This way, Scala offers the mechanism to create strings from your data called <strong class="calibre1">String Interpolation</strong>. ;</p>
<div class="packt_infobox">String Interpolation, allows you to embed variable references directly in processed string literals. For example:<br class="calibre23"/>
; ; ;<kbd class="calibre22">scala&gt; val name = "John Breslin"</kbd><br class="calibre23"/>
<kbd class="calibre22">; ;scala&gt; println(s"Hello, $name") ; // Hello, John Breslin</kbd>.</div>
<p class="mce-root">Now, we can get an efficient logging routine in a more conventional style as a reusable block. To enable logging for any class, we just mix in our <kbd class="calibre11">Logging</kbd> trait! Fantastic! Now that's all it takes to add a logging feature to your class:</p>
<pre class="calibre19">
class SomeClass extends Logging {<br class="title-page-name"/>  ...<br class="title-page-name"/>  //With logging trait, no need for declaring a logger manually for every class<br class="title-page-name"/>  //And now, your logging routine is either efficient and doesn't litter the code!<br class="title-page-name"/><br class="title-page-name"/>  log.debug("Some debug message")<br class="title-page-name"/>  ...<br class="title-page-name"/>}
</pre>
<p class="mce-root">It is even possible to mix-up multiple traits. For example, for the preceding ;trait (that is, <kbd class="calibre11">Logging</kbd>) you can keep extending in the following ;order:</p>
<pre class="calibre19">
trait Logging  {<br class="title-page-name"/>  override def toString = "Logging "<br class="title-page-name"/>}<br class="title-page-name"/>class A extends Logging  {<br class="title-page-name"/>  override def toString = "A-&gt;" + super.toString<br class="title-page-name"/>}<br class="title-page-name"/>trait B extends Logging  {<br class="title-page-name"/>  override def toString = "B-&gt;" + super.toString<br class="title-page-name"/>}<br class="title-page-name"/>trait C extends Logging  {<br class="title-page-name"/>  override def toString = "C-&gt;" + super.toString<br class="title-page-name"/>}<br class="title-page-name"/>class D extends A with B with C {<br class="title-page-name"/>  override def toString = "D-&gt;" + super.toString<br class="title-page-name"/>}
</pre>
<p class="mce-root">However, it is noted that a Scala class can extend multiple traits at once, but JVM classes can extend only one parent class.</p>
<p class="mce-root">Now, to invoke the above traits and classes, use <kbd class="calibre11">new D()</kbd> from Scala REPL, as shown in the following ;figure:</p>
<div class="cdpaligncenter1"><img class="image-border9" src="../images/00220.gif"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 10</strong>: Mixing multiple traits</div>
<p class="mce-root">Everything has gone smoothly so far in this chapter. Now, let's move to a new section where we will discuss some topics for the beginner who wants to drive themselves into the realm of Scala programming.</p>


            </article>

            
        </section>
    

        <section id="1GKCM1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala for the beginners</h1>
                
            
            <article>
                
<p class="mce-root">In this part, you will find that we assume that you have a basic understanding of any previous programming language. If Scala is your first entry into the coding world, then you will find a large set of materials and even courses online that explain Scala for beginners. As mentioned, there are lots of tutorials, videos, and courses out there.</p>
<div class="packt_tip">There is a whole Specialization, which contains this course, on Coursera: <a href="https://www.coursera.org/specializations/scala" class="calibre21">https://www.coursera.org/specializations/scala</a>. Taught by the creator of Scala, Martin Odersky, this online class takes a somewhat academic approach to teaching the fundamentals of functional programming. You will learn a lot about Scala by solving the programming assignments. Moreover, this specialization includes a course on Apache Spark. Furthermore, Kojo (<a href="http://www.kogics.net/sf:kojo" class="calibre21">http://www.kogics.net/sf:kojo</a>) is an interactive learning environment that uses Scala programming to explore and play with math, art, music, animations, and games.</div>


            </article>

            
        </section>
    

        <section id="1HIT81-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Your first line of code</h1>
                
            
            <article>
                
<p class="mce-root">As a first example, we will use the pretty common <kbd class="calibre11">Hello, world!</kbd> program in order to show you how to use Scala and its tools without knowing much about it. Let's open your favorite editor (this example runs on Windows 7, but can be run similarly on Ubuntu or macOS), say Notepad++, and type the following lines of code:</p>
<pre class="calibre19">
object HelloWorld {<br class="title-page-name"/>  def main(args: Array[String]){ <br class="title-page-name"/>    println("Hello, world!")  <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, save the code with a name, say <kbd class="calibre11">HelloWorld.scala</kbd>, as shown in the following figure: ;</p>
<div class="cdpaligncenter"><img class="image-border10" src="../images/00235.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 11:</strong> Saving your first Scala source code using Notepad++</div>
<p class="mce-root">Let's compile the source file as follows:</p>
<pre class="calibre19">
<strong class="calibre1">C:\&gt;scalac HelloWorld.scala</strong><br class="title-page-name"/><strong class="calibre1"> C:\&gt;scala HelloWorld</strong><br class="title-page-name"/><strong class="calibre1"> Hello, world!</strong><br class="title-page-name"/><strong class="calibre1"> C:\&gt;</strong>
</pre>


            </article>

            
        </section>
    

        <section id="1IHDQ1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">I'm ; the hello world program, explain me well!</h1>
                
            
            <article>
                
<p class="mce-root">The program should be familiar to anyone who has some programming of experience. It has a main method which prints the string <kbd class="calibre11">Hello, world!</kbd> to your console. Next, to see how we defined the <kbd class="calibre11">main</kbd> function, we used the <kbd class="calibre11">def main()</kbd> strange syntax to define it. <kbd class="calibre11">def</kbd> is a Scala keyword to declare/define a method, and we will be covering more about methods and different ways of writing them in the next chapter. So, we have an <kbd class="calibre11">Array[String]</kbd> as an argument for this method, which is an array of strings that can be used for initial configurations of your program, and omit is valid. ;Then, we use the common <kbd class="calibre11">println()</kbd> method, which takes a string (or formatted one) and prints it to the console. A simple hello world has opened up many topics to learn; three in particular:</p>
<p class="mce-root">● ; ; ;Methods (covered in a later chapter)<br class="title-page-name"/>
● ; ; ;Objects and classes (covered in a later chapter)<br class="title-page-name"/>
● ; ; ;Type inference - the reason why Scala is a statically typed language - explained earlier</p>


            </article>

            
        </section>
    

        <section id="1JFUC1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Run Scala interactively!</h1>
                
            
            <article>
                
<p class="mce-root">The <kbd class="calibre11">scala</kbd> command starts the interactive shell for you, where you can interpret Scala expressions interactively:</p>
<pre class="calibre19">
<strong class="calibre1">&gt; scala</strong><br class="title-page-name"/><strong class="calibre1">Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_121).</strong><br class="title-page-name"/><strong class="calibre1">Type in expressions for evaluation. Or try :help.</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; object HelloWorld {</strong><br class="title-page-name"/><strong class="calibre1">   |   def main(args: Array[String]){</strong><br class="title-page-name"/><strong class="calibre1">   |     println("Hello, world!")</strong><br class="title-page-name"/><strong class="calibre1">   |   }</strong><br class="title-page-name"/><strong class="calibre1">   | }</strong><br class="title-page-name"/><strong class="calibre1">defined object HelloWorld</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; HelloWorld.main(Array())</strong><br class="title-page-name"/><strong class="calibre1">Hello, world!</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<div class="packt_infobox">The shortcut <kbd class="calibre22">:q</kbd> stands for the internal shell command <kbd class="calibre22">:quit</kbd>, ;used to exit the interpreter.</div>


            </article>

            
        </section>
    

        <section id="1KEEU1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Compile it!</h1>
                
            
            <article>
                
<p class="mce-root">The <kbd class="calibre11">scalac</kbd> command, which is similar to <kbd class="calibre11">javac</kbd> command, compiles one or more Scala source files and generates a bytecode as output, which then can be executed on any Java Virtual Machine. To compile your hello world object, use the following:</p>
<pre class="calibre19">
<strong class="calibre1">&gt; scalac HelloWorld.scala</strong>
</pre>
<p class="mce-root">By default, <kbd class="calibre11">scalac</kbd> generates the class files into the current working directory. You may specify a different output directory using the <kbd class="calibre11">-d</kbd> option:</p>
<pre class="calibre19">
<strong class="calibre1">&gt; scalac -d classes HelloWorld.scala</strong>
</pre>
<p class="mce-root">However, note that the directory called <kbd class="calibre11">classes</kbd> must be created before executing this command.</p>


            </article>

            
        </section>
    

        <section id="1LCVG1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Execute it with Scala command</h1>
                
            
            <article>
                
<p class="mce-root">The <kbd class="calibre11">scala</kbd> command executes the bytecode that is generated by the interpreter:</p>
<pre class="calibre19">
<strong class="calibre1">$ scala HelloWorld</strong>
</pre>
<p class="mce-root">Scala allows us to specify command options, such as the <kbd class="calibre11">-classpath</kbd> (alias <kbd class="calibre11">-cp</kbd>) option:</p>
<pre class="calibre19">
<strong class="calibre1">$ scala -cp classes HelloWorld</strong>
</pre>
<p class="mce-root">Before using the <kbd class="calibre11">scala</kbd> command to execute your source file(s), you should have a main method that acts as an entry point for your application. Otherwise, you should have an <kbd class="calibre11">Object</kbd> that extends <kbd class="calibre11">Trait Scala.App</kbd>, then all the code inside this object will be executed by the command. The following is the same <kbd class="calibre11">Hello, world!</kbd> ;example, but using the <kbd class="calibre11">App</kbd> trait:</p>
<pre class="calibre19">
#!/usr/bin/env Scala <br class="title-page-name"/>object HelloWorld extends App {  <br class="title-page-name"/>  println("Hello, world!") <br class="title-page-name"/>}<br class="title-page-name"/>HelloWorld.main(args)
</pre>
<p class="mce-root">The preceding ;script can be run directly from the command shell:</p>
<pre class="calibre19">
<strong class="calibre1">./script.sh</strong>
</pre>
<p class="mce-root">Note: we assume here that the file <kbd class="calibre11">script.sh</kbd> has the execute permission: ;</p>
<pre class="calibre19">
<strong class="calibre1">$ sudo chmod +x script.sh</strong>
</pre>
<p class="mce-root">Then, the search path for the <kbd class="calibre11">scala</kbd> command is specified in the <kbd class="calibre11">$PATH</kbd> environment variable.</p>


            </article>

            
        </section>
    

        <section id="1MBG21-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">Throughout this chapter, you have learned the basics of the Scala programming language, its features, and available editor. We have also briefly discussed Scala and its syntax. We demonstrated the installation and setting up guidelines for beginners who are new to Scala programming. Later in the chapter, you learned how to write, compile, and execute a sample Scala code. Moreover, a comparative discussion about Scala and Java provided for those who are from a Java background. Here's a short comparison between Scala and Python:</p>
<p class="mce-root">Scala is statically typed, but Python is dynamically typed. Scala (mostly) embraces the functional programming paradigm, while Python doesn't. Python has a unique syntax that lacks most of the parentheses, while Scala (almost) always requires them. In Scala, almost everything is an expression; while this isn't true in Python. However, there are a few points on the upside that are seemingly convoluted. The type complexity is mostly optional. Secondly, according to the documentation provided by <a href="https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684" class="calibre10">https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684</a>, ; <em class="calibre8">Scala compiler is like free testing and documentation as cyclomatic complexity and lines of code escalate. When aptly implemented Scala can perform otherwise all but impossible operations behind consistent and coherent APIs.</em></p>
<p class="mce-root">In next the chapter, we will discuss ;how to improve our experience on the basics to know how Scala implements the object oriented paradigm to allow building modular software systems.</p>


            </article>

            
        </section>
    </body></html>