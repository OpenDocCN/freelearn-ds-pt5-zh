<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Parallel and Concurrent Design</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the Haskell Runtime System (RTS) options</li><li class="listitem" style="list-style-type: disc">Evaluating a procedure in parallel</li><li class="listitem" style="list-style-type: disc">Controlling parallel algorithms in sequence</li><li class="listitem" style="list-style-type: disc">Forking I/O actions for concurrency</li><li class="listitem" style="list-style-type: disc">Communicating with a forked I/O action</li><li class="listitem" style="list-style-type: disc">Killing forked threads</li><li class="listitem" style="list-style-type: disc">Parallelizing pure functions using the Par monad</li><li class="listitem" style="list-style-type: disc">Mapping over a list in parallel</li><li class="listitem" style="list-style-type: disc">Accessing tuple elements in parallel</li><li class="listitem" style="list-style-type: disc">Implementing MapReduce to count word frequencies</li><li class="listitem" style="list-style-type: disc">Manipulating images in parallel using Repa</li><li class="listitem" style="list-style-type: disc">Benchmarking runtime performance in Haskell</li><li class="listitem" style="list-style-type: disc">Using the criterion package to measure performance</li><li class="listitem" style="list-style-type: disc">Benchmarking runtime performance in the terminal</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec110"/>Introduction</h1></div></div></div><div><img src="img/ch09.jpg" alt="Introduction"/></div><p>One of the greatest accomplishments in the study of data analysis is the intelligent approach to parallel and concurrent design. As we collect more and more data, we are able to discover more and more patterns. However, this comes at a price of time and space. More data may take more time to compute or more space in terms of memory. It is a very real problem that this chapter will try to solve.</p><p>The first few recipes will cover how to evoke pure procedures in parallel and in sequence. The following recipes on forking will deal with concurrency using I/O actions. We will then delve deeper by learning how to access a list and tuple elements in parallel. Then, we will implement MapReduce in Haskell to solve a time-consuming problem efficiently.</p><p>We will end the review of parallel and concurrent design by learning how to benchmark runtime performance. Sometimes, the easiest way to discover if code is successfully running in parallel is by timing it against a nonparallel version of the code. If the computation time between the two appears to be the same, then it is very likely that something is wrong. Either the code is not running in parallel or the cost of evoking parallelism outweighs the benefits.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec111"/>Using the Haskell Runtime System options</h1></div></div></div><p>The <a id="id531" class="indexterm"/>
<strong>Runtime System</strong> (<strong>RTS</strong>) in <a id="id532" class="indexterm"/>Haskell configures special options such as scheduling, profiling, and managing storage for a compiled Haskell program. In order to write multithreaded code, we must specify our own RTS options as outlined in this recipe.</p><p>For further reading, the GHC Commentary on the official<a id="id533" class="indexterm"/> Haskell Wiki web page has a very detailed explanation of the runtime system available at <a class="ulink" href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts">https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts</a>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec306"/>How to do it…</h2></div></div></div><p>Open a<a id="id534" class="indexterm"/> terminal, compile a code, and run it using the RTS option. Imagine that our file is named <code class="literal">Main.hs</code>, and issue the following commands:</p><div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded -rtsopts </strong>
<strong>$ ./Main  +RTS -N2</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec307"/>How it works…</h2></div></div></div><p>In order to make use of multiple threads, we must compile our code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled.</p><p>Now that it is compiled with <code class="literal">rtsopts</code>, we can run our program with special instructions placed between the <code class="literal">+RTS</code> and <code class="literal">-RTS</code> flags. If there is a <code class="literal">+RTS</code> flag without a <code class="literal">–RTS</code> flag, then we assume that the RTS options continue until the end of the line.</p><p>We set the number of threads to use by placing <code class="literal">-Nx</code> within the RTS argument, which stands for "use x threads". So, to use two threads, we should type <em>-N2</em>. To use all possible threads, we simply type <em>-N</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec308"/>There's more…</h2></div></div></div><p>Another way to specify the RTS options is during compile time, using the <code class="literal">--with-rtsopts</code> flag. More advanced methods include modifying environment variables or overriding runtime system hooks. More information on these can be found on the official Haskell user guide available at <a class="ulink" href="https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html">https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec112"/>Evaluating a procedure in parallel</h1></div></div></div><p>In this recipe, we will <a id="id535" class="indexterm"/>conduct two time-consuming tasks in parallel. We will use the <code class="literal">rpar</code> function provided by the <code class="literal">parallel</code> package from hackage. The <code class="literal">rpar</code> function annotates<a id="id536" class="indexterm"/> its argument to be evaluated in parallel. Then, we call <a id="id537" class="indexterm"/>
<code class="literal">runEval</code> to actually perform the computation.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec309"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">parallel</code> package<a id="id538" class="indexterm"/> using cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install parallel</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec310"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the parallel package as follows:<div><pre class="programlisting">import Control.Parallel.Strategies (runEval, rpar)</pre></div></li><li class="listitem">Evaluate <a id="id539" class="indexterm"/>two tasks in parallel, and wait for both tasks to finish before returning as seen in the following code snippet:<div><pre class="programlisting">main = do
  print $ runEval $ do
    a &lt;- rpar task1
    b &lt;- rpar task2
    return (a, b)</pre></div></li><li class="listitem">A time-consuming task can be created as follows:<div><pre class="programlisting">task1 = 8^8^9 :: Integer</pre></div></li><li class="listitem">Another time-consuming task can be created as follows:<div><pre class="programlisting">task2 = 8^8^8 :: Integer</pre></div></li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled, as follows:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded –rtsopts</strong>
</pre></div></li><li class="listitem">Run it by specifying the number of cores:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>
</pre></div></li></ol></div><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>The time-consuming calculations (<code class="literal">task1</code> and <code class="literal">task2</code>) in this recipe require a huge amount of memory and may exceed the limitations of the machine in use. Adjust the tasks to be more manageable, such as 4^8^9 or 4^8^8. In this recipe, specifically, the overhead cost of parallelizing these simple mathematical calculations may be greater than the benefits.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec311"/>How it works…</h2></div></div></div><p>Time-consuming functions<a id="id540" class="indexterm"/> are annotated with <code class="literal">rpar</code>, which suggests that the computation should occur in parallel. Once <code class="literal">runEval</code> is applied, the sparked code runs in parallel. Future parts of the code can continue with the execution until the output of these parallel-running threads are needed.</p><p>In our recipe, we run <code class="literal">task1</code> and <code class="literal">task2</code> in parallel. We immediately return the result to be used in future parts of the code, and the code only waits for the tasks to complete once necessary. The computation is being processed in the background until it is needed later.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec312"/>See also</h2></div></div></div><p>To explore examples of using a sequence in a parallel design, refer to the <em>Controlling parallel algorithms in sequence</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec113"/>Controlling parallel algorithms in sequence</h1></div></div></div><p>In this recipe, we <a id="id541" class="indexterm"/>will conduct two time-consuming tasks in parallel. We will use the <code class="literal">rpar</code> function and the <code class="literal">rseq</code> function provided by the <code class="literal">parallel</code> package from hackage. The <code class="literal">rpar</code> function annotates its argument to be evaluated in parallel. The other<a id="id542" class="indexterm"/> function, <code class="literal">rseq</code>, forces sequential evaluations in what is called the <a id="id543" class="indexterm"/>
<strong>weak head normal form</strong>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec313"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">parallel</code> package using cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install parallel</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec314"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the parallel package as follows:<div><pre class="programlisting">import Control.Parallel
import Control.Parallel.Strategies
Evaluate two tasks in parallel, and wait for both tasks to finish before returning.
main = do
  print $ runEval $ do
    a &lt;- rpar task1
    b &lt;- rpar task2
    rseq a
    rseq b
    return (a, b)</pre></div></li><li class="listitem">Perform a time-consuming task as follows:<div><pre class="programlisting">task1 = 8^8^9 :: Integer</pre></div></li><li class="listitem">Perform another time-consuming task as follows:<div><pre class="programlisting">task2 = 8^8^8 :: Integer</pre></div></li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled as follows:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded –rtsopts</strong>
</pre></div></li><li class="listitem">Run it by specifying the number of cores as follows:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec315"/>How it works…</h2></div></div></div><p>Time-consuming functions <a id="id544" class="indexterm"/>are annotated with <code class="literal">rpar</code> or <code class="literal">rseq</code>, which describe whether a computation should happen in parallel or in a sequence. If a function is sparked to be run in parallel, then future parts of the code can be made to run until that value is needed. In that case, the code blocks until the parallel operation is complete. If a function is required to be in sequence, the code will wait until the function has computed a result, and only then will it move on.</p><p>In our recipe, we run <code class="literal">task1</code> and <code class="literal">task2</code> in parallel. We then run<code class="literal"> rseq</code> on the values to demonstrate the concept of sequencing. The first time we call <code class="literal">rseq</code>, we are forcing the code to wait until <code class="literal">task1</code>, which is represented by the variable <code class="literal">a</code>, is complete. Depending on the parallel design of the algorithm, it may not be necessary to sequence it at all. We also force <code class="literal">task2</code>, which is represented by the variable <code class="literal">b</code>, to wait until the value is calculated just to demonstrate how sequencing works.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec316"/>See also</h2></div></div></div><p>To see an example of only parallel design without sequencing, refer to the <em>Evaluating a procedure in parallel</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec114"/>Forking I/O actions for concurrency</h1></div></div></div><p>A quick and easy way <a id="id545" class="indexterm"/>to launch an I/O type function in the background is by calling the <code class="literal">forkIO</code> function provided by the <code class="literal">Control.Concurrent</code> package. In this recipe, we will demonstrate simple input/output concurrently in Haskell. We will get the number of seconds to wait from the user input, and in the background, it will sleep and print a message once the thread wakes up.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec317"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the built-in concurrency package as follows:<div><pre class="programlisting">import Control.Concurrent (forkIO, threadDelay)</pre></div></li><li class="listitem">Ask the user the number of seconds the program has to sleep for. Then, sleep for that many seconds by calling our <code class="literal">sleep</code> function defined in the following code snippet. Finally, recursively call <code class="literal">main</code> again to demonstrate that the user can continue to input while a thread is running in the background:<div><pre class="programlisting">main = do
  putStr "Enter number of seconds to sleep: "
  time &lt;- fmap (read :: String -&gt; Int) getLine
  forkIO $ sleep time
  main</pre></div></li><li class="listitem">Define a function that takes in the number of seconds to sleep, and apply <code class="literal">threadDelay :: Int -&gt; IO ()</code> to that value as follows:<div><pre class="programlisting">sleep :: Int -&gt; IO ()
sleep t = do
  let micro = t * 1000000
  threadDelay micro
  putStrLn $ "[Just woke up after " 
              ++ show t ++ " seconds]"</pre></div></li><li class="listitem">When we run the program, we can quickly input multiple numbers before receiving an output as follows:<div><pre class="programlisting">
<strong>$ ghci Main.hs</strong>

<strong>Prelude&gt; main</strong>

<strong>Prelude&gt; Enter number of seconds to sleep: 3</strong>

<strong>Prelude&gt; Enter number of seconds to sleep: 2</strong>

<strong>Prelude&gt; Enter number of seconds to sleep: [Just woke up after 2 seconds]</strong>

<strong>[Just woke up after 3 seconds]</strong>
</pre></div></li></ol></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The <code class="literal">print</code> and <code class="literal">putrStrLn</code> functions are not atomic, so you may also get interleaved output.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec318"/>See also</h2></div></div></div><p>To send data to a forked action, refer to the <em>Communicating with a forked I/O action</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec115"/>Communicating with a forked I/O action</h1></div></div></div><p>A quick and easy way to <a id="id546" class="indexterm"/>launch an I/O type function in the background is by calling the <code class="literal">forkIO</code> function provided by the <code class="literal">Control.Concurrent</code> package. In this recipe, we will be communicating with forked I/O actions by sending messages using a variable type called <a id="id547" class="indexterm"/>
<code class="literal">MVar</code>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec319"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">HTTP</code> package from cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install HTTP</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec320"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant packages as follows:<div><pre class="programlisting">import Network.HTTP
import Control.Concurrent</pre></div></li><li class="listitem">Create a new variable that will be used by the fork process. The <code class="literal">newEmptyMVar</code> function<a id="id548" class="indexterm"/> is of the <code class="literal">IO (MVar a)</code> type, so we will extract the expression out and label it <code class="literal">m</code> as follows:<div><pre class="programlisting">main = do
  m &lt;- newEmptyMVar
  forkIO $ process m</pre></div></li><li class="listitem">After running the fork, send it some data by calling <code class="literal">putMVar :: MVar a -&gt; a -&gt; IO ()</code>, as shown in the following lines of code. The variable will hold the given value, and the forked process waiting on that data will resume:<div><pre class="programlisting">  putStrLn "sending first website..."
  putMVar m "http://www.haskell.com"</pre></div></li><li class="listitem">We can reuse the expression and send it more data as follows:<div><pre class="programlisting">  putStrLn "sending second website..."
  putMVar m "http://www.gnu.org"</pre></div></li><li class="listitem">To make sure <code class="literal">main</code> does not terminate before the forked process is finished, we just<a id="id549" class="indexterm"/> force <code class="literal">main</code> to wait for 10 seconds by calling the<a id="id550" class="indexterm"/> <code class="literal">threadDelay</code> function. This is for demonstration purposes only, and a complete solution should terminate <code class="literal">main</code> immediately once the fork is complete, as presented in the following code snippet:<div><pre class="programlisting">  threadDelay $ 10 * 1000000</pre></div></li><li class="listitem">Define the code that will be forked to run in parallel as follows:<div><pre class="programlisting">process m = do 
  putStrLn "waiting..."
  v &lt;- takeMVar m
  resp &lt;- get v
  putStrLn $ "response from " ++ show v ++ " is " ++ resp
  process m</pre></div></li><li class="listitem">Create a function to perform an HTTP GET request on a URL as follows:<div><pre class="programlisting">get :: String -&gt; IO String
get url = do
   resp &lt;- simpleHTTP (getRequest url)
   body &lt;- getResponseBody resp
   return $ take 10 body</pre></div></li><li class="listitem">The output of the program will then be as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>


<strong>sending first website...</strong>
<strong>sending second website...</strong>
<strong>waiting...</strong>
<strong>waiting...</strong>
<strong>response from "http://www.haskell.com" is </strong>

<strong>&lt;!doctype html&gt;</strong>
<strong>&lt;html class="no-js" lang="en"&gt;</strong>
<strong>&lt;head id="ctl00_Head1"&gt;&lt;meta http-equiv="X-UA-C</strong>

<strong>response from "http://www.gnu.org" is </strong>

<strong>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</strong>
<strong>    "http://www.w3.org/TR/xhtml1/DTD/xhtml1</strong>
<strong>waiting...</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec321"/>See also</h2></div></div></div><p>To see a simpler example of using <code class="literal">forkIO</code>, refer to the <em>Forking I/O actions for concurrency</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec116"/>Killing forked threads</h1></div></div></div><p>When we create a<a id="id551" class="indexterm"/> new thread, we can keep track of its corresponding thread ID to kill it later manually.</p><p>In this recipe, we will be creating a command-line interface for forking new processes to download a huge file. A download will be initiated with the <code class="literal">d</code> command followed by a number. So, running <code class="literal">d 1</code> will launch a thread to download item #1.</p><p>We will learn how to kill threads while they are still running. Our command to kill threads will look like <code class="literal">k 1</code> in order to kill the downloaded item #1.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec322"/>How to do it…</h2></div></div></div><p>In a new file, which we call <code class="literal">Main.hs</code>, insert the following code:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the required packages as follows:<div><pre class="programlisting">import Control.Concurrent
import qualified Data.Map as M</pre></div></li><li class="listitem">Let <code class="literal">main</code> call the helper <code class="literal">download</code> function:<div><pre class="programlisting">main = download (M.empty :: M.Map Int [ThreadId])</pre></div></li><li class="listitem">Define a function to take the user queries and appropriately respond as follows:<div><pre class="programlisting">download m = do
  input &lt;- (getLine &gt;&gt;= return . words)
  respond m input &gt;&gt;= download</pre></div></li><li class="listitem">Respond to a download request:<div><pre class="programlisting">respond m ["d", nstr] = do
  putStrLn "Starting download..."
  let n = read nstr :: Int
  threadId &lt;- forkIO $ massiveDownload n
  return $ M.insertWith (++) n [threadId] m</pre></div></li><li class="listitem">Respond to a kill request:<div><pre class="programlisting">respond m ["k", nstr] = do
  let n = read nstr :: Int
  case (M.lookup n m) of
    Just threads -&gt; do 
      putStrLn "Killing download(s)..."
      mapM_ killThread threads
      download $ M.delete n m
    Nothing -&gt; do
      putStrLn "No such download"
      download m</pre></div></li><li class="listitem">Respond to an invalid request:<div><pre class="programlisting">respond m _ = do
  putStrLn 
      "Type `d #` to start a download or `k #` to kill it."
  return m</pre></div></li><li class="listitem">Pretend to download a huge file as follows:<div><pre class="programlisting">massiveDownload n = do
  threadDelay $ 10 * 1000000
  putStrLn $ "[Download " ++ (show n) ++" complete!]"</pre></div></li><li class="listitem">Run the<a id="id552" class="indexterm"/> code and evoke a couple of downloads and kill commands as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
<strong>d 1</strong>
<strong>Starting download...</strong>
<strong>d 2</strong>
<strong>Starting download...</strong>
<strong>d 3</strong>
<strong>Starting download...</strong>
<strong>k 1</strong>
<strong>Killing download(s)...</strong>
<strong>[Download 2 complete!]</strong>
<strong>[Download 3 complete!]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec323"/>How it works...</h2></div></div></div><p>The program keeps track of a mapping from the download number to thread IDs. Whenever a new download is initiated, we insert the corresponding thread ID to the map. To kill a thread, we call <code class="literal">killThread</code><a id="id553" class="indexterm"/> on the respective thread ID.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec117"/>Parallelizing pure functions using the Par monad</h1></div></div></div><p>The Par monad <a id="id554" class="indexterm"/>from the <code class="literal">Control.Monad.Par</code> package is used to speed <a id="id555" class="indexterm"/>up pure<a id="id556" class="indexterm"/> functions using parallel threads. Information flow is guided by variables called<a id="id557" class="indexterm"/> <code class="literal">IVar</code>. We can <code class="literal">put</code> values to <code class="literal">IVar</code> in parallel or <code class="literal">get</code> values from it.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec324"/>Getting ready</h2></div></div></div><p>Install the Par monad on cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install monad-par</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec325"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the Par monad as follows:<div><pre class="programlisting">import Control.Monad.Par</pre></div></li><li class="listitem">Run a computation in parallel, and perform some interesting function such as counting the number of digits and printing it out.<div><pre class="programlisting">main = print $ length $ show $ runPar mypar</pre></div></li><li class="listitem">Define an I/O type action as follows:<div><pre class="programlisting">mypar = do 
  v1 &lt;- new :: Par (IVar Integer)
  v2 &lt;- new :: Par (IVar Integer)
  fork $ put v1 task1
  fork $ put v2 task2
  v1' &lt;- get v1
  v2' &lt;- get v2
  return (v1' + v2')  </pre></div></li><li class="listitem">Perform a time-consuming task as follows:<div><pre class="programlisting">task1 = 8^8^8</pre></div></li><li class="listitem">Perform another time-consuming task as follows:<div><pre class="programlisting">task2 = 8^8^7</pre></div></li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled, using the following command:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded –rtsopts</strong>
</pre></div></li><li class="listitem">Run it by specifying the number of cores as follows:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>

<strong>15151337</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec326"/>There's more…</h2></div></div></div><p>The natural nonparallelized version of the code certainly looks cleaner. In the following example, we see the same principle at work mathematically as the previous example but without the use of monads. However, we no longer have the power of concurrency:</p><div><pre class="programlisting">import Control.Monad.Par

main = print $ length $ show $ task1 + task2

task1 = 8^8^8
task2 = 8^8^8</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec327"/>See also</h2></div></div></div><p>For dealing with computations that use I/O, refer to the <em>Forking I/O actions for concurrency</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec118"/>Mapping over a list in parallel</h1></div></div></div><p>In this recipe, we will be <a id="id558" class="indexterm"/>applying the map function in parallel. Given a list of values, we will be using multiple threads to apply a function over each value.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec328"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the parallel strategies as follows:<div><pre class="programlisting">import Control.Parallel.Strategies</pre></div></li><li class="listitem">Map over a list using the <code class="literal">rdeepseq</code> strategy using the following code snippet:<div><pre class="programlisting">main = do
  let results = 
            (parMap rdeepseq (^10) [10^10..10^10+10000]) :: [Int]
  print results</pre></div></li><li class="listitem">The first few characters of the printed output are shown here after compiling and running the code as follows:</li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled as follows:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded -rtsopts</strong>
</pre></div></li><li class="listitem">Run the code by specifying the number of cores as follows:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>

<strong>[0,3644720378636855297,1420199564594381824,-9091195533231350103,-3969065814844243968,5699158338132413177,5185631055696798720,-1664423011715345679,-5301432476323807232,-6822228826283293807,-3978116359327587328,-2988467747382449959,669511447655481344,2530383018990005705,-7998143102955305984,  ...</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec329"/>How it works…</h2></div></div></div><p>The <code class="literal">parMap</code> function<a id="id559" class="indexterm"/> has the type <code class="literal">Strategy b -&gt; (a -&gt; b) -&gt; [a] -&gt; [b]</code>. It looks exactly like the type signature of the map function, except that it takes in something called Strategy. A <strong>Strategy</strong><a id="id560" class="indexterm"/> decouples the method of parallelism from the implementation of code. An example of a Strategy is <code class="literal">rdeepseq</code>, which fully evaluates its argument. For example, Haskell is <a id="id561" class="indexterm"/>lazy evaluated, so the code <code class="literal">length [5^5^5, 6^6^6]</code> will not evaluate the value of <code class="literal">5^5^5</code> or <code class="literal">6^6^6</code>. We can use the <code class="literal">rdeepseq</code> example to better control what computations should be evaluated when run in parallel.</p><p>In contrast, a slow and simple version of the code is shown as follows:</p><div><pre class="programlisting">main = do
  print $ map (^10) [10^10..10^10+10000]</pre></div><p>Try timing the runtime to see the significant differences in using multiple threads.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec330"/>There's more…</h2></div></div></div><p>There are many Strategies depending on how the parallelism should be evoked, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">r0</code> is the simplest <a id="id562" class="indexterm"/>Strategy that simply does not evaluate the expression</li><li class="listitem" style="list-style-type: disc"><code class="literal">dot</code> is used to<a id="id563" class="indexterm"/> compose two Strategies together for finer control in more complicated expressions</li><li class="listitem" style="list-style-type: disc"><code class="literal">rseq</code> will <a id="id564" class="indexterm"/>immediately evaluate the expression</li><li class="listitem" style="list-style-type: disc"><code class="literal">rpar</code> will annotate<a id="id565" class="indexterm"/> the expression to be evaluated in parallel</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec331"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If dealing with tuples, refer to the <em>Accessing tuple elements in parallel</em> recipe</li><li class="listitem" style="list-style-type: disc">For more details on timing code, refer to the <em>Benchmarking runtime performance in Haskell</em> recipe or the <em>Benchmarking runtime performance in the terminal</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec119"/>Accessing tuple elements in parallel</h1></div></div></div><p>In this recipe, we will <a id="id566" class="indexterm"/>cover how to access elements of a tuple in parallel.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec332"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the built-in package as follows:<div><pre class="programlisting">import Control.Parallel.Strategies</pre></div></li><li class="listitem">Evaluate the expression in a tuple in parallel. We perform this task twice with different strategies to demonstrate how strategies are easily swapped to change the parallel nature of the code as follows:<div><pre class="programlisting">main = do
  let (a, b) = withStrategy (parTuple2 rseq rseq) (task1, task2)
  print $ seq (a+b) "done 1"
  let (a, bs) = withStrategy (parTuple2 rseq rdeepseq) (task1, tasks)
  print $ seq (a + sum bs) "done 2"</pre></div></li><li class="listitem">Define time-consuming tasks as follows:<div><pre class="programlisting">task1 = 8^8^8 :: Integer
task2 = 8^8^8 :: Integer
tasks = [10^10..10^10+10000] :: [Integer]</pre></div></li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled, as follows:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded -rtsopts</strong>
</pre></div></li><li class="listitem">Run it by specifying the number of cores as follows:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec333"/>There's more…</h2></div></div></div><p>When dealing with tuples of more than two elements, other helper methods exist such as <code class="literal">parTuple3</code>, <code class="literal">parTuple4</code>, <code class="literal">parTuple5</code>, <code class="literal">parTuple6</code>, <code class="literal">parTuple7</code>, <code class="literal">parTuple8</code>, and <code class="literal">parTuple9</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec334"/>See also</h2></div></div></div><p>If dealing with lists, refer to the <em>Mapping over a list in parallel</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec120"/>Implementing MapReduce to count word frequencies</h1></div></div></div><p>MapReduce is a<a id="id567" class="indexterm"/> framework for efficient parallel algorithms that take advantage of divide and conquer. If a task can be split into smaller tasks, and the results of each individual task can be combined to form the final answer, then MapReduce is likely the best framework for this job.</p><p>In the following figure, we can see that a large list is split up, and the mapper functions work in parallel on each split. After all the mapping is complete, the second phase of the framework kicks in, reducing the various calculations into one final answer.</p><p>In this recipe, we will be counting<a id="id568" class="indexterm"/> word frequencies<a id="id569" class="indexterm"/> in a large corpus of text. Given many files of words, we will apply the MapReduce framework to find the word frequencies in parallel.</p><div><img src="img/6331OS_09_01.jpg" alt="Implementing MapReduce to count word frequencies"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec335"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">parallel</code> package using cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install parallel</strong>
</pre></div><p>Create multiple files with words. In this recipe, we download a huge text file and split it up using the UNIX <code class="literal">split</code> command as follows:</p><div><pre class="programlisting">
<strong>$ wget norvig.com/big.txt</strong>

<strong>$ split –d big.txt words</strong>

<strong>$ ls words*</strong>
<strong>words00</strong>
<strong>words01</strong>
<strong>words02</strong>
<strong>words03</strong>
<strong>…</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec336"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the<a id="id570" class="indexterm"/> relevant packages as follows:<div><pre class="programlisting">import Data.List (sort, group, sortBy, groupBy, isPrefixOf)
import Control.Parallel
import Control.Parallel.Strategies
import Data.Char (isAlpha, isSpace, toLower)
import Data.Map (Map, insertWith, empty, toList)
import System.Directory
import qualified Data.Map as M</pre></div></li><li class="listitem">Define <a id="id571" class="indexterm"/>the MapReduce logic. The mapping functions should all occur before the reducing logic as follows:<div><pre class="programlisting">mapReduce :: Strategy b -&gt; (a -&gt; b) -&gt; 
Strategy b -&gt; ([b] -&gt; b) -&gt; [a] -&gt; b
mapReduce mStrategy m rStrategy r input = 
  mOutput `pseq` rOutput
  where mOutput = parMap mStrategy m input
        rOutput = r mOutput `using` rStrategy</pre></div></li><li class="listitem">Define the <code class="literal">mapper</code> function to count the frequency of words as follows:<div><pre class="programlisting">mapper :: String -&gt; [(String,Int)] 
mapper str = freqCount $ getWords str</pre></div></li><li class="listitem">Count the number of times a word occurs in a string as follows:<div><pre class="programlisting">      freqCount :: [String] -&gt; [(String, Int)]
      freqCount xs = 
        map (\x -&gt; (head x, length x)) . group . sort $ xs</pre></div></li><li class="listitem">Get the words out of an arbitrary corpus of characters as follows:<div><pre class="programlisting">getWords :: String -&gt; [String]
getWords str = words $ filter 
                     (\x -&gt; isAlpha x || isSpace x) lower
  where lower = map toLower str</pre></div></li><li class="listitem">Reduce the list of word frequencies into one final answer as follows:<div><pre class="programlisting">reducer :: [[(String,Int)]] -&gt; [(String,Int)]
reducer ls = toList $ 
             foldl (\m (k, v) -&gt; insertWith (+) k v m) 
                   (empty :: Map String Int) 
                   (concat ls)</pre></div></li><li class="listitem">Set up the <a id="id572" class="indexterm"/>MapReduce problem and run it:<div><pre class="programlisting">main = do       
        files &lt;- getCurrentDirectory &gt;&gt;= getDirectoryContents
        let myFiles = filter ("words `isPrefixOf`) files
           rawFileData &lt;- mapM readFile myFiles
           let freqMap = mapReduce (rpar `dot` rdeepseq) 
                                mapper rseq reducer fawFileData
        putStrLn $ "Found " ++ (show.length) freqMap ++ " words!"
        queryInput freqMap</pre></div></li><li class="listitem">Ask to<a id="id573" class="indexterm"/> use input, and then display the frequency of each word entered:<div><pre class="programlisting">queryInput freqMap = do
  putStrLn "Enter a sentence: "
  sentence &lt;- readLine
  let freqs = map (`lookup` freqMap) (words sentence)
  print $ zip (words sentence) freqs
  queryInput freqMap</pre></div></li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled, as follows:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded -rtsopts</strong>
</pre></div></li><li class="listitem">Run it by specifying the number of cores as follows:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>
<strong>Found 35537 words!</strong>
<strong>Enter a sentence:</strong>
<strong>no one who is young is ever going to be old</strong>
<strong>[ ("no",Just 2328)</strong>
<strong>, ("one",Just 3215)</strong>
<strong>, ("who",Just 2994)</strong>
<strong>, ("is",Just 9731)</strong>
<strong>, ("young",Just 624)</strong>
<strong>, ("is",Just 9731)</strong>
<strong>, ("ever",Just 254)</strong>
<strong>, ("going",Just 369)</strong>
<strong>, ("to",Just 28614)</strong>
<strong>, ("be",Just 6148)</strong>
<strong>, ("old",Just 1138) ]</strong>
</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec121"/>Manipulating images in parallel using Repa</h1></div></div></div><p>Repa is a powerful library for manipulating high-dimensional arrays in parallel. We will use it to read and edit the pixels of an image.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec337"/>Getting ready</h2></div></div></div><p>Install <strong>Developer's Image Library</strong> (<strong>DevIL</strong>), a <a id="id574" class="indexterm"/>cross-platform image manipulation toolkit. It can<a id="id575" class="indexterm"/> be downloaded from <a class="ulink" href="http://openil.sourceforge.net/download.php">http://openil.sourceforge.net/download.php</a> or through <code class="literal">apt-get</code> on Debian systems as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install libdevil-dev</strong>
</pre></div><p>Install the <a id="id576" class="indexterm"/>Repa package from cabal for the DevIL toolkit as follows:</p><div><pre class="programlisting">
<strong>$ cabal install repa-devil</strong>
</pre></div><p>Create two images named <code class="literal">image1.png</code> and <code class="literal">image2.png</code> that have the same dimensions, which are shown as follows:</p><div><img src="img/6331OS_09_02.jpg" alt="Getting ready"/></div><p>Here <a id="id577" class="indexterm"/>comes<a id="id578" class="indexterm"/> the second image:</p><div><img src="img/6331OS_09_03.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec338"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import<a id="id579" class="indexterm"/> the<a id="id580" class="indexterm"/> following libraries as follows:<div><pre class="programlisting">import System.Environment (getArgs)
import Data.Word (Word8)
import qualified Data.Array.Repa as R
import Data.Array.Repa hiding ((++))
import Data.Array.Repa.IO.DevIL (runIL, readImage, 
  writeImage, IL, Image(RGB))
import Data.Array.Repa.Repr.ForeignPtr (F)</pre></div></li><li class="listitem">Read the <a id="id581" class="indexterm"/>images, process them, and produce an output image as follows:<div><pre class="programlisting">main = do
  let image1 = "image1.png"
  let image2 = "image2.png"
  runIL $ do
    (RGB a) &lt;- readImage image1
    (RGB b) &lt;- readImage image2
    imageOut &lt;- (computeP $ intersect a b) 
                                 :: IL (Array F DIM3 Word8)
    writeImage ("output.png") (RGB imageOut)</pre></div></li><li class="listitem">Create the <a id="id582" class="indexterm"/>helper function to process the images as follows:<div><pre class="programlisting">intersect :: Array F DIM3 Word8 -&gt; 
             Array F DIM3 Word8 -&gt; 
             Array D DIM3 Word8
intersect a b = R.zipWith (\w1 w2 -&gt; merge w1 w2) a b
  where merge w1 w2 = if w1 == w2 then 0 else 255</pre></div></li><li class="listitem">Compile the code with the <code class="literal">threaded</code> and <code class="literal">rtsopts</code> flags enabled, as follows:<div><pre class="programlisting">
<strong>$ ghc -O2 --make Main.hs -threaded -rtsopts</strong>
</pre></div></li><li class="listitem">Run it by specifying the number of cores, as follows:<div><pre class="programlisting">
<strong>$ ./Main +RTS -N2</strong>
</pre></div></li></ol></div><p>The output is as follows:</p><div><img src="img/6331OS_09_04.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec339"/>How it works…</h2></div></div></div><p>The images are read as three-dimensional Repa arrays of pixels, where each pixel is represented by a Word8. The first two dimensions index the images by width and height, and the last dimension selects the color channel (red, green, blue, or alpha).</p><p>We run the <code class="literal">zipWith</code> function provided by Repa to combine two images into one with our intersect/merge rule. In order to actually run this process efficiently in parallel, we must call the <code class="literal">computeP</code> function.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec122"/>Benchmarking runtime performance in Haskell</h1></div></div></div><p>Benchmarking runtime is the process<a id="id583" class="indexterm"/> of timing how long it takes for the code to run. We<a id="id584" class="indexterm"/> can understand whether our parallel or concurrent code is in fact faster than the naive implementation by proper benchmarking. This recipe will demonstrate how to time code runtime in Haskell.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec340"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the necessary libraries as follows:<div><pre class="programlisting">import System.CPUTime (getCPUTime)
import Control.Monad (replicateM_)
import Control.Parallel.Strategies (NFData, rdeepseq)
import Control.Exception (evaluate)</pre></div></li><li class="listitem">Create a function to print out the duration of a pure task. Evaluate the pure expression a very large number of times (10^6), and then calculate the average CPU time it takes to run one pure task. The <code class="literal">getCPUTime</code> function<a id="id585" class="indexterm"/> returns the number of picoseconds since the start of the program's execution, as shown in the following code snippet:<div><pre class="programlisting">time :: (Num t, NFData t) =&gt; t -&gt; IO ()
time y = do
  let trials = 10^6
  start &lt;- getCPUTime
  replicateM_ trials $ do
      x &lt;- evaluate $ 1 + y
      rdeepseq x `seq` return ()
  end   &lt;- getCPUTime
  let diff = (fromIntegral (end - start)) / (10^12)
  putStrLn $ "avg seconds: " ++  
    (show (diff / fromIntegral trials))
  return ()</pre></div></li><li class="listitem">Test out the timing function as follows:<div><pre class="programlisting">main = do 
    putStrLn "Starting pure..."
    time (3+7 :: Int)
    putStrLn "...Finished pure"</pre></div></li><li class="listitem">The measurements for conducting a pure task are printed out. Actual measurements will differ depending on the state of the machine.<div><pre class="programlisting">Starting pure…
Avg seconds: 3.2895e-7
…Finished pure</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec341"/>See also</h2></div></div></div><p>The <em>Benchmarking runtime performance in the terminal</em> recipe for producing benchmark results outside the Haskell environment.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec123"/>Using the criterion package to measure performance</h1></div></div></div><p>For more reliable performance<a id="id586" class="indexterm"/> measures, the <code class="literal">criterion</code> package<a id="id587" class="indexterm"/> comes in handy. The package description points out a major flaw in using simple procedures to time pure code.</p><div><blockquote class="blockquote"><p><em>"Because GHC optimizes aggressively when compiling with -O, it is potentially easy to write innocent-looking benchmark code that will only be evaluated once, for which all but the first iteration of the timing loop will be timing the cost of doing nothing."</em></p></blockquote></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec342"/>Getting ready</h2></div></div></div><p>Create a <code class="literal">small.txt</code> file with a few words. Create a file, <code class="literal">big.txt</code>, filled with text as follows:</p><div><pre class="programlisting">
<strong>$ wget norvig.com/big.txt</strong>
</pre></div><p>Install the <code class="literal">criterion</code> library as follows:</p><div><pre class="programlisting">
<strong>$ cabal install criterion</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec343"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the package as follows:<div><pre class="programlisting">import Criterion.Main</pre></div></li><li class="listitem">Define the I/O function we wish to time as follows:<div><pre class="programlisting">splitUp filename = readFile filename &gt;&gt;= return . words</pre></div></li><li class="listitem">Benchmark the desired function as follows:<div><pre class="programlisting">main = defaultMain 
  [ bgroup "splitUp" 
    [ bench "big" $ nfIO $ splitUp "big.txt" 
    , bench "small" $ nfIO $ splitUp "small.txt" ] ]</pre></div></li><li class="listitem">Run the code as follows:<div><pre class="programlisting">
<strong>$ ghc -O --make Main.hs</strong>

<strong>$ ./Main</strong>

<strong>warming up</strong>
<strong>estimating clock resolution...</strong>
<strong>mean is 1.082787 us (640001 iterations)</strong>
<strong>found 42320 outliers among 639999 samples (6.6%)</strong>
<strong>  1860 (0.3%) low severe</strong>
<strong>  40460 (6.3%) high severe</strong>
<strong>estimating cost of a clock call...</strong>
<strong>mean is 33.40185 ns (10 iterations)</strong>
<strong>found 2 outliers among 10 samples (20.0%)</strong>
<strong>  1 (10.0%) high mild</strong>
<strong>  1 (10.0%) high severe</strong>

<strong>benchmarking splitUp/big</strong>
<strong>collecting 100 samples, 1 iterations each, in estimated 65.46450 s</strong>
<strong>mean: 656.1964 ms, lb 655.5417 ms, ub 657.1513 ms, ci 0.950</strong>
<strong>std dev: 4.018375 ms, lb 3.073741 ms, ub 5.746751 ms, ci 0.950</strong>

<strong>benchmarking splitUp/small</strong>
<strong>mean: 15.33773 us, lb 15.16429 us, ub 15.56298 us, ci 0.950</strong>
<strong>std dev: 1.010893 us, lb 823.5281 ns, ub 1.277931 us, ci 0.950</strong>
<strong>found 8 outliers among 100 samples (8.0%)</strong>
<strong>  5 (5.0%) high mild</strong>
<strong>  3 (3.0%) high severe</strong>
<strong>variance introduced by outliers: 61.572%</strong>
<strong>variance is severely inflated by outliers</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec344"/>How it works…</h2></div></div></div><p>By calling <a id="id588" class="indexterm"/>this library's <code class="literal">defaultMain</code> function<a id="id589" class="indexterm"/> in <code class="literal">main</code>, we <a id="id590" class="indexterm"/>can leverage some very powerful benchmarking features. For instance, try running the following command to see a plethora of features supported by criterion:</p><div><pre class="programlisting">
<strong>$ ./Main -h</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec124"/>Benchmarking runtime performance in the terminal</h1></div></div></div><p>Benchmarking runtime<a id="id591" class="indexterm"/> is the process of timing how long it takes the code to run. This skill is invaluable since it helps compare performance. By externally<a id="id592" class="indexterm"/> measuring the runtime as opposed to instrumenting it within the code, we can easily proceed without understanding the inner working of the code. If we're on a Unix-like system such as Linux or OS X, we can use the <code class="literal">time</code> command, and on Windows systems, we can use <code class="literal">Measure-Command</code> with PowerShell.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec345"/>Getting ready</h2></div></div></div><p>Make sure our machine is either Unix-like (such as Linux or OS X) or Windows. Otherwise, we must search online for a way to time execution.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec346"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">On Unix-like systems, there is a<a id="id593" class="indexterm"/> built-in <code class="literal">time</code> command. When running any piece of code from the terminal, we can prefix it with <code class="literal">time</code> as follows:<div><pre class="programlisting">
<strong>$ time runhaskell Main.hs</strong>
<strong>real 0m0.663s</strong>
<strong>user 0m0.612s</strong>
<strong>sys 0m0.057s</strong>
</pre></div><p>The argument to this command is run, and the system resource usage is immediately summarized. The actual accuracy of the results depends on the machine.</p></li><li class="listitem">On Windows, we can use the<a id="id594" class="indexterm"/> <code class="literal">Measure-Command</code> feature in PowerShell. Open PowerShell, go to the correct directory, and execute the following command:<div><pre class="programlisting">
<strong>&gt; Measure-Command { start-process runhaskell Main.hs –Wait }</strong>
</pre></div></li><li class="listitem">You will see a result with the following format:<div><pre class="programlisting">
<strong>Days              : 0</strong>
<strong>Hours             : 0</strong>
<strong>Minutes           : 0</strong>
<strong>Seconds           : 1</strong>
<strong>Milliseconds      : 10</strong>
<strong>Ticks             : 10106611</strong>
<strong>TotalDays         : 1.16974664351852E-05</strong>
<strong>TotalHours        : 0.000280739194444444</strong>
<strong>TotalMinutes      : 0.0168443516666667</strong>
<strong>TotalSeconds      : 1.0106611</strong>
<strong>TotalMilliseconds : 1010.6611</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec347"/>See also</h2></div></div></div><p>To time execution within the Haskell code itself, refer to the <em>Benchmarking runtime performance in Haskell</em> recipe.</p></div></div></body></html>