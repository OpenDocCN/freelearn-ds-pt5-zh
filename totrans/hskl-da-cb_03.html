<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. The Science of Words</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Displaying a number in another base</li><li class="listitem" style="list-style-type: disc">Reading a number from another base</li><li class="listitem" style="list-style-type: disc">Searching for a substring using Data.ByteString</li><li class="listitem" style="list-style-type: disc">Searching a string using the Boyer–Moore–Horspool algorithm</li><li class="listitem" style="list-style-type: disc">Searching a string using the Rabin-Karp algorithm</li><li class="listitem" style="list-style-type: disc">Splitting a string on lines, words, or arbitrary tokens</li><li class="listitem" style="list-style-type: disc">Finding the longest common subsequence</li><li class="listitem" style="list-style-type: disc">Computing a phonetic code</li><li class="listitem" style="list-style-type: disc">Calculating the edit distance between two strings</li><li class="listitem" style="list-style-type: disc">Computing the Jaro–Winkler distance between two strings</li><li class="listitem" style="list-style-type: disc">Finding strings within one-edit distance</li><li class="listitem" style="list-style-type: disc">Fixing spelling mistakes using edit distance</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Introduction</h1></div></div></div><div><img src="img/ch03.jpg" alt="Introduction"/></div><p>Many interesting analysis techniques can be used on a large corpus of words. Whether it be examining the structure of a sentence or the content of a book, these recipes will introduce us to some useful tools.</p><p>When manipulating strings for data analysis, some of the most common functions are among substring search and edit distance computations. Since numbers are often found in a corpus of text, this chapter will start by showing how to represent numbers in an arbitrary base as a string. We will cover a couple of string-searching algorithms and then focus on extracting text to study not only the words but also how the words are used together.</p><p>Many practical applications can be constructed given the simple set of tools provided in this section. For example, in the last recipe, we will demonstrate a way to correct spelling mistakes. How we use these algorithms is entirely up to our creativity, but at least having them at our disposal is an excellent start.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Displaying a number in another base</h1></div></div></div><p>Strings<a id="id170" class="indexterm"/> are a natural way to represent numbers in different bases due to the inclusion of letters as digits. This<a id="id171" class="indexterm"/> recipe will tell us how to <a id="id172" class="indexterm"/>convert a number to a string that can be printed as output.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec92"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We will need to import the following two functions:<div><pre class="programlisting">import Data.Char (intToDigit, chr, ord) 
import Numeric (showIntAtBase)</pre></div></li><li class="listitem">Define a function to represent a number in a particular base as follows:<div><pre class="programlisting">n 'inBase' b = showIntAtBase b numToLetter n ""</pre></div></li><li class="listitem">Define the mapping between numbers and letters for digits larger than nine as follows:<div><pre class="programlisting">numToLetter :: Int -&gt; Char
numToLetter n
  | n &lt; 10 = intToDigit n
  | otherwise = chr (ord 'a' n – 10)</pre></div></li><li class="listitem">Print out the result using the following code snippet:<div><pre class="programlisting">main :: IO ()
main = do
  putStrLn $ 8 'inBase' 12
  putStrLn $ 10 'inBase' 12
  putStrLn $ 12 'inBase' 12
  putStrLn $ 47 'inBase' 12</pre></div></li><li class="listitem">The following is the printed output when running the code:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>8</strong>
<strong>a</strong>
<strong>10</strong>
<strong>3b</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec93"/>How it works...</h2></div></div></div><p>The <code class="literal">showIntAtBase</code> function<a id="id173" class="indexterm"/> takes in a base, the desired number, and its mapping from number to printable digit. We<a id="id174" class="indexterm"/> order our digits in the following manner: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, and so on, up to 36 characters. Putting it all together, we get a convenient way to represent a decimal number in any base.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec94"/>See also</h2></div></div></div><p>To read a string representing a number from another base as a decimal integer, refer to the <em>Reading a number from another base</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Reading a number from another base</h1></div></div></div><p>Decimal, binary, and hexadecimal are widely <a id="id175" class="indexterm"/>used numeral systems that are often represented using a string. This recipe will show how to convert a string representation of a number in an arbitrary base to its decimal integer. We use the <code class="literal">readInt</code> function, which is the dual of the <code class="literal">showIntAtBase</code> function described in the previous recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec95"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import <code class="literal">readInt</code> and the following functions for character manipulation as follows:<div><pre class="programlisting">import Data.Char (ord, digitToInt, isDigit)
import Numeric (readInt)</pre></div></li><li class="listitem">Define a function to convert a string representing a number in a particular base to a decimal integer as follows:<div><pre class="programlisting">str 'base' b = readInt b isValidDigit letterToNum str</pre></div></li><li class="listitem">Define the mapping between letters and numbers for larger digits, as shown in the following code snippet:<div><pre class="programlisting">letterToNum :: Char -&gt; Int
letterToNum d
  | isDigit d = digitToInt d
  | otherwise = ord d - ord 'a' + 10
             
isValidDigit :: Char -&gt; Int
isValidDigit d = letterToNum d &gt;= 0</pre></div></li><li class="listitem">Print out the result using the following line of codes:<div><pre class="programlisting">main :: IO ()
main = do
  print $ "8" 'base' 12
  print $ "a" 'base' 12
  print $ "10" 'base' 12
  print $ "3b" 'base' 12</pre></div></li><li class="listitem">The printed output is as follows:<div><pre class="programlisting">
<strong>[(8,"")]</strong>
<strong>[(10,"")]</strong>
<strong>[(12,"")]</strong>
<strong>[(47,"")]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec96"/>How it works...</h2></div></div></div><p>The <code class="literal">readInt</code> function<a id="id176" class="indexterm"/> reads an unsigned integral value and converts it to the specified base. It takes in the base as the first argument, valid characters as the second<a id="id177" class="indexterm"/> argument, and its mapping from character to number as the third argument. We order our digits in the following order: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, and so on up to 36 characters. Putting it all together, we get a convenient way to convert a string representation of a number in an arbitrary base to a decimal number.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>This recipe assumes that a valid string is passed into the <code class="literal">base</code> function for conversion. Further error checks are necessary to ensure that erroneous input such as <code class="literal">"a" 'base' 4</code> should not result in an answer.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec97"/>See also</h2></div></div></div><p>To do the reverse, refer to the <em>Displaying a number in another base</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Searching for a substring using Data.ByteString</h1></div></div></div><p>There are many<a id="id178" class="indexterm"/> algorithms to search for a string <a id="id179" class="indexterm"/>within another string. This recipe will use an existing <code class="literal">breakSubstring</code> function in the <code class="literal">Data.ByteString</code> library to do most of the heavy lifting.</p><p>The <code class="literal">ByteString</code> documentation<a id="id180" class="indexterm"/> establishes its merits by declaring the following claim:</p><div><blockquote class="blockquote"><p><em>"[A ByteString is] a time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Byte vectors are encoded as strict Word8 arrays of bytes, held in a ForeignPtr, and can be passed between C and Haskell with little effort."</em></p></blockquote></div><p>More information and documentation can be obtained on the package web page at <a class="ulink" href="http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html">http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html</a>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec98"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import<a id="id181" class="indexterm"/> the <code class="literal">breakSubstring</code> function as well as the <code class="literal">Data.ByteString.Char8</code> package as follows:<div><pre class="programlisting">import Data.ByteString (breakSubstring)
import qualified Data.ByteString.Char8 as C</pre></div></li><li class="listitem">Pack<a id="id182" class="indexterm"/> the strings as a <code class="literal">ByteString</code> and feed them into <code class="literal">breakSubstring</code> which has the following type: <code class="literal">ByteString -&gt; ByteString -&gt; (ByteString, ByteString)</code>. Then determine whether the string is found:<div><pre class="programlisting">substringFound :: String -&gt; String -&gt; Bool

substringFound query str = 
  (not . C.null . snd) $ 
  breakSubstring (C.pack query) (C.pack str)</pre></div></li><li class="listitem">Try out some tests in <code class="literal">main</code> as follows:<div><pre class="programlisting">main = do
  print $ substringFound "scraf" "swedish scraf mafia"
  print $ substringFound "flute" "swedish scraf mafia"</pre></div></li><li class="listitem">Executing <code class="literal">main</code> will print out the following results:<div><pre class="programlisting">
<strong>True</strong>
<strong>False</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec99"/>How it works...</h2></div></div></div><p>The <code class="literal">breakSubstring</code> function<a id="id183" class="indexterm"/> recursively checks if the pattern is a prefix of the string. To lazily find the first occurrence of a string, we can call <code class="literal">snd (breakSubstring pat str)</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec100"/>There's more...</h2></div></div></div><p>Another elegant way to quickly find a substring is by using the <code class="literal">isInfixOf</code> function provided by both <code class="literal">Data.List</code> and <code class="literal">Data.ByteString</code>. Moreover, we can also use the <code class="literal">OverloadedStrings</code> language extension to remove verbiage, as shown in the following code snippet:</p><div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}
import Data.ByteString (isInfixOf)

main = do
  print $ isInfixOf "scraf" "swedish scraf mafia"
  print $ isInfixOf "flute" "swedish scraf mafia"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec101"/>See also</h2></div></div></div><p>Depending on the <a id="id184" class="indexterm"/>length of the pattern we're trying to find and the length of the whole string itself, other algorithms may provide better performance. Refer to the <em>Searching a string using the Boyer-Moore-Horspool algorithm</em> and <em>Searching a string using the Rabin-Karp algorithm</em> recipes for more details.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Searching a string using the Boyer-Moore-Horspool algorithm</h1></div></div></div><p>When searching<a id="id185" class="indexterm"/> for a pattern in a string, we refer to the pattern as the <strong>needle</strong><a id="id186" class="indexterm"/> and the whole corpus as<a id="id187" class="indexterm"/> the <strong>haystack</strong>. The Horspool string search algorithm<a id="id188" class="indexterm"/> implemented in this recipe performs well for almost all pattern lengths and alphabet sizes, but is ideal for large alphabet sizes and large needle sizes. Empirical benchmarks can be found by navigating to the following URL:</p><p>
<a class="ulink" href="http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm">http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm</a>
</p><p>By preprocessing the query, the algorithm is able to efficiently skip redundant comparisons. In <a id="id189" class="indexterm"/>this recipe, we will implement a simplified version called Horspool's algorithm, which achieves the same average best case as the Boyer-Moore algorithm, benefits from having a smaller overhead cost, but may in very rare circumstances suffer the same worst-case running time as the naive search when the algorithm performs too many matches. The Boyer-Moore algorithms should only be used if the extra prepossessing time and space required are acceptable.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec102"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We will be using a couple <code class="literal">Data.Map</code> functions as follows:<div><pre class="programlisting">import Data.Map (fromList, (!), findWithDefault)</pre></div></li><li class="listitem">For convenience, define tuples representing character indices as follows:<div><pre class="programlisting">indexMap xs = fromList $ zip [0..] xs

revIndexMap xs = fromList $ zip (reverse xs) [0..]</pre></div></li><li class="listitem">Define the search algorithm to use the recursive <code class="literal">bmh'</code> function as follows:<div><pre class="programlisting">bmh :: Ord a =&gt; [a] -&gt; [a] -&gt; Maybe Int

bmh pat xs = bmh' (length pat - 1) (reverse pat) xs pat</pre></div></li><li class="listitem">Recursively<a id="id190" class="indexterm"/> find the pattern in the current index until the index moves past the length of the string, as shown in the following code snippet:<div><pre class="programlisting">bmh' :: Ord a =&gt; Int -&gt; [a] -&gt; [a] -&gt; [a] -&gt; Maybe Int 

bmh' n [] xs pat = Just (n + 1)
bmh' n (p:ps) xs pat 
  | n &gt;= length xs   = Nothing
  | p == (indexMap xs) ! n = bmh' (n - 1) ps xs pat
  | otherwise              = bmh' (n + findWithDefault
                                  (length pat) (sMap ! n) pMap) 
                                  (reverse pat) xs pat
  where sMap = indexMap xs
        pMap = revIndexMap pat</pre></div></li><li class="listitem">Test out the function as follows:<div><pre class="programlisting">main :: IO ()
main = print $ bmh "Wor" "Hello World"</pre></div></li><li class="listitem">The following printed output displays the first index of the matching substring:<div><pre class="programlisting">
<strong>Just 6</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec103"/>How it works...</h2></div></div></div><p>This <a id="id191" class="indexterm"/>algorithm compares <a id="id192" class="indexterm"/>the desired pattern to a moving window through the text. The efficiency comes from how quickly the moving window shifts left to right through this text. In the Horspool algorithm, the query is compared to the current window character by character from right to left, and the window shifts by the size of the query in the best case.</p><p>Another version of the Horspool algorithm designed by Remco Niemeijer can be found at <a class="ulink" href="http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore">http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec104"/>There's more...</h2></div></div></div><p>The Boyer-Moore algorithm <a id="id193" class="indexterm"/>ensures a faster worst case, but also endures slightly more initial overhead. Refer to the following commands to use the Boyer-Moore algorithm from the <code class="literal">Data.ByteString.Search</code> package:</p><div><pre class="programlisting">
<strong>$ cabal install stringsearch</strong>
</pre></div><p>Import the following libraries:</p><div><pre class="programlisting">import Data.ByteString.Search
import qualified Data.ByteString.Char8 as C</pre></div><p>Feed two <code class="literal">ByteString</code> types to the <code class="literal">indices</code> function to run the search as follows:</p><div><pre class="programlisting">main = print $ indices (C.pack "abc") (C.pack "bdeabcdabc")</pre></div><p>This will print out the following indices:</p><div><pre class="programlisting">
<strong>[3,7]</strong>
</pre></div><p>By benchmarking the performance of this library, we can see that longer search needles really improve runtime. We modify the code to search through a huge corpus of words from a file called <code class="literal">big.txt</code> to find multiple needles. Here, we use the <code class="literal">deepseq</code> function to force evaluation, so Haskell's lazy nature won't ignore it, as shown in the following code:</p><div><pre class="programlisting">shortNeedles = ["abc", "cba"]
longNeedles = ["very big words", "some long string"]

main = do
  corpus &lt;- BS.readFile "big.txt"
  map (\x -&gt; (not.null) (indices x corpus)) shortNeedles     
    'deepseq' return ()</pre></div><p>We can compile this code with special runtime system (RTS) control for easy profiling as follows:</p><div><pre class="programlisting">
<strong>$ ghc -O2 Main.hs –rtsopts</strong>

<strong>$ ./Main +RTS -sstder</strong>
</pre></div><p>We use the text from <code class="literal">norvig.com/big.txt</code> as our corpus. Searching for 25 long needles takes just about 0.06 seconds; however, searching for 25 short needles takes a sluggish 0.19 seconds.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec105"/>See also</h2></div></div></div><p>For another efficient string searching algorithm, refer to the <em>Searching a string using the Rabin-Karp algorithm</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec41"/>Searching a string using the Rabin-Karp algorithm</h1></div></div></div><p>The <a id="id194" class="indexterm"/>Rabin-Karp algorithm <a id="id195" class="indexterm"/>finds a pattern in a body of text by matching a unique representation of the pattern against a moving window. The<a id="id196" class="indexterm"/> unique representation, or hash, is computed by considering a string as a number written in an arbitrary base of 26 or greater.</p><p>The advantage of Rabin-Karp is in searching for many needles in a haystack. It's not very efficient to search for just a single string. After the initial preprocessing of the corpus, the algorithm can quickly find matches.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec106"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">Data.ByteString.Search</code> library<a id="id197" class="indexterm"/> from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install stringsearch</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec107"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">OverloadedStrings</code> language extension to facilitate the <code class="literal">ByteString</code> manipulations in our code as follows. It essentially allows polymorphic behavior for strings so that the GHC compiler may infer it as a <code class="literal">ByteString</code> type when necessary:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}</pre></div></li><li class="listitem">Import the Rabin-Karp algorithms as follows:<div><pre class="programlisting">import Data.ByteString.Search.KarpRabin (indicesOfAny)
import qualified Data.ByteString as BS</pre></div></li><li class="listitem">Define a couple of patterns to find and obtain the corpus from a <code class="literal">big.txt</code> file, as shown in the following code snippet:<div><pre class="programlisting">main = do
  let needles = [ "preparing to go away"
                , "is some letter of recommendation"]
  haystack &lt;- BS.readFile "big.txt"</pre></div></li><li class="listitem">Run the Rabin-Karp algorithm on all the search patterns as follows:<div><pre class="programlisting">  print $ indicesOfAny needles haystack</pre></div></li><li class="listitem">The code prints out all indices found for each needle as a list of tuples. The first element of the tuple is the position in the haystack that the needle was found. The second element of the tuple is a list of indices of the needles. In our recipe, we find one instance of "preparing to go away" and two instances of "is some letter of recommendation."<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>[(3738968,[1]),(5632846,[0]),(5714386,[0])]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec108"/>How it works...</h2></div></div></div><p>In Rabin-Karp, a fixed <a id="id198" class="indexterm"/>window moves from left to right, comparing the unique hash values for efficient comparisons. The hash function converts a string to its numerical representation. Here's an example of converting a string into base b equal to 256: <em>"hello" = h' * b<sup>4</sup> + e' * b<sup>3</sup> + l' * b<sup>2</sup> + l' * b<sup>1</sup> + o' * b<sup>0</sup></em> (which results in 448378203247), where each letter <code class="literal">h' = ord h</code> (which results in 104), and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec109"/>See also</h2></div></div></div><p>To see another efficient string searching algorithm, refer to the <em>Searching a string using the Boyer-Moore-Horspool algorithm</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec42"/>Splitting a string on lines, words, or arbitrary tokens</h1></div></div></div><p>Useful data is often<a id="id199" class="indexterm"/> interspersed <a id="id200" class="indexterm"/>between delimiters, such<a id="id201" class="indexterm"/> as commas or spaces, making string splitting vital for most data analysis tasks.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec110"/>Getting ready</h2></div></div></div><p>Create an <code class="literal">input.txt</code> file similar to the following one:</p><div><pre class="programlisting">
<strong>$ cat input.txt</strong>

<strong>first line</strong>
<strong>second line</strong>
<strong>words are split by space</strong>
<strong>comma,separated,values</strong>
<strong>or any delimiter you want</strong>
</pre></div><p>Install the <code class="literal">split</code> package using Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install split</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec111"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The only function we will need is <code class="literal">splitOn</code>, which is imported as follows:<div><pre class="programlisting">import Data.List.Split (splitOn)</pre></div></li><li class="listitem">First we split the <a id="id202" class="indexterm"/>string into lines, as shown in the following code snippet:<div><pre class="programlisting">main = do 
  input &lt;- readFile "input.txt"
  let ls = lines input
  print $ ls</pre></div></li><li class="listitem">The lines<a id="id203" class="indexterm"/> are printed in a list as follows:<div><pre class="programlisting">
<strong>[ "first line","second line"</strong>
<strong>, "words are split by space"</strong>
<strong>, "comma,separated,values"</strong>
<strong>, "or any delimiter you want"]</strong>
</pre></div></li><li class="listitem">Next, we separate a string on spaces as follows:<div><pre class="programlisting">  let ws = words $ ls !! 2
  print ws</pre></div></li><li class="listitem">The words<a id="id204" class="indexterm"/> are printed in a list as follows:<div><pre class="programlisting">
<strong>["words","are","split","by","space"]</strong>
</pre></div></li><li class="listitem">Next, we show how to split a string on an arbitrary value using the following lines of code:<div><pre class="programlisting">  let cs = splitOn "," $ ls !! 3
  print cs</pre></div></li><li class="listitem">The values are split on the commas as follows:<div><pre class="programlisting">
<strong>["comma","separated","values"]</strong>
</pre></div></li><li class="listitem">Finally, we show splitting on multiple letters as shown in the following code snippet:<div><pre class="programlisting">  let ds = splitOn "an" $ ls !! 4
  print ds</pre></div></li><li class="listitem">The output is as follows:<div><pre class="programlisting">
<strong>["or any d","limit","r you want"]</strong>
</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Finding the longest common subsequence</h1></div></div></div><p>One way to <a id="id205" class="indexterm"/>compare string similarity is by finding their longest common subsequence. This is useful in finding differences between mutations of data such as source code or genome sequences.</p><p>A subsequence of a string is the same string with zero or more of the indices removed. So, some possible subsequences of "BITCOIN" could be "ITCOIN", "TON", "BIN", or even "BITCOIN" itself, as shown in the following figure:</p><div><img src="img/6331OS_03_01.jpg" alt="Finding the longest common subsequence"/></div><p>The longest common subsequence<a id="id206" class="indexterm"/> is exactly what it sounds like. It is the longest subsequence <a id="id207" class="indexterm"/>common to both strings. For example, the longest common subsequence of "find the lights" and "there are four lights" is "the lights."</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec112"/>Getting ready</h2></div></div></div><p>Install <a id="id208" class="indexterm"/>the <code class="literal">data-memocombinators</code> package from Cabal. This allows us to minimize redundant computations to improve runtime as follows:</p><div><pre class="programlisting">
<strong>$ cabal install data-memocombinators</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec113"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The only import we will need is this handy package to easily support memoization:<div><pre class="programlisting">import qualified Data.MemoCombinators as Memo</pre></div></li><li class="listitem">Create a convenience function to enable memoization of functions that take in two string arguments, as shown in the following code snippet:<div><pre class="programlisting">memoize :: (String -&gt; String -&gt; r) -&gt; String -&gt; String -&gt; r
memoize = Memo.memo2 
    (Memo.list Memo.char) (Memo.list Memo.char)</pre></div></li><li class="listitem">Define the largest common subsequence function as follows:<div><pre class="programlisting">lcs :: String -&gt; String -&gt; String

lcs = memoize lcs'
  where lcs' xs'@(x:xs) ys'@(y:ys)
    | x == y = x : lcs xs ys
    | otherwise = longer (lcs xs' ys) (lcs xs ys')
    lcs' _ _ = []</pre></div></li><li class="listitem">Internally, define a function that returns the longer length string.<div><pre class="programlisting">  longer as bs
    | length as &gt; length bs = as
    | otherwise = bs</pre></div></li><li class="listitem">Run the function on two strings as follows.<div><pre class="programlisting">main :: IO ()
main = do
  let xs = "find the lights"
  let ys = "there are four lights"
  print $ lcs xs ys</pre></div></li><li class="listitem">The following is the longest common subsequence between the two strings:<div><pre class="programlisting">
<strong>"the lights"</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec114"/>How it works...</h2></div></div></div><p>The algorithm <a id="id209" class="indexterm"/>is implemented naively, with memoization added to the recursive calls. If the first two items of a list are the same, then the longest common subsequence is the <code class="literal">lcs</code> function applied to the remaining parts of the list. Otherwise, the longest common subsequence is the longer of the two possibilities.</p><p>Naively, this algorithm will stall when given two strings as small as 10 characters each. Since the code breaks down to multiple identical subproblems, we can easily use a simple <code class="literal">memoize</code> function that remembers already computed values, improving the runtime dramatically.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec44"/>Computing a phonetic code</h1></div></div></div><p>If we're dealing <a id="id210" class="indexterm"/>with a corpus of English words, then we can categorize them into phonetic codes to see how similar they sound. Phonetic codes work for any alphabetical strings, not just actual words. We will use the <code class="literal">Text.PhoneticCode</code> package<a id="id211" class="indexterm"/> to compute the Soundex and Phoneix phonetic codes. The package documentation can be found on Hackage at <a class="ulink" href="http://hackage.haskell.org/package/phonetic-code">http://hackage.haskell.org/package/phonetic-code</a>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec115"/>Getting ready</h2></div></div></div><p>Install the<a id="id212" class="indexterm"/> phonetic code library from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install phonetic-code</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec116"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the phonetic code functions as follows:<div><pre class="programlisting">import Text.PhoneticCode.Soundex (soundexNARA, soundexSimple)
import Text.PhoneticCode.Phonix (phonix)</pre></div></li><li class="listitem">Define a list of similar-sounding words as follows:<div><pre class="programlisting">ws = ["haskell", "hackle", "haggle", "hassle"]</pre></div></li><li class="listitem">Test out<a id="id213" class="indexterm"/> the phonetic codes on these words, as shown in the following code snippet:<div><pre class="programlisting">main :: IO ()
main = do
  print $ map soundexNARA ws
  print $ map soundexSimple ws
  print $ map phonix ws</pre></div></li><li class="listitem">The output will be printed as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>["H240","H240","H240","H240"]</strong>

<strong>["H240","H240","H240","H240"]</strong>

<strong>["H82","H2","H2","H8"]</strong>
</pre></div></li></ol></div><p>Notice how <code class="literal">phonix</code> produces a finer categorization than <code class="literal">soundex</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec117"/>How it works...</h2></div></div></div><p>The algorithms perform simple string manipulations based on heuristic English-language-dependent patterns.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec118"/>There's more...</h2></div></div></div><p>Metaphone<a id="id214" class="indexterm"/> is an improvement over the Soundex algorithm and <a id="id215" class="indexterm"/>can be found at <a class="ulink" href="http://aspell.net/metaphone">http://aspell.net/metaphone</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec45"/>Computing the edit distance</h1></div></div></div><p>The edit distance <a id="id216" class="indexterm"/>or Levenshtein distance is the minimum number of simple string operations required to convert<a id="id217" class="indexterm"/> one string into another. In this recipe, we will compute the edit distance based on only insertions, deletions, and substitutions of characters.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec119"/>Getting ready</h2></div></div></div><p>Review the equation shown in the following figure obtained from the Wikipedia article about the Levenshtein distance (<a class="ulink" href="http://en.wikipedia.org/wiki/Levenshtein_distance">http://en.wikipedia.org/wiki/Levenshtein_distance</a>):</p><div><img src="img/6331OS_03_02.jpg" alt="Getting ready"/></div><p>Here, <em>a</em> and <em>b</em> are the two strings, and i and j are numbers representing their lengths.</p><p>The Haskell code will be a direct translation of this mathematical formula.</p><p>Also, install the <code class="literal">data-memocombinators</code> package<a id="id218" class="indexterm"/> from Cabal. This allows us to minimize redundant computations to improve runtime.</p><div><pre class="programlisting">
<strong>$ cabal install data-memocombinators</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec120"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The only import we will need is the ability to easily memoize functions using the following line of code:<div><pre class="programlisting">import qualified Data.MemoCombinators as Memo</pre></div></li><li class="listitem">Define the Levenshtein distance function exactly as described in the formula using the following code snippet:<div><pre class="programlisting">lev :: Eq a =&gt; [a] -&gt; [a] -&gt; Int
lev a b = levM (length a) (length b)
  where levM = memoize lev'
    lev' i j
      | min i j == 0 = max i j
      | otherwise    = minimum 
        [ ( 1 + levM (i-1) j )
        , ( 1 + levM i (j-1) )
        , ( ind i j + levM (i-1) (j-1) ) ]</pre></div></li><li class="listitem">Define the indicator function that returns 1 if the characters don't match.<div><pre class="programlisting">  ind i j
    | a !! (i-1) == b !! (j-1) = 0
    | otherwise = 1</pre></div></li><li class="listitem">Create a<a id="id219" class="indexterm"/> convenience function to enable memoization of functions that take in two string arguments:<div><pre class="programlisting">memoize = Memo.memo2 (Memo.integral) (Memo.integral)</pre></div></li><li class="listitem">Print out the edit distance between two strings:<div><pre class="programlisting">main = print $ lev "mercury" "sylvester"</pre></div></li><li class="listitem">The result is as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>8</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec121"/>How it works...</h2></div></div></div><p>This algorithm recursively tries all deletions, insertions, and substitutions and finds the minimum distance from one string to another.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec122"/>See also</h2></div></div></div><p>Another measurement is described in the <em>Computing the Jaro-Winkler distance between two strings</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec46"/>Computing the Jaro-Winkler distance between two strings</h1></div></div></div><p>The Jaro-Winkler distance<a id="id220" class="indexterm"/> measures string similarity represented as a real number between 0 and 1. The value 0 corresponds to no similarity, and 1 corresponds to an identical match.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec123"/>Getting ready</h2></div></div></div><p>The algorithm <a id="id221" class="indexterm"/>behind the function comes from the following mathematical formula presented in the Wikipedia article about the Jaro-Winkler distance <a class="ulink" href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>:</p><div><img src="img/6331OS_03_03.jpg" alt="Getting ready"/></div><p>In the preceding formula, the following are the representations of the variables used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>s1</em> is the first string.</li><li class="listitem" style="list-style-type: disc"><em>s2</em> is the second string.</li><li class="listitem" style="list-style-type: disc"><em>m</em> is the number of identical characters within a distance of at the most half the length of the longer string. These are called matching characters.</li><li class="listitem" style="list-style-type: disc"><em>t</em> is half the number of matching characters that are not in the same index. In other words, it is half the number of transpositions.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec124"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We will need access to the <code class="literal">elemIndices</code> function, which is imported as follows:<div><pre class="programlisting">import Data.List (elemIndices)</pre></div></li><li class="listitem">Define the Jaro-Winkler function based on the following formula:<div><pre class="programlisting">jaro :: Eq a =&gt; [a] -&gt; [a] -&gt; Double

jaro s1 s2
  | m == 0    = 0.0
  | otherwise = (1/3) * (m/ls1 + m/ls2 + (m-t)/m)</pre></div></li><li class="listitem">Define the variables used, as follows:<div><pre class="programlisting">  where ls1 = toDouble $ length s1

        ls2 = toDouble $ length s2

         m' = matching s1 s2 d

         d = fromIntegral $ 
         max (length s1) (length s2) 'div' 2 – 1

         m = toDouble m'

         t = toDouble $ (m' - matching s1 s2 0) 'div' 2</pre></div></li><li class="listitem">Define a helper function to convert an integer to <code class="literal">Double</code> type:<div><pre class="programlisting">toDouble :: Integral a =&gt; a -&gt; Double

toDouble n = (fromIntegral n) :: Double</pre></div></li><li class="listitem">Define a<a id="id222" class="indexterm"/> helper function to find the number of matching characters within a specified distance, as shown in the following code snippet:<div><pre class="programlisting">matching :: Eq a =&gt; [a] -&gt; [a] -&gt; Int -&gt; Int

matching s1 s2 d = length $ filter 
  (\(c,i) -&gt; not (null (matches s2 c i d))) 
  (zip s1 [0..])</pre></div></li><li class="listitem">Define a helper function to find the number of matching characters from a specific character at a specified index as follows.<div><pre class="programlisting">matches :: Eq a =&gt; [a] -&gt; a -&gt; Int -&gt; Int -&gt; [Int]

matches str c i d = filter (&lt;= d) $ 
  map (dist i) (elemIndices c str)
  where dist a b = abs $ a - b</pre></div></li><li class="listitem">Test out the algorithm by printing out a couple of examples as follows:<div><pre class="programlisting">main = do
  print $ jaro "marisa" "magical"
  print $ jaro "haskell" "hackage"</pre></div></li><li class="listitem">The similarities are printed out as such, implying "marisa" is closer to "magical" than "haskell" is to "hackage".<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>0.746031746031746</strong>
<strong>0.7142857142857142</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec125"/>See also</h2></div></div></div><p>Another way to compute string similarity is defined in the previous recipe entitled <em>Computing the Edit Distance</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec47"/>Finding strings within one-edit distance</h1></div></div></div><p>This recipe will <a id="id223" class="indexterm"/>demonstrate how to find strings that are one-edit distance away from a specified string. This function can be used to correct spelling.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec126"/>Getting ready</h2></div></div></div><p>The algorithm in this recipe is based heavily on<a id="id224" class="indexterm"/> Peter Norvig's spell corrector algorithm described at <a class="ulink" href="http://norvig.com/spell-correct.html">http://norvig.com/spell-correct.html</a>. Take a look at and study the <code class="literal">edits1</code> Python function implemented there.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec127"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import a couple of character and list functions as follows:<div><pre class="programlisting">import Data.Char (toLower)
import Data.List (group, sort)</pre></div></li><li class="listitem">Define a function to return strings that are one-edit distance away, as shown in the following code snippet:<div><pre class="programlisting">edits1 :: String -&gt; [String]

edits1 word = unique $ 
              deletes ++ transposes ++ replaces ++ inserts
  where splits   = [ (take i word', drop i word') | 
    i &lt;- [0..length word']]</pre></div></li><li class="listitem">Create a list of strings with one character deleted, as follows:<div><pre class="programlisting">  deletes = [ a ++ (tail b) | 
    (a,b) &lt;- splits, (not.null) b]</pre></div></li><li class="listitem">Create a list of strings with two characters swapped, as follows:<div><pre class="programlisting">  transposes = [a ++ [b!!1] ++ [head b] ++ (drop 2 b) | 
    (a,b) &lt;- splits, length b &gt; 1 ]</pre></div></li><li class="listitem">Create a list of strings with one of the characters replaced by another letter in the alphabet, as follows:<div><pre class="programlisting">  replaces  = [ a ++ [c] ++ (drop 1 b) 
    | (a,b) &lt;- splits
    , c &lt;- alphabet
    , (not.null) b ]</pre></div></li><li class="listitem">Create a list of strings with one character inserted anywhere, as follows:<div><pre class="programlisting">  inserts = [a ++ [c] ++ b 
  | (a,b) &lt;- splits
  , c &lt;- alphabet ]</pre></div></li><li class="listitem">Define the alphabet and a helper function to convert a string to lowercase as follows:<div><pre class="programlisting">  alphabet = ['a'..'z']
  word' = map toLower word</pre></div></li><li class="listitem">Define <a id="id225" class="indexterm"/>a helper function to obtain unique elements from a list, as follows:<div><pre class="programlisting">  unique :: [String] -&gt; [String]
  unique = map head.group.sort</pre></div></li><li class="listitem">Print out all possible strings that are one-edit distance away from the following string, as follows:<div><pre class="programlisting">main = print $ edits1 "hi"</pre></div></li></ol></div><p>The result is, as follows:</p><div><pre class="programlisting">
<strong>["ahi","ai","bhi","bi","chi","ci","dhi","di","ehi","ei","fhi","fi","ghi","gi","h","ha","hai","hb","hbi","hc","hci","hd","hdi","he","hei","hf","hfi","hg","hgi","hh","hhi","hi","hia","hib","hic","hid","hie","hif","hig","hih","hii","hij","hik","hil","him","hin","hio","hip","hiq","hir","his","hit","hiu","hiv","hiw","hix","hiy","hiz","hj","hji","hk","hki","hl","hli","hm","hmi","hn","hni","ho","hoi","hp","hpi","hq","hqi","hr","hri","hs","hsi","ht","hti","hu","hui","hv","hvi","hw","hwi","hx","hxi","hy","hyi","hz","hzi","i","ih","ihi","ii","jhi","ji","khi","ki","lhi","li","mhi","mi","nhi","ni","ohi","oi","phi","pi","qhi","qi","rhi","ri","shi","si","thi","ti","uhi","ui","vhi","vi","whi","wi","xhi","xi","yhi","yi","zhi","zi"]</strong>
</pre></div><p>More intuitively, we've created a neighborhood of words that are different by only 1 insertion, deletion, or substitution, or transpositions. The following figure tries to show this neighborhood:</p><div><img src="img/6331OS_03_04.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec128"/>There's more...</h2></div></div></div><p>We can recursively apply <code class="literal">edit1</code> to find strings that are an arbitrary edit distance away. However, for values of <em>n</em> greater than three, this will take an unacceptably long time. In the following code, <code class="literal">edits1</code><a id="id226" class="indexterm"/>
<code class="literal">'</code> is a function that takes in a list of strings and produces all strings that are one-edit distance away from these. Then in <code class="literal">editsN</code>, we simply apply the <code class="literal">edits1'</code> function iteratively as follows:</p><div><pre class="programlisting">edits1' :: [String] -&gt; [String]
edits1' ls = unique $ concat $ map edits1 ls

editsN :: String -&gt; Int -&gt; [String]
editsN word n = iterate edits1' (edits1 word) !! n</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec129"/>See also</h2></div></div></div><p>This function is very useful in implementing a spell corrector described in the <em>Fixing spelling mistakes</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec48"/>Fixing spelling mistakes</h1></div></div></div><p>When gathering human-provided data, spelling mistakes may sneak in. This recipe will correct a misspelled word<a id="id227" class="indexterm"/> using Peter Norvig's simple heuristic spellchecker<a id="id228" class="indexterm"/> described at <a class="ulink" href="http://norvig.com/spell-correct.html">http://norvig.com/spell-correct.html</a>.</p><p>This recipe is just one approach to a very difficult problem in machine learning. We can use it as a starting point or as an influence to implement a more powerful solution with better results.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec130"/>Getting ready</h2></div></div></div><p>Refer to Norvig's spell-correction Python algorithm<a id="id229" class="indexterm"/> located at <a class="ulink" href="http://norvig.com/spell-correct.html">http://norvig.com/spell-correct.html</a>.</p><p>The core algorithm <a id="id230" class="indexterm"/>works as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transform raw text into lowercase alphabetical words</li><li class="listitem" style="list-style-type: disc">Compute a frequency map of all the words</li><li class="listitem" style="list-style-type: disc">Define functions to produce all strings within an edit distance of one or two</li><li class="listitem" style="list-style-type: disc">Find all possible candidates of a misspelling by looking up valid words within this edit distance of one or two</li><li class="listitem" style="list-style-type: disc">Finally, pick out the candidate with the highest frequency of occurrence in the trained corpus</li></ul></div><p>The Haskell algorithm<a id="id231" class="indexterm"/> below mimics this Python code.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec131"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the following functions:<div><pre class="programlisting">import Data.Char (isAlpha, isSpace, toLower)
import Data.List (group, sort, maximumBy)
import Data.Ord (comparing)
import Data.Map (fromListWith, Map, member, (!))</pre></div></li><li class="listitem">Define a <a id="id232" class="indexterm"/>function to automatically correct the spelling of each word in a sentence:<div><pre class="programlisting">autofix :: Map String Int -&gt; String -&gt; String

autofix m sentence = unwords $ 
                     map (correct m) (words sentence)</pre></div></li><li class="listitem">Get the words from a body of text.<div><pre class="programlisting">getWords :: String -&gt; [String]

getWords str = words $ 
               filter (\x -&gt; isAlpha x || isSpace x) lower

  where lower = map toLower str</pre></div></li><li class="listitem">Compute a frequency map of the words provided, as follows:<div><pre class="programlisting">train :: [String] -&gt; Map String Int

train = fromListWith (+) . ('zip' repeat 1)</pre></div></li><li class="listitem">Find strings one-edit distance away as follows:<div><pre class="programlisting">edits 1 :: String -&gt; [String]

edits1 word = unique $ 
              deletes ++ transposes ++ replaces ++ inserts

  where splits = [ (take i word', drop i word') 
                  | i &lt;- [0..length word']]

  deletes = [ a ++ (tail b) 
                  | (a,b) &lt;- splits
                  , (not.null) b ]

  transposes = [ a ++ [b !! 1] ++ [head b] ++ (drop 2 b) 
                  | (a,b) &lt;- splits, length b &gt; 1 ]

  replaces = [ a ++ [c] ++ (drop 1 b) 
                  | (a,b) &lt;- splits, c &lt;- alphabet
                  , (not.null) b ]

  inserts = [a ++ [c] ++ b | 
                    (a,b) &lt;- splits, c &lt;- alphabet ]

  alphabet = ['a'..'z']

  word' = map toLower word</pre></div></li><li class="listitem">Find words that are apart by an edit distance of two:<div><pre class="programlisting">knownEdits2 :: String -&gt; Map String a -&gt; [String]

knownEdits2 word m = unique $ [ e2 
                              | e1 &lt;- edits1 word
                              , e2 &lt;- edits1 e1
                              , e2 'member' m]</pre></div></li><li class="listitem">Define a<a id="id233" class="indexterm"/> helper function to obtain unique elements from a list, as follows:<div><pre class="programlisting">unique :: [String] -&gt; [String]

unique = map head.group.sort</pre></div></li><li class="listitem">Find known words from a list of strings as follows:<div><pre class="programlisting">known :: [String] -&gt; Map String a -&gt; [String]

known ws m = filter ('member' m) ws</pre></div></li><li class="listitem">Correct a spelling mistake by returning the most common candidate as follows:<div><pre class="programlisting">correct :: Map String Int -&gt; String -&gt; String

correct m word = maximumBy (comparing (m!)) candidates
  where candidates = head $ filter (not.null) 
                     [ known [word] m 
                     , known (edits1 word) m
                     , knownEdits2 word m
                     , [word] ]</pre></div></li><li class="listitem">Gather a list of known words used in common literature from <code class="literal">big.txt</code>. The file is available at <a class="ulink" href="http://norvig.com/big.txt">http://norvig.com/big.txt</a>, or we can make our own. Test out the spell corrector as follows:<div><pre class="programlisting">main :: IO ()

main = do
  rawText &lt;- readFile "big.txt"
  let m = train $ getWords rawText
  let sentence = "such codez many hsakell very spel so korrect"
  print $ autofix m sentence</pre></div></li><li class="listitem">The correct spellings are printed out as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>"such code many haskell very spell so correct"</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec132"/>How it works...</h2></div></div></div><p>The algorithm assumes <a id="id234" class="indexterm"/>that spelling mistakes occur one- or two-edit distances away. It establishes a list of known words within one- or two-edit distances and returns the most commonly used word based on the frequency map generated by reading in a corpus of real-world text.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec133"/>There's more...</h2></div></div></div><p>This algorithm runs quickly, but it is very simplistic. This recipe provides a starting point to implement a spell corrector, but is certainly not state of the art. Some improvements that can be added to the code could involve parallelizing, caching, or designing better heuristics.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec134"/>See also</h2></div></div></div><p>For more in-depth analysis about the <code class="literal">edit1</code> function, refer to the <em>Finding strings within one-edit distance</em> recipe.</p></div></div></body></html>