<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 1. The Groundwork – Julia's Environment"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch01" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Chapter 1. The Groundwork – Julia's Environment</h1></div></div></div><p class="calibre11">Julia is a fairly young programming language. In 2009, three developers (Stefan Karpinski, Jeff Bezanson, and Viral Shah) at MIT in the Applied Computing group under the supervision of Prof. Alan Edelman started working on a project that lead to Julia. In February 2012, Julia was presented publicly and became open source. The source code is available on GitHub (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>). The source of the registered packages can also be found on GitHub. Currently, all four of the initial creators, along with developers from around the world, actively contribute to Julia.</p><div class="note" title="Note"><div class="inner"><h3 class="title4"><a id="note3" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Note</h3><p class="calibre26">The current release is 0.4 and is still away from its 1.0 release candidate.</p></div></div><p class="calibre11">Based on solid principles, its popularity is steadily increasing in the field of scientific computing, data science, and high-performance computing.</p><p class="calibre11">This chapter will guide you through the download and installation of all the necessary components of Julia. This chapter covers the following topics:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">How is Julia different?</li><li class="listitem">Setting up Julia's environment.</li><li class="listitem">Using Julia's shell and REPL.</li><li class="listitem">Using Jupyter notebooks</li><li class="listitem">Package management</li><li class="listitem">Parallel computation</li><li class="listitem">Multiple dispatch</li><li class="listitem">Language interoperability</li></ul></div><p class="calibre11">Traditionally, the scientific community has used slower dynamic languages to build their applications, although they have required the highest computing performance. Domain experts who had experience with programming, but were not generally seasoned developers, always preferred dynamic languages over statically typed languages.</p><div class="calibre2" title="Julia is different"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec7" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Julia is different</h1></div></div></div><p class="calibre11">Over the years, with the advancement in compiler techniques and language design, it is possible to eliminate the trade-off between performance and dynamic prototyping. So, the scientific computing required was a good dynamic language like Python together with performance like C. And then came Julia, a general purpose programming language designed according to the requirements of scientific and technical computing, providing performance comparable to C/C++, and with an environment productive enough for prototyping like the high-level dynamic language of Python. The key to Julia's performance is its design and <span class="strong"><strong class="calibre19">Low Level Virtual Machine</strong></span> (LLVM) based Just-in-Time compiler which enables it to approach the performance of C and Fortran.</p><p class="calibre11">The key features offered by Julia are:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">A general purpose high-level dynamic programming language designed to be effective for numerical and scientific computing</li><li class="listitem">A <span class="strong"><strong class="calibre19">Low-Level Virtual Machine </strong></span>(<span class="strong"><strong class="calibre19">LLVM</strong></span>) based <span class="strong"><strong class="calibre19">Just-in-Time</strong></span> (<span class="strong"><strong class="calibre19">JIT</strong></span>) compiler that enables Julia to approach the performance of statically-compiled languages like C/C++</li></ul></div><p class="calibre11">The following quote is from the development team of Julia—Jeff Bezanson, Stefan Karpinski, Viral Shah, and Alan Edelman:</p><div class="note" title="Note"><div class="inner"><h3 class="title2"><a id="note4" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Note</h3><p class="calibre26">
</p><p class="calibre26">
<span class="strong"><strong class="calibre19">We are greedy: we want more.</strong></span>
</p><p class="calibre26">
</p><p class="calibre26">We want a language that's open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that's homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.</p><p class="calibre26">
</p><p class="calibre26">(Did we mention it should be as fast as C?)</p><p class="calibre26">
</p></div></div><p class="calibre11">It is quite often compared with Python, R, MATLAB, and Octave. These have been around for quite some time and Julia is highly influenced by them, especially when it comes to numerical and scientific computing. Although Julia is really good at it, it is not restricted to just scientific computing as it can also be used for web and general purpose programming.</p><p class="calibre11">The development team of Julia aims to create a remarkable and never done before combination of power and efficiency without compromising the ease of use in one single language. Most of Julia's core is implemented in C/C++. Julia's parser is written in Scheme. Julia's efficient and cross-platform I/O is provided by the Node.js's libuv.</p><p class="calibre11">Features and advantages of Julia can be summarized as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">It's designed for distributed and parallel computation.</li><li class="listitem">Julia provides an extensive library of mathematical functions with great numerical accuracy.</li><li class="listitem">Julia gives the functionality of multiple dispatch. Multiple dispatch refers to using many combinations of argument types to define function behaviors.</li><li class="listitem">The Pycall package enables Julia to call Python functions in its code and Matlab packages using Matlab.jl. Functions and libraries written in C can also be called directly without any need for APIs or wrappers.</li><li class="listitem">Julia provides powerful shell-like capabilities for managing other processes in the system.</li><li class="listitem">Unlike other languages, user-defined types in Julia are compact and quite fast as built-ins.</li><li class="listitem">Data analysis makes great use of vectorized code to gain performance benefits. Julia eliminates the need to vectorize code to gain performance. De-vectorized code written in Julia can be as fast as vectorized code.</li><li class="listitem">It uses lightweight "green" threading also known as tasks or coroutines, cooperative multitasking, or one-shot continuations.</li><li class="listitem">Julia has a powerful type system. The conversions provided are elegant and extensible.</li><li class="listitem">It has efficient support for Unicode.</li><li class="listitem">It has facilities for metaprogramming and Lisp-like macros.</li><li class="listitem">It has a built-in package manager. (Pkg)</li><li class="listitem">Julia provides efficient, specialized and automatic generation of code for different argument types.</li><li class="listitem">It's free and open source with an MIT license.</li></ul></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Setting up the environment"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec8" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Setting up the environment</h1></div></div></div><p class="calibre11">Julia is available free. It can be downloaded from its website at the following address: <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://julialang.org/downloads/">http://julialang.org/downloads/</a>. The website also has exhaustive documentation, examples, and links to tutorials and community. The documentation can be downloaded in popular formats.</p><div class="calibre2" title="Installing Julia (Linux)"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec6" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Installing Julia (Linux)</h2></div></div></div><p class="calibre11">Ubuntu/Linux Mint is one of the most famous Linux distros, and their deb packages of Julia are also provided. These are available for both 32-bit and 64-bit distributions.</p><p class="calibre11">To install Julia, add the <span class="strong"><strong class="calibre19">PPA</strong></span> (<span class="strong"><strong class="calibre19">personal package archive</strong></span>). Ubuntu users are privileged enough to have PPA. It is treated as an apt repository to build and publish Ubuntu source packages. In the terminal, type the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">sudo apt-get add-repository ppa:staticfloat/juliareleases 
sudo apt-get update 
</strong></span>
</pre><p class="calibre11">This adds the PPA and updates the package index in the repository.</p><p class="calibre11">Now install Julia:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">sudo apt-get install Julia  
</strong></span>
</pre><p class="calibre11">The installation is complete. To check if the installation is successful in the Terminal type in the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia --version 
</strong></span>
</pre><p class="calibre11">This gives the installed Julia's version.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/image_01_001.jpg" alt="Installing Julia (Linux)" class="calibre28"/></div><p class="calibre11">
</p><p class="calibre11">To open the Julia's interactive shell, type <code class="literal">julia</code> into the Terminal. To uninstall Julia, simply use <code class="literal">apt</code> to remove it:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">sudo apt-get remove julia 
</strong></span>
</pre><p class="calibre11">For Fedora/RHEL/CentOS or distributions based on them, enable the EPEL repository for your distribution version. Then, click on the link provided. Enable Julia's repository using the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">dnf copr enable nalimilan/julia</strong></span>
</pre><p class="calibre11">Or copy the relevant <code class="literal">.repo</code> file available as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">/etc/yum.repos.d/</strong></span>
</pre><p class="calibre11">Finally, in the Terminal type the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">yum install julia</strong></span>
</pre></div><div class="calibre2" title="Installing Julia (Mac)"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec7" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Installing Julia (Mac)</h2></div></div></div><p class="calibre11">Users with Mac OS X need to click on the downloaded <code class="literal">.dmg</code> file to run the disk image. After that, drag the app icon into the <span class="strong"><strong class="calibre19">Applications</strong></span> folder. It may prompt you to ask if you want to continue as the source has been downloaded from the Internet and so is not considered secure. Click on continue if it is downloaded for the Julia language official website.</p><p class="calibre11">Julia can also be installed using homebrew on the Mac as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">brew update 
brew tap staticfloat/julia 
brew install julia 
</strong></span>
</pre><p class="calibre11">The installation is complete. To check if the installation is successful in the Terminal, type the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia --version 
</strong></span>
</pre><p class="calibre11">This gives you the installed Julia version.</p></div><div class="calibre2" title="Installing Julia (Windows)"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec8" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Installing Julia (Windows)</h2></div></div></div><p class="calibre11">Download the <code class="literal">.exe</code> file provided on the download page according to your system's configuration (32-bit/64-bit). Julia is installed on Windows by running the downloaded <code class="literal">.exe</code> file, which will extract Julia into a folder. Inside this folder is a batch file called <code class="literal">julia.bat</code>, which can be used to start the Julia console.</p><p class="calibre11">To uninstall, delete the <code class="literal">Julia</code> folder.</p></div><div class="calibre2" title="Exploring the source code"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec9" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Exploring the source code</h2></div></div></div><p class="calibre11">For enthusiasts, Julia's source code is available and users are encouraged to contribute by adding features or by bug fixing. This is the directory structure of the tree:</p><div class="informaltable"><table border="1" class="calibre12"><colgroup class="calibre13"><col class="calibre14"/><col class="calibre14"/></colgroup><tbody class="calibre15"><tr class="calibre16"><td class="calibre17">
<p class="calibre18">
<code class="literal">base/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Source code for Julia's standard library</p>
</td></tr><tr class="calibre20"><td class="calibre17">
<p class="calibre18">
<code class="literal">contrib/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Editor support for Julia source, miscellaneous scripts</p>
</td></tr><tr class="calibre16"><td class="calibre17">
<p class="calibre18">
<code class="literal">deps/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">External dependencies</p>
</td></tr><tr class="calibre20"><td class="calibre17">
<p class="calibre18">
<code class="literal">doc/manual</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Source for the user manual</p>
</td></tr><tr class="calibre16"><td class="calibre17">
<p class="calibre18">
<code class="literal">doc/stdlib</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Source for standard library function help text</p>
</td></tr><tr class="calibre20"><td class="calibre17">
<p class="calibre18">
<code class="literal">examples/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Example Julia programs</p>
</td></tr><tr class="calibre16"><td class="calibre17">
<p class="calibre18">
<code class="literal">src/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Source for Julia language core</p>
</td></tr><tr class="calibre20"><td class="calibre17">
<p class="calibre18">
<code class="literal">test/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Test suites</p>
</td></tr><tr class="calibre16"><td class="calibre17">
<p class="calibre18">
<code class="literal">test/perf</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Benchmark suites</p>
</td></tr><tr class="calibre20"><td class="calibre17">
<p class="calibre18">
<code class="literal">ui/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Source for various frontends</p>
</td></tr><tr class="calibre29"><td class="calibre17">
<p class="calibre18">
<code class="literal">usr/</code>
</p>
</td><td class="calibre17">
<p class="calibre18">Binaries and shared libraries loaded by Julia's standard libraries</p>
</td></tr></tbody></table></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Using REPL"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec9" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Using REPL</h1></div></div></div><p class="calibre11">Read-Eval-Print-Loop is an interactive shell or the language shell that provides the functionality to test out pieces of code. Julia provides an interactive shell with a Just-in-Time compiler at the backend. We can give inputs in a line, it is compiled and evaluated, and the result is given in the next line.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/image_01_002.jpg" alt="Using REPL" class="calibre30"/></div><p class="calibre11">
</p><p class="calibre11">The benefit of using the REPL is that we can test out our code for possible errors. Also, it is a good environment for beginners. We can type in the expressions and press <span class="strong"><em class="calibre23">Enter</em></span> to evaluate.</p><p class="calibre11">A Julia library, or custom-written Julia program, can be included in the REPL using <code class="literal">include</code>. For example, I have a file called <code class="literal">hello.jl</code>, which I will include in the REPL by doing the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; include ("hello.jl") 
</strong></span>
</pre><p class="calibre11">Julia also stores all the commands written in the REPL in the <code class="literal">.julia_history</code>. This file is located at <code class="literal">/home/$USER</code> on Ubuntu, <code class="literal">C:\Users\username</code> on Windows, or <code class="literal">~/.julia_history</code> on OS X.</p><p class="calibre11">As with a Linux Terminal, we can reverse-search using <span class="strong"><em class="calibre23">Ctrl</em></span> + <span class="strong"><em class="calibre23">R</em></span> in Julia's shell. This is a really nice feature as we can go back in the history of typed commands.</p><p class="calibre11">Typing <code class="literal">?</code> in the language shell will change the prompt to:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">help?&gt;  
</strong></span>
</pre><p class="calibre11">
</p><div class="mediaobject"><img src="Images/image_01_003.jpg" alt="Using REPL" class="calibre31"/></div><p class="calibre11">
</p><p class="calibre11">To clear the screen, press <span class="strong"><em class="calibre23">Ctrl</em></span> + <span class="strong"><em class="calibre23">L</em></span>. To come out of the REPL press <span class="strong"><em class="calibre23">Ctrl</em></span> + <span class="strong"><em class="calibre23">D</em></span> or type the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; exit().
</strong></span>
</pre></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Using Jupyter Notebook"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec10" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Using Jupyter Notebook</h1></div></div></div><p class="calibre11">Data science and scientific computing are privileged to have an amazing interactive tool called Jupyter Notebook. With Jupyter Notebook you can to write and run code in an interactive web environment, which also has the capability to have visualizations, images, and videos. It makes testing of equations and prototyping a lot easier. It has the support of over 40 programming languages and is completely open source.</p><p class="calibre11">GitHub supports Jupyter notebooks. The notebook with the record of computation can be shared via the Jupyter notebook viewer or other cloud storage. Jupyter notebooks are extensively used for coding machine-learning algorithms, statistical modeling and numerical simulation, and data munging.</p><p class="calibre11">Jupyter Notebook is implemented in Python but you can run the code in any of the 40 languages provided you have their kernel. You can check if Python is installed on your system or not by typing the following into the Terminal:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">python -version 
</strong></span>
</pre><p class="calibre11">This will give the version of Python if it is there on the system. It is best to have Python 2.7.x or 3.5.x or a later version.</p><p class="calibre11">If Python is not installed then you can install it by downloading it from the official website for Windows. For Linux, typing the following should work:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">sudo apt-get install python 
</strong></span>
</pre><p class="calibre11">It is highly recommended to install Anaconda if you are new to Python and data science. Commonly used packages for data science, numerical, and scientific computing including Jupyter notebook come bundled with Anaconda making it the preferred way to set up the environment. Instructions can be found at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://www.continuum.io/downloads">https://www.continuum.io/downloads</a>.</p><p class="calibre11">Jupyter is present in the Anaconda package, but you can check if the Jupyter package is up to date by typing in the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">conda install jupyter 
</strong></span>
</pre><p class="calibre11">Another way to install Jupyter is by using <code class="literal">pip</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">pip install jupyter 
</strong></span>
</pre><p class="calibre11">To check if Jupyter is installed properly, type the following in the Terminal:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">jupyter -version 
</strong></span>
</pre><p class="calibre11">It should give the version of the Jupyter if it is installed.</p><p class="calibre11">Now, to use Julia with Jupyter we need the <code class="literal">IJulia</code> package. This can be installed using Julia's package manager.</p><p class="calibre11">After installing IJulia, we can create a new notebook by selecting Julia under the <span class="strong"><strong class="calibre19">Notebooks</strong></span> section in Jupyter.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/image_01_004.jpg" alt="Using Jupyter Notebook" class="calibre32"/></div><p class="calibre11">
</p><p class="calibre11">To get the latest version of all your packages, in Julia's shell type the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; Pkg.update() 
</strong></span>
</pre><p class="calibre11">After that add the IJulia package by typing the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; Pkg.add("IJulia") 
</strong></span>
</pre><p class="calibre11">In Linux, you may face some warnings, so it's better to build the package:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; Pkg.build("IJulia") 
</strong></span>
</pre><p class="calibre11">After IJulia is installed, come back to the Terminal and start the Jupyter notebook:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">jupyter notebook 
</strong></span>
</pre><p class="calibre11">A browser window will open. Under <span class="strong"><strong class="calibre19">New</strong></span>, you will find options to create new notebooks with the kernels already installed. As we want to start a Julia notebook we will select <span class="strong"><strong class="calibre19">Julia 0.4.2</strong></span>. This will start a new Julia notebook. You can try out a simple example.</p><p class="calibre11">In this example, we are creating a histogram of random numbers. This is just an example we will be studying the components used in detail in coming chapters.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/image_01_005.jpg" alt="Using Jupyter Notebook" class="calibre33"/></div><p class="calibre11">
</p><p class="calibre11">Popular editors such as Atom and Sublime have a plugin for Julia. Atom has language—julia and Sublime has Sublime—IJulia, both of which can be downloaded from their package managers.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Package management"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec11" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Package management</h1></div></div></div><p class="calibre11">Julia provides a built-in package manager. Using Pkg we can install libraries written in Julia. For external libraries, we can also compile them from their source or use the standard package manager of the operating system. A list of registered packages is maintained at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://pkg.julialang.org">http://pkg.julialang.org</a>.</p><p class="calibre11">Pkg is provided in the base installation. The Pkg module contains all the package manager commands.</p><div class="calibre2" title="Pkg.status() – package status"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec10" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Pkg.status() – package status</h2></div></div></div><p class="calibre11">The <code class="literal">Pkg.status()</code> is a function that prints out a list of currently installed packages with a summary. This is handy when you need to know if the package you want to use is installed or not.</p><p class="calibre11">When the <code class="literal">Pkg</code> command is run for the first time, the package directory is automatically created. It is required by the command that the <code class="literal">Pkg.status()</code> returns a valid list of the packages installed. The list of packages given by the <code class="literal">Pkg.status()</code> are of registered versions which are managed by Pkg.</p><p class="calibre11">
<code class="literal">Pkg.installed()</code> can also be used to return a list of all the installed packages with their versions.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/image_01_006.jpg" alt="Pkg.status() – package status" class="calibre34"/></div><p class="calibre11">
</p></div><div class="calibre2" title="Pkg.add() – adding packages"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec11" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Pkg.add() – adding packages</h2></div></div></div><p class="calibre11">Julia's package manager is declarative and intelligent. You only have to tell it what you want and it will figure out what version to install and will resolve dependencies if there are any. Therefore, we only need to add the list of requirements that we want and it resolves which packages and their versions to install.</p><p class="calibre11">The <code class="literal">~/.julia/v0.4/REQUIRE</code> file contains the package requirements. We can open it using a text editor such as vi or atom, or use <code class="literal">Pkg.edit()</code> in Julia's shell to edit this file. After editing the file, run <code class="literal">Pkg.resolve()</code> to install or remove the packages.</p><p class="calibre11">We can also use <code class="literal">Pkg.add(package_name)</code> to add packages and <code class="literal">Pkg.rm(package_name)</code> to remove packages. Earlier, we used <code class="literal">Pkg.add("IJulia")</code>  to install the IJulia package.</p><p class="calibre11">When we don't want to have a package installed on our system anymore, <code class="literal">Pkg.rm()</code> is used for removing the requirement from the <code class="literal">REQUIRE</code> file. Similar to <code class="literal">Pkg.add()</code>, <code class="literal">Pkg.rm()</code> first removes the requirement of the package from the <code class="literal">REQUIRE</code> file and then updates the list of installed packages by running <code class="literal">Pkg.resolve()</code> to match.</p></div><div class="calibre2" title="Working with unregistered packages"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec12" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Working with unregistered packages</h2></div></div></div><p class="calibre11">Frequently, we would like to be able to use packages created by our team members or someone who has published on Git but they are not in the registered packages of Pkg. Julia allows us to do that by using a clone. Julia packages are hosted on Git repositories and can be cloned using mechanisms supported by Git. The index of registered packages is maintained at <code class="literal">METADATA.jl</code>. For unofficial packages, we can use the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">Pkg.clone("git://example.com/path/unofficialPackage/Package.jl.git") 
</strong></span>
</pre><p class="calibre11">Sometimes unregistered packages have dependencies that require fulfilling before use. If that is the scenario, a <code class="literal">REQUIRE</code> file is needed at the top of the source tree of the unregistered package. The dependencies of the unregistered packages on the registered packages are determined by this <code class="literal">REQUIRE</code> file. When we run <code class="literal">Pkg.clone(url)</code>, these dependencies are automatically installed.</p><div class="calibre2" title="Pkg.update() – package update"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title5"><a id="ch01lvl3sec0" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Pkg.update() – package update</h3></div></div></div><p class="calibre11">It's good to have updated packages.  Julia, which is under active development, has its packages frequently updated and new functionalities are added.</p><p class="calibre11">To update all of the packages, type the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">Pkg.update() 
</strong></span>
</pre><p class="calibre11">Under the hood, new changes are pulled into the METADATA file in the directory located at <code class="literal">~/.julia/v0.4/ </code>and it checks for any new registered package versions which may have been published since the last update. If there are new registered package versions, <code class="literal">Pkg.update()</code> attempts to update the packages which are not dirty and are checked out on a branch. This update process satisfies the top-level requirements by computing the optimal set of package versions to be installed. The packages with specific versions that must be installed are defined in the REQUIRE file in Julia's directory (<code class="literal">~/.julia/v0.4/</code>).</p></div></div><div class="calibre2" title="METADATA repository"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec13" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>METADATA repository</h2></div></div></div><p class="calibre11">Registered packages are downloaded and installed using the official <code class="literal">METADATA.jl</code> repository. A different <code class="literal">METADATA</code> repository location can also be provided if required:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; Pkg.init("https://julia.customrepo.com/METADATA.jl.git", "branch") 
</strong></span>
</pre></div><div class="calibre2" title="Developing packages"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec14" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Developing packages</h2></div></div></div><p class="calibre11">Julia allows us to view the source code and as it is tracked by Git, the full development history of all the installed packages is available. We can also make our desired changes and commit to our own repository, or do bug fixes and contribute enhancements upstream.</p><p class="calibre11">You may also want to create your own packages and publish them at some point in time. Julia's package manager allows you to do that too.</p><p class="calibre11">It is a requirement that Git is installed on the system and the developer needs an account at their hosting provider of choice (GitHub, Bitbucket, and so on). Having the ability to communicate over SSH is preferred—to enable that, upload your public ssh-key to your hosting provider.</p></div><div class="calibre2" title="Creating a new package"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec15" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Creating a new package</h2></div></div></div><p class="calibre11">It is preferable to have the <code class="literal">REQUIRE</code> file in the package repository. This should have the bare minimum of a description of the Julia version.</p><p class="calibre11">For example, if we would like to create a new Julia package called <code class="literal">HelloWorld</code> we would have the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">Pkg.generate("HelloWorld", "MIT") 
</strong></span>
</pre><p class="calibre11">Here, <code class="literal">HelloWorld</code> is the package that we want to create and <code class="literal">MIT</code> is the license that our package will have. The license should be known to the package generator.</p><p class="calibre11">This will create a directory as follows: <code class="literal">~/.julia/v0.4/HelloWorld</code>. The directory that is created is initialized as a Git repository. Also, all the files required by the package are kept in this directory. This directory is then committed to the repository.</p><p class="calibre11">This can now be pushed to the remote repository for the world to use.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Parallel computation using Julia"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec12" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Parallel computation using Julia</h1></div></div></div><p class="calibre11">Advancement in modern computing has led to multi-core CPUs in systems and sometimes these systems are combined together in a cluster capable of performing a task which a single system might not be able to perform alone, or if it did it would take an undesirable amount of time. Julia's environment of parallel processing is based on message passing. Multiple processes are allowed for programs in separate memory domains.</p><p class="calibre11">Message passing is implemented differently in Julia from other popular environments such as MPI. Julia provides one-sided communication, therefore the programmer explicitly manages only one process in the two-process operation.</p><p class="calibre11">Julia's parallel programming paradigm is built on the following:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Remote references</li><li class="listitem">Remote calls</li></ul></div><p class="calibre11">A request to run a function on another process is called a remote call. The reference to an object by another object on a particular process is called a remote reference. A remote reference is a construct used in most distributed object systems. Therefore, a call which is made with some specific arguments to the objects generally on a different process by the objects of the different process is called the remote call and this will return a reference to the remote object which is called the remote reference.</p><p class="calibre11">The remote call returns a remote reference to its result. Remote calls return immediately. The process that made the call proceeds to its next operation. Meanwhile, the remote call happens somewhere else. A call to <code class="literal">wait()</code> on its remote reference waits for the remote call to finish. The full value of the result can be obtained using <code class="literal">fetch()</code>, and <code class="literal">put!()</code> is used to store the result to a remote reference.</p><p class="calibre11">Julia uses a single process default. To start Julia with multiple processors use the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia -p n</strong></span>
</pre><p class="calibre11">where n is the number of worker processes. Alternatively, it is possible to create extra processors from a running system by using <code class="literal">addproc(n)</code>. It is advisable to put n equal to the number of the CPU cores in the system.</p><p class="calibre11">
<code class="literal">pmap</code> and <code class="literal">@parallel </code>are the two most frequently used and useful functions.</p><p class="calibre11">Julia provides a <span class="strong"><em class="calibre23">parallel for loop,</em></span> used to run a number of processes in parallel. This is used as follows.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/B05321_01_8.jpg" alt="Parallel computation using Julia" class="calibre35"/></div><p class="calibre11">
</p><p class="calibre11">
<span class="strong"><em class="calibre23">Parallel for loop</em></span> works by having multiple processes assigned iterations and then reducing the result (in this case (+)). It is somewhat similar to the map-reduce concept. Iterations will run independently over different processes and the results obtained by these processes will be combined at the end (like map-reduce). The resultant of one loop can also become the feeder for the other loop. The answer is the resultant of this whole parallel loop.</p><p class="calibre11">It is very different than a normal iterative loop because the iterations do not take place in a specified sequence. As the iterations run on different processes, any writes that happens on variables or arrays are not globally visible. The variables used are copied and broadcasted to each process of the parallel for loop.</p><p class="calibre11">For example:</p><pre class="programlisting">arr = zeros(500000) 
@parallel for i=1:500000 
  arr[i] = i 
end 
</pre><p class="calibre11">This will not give the desired result as each process gets their own separate copy of <code class="literal">arr</code>. The vector will not be filled in with <code class="literal">i</code> as expected. We must avoid such <span class="strong"><em class="calibre23">parallel for loops</em></span>.</p><p class="calibre11">
<code class="literal">pmap</code> refers to parallel map. For example:</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/B05321_01_7.jpg" alt="Parallel computation using Julia" class="calibre36"/></div><p class="calibre11">
</p><p class="calibre11">This code solves the problem if we have a number of large random matrices and we are required to obtain the singular values, in parallel.</p><p class="calibre11">Julia's <code class="literal">pmap()</code> is designed differently. It is well suited for cases where a large amount of work is done by each function call, whereas <code class="literal">@parallel</code> is suited for handling situations which involve numerous small iterations. Both <code class="literal">pmap()</code> and <code class="literal">@parallel</code> for utilize worker nodes for parallel computation. However, the node from which the calling process originated does the final reduction in <code class="literal">@parallel</code> for.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Julia's key feature – multiple dispatch"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec13" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Julia's key feature – multiple dispatch</h1></div></div></div><p class="calibre11">A function is an object, mapping a tuple of arguments using some expression to a return value. When this function object is unable to return a value, it throws an exception. For different types of arguments the same conceptual function can have different implementations. For example, we can have a function to add two floating point numbers and another function to add two integers. But conceptually, we are only adding two numbers. Julia provides a functionality by which different implementations of the same concept can be implemented easily. The functions don't need to be defined all at once. They are defined in small abstracts. These small abstracts are different argument type combinations and have different behaviors associated with them. The definition of one of these behaviors is called a method.</p><p class="calibre11">The types and the number of arguments that a method definition accepts is indicated by the annotation of its signatures. Therefore, the most suitable method is applied whenever a function is called with a certain set of arguments. To apply a method when a function is invoked is known as dispatch. Traditionally, object-oriented languages consider only the first argument in dispatch. Julia is different as all of the function's arguments are considered (not just only the first) and then it choses which method should be invoked. This is known as multiple dispatch.</p><p class="calibre11">Multiple dispatch is particularly useful for mathematical and scientific code. We shouldn't consider that the operations belong to one argument more than any of the others. All of the argument types are considered when implementing a mathematical operator. Multiple dispatch is not limited to mathematical expressions as it can be used in numerous real-world scenarios and is a powerful paradigm for structuring the programs.</p><div class="calibre2" title="Methods in multiple dispatch"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec16" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Methods in multiple dispatch</h2></div></div></div><p class="calibre11">
<code class="literal">+ </code>is a function in Julia using multiple dispatch. Multiple dispatch is used by all of Julia's standard functions and operators. For various possible combinations of argument types and count, all of them have many methods defining their behavior. A method is restricted to take certain types of arguments using the <code class="literal">::</code> type-assertion operator:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; f(x::Float64, y::Float64) = x + y 
</strong></span>
</pre><p class="calibre11">The function definition will only be applied for calls where <code class="literal">x</code> and <code class="literal">y</code> are both values of type <code class="literal">Float64</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">julia&gt; f(10.0, 14.0) 
24.0 
</strong></span>
</pre><p class="calibre11">If we try to apply this definition to other types of arguments, it will give a method error.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/B05321_01_9.jpg" alt="Methods in multiple dispatch" class="calibre37"/></div><p class="calibre11">
</p><p class="calibre11">The arguments must be of precisely the same type as defined in the function definition.</p><p class="calibre11">The function object is created in the first method definition. New method definitions add new behaviors to the existing function object. When a function is invoked, the number and types of the arguments are matched, and the most specific method definition matching will be executed.</p><p class="calibre11">The following example creates a function with two methods. One method definition takes two arguments of the type <code class="literal">Float64</code> and adds them. The second method definition takes two arguments of the type <code class="literal">Number</code>, multiplies them by two and adds them. When we invoke the function with <code class="literal">Float64</code> arguments, then the first method definition is applied, and when we invoke the function with Integer arguments, the second method definition is applied as the number can take any numeric values. In the following example, we are playing with floating point numbers and integers using multiple dispatch.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/B05321_01_10.jpg" alt="Methods in multiple dispatch" class="calibre38"/></div><p class="calibre11">
</p><p class="calibre11">In Julia, all values are instances of the abstract type "Any". When the type declaration is not given with <code class="literal">::</code>, that means it is not specifically defined as the type of the argument, therefore Any is the default type of method parameter and it doesn't have the restriction of taking any type of value. Generally, one method definition is written in such a way that it will be applied to the certain arguments to which no other method definition applies. It is one of the Julia language's most powerful features.</p><p class="calibre11">It is efficient with a great ease of expressiveness to generate specialized code and implement complex algorithms without caring much about the low-level implementation using Julia's multiple dispatch and flexible parametric type system.</p></div><div class="calibre2" title="Ambiguities – method definitions"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec17" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Ambiguities – method definitions</h2></div></div></div><p class="calibre11">Sometimes function behaviors are defined in such a way that there isn't a unique method to apply for a certain set of arguments. Julia throws a warning in such cases about this ambiguity, but proceeds by arbitrarily picking a method. To avoid this ambiguity we should define a method to handle such cases.</p><p class="calibre11">In the following example, we define a method definition with one argument of the type <code class="literal">Any</code> and another argument of the type <code class="literal">Float64</code>. In the second method definition, we just changed the order, but this doesn't differentiate it from the first definition. In this case, Julia will give a warning of ambiguous method definition but will allow us to proceed.</p><p class="calibre11">
</p><div class="mediaobject"><img src="Images/B05321_01_11.jpg" alt="Ambiguities – method definitions" class="calibre39"/></div><p class="calibre11">
</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Facilitating language interoperability"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec14" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Facilitating language interoperability</h1></div></div></div><p class="calibre11">Although Julia can be used to write most kinds of code, there are mature libraries for numerical and scientific computing which we would like to exploit. These libraries can be in C, Fortran or Python. Julia allows the ease of using the existing code written in Python, C, or Fortran. This is done by making Julia perform simple and efficient-to-call C, Fortran, or Python functions.</p><p class="calibre11">The C/Fortran libraries should be available to Julia. An ordinary but valid call with <code class="literal">ccall </code>is made to this code. This is possible when the code is available as a shared library. Julia's JIT generates the same machine instructions as the native C call. Therefore, it is generally no different from calling through a C code with a minimal overhead.</p><p class="calibre11">Importing Python code can be beneficial and sometimes needed, especially for data science, because it already has an exhaustive library of implementations of machine learning and statistical functions. For example, it contains scikit-learn and pandas. To use Python in Julia, we require <code class="literal">PyCall.jl</code>. To add <code class="literal">PyCall.jl</code> do the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre19">Pkg.add("PyCall") 
</strong></span>
</pre><p class="calibre11">
</p><div class="mediaobject"><img src="Images/B05321_01_12.jpg" alt="Facilitating language interoperability" class="calibre40"/></div><p class="calibre11">
</p><p class="calibre11">PyCall contains a macro <code class="literal">@pyimport</code> that facilitates importing Python packages and provides Julia wrappers for all of the functions and constants therein, including automatic conversion of types between Julia and Python.</p><p class="calibre11">PyCall also provides functionalities for lower-level manipulation of Python objects, including a PyObject type for opaque Python objects. It also has a <code class="literal">pycall</code> function (similar to Julia's <code class="literal">ccall</code> function), which can be used in Julia to call Python functions with type conversions. PyCall does not use the Python program but links directly to the <code class="literal">libpython</code> library. During the <code class="literal">Pkg.build</code>, it finds the location of the <code class="literal">libpython</code> by Punning python.</p><div class="calibre2" title="Calling Python code in Julia"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch01lvl2sec18" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Calling Python code in Julia</h2></div></div></div><p class="calibre11">The <code class="literal">@pyimport</code> macro automatically makes the appropriate type conversions to Julia types in most of the scenarios based on a runtime inspection of the Python objects. It achieves better control over these type conversions by using lower-level functions. Using PyCall in scenarios where the return type is known can help in improving the performance, both by eliminating the overhead of runtime type inference, and also by providing more type information to the Julia compiler:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">pycall(function::PyObject, returntype::Type, args...)</code>: This calls the given Python function (typically looked up from a module) with the given <code class="literal">args...</code> (of standard Julia types which are converted automatically to the corresponding Python types if possible), converting the return value to <code class="literal">returntype</code> (use a <code class="literal">returntype</code> of PyObject to return the unconverted Python object reference, or PyAny to request an automated conversion).</li><li class="listitem"><code class="literal">pyimport(s)</code>: This imports the Python modules (a string or symbol) and returns a pointer to it (a PyObject). Functions or other symbols in the module may then be looked up by s[name] where the name is a string (for the raw PyObject) or a symbol (for automatic type conversion). Unlike the <code class="literal">@pyimport</code> macro, this does not define a Julia module and members cannot be accessed with an <code class="literal">s.name</code>.</li></ul></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec15" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>Summary</h1></div></div></div><p class="calibre11">In this chapter, we learned how Julia is different and how an LLVM-based JIT compiler enables Julia to approach the performance of C/C++. We introduced you to how to download Julia, install it, and build it from source. The notable features that we found were that the language is elegant, concise, and powerful and it has amazing capabilities for numeric and scientific computing.</p><p class="calibre11">We worked on some examples of working with Julia via the command line (REPL) and saw how full of features the language shell is. The features found were tab-completion, reverse-search, and help functions. We also discussed why should we use Jupyter Notebook and went on to set up Jupyter with the IJulia package. We worked on a simple example to use the Jupyter Notebook and Julia's visualization package, Gadfly.</p><p class="calibre11">In addition, we learned about Julia's powerful built-in package management and how to add, update, and remove modules. Also, we went through the process of creating our own package and publishing it to the community. We also introduced you to one of the most powerful features of Julia—multiple dispatch—and worked on some basic examples of how to create method definitions to implement multiple dispatch.</p><p class="calibre11">In addition, we introduced you to the parallel computation, explaining how it is different from conventional message passing and how to make use of all the compute resources available. We also learned Julia's feature of language interoperability and how we can call a Python module or a library from the Julia program.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="References"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec16" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9"/>References</h1></div></div></div><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://julialang.org/">http://julialang.org/</a></li><li class="listitem"><a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/JuliaLang">https://github.com/JuliaLang</a></li><li class="listitem"><a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/JuliaStats">https://github.com/JuliaStats</a></li></ul></div></div></div>



  </body></html>