<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Recommending the Right Products</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to dive deeper into building product recommendation systems with which we can target customers better, using product recommendations that are custom-tailored toward individual customers. Studies have shown that personalized product recommendations improve conversion rates and customer retention rates. As we have more data available for utilizing data science and machine learning for target marketing, the importance and effectiveness of customized product recommendations in marketing messages have grown significantly. In this chapter, we are going to discuss the commonly-used machine learning algorithms for developing recommendation systems, collaborative filtering, and the two approaches to implementing collaborative filtering algorithms for product recommendations.</p>
<p>I<span>n this chapte</span><span>r, we will cover the following topics:</span></p>
<ul>
<li>Collaborative filtering and product recommendation</li>
<li>Building a product recommendation algorithm with Python</li>
<li><span>Building a product recommendation algorithm with</span> R</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collaborative filtering and product recommendation</h1>
                </header>
            
            <article>
                
<p>According to a study conducted by Salesforce, those customers who are prompted with personalized product recommendations drive 24% of the orders and 26% of the revenue. This signifies how much impact product recommendation has on order volume and the overall sales revenue. In the report that Salesforce published, they have also found that product recommendations lead to repeat visits, purchases with recommendations yield higher average-order value, and customers do buy recommended items. You can view this report at: <a href="https://www.salesforce.com/blog/2017/11/personalized-product-recommendations-drive-just-7-visits-26-revenue">https://www.salesforce.com/blog/2017/11/personalized-product-recommendations-drive-just-7-visits-26-revenue</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product recommender system</h1>
                </header>
            
            <article>
                
<p>A <strong>product recommender system</strong> is a system with the goal of predicting and compiling a list of items that a customer is likely to purchase. Recommender systems have gained lots of popularity in recent years and have been developed and implemented for various business use cases. For example, the music streaming service, Pandora, utilizes recommender systems for music recommendations for their listeners. The e-commerce company, Amazon, utilizes recommendater systems to predict and show a list of products that a customer is likely to purchase. The media service provider, Netflix, uses recommender systems to recommend movies or TV shows for individual users that they are likely to watch. The usage of a recommender system does not stop here. It can also be used to recommend related articles, news, or books to users. With the potential of being used in a variety of areas, recommender systems play a critical role in many businesses, especially in e-commerce and media businesses, as they directly impact the sales revenue and user engagements.</p>
<p>There are typically two ways to produce a list of recommendations:</p>
<ul>
<li>Collaborative filtering </li>
<li>Content-based filtering</li>
</ul>
<p>The <strong>collaborative filtering</strong> method is based on previous user behaviors, such as pages that they viewed, products that they purchased, or ratings that they have given to different items. The collaborative filtering approach then uses this data to find similarities between users or items, and recommends the most similar items or contents to the users. The basic assumption behind the collaborative filtering method is that those who have viewed or purchased similar contents or products in the past are likely to view or purchase similar kinds of contents or products in the future. Thus, based on this assumption, if one person purchased items A, B, and C and another person purchased items A, B, and D in the past, then the first person is likely to purchase item D and the other person is likely to purchase the item C, as they share lots of similarities between them.</p>
<p><strong>Content-based filtering</strong>, on the other hand, produces a list of recommendations based on the characteristics of an item or a user. It typically looks at the keywords that describe the characteristics of an item. The basic assumption behind the content-based filtering method is that the users are likely to view or purchase items that are similar to those items that they have bought or viewed in the past. For example, if a user has listened to some songs in the past, then the content-based filtering method will recommend similar kinds of songs that share similar characteristics to those songs that the user has already listened to. </p>
<p>In this chapter, we are going to use a collaborative filtering algorithm to build a product recommendation system. Let's take a closer look at how a collaborative filtering algorithm is built in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collaborative filtering</h1>
                </header>
            
            <article>
                
<p>As discussed in the previous section, a collaborative filtering algorithm is used to recommend products based on the history of user behaviors and the similarities between users. The first step to implementing a collaborative filtering algorithm for a product recommendation system is building a <strong>user-to-item matrix</strong>. A user-to-item matrix comprises individual users in the rows and individual items in the columns. It will be easier to explain with an example. Take a look at the following matrix:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb6b5e42-258a-4e01-b5ef-788d8648559f.png" style="width:32.08em;height:9.33em;"/></p>
<p>The rows in this matrix represent each user and the columns represent each item. The values in each cell represent whether the given user bought the given item or not. For example, user <strong>1</strong> has purchased items <strong>B</strong> and <strong>D</strong> and user <strong>2</strong> has purchased items <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>E</strong>. In order to build a collaborative filtering-based product recommendation system, we need to first build this type of user-to-item matrix. We will discuss how to build such a matrix programmatically in <span>more</span><span> </span><span>detail with an example in the programming exercises in the following section.</span></p>
<p>With this user-to-item matrix, the next step to building a collaborative filtering-based product recommender system is to compute similarities between users. To measure the similarities, <strong>cosine similarity</strong> is frequently used. The equation for computing the cosine similarity between two users looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1157 image-border" src="assets/22ae66e5-e7e8-4b16-ab16-1bf069d35465.png" style="width:22.83em;height:8.50em;"/></p>
<p>In this equation, <em>U<sub>1</sub></em> and <em>U<sub>2</sub></em> represent user <strong>1</strong> and user <strong>2</strong>. <em>P<sub>1i</sub></em> and <em>P<sub>2i</sub></em> represent each product, <em>i</em>, that user <strong>1</strong> and user <strong>2</strong> have bought. If you use this equation, you will get <span><kbd>0.353553</kbd> as</span> the cosine similarity between users <strong>1</strong> and <strong>2</strong> in the previous example and <span><kbd>0.866025</kbd> as the cosine similarity between users</span> <strong>2</strong> and <strong>4</strong><span>. As you can imagine, the larger the cosine similarity is, the more similar the two users are. So, in our example, users</span> <strong>2</strong> <span>and</span> <strong>4</strong> <span>are more similar to each other than users</span> <strong>1</strong> <span>and</span> <strong>2</strong><span>. We will discuss how we can compute cosine similarities between users using Python and R in the following programming exercise section.</span></p>
<p>Lastly, when using a collaborative filtering algorithm for product recommendations, there are two approaches that you can take—a user-based approach and an item-based approach. As the names suggest, the user-based approach to collaborative filtering uses the similarities between users. On the other hand, the item-based approach collaborative filtering uses the similarities between items. This means that when we are calculating similarities between the two users in user-based approach collaborative filtering, we need to build and use a user-to-item matrix, as we have discussed previously. However, for the item-based approach, we need to calculate similarities between the two items, and this means that we need to build and use an item-to-user matrix, which we can get by simply transposing the user-to-item matrix. In the following programming exercise section, we are going to discuss in more detail the differences between these two approaches and how to build recommendation systems based on these two approaches using Python and R.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a product recommendation algorithm with Python</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to discuss how to build a product recommendation system using Python. More specifically, we will be learning how to implement a collaborative filtering algorithm in Python using a machine learning library, <kbd>scikit-learn</kbd>. <span>For those readers who would like to use R instead of Python for this exercise, you can skip to the next section. We will start this section by analyzing some e-commerce business data and then discuss the two approaches to building a product recommendation system with collaborative filtering.</span></p>
<p><span>For this exercise, we will be using one of the publicly available datasets from the </span>UCI Machine Learning Repository, which can be found at this li<span>nk: <a href="http://archive.ics.uci.edu/ml/datasets/online+retail#">http://archive.ics.uci.edu/ml/datasets/online+retail#</a></span><span>. You can follow this link and download the data in Microsoft Excel format, in a file named <kbd>Online Retail.xlsx</kbd>. Once you have downloaded this data, you can load it into your Jupyter Notebook by running the following command:</span></p>
<pre>import pandas as pd<br/><br/>df = pd.read_excel(io='../data/Online Retail.xlsx', sheet_name='Online Retail')</pre>
<p>Similar to <a href="73a716c6-6a84-4785-b04e-87651d0a29d1.xhtml" target="_blank">Chapter 5</a>, <em>Product Analytics</em>, we are using the <kbd>read_excel</kbd> function in the <kbd>pandas</kbd> package to load the data in Excel format. We provide the path to the data to the argument, <kbd>io=</kbd>, and the name of the Excel spreadsheet to the argument, <kbd>sheet_name</kbd>.</p>
<p><span>Once you have loaded this data into a </span><kbd>pandas</kbd><span> </span><kbd>DataFrame</kbd><span>, it should look as in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1158 image-border" src="assets/e124c242-0c1d-4f1a-bb53-77c13b96399a.png" style="width:40.17em;height:15.17em;"/></p>
<p>If you recall from the previous chapter, there are records with negative values in the <kbd>Quantity</kbd> column<span>, which represent canceled orders</span>. We are going to disregard and remove these records. We can filter out all these records in our<span> </span><kbd>DataFrame</kbd><span> </span>with the following code:</p>
<pre>df = df.loc[df['Quantity'] &gt; 0]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data preparation</h1>
                </header>
            
            <article>
                
<p>Before we dive into building a product recommender engine using a collaborative filtering algorithm, we need to do the following<span> couple of things</span>:</p>
<ul>
<li>Handle <kbd>NaN</kbd> values in the dataset</li>
<li>Build a customer-to-item matrix</li>
</ul>
<p>First, we need to handle <kbd>NaN</kbd> values in our dataset, especially those <kbd>NaNs</kbd> in the <kbd>CustomerID</kbd> field. Without correct values in the <kbd>CustomerID</kbd> field, we cannot build a proper recommendation system, since the collaborative filtering algorithm depends on the historical item purchase data for individual customers.</p>
<p>Second, we need to build customer-to-item matrix before we move onto implementing the collaborative filtering algorithm for product recommendation. The customer-item matrix is simply tabular data, where each column represents each product or item, each row represents a customer, and the value in each cell represents whether the given customer purchased the given product or not. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling NaNs in the CustomerID field</h1>
                </header>
            
            <article>
                
<p>If you look closely at the data, you will notice that there are some records with no <kbd>CustomerID</kbd>. As we need to build a customer-item matrix where each row is specific to each customer, we cannot include those records with no <kbd>CustomerID</kbd> in our data. Let's first take a look at how many records do not have <kbd>CustomerID</kbd>.</p>
<p>Take a look at the following code:</p>
<pre>df['CustomerID'].isna().sum()</pre>
<p>The <kbd>isna</kbd> function that we are using here detects missing values and returns <kbd>True</kbd> for each missing value. By summing over these values, we can count the number of records with no <kbd>CustomerID</kbd>. The result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1160 image-border" src="assets/b7555d17-37a0-4481-b667-141dce72b1eb.png" style="width:20.00em;height:3.92em;"/></p>
<p>As you can see from this output, there are <kbd>133,361</kbd> records with no <kbd>CustomerID</kbd>. And some of the data with missing <kbd>CustomerID</kbd> looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1161 image-border" src="assets/4abdcb7c-5ee9-44bb-b3fa-6f48acb5eeb9.png" style="width:49.83em;height:11.75em;"/></p>
<p>Now that we know there are records with missing <kbd>CustomerID</kbd> entries, we need to exclude them from further analysis. One way to drop them from our <kbd>DataFrame</kbd> is by using the <kbd>dropna</kbd> function, as in the following:</p>
<pre>df = df.dropna(subset=['CustomerID'])</pre>
<p>The <kbd>dropna</kbd> function in the <kbd>pandas</kbd> package removes records with missing values from a given DataFrame. As you can see from this code snippet, using the <kbd>subset</kbd> parameter, we can drop missing values based on specific columns. Here, we are dropping records for those without <kbd>CustomerID</kbd>. Once you run this code, all the records in the DataFrame, <kbd>df</kbd>, will now have <kbd>CustomerID</kbd> values. The dimensions of the DataFrame, <kbd>df</kbd>, before and after dropping the missing values should look as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1162 image-border" src="assets/92800353-212d-4136-99a3-69124fc51139.png" style="width:24.25em;height:10.33em;"/></p>
<p class="mce-root"/>
<p><span>As you can see from this output</span><span>, the </span><kbd>133,361</kbd><span> records with no </span><kbd>CustomerID</kbd><span> values were dropped from the original </span><kbd>DataFrame</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a customer-item matrix</h1>
                </header>
            
            <article>
                
<p>The data we have now represents individual items purchased by customers. However, in order to build a product recommendation system with a collaborative filtering algorithm, we need to have data where each record contains information on which item each customer has bought. In this section, we are going to transform the data into a customer-item matrix, where each row represents a customer and the columns correspond to different products.</p>
<p>Let's take a look at the following code:</p>
<pre>customer_item_matrix = df.pivot_table(<br/>    index='CustomerID', <br/>    columns='StockCode', <br/>    values='Quantity',<br/>    aggfunc='sum'<br/>)</pre>
<p>As you can see from this code snippet, we are using the <kbd>pivot_table</kbd> function to transform our data into a customer-item matrix. Here, we define the <kbd>index</kbd> as <kbd>CustomerID</kbd>, and use <kbd>columns</kbd> to represent each <kbd>StockCode</kbd>. By using <kbd>sum</kbd> as the <kbd>aggfunc</kbd> and the <kbd>Quantity</kbd> field for <kbd>values</kbd>, we can sum all the quantities bought for each item. A snapshot of the resulting <kbd>customer_item_matrix</kbd> looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1163 image-border" src="assets/bb68edb5-32e0-4647-9d18-17fbac432bac.png" style="width:37.92em;height:14.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's take a closer look at this data. The customer with <kbd>CustomerID</kbd> <kbd>12481</kbd> has bought <kbd>36</kbd> of the item with <kbd>StockCode</kbd> <kbd>15036</kbd>. Similarly, the customer with <kbd>CustomerID</kbd> <kbd>12484</kbd> has bought <kbd>16</kbd> of the item with <kbd>StockCode</kbd> <kbd>11001</kbd>, and the customer with <kbd>CustomerID</kbd> <kbd>12488</kbd> has bought <kbd>10</kbd> of the item with <kbd>StockCode</kbd> <kbd>10135</kbd>. As you can see from this, we now have a matrix where each row represents the total quantities bought for each product for each customer.</p>
<p>Now, let's <kbd>0</kbd>-<kbd>1</kbd> encode this data, so that the value of <kbd>1</kbd> means that the given product was purchased by the given customer, and the value of <kbd>0</kbd> means that the given product was never purchased by the given customer. Take a look at the following code:</p>
<pre>customer_item_matrix = customer_item_matrix.applymap(lambda x: 1 if x &gt; 0 else 0)</pre>
<p>As you can see from this code, we are using the <kbd>applymap</kbd> function, which applies a given function to each element of a DataFrame. The Lambda function that we are using in this code simply encodes all the elements whose values are greater than <kbd>0</kbd> with <kbd>1</kbd>, and the rest with <kbd>0</kbd>. A snapshot of this transformed DataFrame looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1165 image-border" src="assets/c9a22faa-0a07-46fa-b046-869a3bb2d82f.png" style="width:36.58em;height:13.75em;"/></p>
<p>We now have a customer-item matrix that we can use for the collaborative filtering algorithm. Let's now move on to building product recommender engines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collaborative filtering</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to explore two approaches to building a product recommender engine—user-based versus item-based. In the user-based approach, we compute similarities between users based on their item purchase history. In the item-based approach, on the other hand, we compute similarities between items based on which items are often bought together with which other items.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To measure the similarity between users or between items, we are going to use the <kbd>cosine_similarity</kbd> method in the <kbd>scikit-learn</kbd> package. You can import this function using the following code:</p>
<pre>from sklearn.metrics.pairwise import cosine_similarity</pre>
<p>This <kbd>cosine_similarity</kbd> function in the <kbd>sklearn</kbd> package computes the pair-wise cosine similarities in the given data. Let's dive in now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User-based collaborative filtering and recommendations</h1>
                </header>
            
            <article>
                
<p>In order to build a user-based collaborative filtering algorithm, we need to compute cosine similarities between users. Let's take a look at the following code:</p>
<pre>user_user_sim_matrix = pd.DataFrame(<br/>    cosine_similarity(customer_item_matrix)<br/>)</pre>
<p>As is noticeable from this code, we are using the <kbd>cosine_similarity</kbd> function from the <kbd>sklearn</kbd> package's <kbd>metrics.pairwise</kbd> module. This function computes pairwise cosine similarities between the samples and outputs the results as an <kbd>array</kbd> type. Then, we create a <kbd>pandas</kbd> <kbd>DataFrame</kbd> with this output array and store it into a variable named <kbd>user_user_sim_matrix</kbd>, which stands for <em>user-to-user similarity matrix</em>. The result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1166 image-border" src="assets/6c9a348a-5b29-48c1-ae38-3c39e6d09f9a.png" style="width:162.50em;height:41.08em;"/></p>
<p class="mce-root"/>
<p>As you can see from this snapshot of the user-to-user similarity matrix, the index and column names are not easy to understand. Since each column and each row index stand for individual customers, we are going to rename the index and columns using the following code:</p>
<pre>user_user_sim_matrix.columns = customer_item_matrix.index<br/><br/>user_user_sim_matrix['CustomerID'] = customer_item_matrix.index<br/>user_user_sim_matrix = user_user_sim_matrix.set_index('CustomerID')</pre>
<p>Now the result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1167 image-border" src="assets/e4036bf2-6b6b-4551-a321-3dd1e022a9bc.png" style="width:162.50em;height:45.08em;"/></p>
<p>Let's take a closer look at this user-to-user similarity matrix. As you can imagine, the cosine similarity between a customer to themselves is <kbd>1</kbd>, and this is what we can observe from this similarity matrix. The diagonal elements in this user-to-user similarity matrix have values of <kbd>1</kbd>. The rest represents the pairwise cosine similarity between two customers. For example, the cosine similarity measure between customers <kbd>12347</kbd> and <kbd>12348</kbd> is <kbd>0.063022</kbd>. On the other hand, the cosine similarity between customers <kbd>12347</kbd> and <kbd>12349</kbd> is <kbd>0.046130</kbd>. This suggests that customer <kbd>12348</kbd> is more similar to customer <kbd>12347</kbd> than customer <kbd>12349</kbd> is to the customer <kbd>12347</kbd>, based on the products that they purchased. This way, we can easily tell which customers are similar to others, and which customers have bought similar items to others.</p>
<p>These pairwise cosine similarity measures are what we are going to use for product recommendations. Let's work by picking one customer as an example. We will first rank the most similar customers to the customer with ID <kbd>12350</kbd>, using the following code:</p>
<pre>user_user_sim_matrix.loc[12350.0].sort_values(ascending=False)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When you run this code, you will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1168 image-border" src="assets/fcd4bc3d-404a-4c70-a389-635a34c46af7.png" style="width:37.33em;height:15.08em;"/></p>
<p>These are the top 10 customers that are the most similar to customer <kbd>12350</kbd>. Let's pick customer <kbd>17935</kbd> and discuss how we can recommend products using these results. The strategy is as follows. First, we need to identify the items that the customers <kbd>12350</kbd> and <kbd>17935</kbd> have already bought. Then, we are going to find the products that the target customer <kbd>17935</kbd> has not purchased, but customer <kbd>12350</kbd> has. Since these two customers have bought similar items in the past, we are going to assume that the target customer <kbd>17935</kbd> has a high chance of purchasing the items that he or she has not bought, but customer <kbd>12350</kbd> has bought. Lastly, we are going to use this list of items and recommend them to the target customer <kbd>17935</kbd>.</p>
<p>Let's first take a look at how we can retrieve the items that the customer <kbd>12350</kbd> has purchased in the past. The code looks as follows:</p>
<pre>items_bought_by_A = set(customer_item_matrix.loc[12350.0].iloc[<br/>    customer_item_matrix.loc[12350.0].nonzero()<br/>].index)</pre>
<p>As you can see from this code, we are using the <kbd>nonzero</kbd> function in the <kbd>pandas</kbd> package. This function returns the integer indexes of the elements that are non-zero. Using this function on the <kbd>customer_item_matrix</kbd> for the given customer <kbd>12350</kbd>, we can get the list of items that the customer <kbd>12350</kbd> has purchased. We can apply the same code for the target customer <kbd>17935</kbd>, as in the following:</p>
<pre>items_bought_by_B = set(customer_item_matrix.loc[17935.0].iloc[<br/>    customer_item_matrix.loc[17935.0].nonzero()<br/>].index)</pre>
<p>Now we have two sets of items that customers <kbd>12350</kbd> and <kbd>17935</kbd> have purchased. Using a simple set operation, we can find the items that customer <kbd>12350</kbd> has bought, but customer <kbd>17935</kbd> has not. The code looks like the following:</p>
<pre>items_to_recommend_to_B = items_bought_by_A - items_bought_by_B</pre>
<p>Now the items in the <kbd>items_to_recommend_to_B</kbd> <span>variable </span>are the items that customer <kbd>12350</kbd> purchased, but customer <kbd>17935</kbd> did not purchase (yet). Based on our assumption, these are the items that customer <kbd>17935</kbd> is likely to purchase. The list of items to recommend to customer <kbd>17935</kbd> looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1169 image-border" src="assets/74829a3a-5fb5-4666-aa32-a37294db4f54.png" style="width:21.50em;height:18.00em;"/></p>
<p>In order to get the descriptions of these items, you can use the following code:</p>
<pre>df.loc[<br/>    df['StockCode'].isin(items_to_recommend_to_B), <br/>    ['StockCode', 'Description']<br/>].drop_duplicates().set_index('StockCode')</pre>
<p>As you can notice from this code, we are using the <kbd>isin</kbd> operator to get the records that match with the items in the <kbd>items_to_recommend_to_B</kbd> variable.</p>
<p>Once you run this code, you will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1170 image-border" src="assets/c8514630-b2d5-4fb6-931c-4f7c78775442.png" style="width:32.75em;height:33.42em;"/></p>
<p>Using user-based collaborative filtering, we have discussed how we can do targeted product recommendations for individual customers. You can custom-tailor and include <span>these products </span><span>that each target customer is likely to purchase in </span>your marketing messages<span>, which can potentially drive more conversions from your customers. As discussed so far, using a user-based collaborative filtering algorithm, you can easily do product recommendations for target customers.</span></p>
<p><span>However, there is one main disadvantage of using user-based collaborative filtering. As we have seen in this exercise, recommendations are based on the individual customer's purchase history. For new customers, we are not going to have enough data to compare these new customers against the others. In order to handle this problem, we can use item-based collaborative filtering, which we are going to discuss in the following section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Item-based collaborative filtering and recommendations</h1>
                </header>
            
            <article>
                
<p>Item-based collaborative filtering is similar to the user-based approach, except that it uses the similarity measures between items, instead of between users or customers. We had to compute cosine similarities between users before, but now, we are going to compute cosine similarities between items. Take a look at the following code:</p>
<pre>item_item_sim_matrix = pd.DataFrame(<br/>    cosine_similarity(customer_item_matrix.T)<br/>)</pre>
<p>If you compare this code to the previous code, where we computed a user-to-user similarity matrix, the only difference is the fact that we are transposing the <kbd>customer_item_matrix</kbd> here, so that the row indexes represent individual items and the columns represent the customers. We are still using the <kbd>cosine_similarity</kbd> function of the <kbd>sklearn</kbd> package's <kbd>metrics.pairwise</kbd> module. In order to correctly name the indexes and columns with product codes, you can use the following code:</p>
<pre>item_item_sim_matrix.columns = customer_item_matrix.T.index<br/><br/>item_item_sim_matrix['StockCode'] = customer_item_matrix.T.index<br/>item_item_sim_matrix = item_item_sim_matrix.set_index('StockCode')</pre>
<p>Now the result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1171 image-border" src="assets/39a947de-cb00-483e-a8b2-9a3fb7fee36d.png" style="width:165.83em;height:73.83em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As before, the diagonal elements have values of <kbd>1</kbd>. This is because the similarity between an item and itself is <kbd>1</kbd>, meaning the two are identical. The rest of the elements contain the similarity measure values between items based on the cosine similarity calculation. For example, looking at the preceding item-to-item similarity matrix, the cosine similarity between the item with <kbd>StockCode</kbd> <kbd>10002</kbd> and the item with <kbd>StockCode</kbd> <kbd>10120</kbd> is <kbd>0.094868</kbd>. On the other hand, the cosine similarity between the item <kbd>10002</kbd> and the item <kbd>10125</kbd> is <kbd>0.090351</kbd>. This suggests that the item with <kbd>StockCode</kbd> <kbd>10120</kbd> is more similar to that with <kbd>StockCode</kbd> <kbd>10002</kbd>, than the item with <kbd>StockCode</kbd> <kbd>10125</kbd> is to that with <kbd>StockCode</kbd><span> </span><kbd>10002</kbd>.</p>
<p><span>The strategy for doing product recommendation using this item-to-item similarity matrix is similar to what we did using the user-based approach in the previous section. First, for the given product that the target customer bought, we are going to find the most similar items from the item-to-item similarity matrix that we have just built. Then, we are going to recommend these similar items to the customer, since those similar items were bought by other customers who have bought the product that the target customer initially bought. Let's work with an example.</span></p>
<p>Assume a new customer just bought a product with <kbd>StockCode</kbd> <kbd>23166</kbd>, and we want to include some products that this customer is the most likely to purchase in our marketing emails. The first thing we need to do is find the most similar items to the one with <kbd>StockCode</kbd> <kbd>23166</kbd>. You can use the following code to get the top 10 most similar items to the item with <kbd>StockCode</kbd> <kbd>23166</kbd>:</p>
<pre>top_10_similar_items = list(<br/>   item_item_sim_matrix\<br/>        .loc[23166]\<br/>        .sort_values(ascending=False)\<br/>        .iloc[:10]\<br/>    .index<br/>)</pre>
<p>The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1172 image-border" src="assets/c34a8b86-441b-451f-9c98-103ddfa7dd7e.png" style="width:44.75em;height:4.42em;"/></p>
<p>We can get the descriptions of these similar items using the following code:</p>
<pre>df.loc[<br/>    df['StockCode'].isin(top_10_similar_items), <br/>    ['StockCode', 'Description']<br/>].drop_duplicates().set_index('StockCode').loc[top_10_similar_items]</pre>
<p>As you can see from this code, we are using the <kbd>isin</kbd> operator to filter for the items that match the list of similar items in the <kbd>top_10_similar_items</kbd> variable. Once you run this code, you will see the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1173 image-border" src="assets/b101fa25-8e6b-414d-a86f-235f73e507d1.png" style="width:21.42em;height:20.25em;"/></p>
<p>The first item here is the item that the target customer just bought and the other nine items are the items that are frequently bought by others who have bought the first item. As you can see, those who have bought ceramic top storage jars often buy jelly moulds, spice tins, and cake tins. With this data, you can include these items in your marketing messages for this target customer as further product recommendations. Personalizing the marketing messages with targeted product recommendations typically yields higher conversion rates from customers. Using an item-based collaborative filtering algorithm, you can now easily do product recommendations for both new and existing customers.</p>
<div class="packt_infobox">The full details for this Python exercise can be found at: <a href="https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/python/ProductRecommendation.ipynb">https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/python/ProductRecommendation.ipynb</a></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a product recommendation algorithm with R</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to discuss how to build a product recommendation system using R. More specifically, we will be learning how to implement a collaborative filtering algorithm in R using the<span> </span><kbd>dplyr</kbd>, <kbd>reshape2</kbd>, and <kbd>coop</kbd> packages. <span>For those readers who would like to use Python instead of R for this exercise, you can go to the previous section. We will start this section by analyzing some e-commerce business data and then discuss the two approaches to building a product recommendation system with collaborative filtering.</span></p>
<p><span>For this exercise, we will be using one of the publicly available datasets from</span> the UCI Machine Learning Repository, <span>which can be found at: <a href="http://archive.ics.uci.edu/ml/datasets/online+retail#">http://archive.ics.uci.edu/ml/datasets/online+retail#</a></span><span>. You can go to this link and download the data, available in Microsoft Excel format, named <kbd>Online Retail.xlsx</kbd>. Once you have downloaded this data, you can load it into your RStudio by running the following command:</span></p>
<pre>library(dplyr)<br/>library(readxl)<br/><br/>df &lt;- read_excel(<br/>  path="~/Documents/research/data-science-marketing/ch.6/data/Online Retail.xlsx", <br/>  sheet="Online Retail"<br/>)</pre>
<p>Similar to the previous chapter, we are using the<span> </span><kbd>read_excel</kbd><span> </span>function in the<span> </span><kbd>readxl</kbd><span> </span>package to load the data in Excel format. We provide the path to the data to the argument<span> </span><kbd>path</kbd>, and the name of the Excel spreadsheet to the argument<span> </span><kbd>sheet</kbd>.</p>
<p><span>Once you have loaded this data into a</span><span> </span><kbd>DataFrame</kbd><span>, it should look like the following:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1174 image-border" src="assets/afb2a4f5-fc1c-42ea-a115-8d69a1eda07f.png" style="width:76.75em;height:22.92em;"/></p>
<p class="mce-root"/>
<p>If you recall from the previous chapter, there are records with negative values in the<span> </span><kbd>Quantity</kbd><span> </span>column, which represent canceled orders. We are going to disregard and remove those records. We can filter out all these records in our<span> </span><kbd>DataFrame</kbd><span> </span>with the following code:</p>
<pre># ignore cancel orders<br/>df &lt;- df[which(df$Quantity &gt; 0),]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data preparation</h1>
                </header>
            
            <article>
                
<p><span>Before we dive into building a product recommender engine using a collaborative filtering algorithm, there are a couple of things we need to do. First, we need to handle </span><kbd>NaN</kbd><span> values in our dataset, especially those records with <kbd>NA</kbd> values</span><span> in the </span><kbd>CustomerID</kbd><span> field. Without correct values in the </span><kbd>CustomerID</kbd><span> field, we cannot build a proper recommendation system, since the collaborative filtering algorithm depends on the historical item purchase data for individual customers. Second, we need to build customer-to-item matrix before we move onto implementing a collaborative filtering algorithm for product recommendation. The customer-item matrix is simply tabular data where each column represents each product or item, each row represents a customer, and the value in each cell represents whether the given customer purchased the given product or not. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling NA values in the CustomerID field</h1>
                </header>
            
            <article>
                
<p>If you look closely at the data, you will notice that there are some records with no<span> </span><kbd>CustomerID</kbd>. Since we need to build a customer-item matrix, where each row is specific to each customer, we cannot include those records with no<span> </span><kbd>CustomerID</kbd><span> </span>in our data. Let's first take a look at how many records do not have a<span> </span><kbd>CustomerID</kbd>.</p>
<p>Take a look at the following code:</p>
<pre># there are 133,361 records with no CustomerID<br/>sum(is.na(df$CustomerID))</pre>
<p>The<span> </span><kbd>is.na</kbd><span> </span>function that we are using here detects missing values and returns<span> </span><kbd>TRUE</kbd><span> </span>for each of the missing values. By summing over these values using the <kbd>sum</kbd> function, we can count the number of records with no<span> </span><kbd>CustomerID</kbd>. The result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1175 image-border" src="assets/0a9abc50-60e2-4f84-b386-b8bf5d454b98.png" style="width:14.17em;height:2.67em;"/></p>
<p class="mce-root"/>
<p>As you can see from this output, there are<span> </span><kbd>133,361</kbd><span> </span>records with no<span> </span><kbd>CustomerID</kbd>. In order to look at those records with no <kbd>CustomerID</kbd>, you can use the following code:</p>
<pre># sneak peek at records with no CustomerID<br/>head(df[which(is.na(df$CustomerID)),])</pre>
<p>And the output looks like the following code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1176 image-border" src="assets/dfb92dd0-c302-4e72-9447-cb7c444cd882.png" style="width:70.33em;height:13.92em;"/></p>
<p>Now that we know there are records with missing<span> </span><kbd>CustomerID</kbd> values, we need to exclude them from further analysis. One way to drop them from our<span> </span><kbd>DataFrame</kbd><span> </span>is by using the<span> </span><kbd>na.omit</kbd><span> </span>function, as in the following:</p>
<pre># remove records with NA<br/>df &lt;- na.omit(df)</pre>
<p>The<span> </span><kbd>na.omit</kbd><span> </span>function in R removes records with missing values (<kbd>NA</kbd>) from a DataFrame. Once you run this code, all the records in the DataFrame<span> </span><kbd>df</kbd> will now have<span> </span><kbd>CustomerID</kbd> values. The dimensions of the DataFrame <kbd>df</kbd> before and after dropping the missing values should look as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1177 image-border" src="assets/8bcd2960-7950-4f04-a09c-71af11a813ee.png" style="width:13.75em;height:9.17em;"/></p>
<p>As you can see from the outputs of the <kbd>dim(df)</kbd> commands, the <kbd>133,361</kbd> records with no <kbd>CustomerID</kbd> values were dropped from the original <kbd>DataFrame</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a customer-item matrix</h1>
                </header>
            
            <article>
                
<p>The data we have now represents individual items purchased by customers. However, in order to build a product recommendation system with a collaborative filtering algorithm, we need to have data where each record contains information on which item each customer has bought. In this section, we are going to transform the data into a customer-item matrix, where each row represents a customer and the columns correspond to different products.</p>
<p>In order to transform our data into a customer-item matrix, we are going to use the <kbd>dcast</kbd> function in the <kbd>reshape2</kbd> package. If you do not already have this package installed in your R environment, you can run the following commands to install and include this package in your R environment:</p>
<pre>install.packages("reshape2")<br/><br/>library(reshape2)</pre>
<p>Let's take a look at the following code:</p>
<pre>customerItemMatrix &lt;- dcast(<br/>  df, CustomerID ~ StockCode, value.var="Quantity"<br/>)</pre>
<p>The <kbd>dcast</kbd> function of the <kbd>reshape2</kbd> package uses a formula to reshape a <kbd>DataFrame</kbd> into another form of <kbd>DataFrame</kbd>. In our case, we want our data to be reshaped so that the rows represent individual customers and the columns represent the different products. By defining the formula as <kbd>CustomerID ~ StockCode</kbd>, the <kbd>dcast</kbd> function is going to reshape the data, so that the individual codes of the <kbd>StockCode</kbd> map to columns and each row represents an individual customer. The <kbd>value.var</kbd> argument defines which value to take. Here, we are telling the <kbd>dcast</kbd> function to take the values of the <kbd>Quantity</kbd> field as the values of the elements in the reshaped <kbd>DataFrame</kbd>. The result looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1178 image-border" src="assets/36ec0e90-40ad-47c3-ac31-73c93b473055.png" style="width:36.50em;height:14.58em;"/></p>
<p>Let's take a closer look at this data. The customer with<span> </span><kbd>CustomerID</kbd><span> </span><kbd>12731</kbd><span> </span>has bought<span> </span><kbd>3</kbd><span> </span>of the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10002</kbd>. Similarly, the customer with<span> </span><kbd>CustomerID</kbd><span> </span><kbd>12748</kbd><span> </span>has bought <kbd>2</kbd> of the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10080</kbd>,<span> </span>and the customer with<span> </span><kbd>CustomerID</kbd><span> </span><kbd>12735</kbd><span> </span>has bought <kbd>1</kbd> of the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10125</kbd>. As you can see from this, we now have a matrix where each row represents the total quantities bought for each product for each customer.</p>
<p>Now, let's <kbd>0</kbd>-<kbd>1</kbd> encode this data, so that the value of <kbd>1</kbd> means that the given product was purchased by the given customer, and a value of <kbd>0</kbd> means that the given product was never purchased by the given customer. Take a look at the following code:</p>
<pre># 0-1 encode <br/>encode_fn &lt;- function(x) {as.integer(x &gt; 0)}<br/><br/>customerItemMatrix &lt;- customerItemMatrix %&gt;% <br/>  mutate_at(vars(-CustomerID), funs(encode_fn))</pre>
<p>As you can see from this code, we first define the encoding function, <kbd>encode_fn</kbd>. This function simply encodes each value as <kbd>1</kbd> if it is greater than <kbd>0</kbd>, and as <kbd>0</kbd> if it is not. Then we are using the <kbd>muate_at</kbd> function of the <kbd>dplyr</kbd> package, which applies the <kbd>encode_fn</kbd> encoding function to each element of the matrix, except the <kbd>CustomerID</kbd> column. The result should look as in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1179 image-border" src="assets/2f4237b9-9ed7-4709-8ccc-e61ca747c888.png" style="width:72.67em;height:29.33em;"/></p>
<p>We now have a customer-item matrix that we can use for a collaborative filtering algorithm. Let's now move on to building product recommender engines.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collaborative filtering</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to explore two approaches to building a product recommender engine—user-based versus item-based. In the user-based approach, we compute similarities between users based on their item purchase history. In the item-based approach, on the other hand, we compute similarities between items based on which items are often bought together with other items. To measure the similarity between users or between items, we are going to use the<span> </span><kbd>cosine</kbd><span> </span>function in the<span> </span><kbd>coop</kbd><span> </span>library, which is a library for fast implementation of cosine similarity computation in R. You can install and this R library using the following code:</p>
<pre>install.packages("coop")<br/><br/>library(coop)</pre>
<p>The<span> </span><kbd>cosine</kbd><span> </span>function in the<span> </span><kbd>coop</kbd><span> </span>library computes the cosine similarity matrix efficiently in R. Let's dive in now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User-based collaborative filtering and recommendations</h1>
                </header>
            
            <article>
                
<p>In order to build a user-based collaborative filtering algorithm, we need to compute cosine similarities between users. Let's take a look at the following code:</p>
<pre># User-to-User Similarity Matrix<br/>userToUserSimMatrix &lt;- cosine(<br/>  as.matrix(<br/>    # excluding CustomerID column<br/>    t(customerItemMatrix[, 2:dim(customerItemMatrix)[2]])<br/>  )<br/>)<br/>colnames(userToUserSimMatrix) &lt;- customerItemMatrix$CustomerID</pre>
<p>As is noticeable from this code, using the<span> </span><kbd>cosine</kbd><span> </span>function from the<span> </span><kbd>coop</kbd><span> library, you can compute and build a cosine similarity matrix.</span> One thing to note in this code is the fact that we transpose the <kbd>customerItemMatrix</kbd> before computing cosine similarities. This is to compute user-to-user similarities. Without the transposition, the <kbd>cosine</kbd> function will be computing item-to-item similarities. Lastly, we are renaming the columns with customer IDs in the last line of this code.</p>
<p>The result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1180 image-border" src="assets/8fcc0c2f-cdaa-44da-a400-1c746ff39ee1.png" style="width:78.08em;height:30.75em;"/></p>
<p>Let's take a closer look at this user-to-user similarity matrix. As you can imagine, the cosine similarity between a customer to himself or herself is <kbd>1</kbd> and this is what we can observe from this similarity matrix. The diagonal elements in this user-to-user similarity matrix have values of <kbd>1</kbd>. The rest represents the pairwise cosine similarity between two customers. For example, the cosine similarity measure between customers<span> </span><kbd>12347</kbd><span> </span>and<span> </span><kbd>12348</kbd> is<span> </span><kbd>0.06302187</kbd>. On the other hand, the cosine similarity between customers<span> </span><kbd>12347</kbd><span> </span>and<span> </span><kbd>12349</kbd> is<span> </span><kbd>0.04612963</kbd>. This suggests that customer<span> </span><kbd>12348</kbd><span> </span>is more similar to customer<span> </span><kbd>12347</kbd><span> </span>than customer<span> </span><kbd>12349</kbd><span> </span>to customer<span> </span><kbd>12347</kbd>, based on the products that they purchased previously. This way we can easily tell which customers are similar to which others and which customers have bought similar items to which others.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>These pairwise cosine similarity measures are what we are going to use for product recommendations. Let's work by picking one customer as an example. We will first rank the most similar customers to customer with ID <kbd>12350</kbd> using the following code:</p>
<pre>top10SimilarCustomersTo12350 &lt;- customerItemMatrix$CustomerID[<br/> order(userToUserSimMatrix[,"12350"], decreasing = TRUE)[1:11]<br/>]</pre>
<p>As you can see from this code, we are using the order function to sort the values in the column <kbd>12350</kbd> of <kbd>userToUserSimMatrix</kbd>. With the <kbd>decreasing = TRUE</kbd> flag, we can sort the values in descending order.</p>
<p>When you run this code, you will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1181 image-border" src="assets/5cce0e7b-48bd-4460-b4d1-059e3878d548.png" style="width:33.08em;height:2.50em;"/></p>
<p>These are the top 10 customers that are the most similar to customer<span> </span><kbd>12350</kbd>. Let's pick customer<span> </span><kbd>17935</kbd> and discuss how we can recommend products using these results. The strategy is as follows. First we need to identify the items that customers<span> </span><kbd>12350</kbd><span> </span>and<span> </span><kbd>17935</kbd> have already bought. Then, we are going to find the products that the target customer<span> </span><kbd>17935</kbd> has not purchased, but customer<span> </span><kbd>12350</kbd> has. Since these two customers have bought similar items in the past, we are going to assume that the target customer<span> </span><kbd>17935</kbd> has high chance of purchasing these items that he or she has not bought, but that customer<span> </span><kbd>12350</kbd> has bought. Lastly, we are going to use this list of items and recommend them to the target customer <kbd>17935</kbd>.</p>
<p>Let's first take a look at how we can retrieve the items that customer <kbd>12350</kbd> has purchased in the past. The code looks as follows:</p>
<pre>itemsBoughtByA &lt;- customerItemMatrix[<br/>  which(customerItemMatrix$CustomerID == "12350"),<br/>]<br/><br/>itemsBoughtByA &lt;- colnames(customerItemMatrix)[which(itemsBoughtByA != 0)]</pre>
<p>As you can see from this code, we are using the <kbd>which</kbd> operator to find the column indexes of the elements that are non-zero. The result of this code looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1183 image-border" src="assets/5b53e815-97c5-46a5-a767-c9263c581da4.png" style="width:39.08em;height:4.42em;"/></p>
<p>Using the following code, we can get the list of items that the customer<span> </span><kbd>17935</kbd> has purchased:</p>
<pre>itemsBoughtByB &lt;- customerItemMatrix[<br/>  which(customerItemMatrix$CustomerID == "17935"),<br/>]<br/><br/>itemsBoughtByB &lt;- colnames(customerItemMatrix)[which(itemsBoughtByB != 0)]</pre>
<p>The items that customer <kbd>17935</kbd> has bought are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1184 image-border" src="assets/2fdc0326-a8a6-47a8-990f-8c7a44647e15.png" style="width:44.92em;height:7.08em;"/></p>
<p>Now we have two sets of items that customers<span> </span><kbd>12350</kbd><span> </span>and<span> </span><kbd>17935</kbd> have purchased. Using the simple set operation, we can find the items that customer<span> </span><kbd>12350</kbd> has bought, but customer<span> </span><kbd>17935</kbd> has not. The code looks like the following:</p>
<pre>itemsToRecommendToB &lt;- setdiff(itemsBoughtByA, itemsBoughtByB)</pre>
<p>Now the items in the,<span> </span><kbd>itemsToRecommendToB</kbd> variable, are the items that customer<span> </span><kbd>12350</kbd> purchased, but customer<span> </span><kbd>17935</kbd> did not purchase yet. Based on our assumption, these are the items that customer<span> </span><kbd>17935</kbd> is likely to purchase. The list of items to recommend to customer <kbd>17935</kbd> looks as in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1185 image-border" src="assets/f7f47bec-3222-449f-b197-5903b3a72ab7.png" style="width:40.75em;height:3.33em;"/></p>
<p>In order to get the descriptions of these items, you can use the following code:</p>
<pre>itemsToRecommendToBDescriptions &lt;- unique(<br/>  df[<br/>    which(df$StockCode %in% itemsToRecommendToB), <br/>    c("StockCode", "Description")<br/>    ]<br/>)<br/>itemsToRecommendToBDescriptions &lt;- itemsToRecommendToBDescriptions[<br/>  match(itemsToRecommendToB, itemsToRecommendToBDescriptions$StockCode),<br/>]</pre>
<p>As you can notice from this code, we are using the<span> </span><kbd>%in%</kbd><span> </span>operator to get the records that match with the items in the <kbd>itemsToRecommendToB</kbd> variable. Once you run this code, you will get the following output that has descriptions of the recommended items:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1186 image-border" src="assets/3401d7e1-77f1-4850-aef5-4dd15d258c58.png" style="width:22.50em;height:21.33em;"/></p>
<p>Using user-based collaborative filtering, we have discussed how we can do targeted product recommendations for individual customers. You can custom-tailor and include <span>these products </span><span>that each target customer is likely to purchase in </span>your marketing messages<span>, which can potentially drive more conversions from your customers. As discussed so far, using a user-based collaborative filtering algorithm, you can easily create product recommendations for target customers.</span></p>
<p><span>However, there is one main disadvantage of using user-based collaborative filtering. As we have seen in this exercise, recommendations are based on the individual customer's purchase history. For new customers, we are not going to have enough data to compare them with the others. In order to handle this problem, we can use item-based collaborative filtering that we will be discussing in the following section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Item-based collaborative filtering and recommendations</h1>
                </header>
            
            <article>
                
<p>Item-based collaborative filtering is similar to the user-based approach, except that it is using the similarity measures between items, instead of between users or customers. We had to compute cosine similarities between users before, but now we are going to compute cosine similarities between items. Take a look at the following code:</p>
<pre># Item-to-Item Similarity Matrix<br/>itemToItemSimMatrix &lt;- cosine(<br/>  as.matrix(<br/>    # excluding CustomerID column<br/>    customerItemMatrix[, 2:dim(customerItemMatrix)[2]]<br/>  )<br/>)</pre>
<p>If you compare this code to the previous code, where we computed user-to-user similarity matrix, the only difference is the fact that we are not transposing the<span> </span><kbd>customerItemMatrix</kbd><span> </span>this time. We are still using the<span> </span><kbd>cosine</kbd><span> </span>function of the<span> </span><kbd>coop</kbd><span> library</span>.</p>
<p>The result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1187 image-border" src="assets/b2de1e8a-a7af-4973-aaf5-e3371da48859.png" style="width:78.92em;height:33.50em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As before, the diagonal elements have values of <kbd>1</kbd>. This is because the similarity between an item and itself is <kbd>1</kbd>, meaning the two are identical. The other elements contain the similarity measure values between items based on the cosine similarity calculation. For example, looking at the preceding item-to-item similarity matrix, the cosine similarity between the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10002</kbd> and the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10120</kbd> is<span> </span><kbd>0.09486833</kbd>. On the other hand, the cosine similarity between item<span> </span><kbd>10002</kbd> and item<span> </span><kbd>10125</kbd> is<span> </span><kbd>0.09035079</kbd>. This suggests that the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10120</kbd> is more similar to that with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10002</kbd> than the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10125</kbd> is to that with<span> </span><kbd>StockCode</kbd><span> </span><kbd>10002</kbd>.</p>
<p>The strategy to do product recommendation using this item-to-item similarity matrix is similar to what we did using the user-based approach in the previous section. First, for the given product that the target customer bought, we are going to find the most similar items from the item-to-item similarity matrix that we have just built. Then, we are going to recommend these similar items to the customer, since those similar items were bought by other customers who have bought the product that the target customer initially bought. Let's work with an example.</p>
<p>Assume a new customer just bought a product with<span> </span><kbd>StockCode</kbd><span> </span><kbd>23166</kbd>, and we want to include some products that this customer is most likely to purchase in our marketing emails. The first thing we need to do is find the most similar items to the one with<span> </span><kbd>StockCode</kbd><span> </span><kbd>23166</kbd>. You can use the following code to get the top 10 most similar items to the item with<span> </span><kbd>StockCode</kbd><span> </span><kbd>23166</kbd>:</p>
<pre>top10SimilarItemsTo23166 &lt;- colnames(itemToItemSimMatrix)[<br/>  order(itemToItemSimMatrix[,"23166"], decreasing = TRUE)[1:11]<br/>]</pre>
<p>Using the <kbd>order</kbd> function with the <kbd>decreasing = TRUE</kbd> flag, we can sort the similar items in descending order. Then, with this reverse sorted list of indexes, we can get the top 10 similar items to the item with <kbd>StockCode</kbd> <kbd>23166</kbd>.</p>
<p>The result looks as in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1188 image-border" src="assets/3b7dc18a-ad78-4097-98a9-fcd94ca86a74.png" style="width:39.33em;height:3.50em;"/></p>
<p>We can get the descriptions of these similar items using the following code:</p>
<pre>top10SimilarItemDescriptions &lt;- unique(<br/>  df[<br/>    which(df$StockCode %in% top10SimilarItemsTo23166), <br/>    c("StockCode", "Description")<br/>  ]<br/>)<br/>top10SimilarItemDescriptions &lt;- top10SimilarItemDescriptions[<br/>  match(top10SimilarItemsTo23166, top10SimilarItemDescriptions$StockCode),<br/>]</pre>
<p>As you can see from this code, we are using the<span> </span><kbd>%in%</kbd><span> </span>operator to filter for the items that match the list of similar items in the variable<span> </span><kbd>top10SimilarItemsTo23166</kbd>. Once you run this code, you will see the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1189 image-border" src="assets/7d4e688b-27eb-40a9-a42b-a0cb136342c0.png" style="width:22.00em;height:17.83em;"/></p>
<p>The first item here is the item that the target customer just bought, and the remaining 10 items are the items that are frequently bought by others who have bought the first item. As you can see, those who have bought ceramic-top storage jars often buy jelly moulds, spice tins, and cake tins. With this data, you can include these items in your marketing messages for this target customer as further product recommendations. Personalizing the marketing messages with targeted product recommendations typically yields higher conversion rates from customers. Using an item-based collaborative filtering algorithm, you can now easily do product recommendations for both new and existing customers.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">The full code for this R exercise can be found in this link: <a href="https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/R/ProductRecommendation.R">https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.6/R/ProductRecommendation.R</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have discussed product recommender systems. We have learned how personalized product recommendations improve conversion and customer retention rates, according to a study conducted by Salesforce. We have discussed the two approaches, collaborative filtering and content-based filtering, to building product recommendation systems; how they differ from one another; and what their assumptions are. Then, we dove deeper into how we can build collaborative filtering-based recommender systems. As you might recall, the first step to building a collaborative filtering-based recommender system is to build a user-to-item matrix, and then the next step is to use cosine similarity to compute the similarities between the users. We have also discussed the two different approaches to utilizing a collaborative filtering algorithm for product recommendations—a user-based approach and an item-based approach.</p>
<p>From the next chapter, we are going to switch gears and focus on utilizing customer behavior data to our advantage to improve our marketing strategies. In the next chapter, we are going to discuss the benefits and importance of conducting customer analytics.</p>


            </article>

            
        </section>
    </body></html>