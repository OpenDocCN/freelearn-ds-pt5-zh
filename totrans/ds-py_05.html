<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Python and PixieDust Best Practices and Advanced Concepts</h1></div></div></div><div><blockquote class="blockquote"><p>"In God we Trust, all others bring data."</p></blockquote></div><p>                                   – <em>W. Edwards Deming</em>
</p><p>In the remaining chapters of this book, we will do a deep dive into the architecture of industry use cases, including the implementation of sample data pipelines, heavily applying the techniques we've learned so far. Before we start looking at the code, let's complete our toolbox with a few best practices and advanced PixieDust concepts that will be useful in the implementation of our sample applications:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calling third-party Python libraries with <code class="literal">@captureOutput</code> decorator</li><li class="listitem" style="list-style-type: disc">Increasing modularity and code reuse of your PixieApp</li><li class="listitem" style="list-style-type: disc">PixieDust support of streaming data</li><li class="listitem" style="list-style-type: disc">Adding dashboard drill-downs with PixieApp events</li><li class="listitem" style="list-style-type: disc">Extending PixieDust with a custom display renderer</li><li class="listitem" style="list-style-type: disc">Debugging:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Line-by-line Python code debugging running on the Jupyter Notebook using pdb</li><li class="listitem" style="list-style-type: disc">Visual debugging with PixieDebugger</li><li class="listitem" style="list-style-type: disc">Using the PixieDust logging framework to troubleshoot issues</li><li class="listitem" style="list-style-type: disc">Tips for client-side JavaScript debugging</li></ul></div></li><li class="listitem" style="list-style-type: disc">Running Node.js inside a Python Notebook</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Use @captureOutput decorator to integrate the output of third-party Python libraries</h1></div></div></div><p>Suppose that you want to reuse your PixieApp in a third-party library that you have been using for a while in order to <a id="id248" class="indexterm"/>perform a certain task, such as, for example, computing clusters with the scikit-learn machine learning library (<a class="ulink" href="http://scikit-learn.org">http://scikit-learn.org</a>) and displaying them as a graph. The problem is that most of the time, you are calling a high-level method that doesn't return data, but rather directly draws something on the cell output area, such as a chart or a report table. Calling this method from a PixieApp route will not work because the contract for routes is to return an HTML fragment string that will be processed by the framework. In this case, the method most likely doesn't return anything since it is writing the results directly in the cell output. The solution is to use the <code class="literal">@captureOutput</code> decorator—which is part of the PixieApp framework—in the route method.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>Create a word cloud image with @captureOutput</h2></div></div></div><p>To better <a id="id249" class="indexterm"/>illustrate the <code class="literal">@captureOutput</code> scenario described earlier, let's take a concrete example where we want to build <a id="id250" class="indexterm"/>a PixieApp that uses the <code class="literal">wordcloud</code> Python library (<a class="ulink" href="https://pypi.python.org/pypi/wordcloud">https://pypi.python.org/pypi/wordcloud</a>) to generate a word cloud image from a text file provided by the user via a URL.</p><p>We first install the <code class="literal">wordcloud</code> library by running the following command in its own cell:</p><div><pre class="programlisting">
<strong>!pip install wordcloud</strong>
</pre></div><div><div><h3 class="title"><a id="note81"/>Note</h3><p>
<strong>Note</strong>: Make sure to restart the kernel when the installation of the <code class="literal">wordcloud</code> library is complete.</p></div></div><p>The code for the PixieApp looks like this:</p><div><pre class="programlisting">from pixiedust.display.app import *
import requests
from wordcloud import WordCloud
import matplotlib.pyplot as plt

@PixieApp
class WordCloudApp():
    @route()
    def main_screen(self):
        return """
        &lt;div style="text-align:center"&gt;
            &lt;label&gt;Enter a url: &lt;/label&gt;
            &lt;input type="text" size="80" id="url{{prefix}}"&gt;
            &lt;button type="submit"
                pd_options="url=$val(url{{prefix}})"
                pd_target="wordcloud{{prefix}}"&gt;
                Go
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;center&gt;&lt;div id="wordcloud{{prefix}}"&gt;&lt;/div&gt;&lt;/center&gt;
        """

    @route(url="*")
    <strong>@captureOutput</strong>
    def generate_word_cloud(self, url):
        text = requests.get(url).text
        plt.axis("off")
        plt.imshow(
            WordCloud(max_font_size=40).generate(text),
            interpolation='bilinear'
        )

app = WordCloudApp()
app.run()</pre></div><div><div><h3 class="title"><a id="note82"/>Note</h3><p>You can find the code here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode1.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode1.py</a>
</p></div></div><p>Notice that by simply adding the <code class="literal">@captureOutput</code> decorator to the <code class="literal">generate_word_cloud</code> route, we <a id="id251" class="indexterm"/>don't need to return an HTML fragment string any more. We can simply invoke the Matplotlib <code class="literal">imshow()</code> function that sends the image to the system output. The <a id="id252" class="indexterm"/>PixieApp framework will take care of capturing the output and package it as an HTML fragment string that will be injected in the correct div placeholder. The result is as follows:</p><div><div><h3 class="title"><a id="note83"/>Note</h3><p>
<strong>Note</strong>: We use the following input URL coming from the <code class="literal">wordcloud</code> repo on GitHub:</p><p>
<a class="ulink" href="https://github.com/amueller/word_cloud/blob/master/examples/constitution.txt">https://github.com/amueller/word_cloud/blob/master/examples/constitution.txt</a>
</p></div></div><div><div><h3 class="title"><a id="note84"/>Note</h3><p>Another good link to use is:</p><p>
<a class="ulink" href="https://raw.githubusercontent.com/amueller/word_cloud/master/examples/a_new_hope.txt">https://raw.githubusercontent.com/amueller/word_cloud/master/examples/a_new_hope.txt</a>
</p></div></div><div><img src="img/B09699_05_01.jpg" alt="Create a word cloud image with @captureOutput" width="1000" height="366"/><div><p>Simple PixieApp that generates a word cloud from a text</p></div></div><p>Any function that draws directly to the cell output can be used with the <code class="literal">@captureOutput</code> decorator. For example, you can use <a id="id253" class="indexterm"/>the Matplotlib <code class="literal">show()</code> method or the IPython <code class="literal">display()</code> method with the HTML or JavaScript classes. You can even use the <code class="literal">display_markdown()</code> method to <a id="id254" class="indexterm"/>output rich text using the Markdown markup language (<a class="ulink" href="https://en.wikipedia.org/wiki/Markdown">https://en.wikipedia.org/wiki/Markdown</a>) as shown <a id="id255" class="indexterm"/>in the following code:</p><div><pre class="programlisting">from pixiedust.display.app import *
from IPython.display import display_markdown

@PixieApp
class TestMarkdown():
    @route()
    <strong>@captureOutput</strong>
    def main_screen(self):
        display_markdown("""
# Main Header:
## Secondary Header with bullet
1. item1
2. item2
3. item3

Showing image of the PixieDust logo
![alt text](https://github.com/pixiedust/pixiedust/raw/master/docs/_static/PixieDust%202C%20\(256x256\).png "PixieDust Logo")
    """, raw=True)

TestMarkdown().run()</pre></div><p>This produces the following result:</p><div><img src="img/B09699_05_02.jpg" alt="Create a word cloud image with @captureOutput" width="970" height="524"/><div><p>PixieApp using @captureOutput with Markdown</p></div></div></div></div></div></div>



  
<div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Increase modularity and code reuse</h1></div></div></div><p>Breaking up <a id="id256" class="indexterm"/>your application into smaller, self-contained components is always a good <a id="id257" class="indexterm"/>development practice because it makes the code reusable and easier to maintain. The PixieApp framework provides two ways to create and run reusable components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dynamically invoking other PixieApps with the <code class="literal">pd_app</code> attribute</li><li class="listitem" style="list-style-type: disc">Packaging part of an application as a reusable widget</li></ul></div><p>Using the <code class="literal">pd_app</code> attribute, you can dynamically invoke another PixieApp (we'll call it child PixieApp from here on) by its fully qualified class name. The output of the child PixieApp is placed in the host HTML element (usually a div element) or in a dialog by using the <code class="literal">runInDialog=true</code> option. You can also initialize the child PixieApp using the <code class="literal">pd_options</code> attribute, in which case the framework will invoke the corresponding route.</p><p>To better <a id="id258" class="indexterm"/>understand how <code class="literal">pd_app</code> works, let's rewrite our <code class="literal">WordCloud</code> application <a id="id259" class="indexterm"/>by refactoring the code that generates the <code class="literal">WordCloud</code> image in its own PixieApp that we'll call <code class="literal">WCChildApp</code>.</p><p>The following code implements <code class="literal">WCChildApp</code> as a regular PixieApp, but notice that it doesn't contain a default route. It only has a route called <code class="literal">generate_word_cloud</code> that is supposed to be called by another PixieApp using a <code class="literal">url</code> argument:</p><div><pre class="programlisting">from pixiedust.display.app import *
import requests
from wordcloud import WordCloud
import matplotlib.pyplot as plt

@PixieApp
class WCChildApp():
    @route(url='*')
    @captureOutput
    def generate_word_cloud(self, url):
        text = requests.get(url).text
        plt.axis("off")
        plt.imshow(
            WordCloud(max_font_size=40).generate(text),
            interpolation='bilinear'
        )</pre></div><div><div><h3 class="title"><a id="note85"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode2.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode2.py</a>
</p></div></div><p>We can now build the main PixieApp that will invoke the <code class="literal">WCChildApp</code> when the user clicks on the <strong>Go</strong> button after specifying the URL:</p><div><pre class="programlisting">@PixieApp
class WordCloudApp():
    @route()
    def main_screen(self):
        return """
        &lt;div style="text-align:center"&gt;
            &lt;label&gt;Enter a url: &lt;/label&gt;
            &lt;input type="text" size="80" id="url{{prefix}}"&gt;
            &lt;button type="submit"
                pd_options="url=$val(url{{prefix}})"
                <strong>pd_app="WCChildApp"</strong>
                pd_target="wordcloud{{prefix}}"&gt;
                Go
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;center&gt;&lt;div id="wordcloud{{prefix}}"&gt;&lt;/div&gt;&lt;/center&gt;
        """

app = WordCloudApp()
app.run()</pre></div><div><div><h3 class="title"><a id="note86"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode3.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode3.py</a>
</p></div></div><p>In the preceding code, the <code class="literal">Go</code> button has the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pd_app="WCChildApp"</code>: Use the class name for the child PixieApp. Note that if your child PixieApp lives in an imported Python module, then you'll need to use the fully qualified name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pd_options="url=$val(url{{prefix}})"</code>: Store the URL entered by the user as an initialization option to the child PixieApp.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pd_target="wordcloud{{prefix}}"</code>: Tell PixieDust to place the output of the child PixieApp in the div with the ID <code class="literal">wordcloud{{prefix}}</code>.</li></ul></div><p>The <code class="literal">pd_app</code> attribute is a powerful way to modularize your code by encapsulating the logic and presentation of a <a id="id260" class="indexterm"/>component. The <code class="literal">pd_widget</code> attribute provides another way to achieve similar results, but this time the component is not invoked externally, but rather by inheritance.</p><p>Each method has pros and cons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">pd_widget</code> technique is implemented as a route and is certainly more lightweight than <code class="literal">pd_app,</code> which requires the creation of an entirely new PixieApp instance. Note that both <code class="literal">pd_widget</code> and <code class="literal">pd_app</code> (through the <code class="literal">parent_pixieapp</code> variable) have access to all variables contained in the host app.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">pd_app</code> attribute provides a cleaner separation between the components and more flexibility than widgets. You could, for example, have a button that dynamically invokes multiple PixieApps based on some user selection.<div><div><h3 class="title"><a id="note87"/>Note</h3><p>
<strong>Note</strong>: As we'll see later in this chapter, this is actually what the PixieDust display uses for the options dialog.</p></div></div></li></ul></div><p>If you find yourself in need of having multiple copies of the same component in a PixieApp, ask yourself whether the component requires its state to be maintained in a class variable. If that's the case, it is preferable to use <code class="literal">pd_app,</code> but, if not, then using <code class="literal">pd_widget</code> would work as well.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Creating a widget with pd_widget</h2></div></div></div><p>To create a <a id="id261" class="indexterm"/>widget, you can use the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a PixieApp class <a id="id262" class="indexterm"/>that contains a route tagged with a special argument called <code class="literal">widget</code></li><li class="listitem">Make the main class inherit from the PixieApp widget</li><li class="listitem">Invoke the widget using the <code class="literal">pd_widget</code> attribute on a div element</li></ol></div><p>Again, as an illustration, let's rewrite the <code class="literal">WordCloud</code> app with the widget:</p><div><pre class="programlisting">from pixiedust.display.app import *
import requests
from word cloud import WordCloud
import matplotlib.pyplot as plt

@PixieApp
class WCChildApp():
    <strong>@route(widget='wordcloud')</strong>
    @captureOutput
    def generate_word_cloud(self):
        text = requests.get(self.url).text if self.url else ""
        plt.axis("off")
        plt.imshow(
            WordCloud(max_font_size=40).generate(text),
            interpolation='bilinear'
        )</pre></div><div><div><h3 class="title"><a id="note88"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode4.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode4.py</a>
</p></div></div><p>Notice in the preceding code that <code class="literal">url</code> is now referenced as a class variable because we assume that the base class will provide it. The code has to test whether <code class="literal">url</code> is <code class="literal">None,</code> which would be the case on startup. We implement it this way because <code class="literal">pd_widget</code> is an attribute that cannot easily be dynamically generated (you would have to use a secondary route that generates the div fragment with the <code class="literal">pd_widget</code> attribute).</p><p>The main PixieApp class now looks like this:</p><div><pre class="programlisting">@PixieApp
class WordCloudApp(WCChildApp):
    @route()
    def main_screen(self):
        self.url=None
        return """
        &lt;div style="text-align:center"&gt;
            &lt;label&gt;Enter a url: &lt;/label&gt;
            &lt;input type="text" size="80" id="url{{prefix}}"&gt;
            &lt;button type="submit"
                pd_script="self.url = '$val(url{{prefix}})'"
                pd_refresh="wordcloud{{prefix}}"&gt;
                Go
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;center&gt;&lt;div <strong>pd_widget="wordcloud"</strong> id="wordcloud{{prefix}}"&gt;&lt;/div&gt;&lt;/center&gt;
        """

app = WordCloudApp()
app.run()</pre></div><div><div><h3 class="title"><a id="note89"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode5.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode5.py</a>
</p></div></div><p>The div that contains the <code class="literal">pd_widget</code> attribute is rendered on start, but since <code class="literal">url</code> is still <code class="literal">None</code>, no <a id="id263" class="indexterm"/>word cloud is actually generated. The <code class="literal">Go</code> button has a <code class="literal">pd_script</code> attribute that set the <code class="literal">self.url</code> to the value provided by the user. It also has a <code class="literal">pd_refresh</code> attribute sets to the <code class="literal">pd_widget</code> div that will call the <code class="literal">wordcloud</code> widget again, but this time with a URL initialized to the correct value.</p><p>In this section, we've seen two ways to modularize your code for reuse, as well as the pros and cons for both. I strongly recommend that you play with the code to get a feel of when to use each technique. Don't worry if you feel this is still a little fuzzy; it will hopefully become clearer when we use these techniques in the sample code of the chapters ahead.</p><p>In the next section, we change gears and look at streaming data support in PixieDust.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec24"/>PixieDust support of streaming data</h2></div></div></div><p>With the rise of <strong>IOT</strong> devices (<strong>Internet of Things</strong>), being able to analyze and visualize live streams of <a id="id264" class="indexterm"/>data is becoming more and more important. For example, you could have sensors such as thermometers in machines or portable medical devices like pacemakers, continuously streaming data to a streaming service such as Kafka. PixieDust makes it easier to work with live data inside Jupyter Notebooks by providing simple integration APIs to both the PixieApp and the <code class="literal">display()</code> framework.</p><p>On a visualization level, PixieDust uses Bokeh (<a class="ulink" href="https://bokeh.pydata.org">https://bokeh.pydata.org</a>) support for efficient data source updates to plot streaming data into live charts (note that at the moment, only line chart and scatter plot are supported, but more will be added in the future). The <code class="literal">display()</code> framework also supports geospatial visualization of streaming data using the Mapbox rendering engine.</p><p>To activate streaming visualizations, you need to use a class that inherits from <code class="literal">StreamingDataAdapter,</code> which is an abstract class that is part of the PixieDust API. This class acts as a generic bridge between the streaming data source and the visualization framework.</p><div><div><h3 class="title"><a id="note90"/>Note</h3><p>
<strong>Note</strong>: I recommend spending time looking at the code for <code class="literal">StreamingDataAdapter</code> here:</p><p>
<a class="ulink" href="https://github.com/pixiedust/pixiedust/blob/0c536b45c9af681a4da160170d38879298aa87cb/pixiedust/display/streaming/__init__.py">https://github.com/pixiedust/pixiedust/blob/0c536b45c9af681a4da160170d38879298aa87cb/pixiedust/display/streaming/__init__.py</a>
</p></div></div><p>The following diagram shows how the <code class="literal">StreamingDataAdapter</code> data structure fits into the <code class="literal">display()</code> framework:</p><div><img src="img/B09699_05_03.jpg" alt="PixieDust support of streaming data" width="455" height="311"/><div><p>StreamingDataAdapter architecture</p></div></div><p>When implementing a subclass of <code class="literal">StreamingDataAdapter</code>, you must override the <code class="literal">doGetNextData()</code> method provided by the base class, which will be called repeatedly to fetch new data to update the <a id="id265" class="indexterm"/>visualization. You can also optionally override the <code class="literal">getMetadata()</code> method to pass context to the rendering engine (we'll use this method later to configure the Mapbox rendering).</p><p>The abstract implementation of <code class="literal">doGetNextData()</code> looks like this:</p><div><pre class="programlisting">@abstractmethod
def doGetNextData(self):
    """Return the next batch of data from the underlying stream.
    Accepted return values are:
    1. (x,y): tuple of list/numpy arrays representing the x and y axis
    2. pandas dataframe
    3. y: list/numpy array representing the y axis. In this case, the x axis is automatically created
    4. pandas serie: similar to #3
    5. json
    6. geojson
    7. url with supported payload (json/geojson)
    """
    Pass</pre></div><div><div><h3 class="title"><a id="note91"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode6.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode6.py</a>
</p></div></div><p>The preceding docstring explains the different types of data that is allowed to be returned from <code class="literal">doGetNextData()</code>.</p><p>As an example, we want to visualize the location of a fictitious drone wandering around the earth on a map and in real time. Its current location is provided by a REST service at: <a class="ulink" href="https://wanderdrone.appspot.com">https://wanderdrone.appspot.com</a>.</p><p>The payload uses GeoJSON (<a class="ulink" href="http://geojson.org">http://geojson.org</a>), for example:</p><div><pre class="programlisting">{
    "geometry": {
        "type": "Point",
        "coordinates": [
            -93.824908715741202, 10.875051131034805
        ]
    },
    "type": "Feature",
    "properties": {}
}</pre></div><div><div><h3 class="title"><a id="note92"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode7.json">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode7.json</a>
</p></div></div><p>To render our drone <a id="id266" class="indexterm"/>location in real time, we create a <code class="literal">DroneStreamingAdapter</code> class that inherits from <code class="literal">StreamingDataAdapter</code> and simply return the drone location service URL in the <code class="literal">doGetNextData()</code> method as shown in the following code:</p><div><pre class="programlisting">from pixiedust.display.streaming import *

class DroneStreamingAdapter(StreamingDataAdapter):
    def getMetadata(self):
        iconImage = "rocket-15"
        return {
            "layout": {"icon-image": iconImage, "icon-size": 1.5},
            "type": "symbol"
        }
    def doGetNextData(self):
        return "https://wanderdrone.appspot.com/"
adapter = DroneStreamingAdapter()
display(adapter)</pre></div><div><div><h3 class="title"><a id="note93"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode8.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode8.py</a>
</p></div></div><p>In the <code class="literal">getMetadata()</code> method, we return the Mapbox specific style properties (as documented here: <a class="ulink" href="https://www.mapbox.com/mapbox-gl-js/style-spec">https://www.mapbox.com/mapbox-gl-js/style-spec</a>) that uses a rocket Maki icon (<a class="ulink" href="https://www.mapbox.com/maki-icons">https://www.mapbox.com/maki-icons</a>) as a symbol for the drone.</p><p>With a few lines of code, we <a id="id267" class="indexterm"/>were able to create a real-time geospatial visualization of a drone location, with the following results:</p><div><img src="img/B09699_05_04.jpg" alt="PixieDust support of streaming data" width="1000" height="645"/><div><p>Real-time geospatial mapping of a drone</p></div></div><div><div><h3 class="title"><a id="note94"/>Note</h3><p>You can find the complete Notebook for this example in the PixieDust repo at this location:</p><p>
<a class="ulink" href="https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/Mapbox%20Streaming.ipynb">https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/Mapbox%20Streaming.ipynb</a>
</p></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Adding streaming capabilities to your PixieApp</h3></div></div></div><p>In the next example, we <a id="id268" class="indexterm"/>show how to visualize streaming data coming from an Apache Kafka data source, using the <code class="literal">MessageHubStreamingApp</code> PixieApp provided out of the box by PixieDust: <a class="ulink" href="https://github.com/pixiedust/pixiedust/blob/master/pixiedust/apps/messageHub/messageHubApp.py">https://github.com/pixiedust/pixiedust/blob/master/pixiedust/apps/messageHub/messageHubApp.py</a>.</p><div><div><h3 class="title"><a id="note95"/>Note</h3><p>
<strong>Note</strong>: <code class="literal">MessageHubStreamingApp</code> works with the IBM Cloud Kafka service called Message Hub (<a class="ulink" href="https://console.bluemix.net/docs/services/MessageHub/index.html#messagehub">https://console.bluemix.net/docs/services/MessageHub/index.html#messagehub</a>), but it can easily be adapted to any other Kafka service.</p></div></div><p>Don't worry if you are not familiar with Apache Kafka as we'll cover aspects of this in <a class="link" href="ch07.xhtml" title="Chapter 7. Analytics Study: NLP and Big Data with Twitter Sentiment Analysis">Chapter 7</a>, <em>Analytics Study: NLP and Big Data with Twitter Sentiment Analysis</em>.</p><p>This PixieApp lets the user choose a Kafka topic associated with a service instance and display the events in real-time. Assuming that the events payload from the selected topic uses a JSON format, it presents a schema inferred from sampling the events data. The user can then choose a particular field (must be numerical) and a real-time chart showing the average of the values for this field over time is displayed.</p><div><img src="img/B09699_05_05.jpg" alt="Adding streaming capabilities to your PixieApp" width="901" height="1000"/><div><p>Real-time visualization of streaming data</p></div></div><p>The key PixieApp attribute needed to provide streaming capabilities is <code class="literal">pd_refresh_rate,</code> which executes a particular kernel request at specified intervals (pull model). In the preceding <a id="id269" class="indexterm"/>application, we use it to update the real-time chart, as shown in the following HTML fragment returned by the <code class="literal">showChart</code> route:</p><div><pre class="programlisting">    @route(topic="*",streampreview="*",schemaX="*")
    def showChart(self, schemaX):
        self.schemaX = schemaX
        self.avgChannelData = self.streamingData.getStreamingChannel(self.computeAverages)
        return """
&lt;div class="well" style="text-align:center"&gt;
    &lt;div style="font-size:x-large"&gt;Real-time chart for {{this.schemaX}}(average).&lt;/div&gt;
&lt;/div&gt;

&lt;div pd_refresh_rate="1000" pd_entity="avgChannelData"&gt;&lt;/div&gt;
        """</pre></div><div><div><h3 class="title"><a id="note96"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode9.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode9.py</a>
</p></div></div><p>The preceding div is bound to the <code class="literal">avgChannelData</code> entity via the <code class="literal">pd_entity</code> attribute and is responsible for creating the real-time chart that is updated every second (<em>pd_refresh_rate=1000 ms</em>). In turn, the <code class="literal">avgChannelData</code> entity is created via a call to <code class="literal">getStreamingChannel(),</code> which is passed to the <code class="literal">self</code>. The <code class="literal">computeAverage</code> function is responsible for updating the <a id="id270" class="indexterm"/>average value for all the data being streamed. It is important to note that <code class="literal">avgChannelData</code> is a class that inherits from <code class="literal">StreamingDataAdapter</code> and, therefore, can be passed to the <code class="literal">display()</code> framework for building real-time charts.</p><p>The last piece of the puzzle is for the PixieApp to return a <code class="literal">displayHandler</code> needed by the <code class="literal">display()</code> framework. This is done by overriding the <code class="literal">newDisplayHandler()</code> method as follows:</p><div><pre class="programlisting">def newDisplayHandler(self, options, entity):
    if self.streamingDisplay is None:
        self.streamingDisplay = LineChartStreamingDisplay(options, entity)
    else:
        self.streamingDisplay.options = options
    return self.streamingDisplay</pre></div><div><div><h3 class="title"><a id="note97"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode10.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode10.py</a>
</p></div></div><p>In the preceding code, we use it to create an instance of <code class="literal">LineChartStreamingDisplay</code> provided by PixieDust in the <code class="literal">pixiedust.display.streaming.bokeh</code> package (<a class="ulink" href="https://github.com/pixiedust/pixiedust/blob/master/pixiedust/display/streaming/bokeh/lineChartStreamingDisplay.py">https://github.com/pixiedust/pixiedust/blob/master/pixiedust/display/streaming/bokeh/lineChartStreamingDisplay.py</a>), passing the <code class="literal">avgChannelData</code> entity.</p><p>If you want to see this application in action, you need to create a Message Hub service instance on IBM Cloud (<a class="ulink" href="https://console.bluemix.net/catalog/services/message-hub">https://console.bluemix.net/catalog/services/message-hub</a>) and, using its credentials, invoke this PixieApp in a Notebook with the following code:</p><div><pre class="programlisting">from pixiedust.apps.messageHub import *
MessageHubStreamingApp().run(
    credentials={
        "username": "XXXX",
        "password": "XXXX",
        "api_key" : "XXXX",
        "prod": True
    }
)</pre></div><p>If you are interested in knowing more about PixieDust streaming, you can find other streaming application examples here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A simple PixieApp that demonstrate how to create streaming visualizations from randomly generated data: <a class="ulink" href="https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Random.ipynb">https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Random.ipynb</a><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">PixieApp that shows how to build live visualization of stock tickers: <a class="ulink" href="https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Stock%20Ticker.ipynb">https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Stock%20Ticker.ipynb</a></li></ul></div><p>The next topic will cover PixieApp events that let you add interactivity between different components of your application.</p></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec25"/>Adding dashboard drill-downs with PixieApp events</h2></div></div></div><p>The PixieApp framework supports sending and receiving events between different components using <a id="id271" class="indexterm"/>the publish-subscribe pattern available in browsers. The great advantage of using this model, which borrows from the loose coupling pattern (<a class="ulink" href="https://en.wikipedia.org/wiki/Loose_coupling">https://en.wikipedia.org/wiki/Loose_coupling</a>), is that it allows the sending and receiving components to remain agnostic of each other. Therefore, their implementation can be executed independently from one another and will not be sensitive to changes in requirements. This can be very useful when your PixieApp is using components from different PixieApps built by different teams, or if the events are coming from the user interacting with a chart (for instance, clicking on a map) and you want to provide drill-down features.</p><p>Each event carries a JSON payload of arbitrary keys and values. The payload must have at least one of the following keys (or both):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">targetDivId</code>: A DOM ID identifying the element sending the event</li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: A string identifying the event type</li></ul></div><p>Publishers can trigger events in two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Declarative</strong>: Use the <code class="literal">pd_event_payload</code> attribute to specify the payload content. This attribute follows the same rules as <code class="literal">pd_options</code>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each key/value pair must be encoded using the <code class="literal">key=value</code> notation</li><li class="listitem" style="list-style-type: disc">The event will be triggered by a click or a change event</li><li class="listitem" style="list-style-type: disc">Support must be provided for the <code class="literal">$val()</code> directive to dynamically inject user-entered input</li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">&lt;pd_event_payload&gt;</code> child to enter raw JSON<div><pre class="programlisting">&lt;button type="submit" pd_event_payload="type=topicA;message=Button clicked"&gt;
    Send event A
&lt;/button&gt;</pre></div><div><pre class="programlisting">&lt;button type="submit"&gt;
    &lt;pd_event_payload&gt;
    {
        "type":"topicA",
        "message":"Button Clicked"
    }
    &lt;/pd_event_payload&gt;
    Send event A
&lt;/button&gt;</pre></div></li></ul></div><p>Example:</p><p>Alternatively, we can use this:</p><div><div><h3 class="title"><a id="note98"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode11.html">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode11.html</a>
</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Programmatic</strong>: In some cases, you may want to directly trigger an event via JavaScript. In this case, you <a id="id272" class="indexterm"/>can use the <code class="literal">sendEvent(payload, divId)</code> method of the <code class="literal">pixiedust</code> global object. The <code class="literal">divId</code> is an optional argument that specifies the origin of the event. If the <code class="literal">divId</code> argument is omitted, then it defaults to the <code class="literal">divId</code> of the element that is currently sending the event. As a result, you should always use <code class="literal">pixiedust.sendEvent</code> without a <code class="literal">divId</code> from a JavaScript handler of a user event such as click, and hover.<p>Example:</p><div><pre class="programlisting">&lt;table
onclick="pixiedust.sendEvent({type:'topicB',text:event.srcElement.innerText})"&gt;
    &lt;tr&gt;&lt;td&gt;Row 1&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row 2&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Row 3&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</pre></div><div><div><h3 class="title"><a id="note99"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode12.html">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode12.html</a>
</p></div></div></li></ul></div><p>Subscribers can listen to an event by declaring a <code class="literal">&lt;pd_event_handler&gt;</code> element that can accept any of the <a id="id273" class="indexterm"/>PixieApp Kernel execution attributes, such as <code class="literal">pd_options</code> and <code class="literal">pd_script</code>. It must also use the <code class="literal">pd_source</code> attribute to filter which events they want to process. The <code class="literal">pd_source</code> attribute can contain one of the following values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">targetDivId</code>: Only events originating from the element with the specified ID will be accepted</li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: Only events with the specified type will be accepted</li><li class="listitem" style="list-style-type: disc"><code class="literal">"*"</code>: Denotes that any event will be accepted</li></ul></div><p>Example:</p><div><pre class="programlisting">&lt;div class="col-sm-6" id="listenerA{{prefix}}"&gt;
    Listening to button event
    &lt;pd_event_handler
        pd_source="topicA"
        pd_script="print(eventInfo)"
        pd_target="listenerA{{prefix}}"&gt;
    &lt;/pd_event_handler&gt;
&lt;/div&gt;</pre></div><div><div><h3 class="title"><a id="note100"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode13.html">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode13.html</a>
</p></div></div><p>The following diagram shows how components interact with one another:</p><p> </p><div><img src="img/B09699_05_06.jpg" alt="Adding dashboard drill-downs with PixieApp events" width="451" height="318"/><div><p>Sending/receiving events between components</p></div></div><p>
</p><p>In the following code sample, we illustrate the PixieDust eventing system by building two publishers, a button <a id="id274" class="indexterm"/>element and a table, where each row is an event source. We also have two listeners implemented as div elements:</p><div><pre class="programlisting">from pixiedust.display.app import *
@PixieApp
class TestEvents():
    @route()
    def main_screen(self):
        return """
&lt;div&gt;
    &lt;button type="submit"&gt;
        &lt;pd_event_payload&gt;
        {
            "type":"topicA",
            "message":"Button Clicked"
        }
        &lt;/pd_event_payload&gt;
        Send event A
    &lt;/button&gt;
    &lt;table onclick="pixiedust.sendEvent({type:'topicB',text:event.srcElement.innerText})"&gt;
        &lt;tr&gt;&lt;td&gt;Row 1&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Row 2&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Row 3&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
&lt;/div&gt;
&lt;div class="container" style="margin-top:30px"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-sm-6" id="listenerA{{prefix}}"&gt;
            Listening to button event
            &lt;pd_event_handler pd_source="topicA" pd_script="print(eventInfo)" pd_target="listenerA{{prefix}}"&gt;
            &lt;/pd_event_handler&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-6" id="listenerB{{prefix}}"&gt;
            Listening to table event
            &lt;pd_event_handler pd_source="topicB" pd_script="print(eventInfo)" pd_target="listenerB{{prefix}}"&gt;
            &lt;/pd_event_handler&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
        """
app = TestEvents()
app.run()</pre></div><div><div><h3 class="title"><a id="note101"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode14.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode14.py</a>
</p></div></div><p>The preceding code produces the following results:</p><div><img src="img/B09699_05_07.jpg" alt="Adding dashboard drill-downs with PixieApp events" width="1000" height="243"/><div><p>User interaction flow for PixieApp events</p></div></div><p>PixieApp events enable you to create sophisticated dashboards with drill-down capabilities. It is also good to know that you can leverage events that are automatically published for some of the charts generated by the <code class="literal">display()</code> framework. For example, built-in renderers, such as <a id="id275" class="indexterm"/>Google Maps, Mapbox, and Table, will automatically generate events when the user clicks somewhere on the chart. This is very useful for rapidly building all kinds of interactive dashboards with drill-down capabilities.</p><p>In the next topic, we'll discuss how to use the PixieDust extensibility APIs to create custom visualizations.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Extending PixieDust visualizations</h2></div></div></div><p>PixieDust is designed to be highly extensible. You can create your own visualization and control when it can be invoked, based on the entity being displayed. There are multiple extensibility layers <a id="id276" class="indexterm"/>provided by the PixieDust framework. The lowest and most powerful one lets you create your own <code class="literal">Display</code> class. However, the majority of visualizations have a lot of properties in common, such as standard options (aggregation, max rows, title, and so on), or a caching mechanism to prevent recomputing everything if the user only selected a minor option that doesn't require reprocessing of the data.</p><p>To prevent users from reinventing the wheel every time, PixieDust offers a second extensibility layer called <strong>renderer</strong> that includes all the facilities described here.</p><p>The following diagram illustrates the different layers:</p><div><img src="img/B09699_05_08.jpg" alt="Extending PixieDust visualizations" width="421" height="303"/><div><p>PixieDust extension layers</p></div></div><p>To start working with the <strong>Display Extension Layer</strong>, you'll need to get your visualization presented in the menu by creating a class that inherits from <code class="literal">pixiedust.display.DisplayHandlerMeta</code>. This class contains two methods that need to be overridden:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getMenuInfo(self,entity,dataHandler)</code>: Return an empty array if the entity passed as an argument is not supported, otherwise an array containing a set of JSON objects with information about the menu. Each JSON object must contain the following information:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: A unique <a id="id277" class="indexterm"/>string that identifies your tool.</li><li class="listitem" style="list-style-type: disc"><code class="literal">categoryId</code>: A unique string that identifies the menu category or group. A full list of all the built-in categories is provided a little later on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">title</code>: An arbitrary string that describes the menu.</li><li class="listitem" style="list-style-type: disc"><code class="literal">icon</code>: The name of a font-awesome icon, or a URL for an image.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">newDisplayHandler(self,options,entity)</code>: When your menu is activated by the user, the <code class="literal">newDisplayHandler()</code> method is called. This method must return a class instance that inherits from <code class="literal">pixiedust.display.Display</code>. The contract is for this class to implement the <code class="literal">doRender()</code> method, which is responsible for creating the visualization.</li></ul></div><p>Let's take the example of creating a custom table rendering for a pandas DataFrame. We first create the <code class="literal">DisplayHandlerMeta</code> class that configures the menu and the factory method:</p><div><pre class="programlisting">from pixiedust.display.display import *
import pandas
<strong>@PixiedustDisplay()</strong>
class SimpleDisplayMeta(DisplayHandlerMeta):
    @addId
    def getMenuInfo(self,entity,dataHandler):
        if type(entity) is pandas.core.frame.DataFrame:
            return [
               {"categoryId": "Table", "title": "Simple Table", "icon": "fa-table", "id": "simpleTest"}
            ]
        return []
    def newDisplayHandler(self,options,entity):
        return SimpleDisplay(options,entity)</pre></div><div><div><h3 class="title"><a id="note102"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode15.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode15.py</a>
</p></div></div><p>Notice that the preceding <code class="literal">SimpleDisplayMeta</code> class needs to be decorated with <code class="literal">@PixiedustDisplay,</code> which is required to add this class to the internal PixieDust registry of plugins. In the <code class="literal">getMenuInfo()</code> method, we first check whether the entity type is <em>pandas DataFrame</em> and, if not, return an empty array signifying that this plugin doesn't support the current entity and will therefore not contribute anything to the menu. If the type is correct, we return an <a id="id278" class="indexterm"/>array with one JSON object containing the menu info.</p><p>The factory method <code class="literal">newDisplayHandler()</code> gets passed the <code class="literal">options</code> and <code class="literal">entity</code> as parameters. The <code class="literal">options</code> argument is a dictionary of key/value pairs containing the various choices made by the users. As we'll see later, the visualization can define arbitrary key/value pairs reflecting its capabilities, and the PixieDust framework will automatically persist them in the cell metadata.</p><p>For example, you could add an option for displaying HTTP links as clickable in the UI. In our example, we return a <code class="literal">SimpleDisplay</code> instance as defined here:</p><div><pre class="programlisting">class SimpleDisplay(Display):
    def doRender(self, handlerId):
        self._addHTMLTemplateString("""
&lt;table class="table table-striped"&gt;
   &lt;thead&gt;
       {%for column in entity.columns.tolist()%}
       &lt;th&gt;{{column}}&lt;/th&gt;
       {%endfor%}
   &lt;/thead&gt;
   &lt;tbody&gt;
       {%for _, row in entity.iterrows()%}
       &lt;tr&gt;
           {%for value in row.tolist()%}
           &lt;td&gt;{{value}}&lt;/td&gt;
           {%endfor%}
       &lt;/tr&gt;
       {%endfor%}
   &lt;/tbody&gt;
&lt;/table&gt;
        """)</pre></div><div><div><h3 class="title"><a id="note103"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode16.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode16.py</a>
</p></div></div><p>As stated before, the <code class="literal">SimpleDisplay</code> class must inherit from the <code class="literal">Display</code> class and implement the <code class="literal">doRender()</code> method. Within the implementation of this method, you have access to the <code class="literal">self.entity</code> and <code class="literal">self.options</code> variables to adjust how the information is rendered on screen. In the preceding sample, we use the <code class="literal">self._addHTMLTemplateString()</code> method to create the HTML fragment that will render the visualization. As is the case for PixieApp routes, the string being passed to <code class="literal">self._addHTMLTemplateString()</code> can leverage the Jinja2 template engine and have automatic access to variables such as <code class="literal">entity</code>. If you don't want to hardcode the template string in the Python file, you <a id="id279" class="indexterm"/>can extract it into its own file that you must place in a directory called <code class="literal">templates</code> that must be located in the same directory as the calling Python file. You would then need to use the <code class="literal">self._addHTMLTemplate()</code> method that takes the name of the file as an argument (without specifying the <code class="literal">templates</code> directory).</p><div><div><h3 class="title"><a id="note104"/>Note</h3><p>The other advantage of externalizing the HTML fragment into its own file is that you don't have to restart the kernel every time you make a change, which can save you a lot of time. Because of the way Python works, the same cannot be said if the HTML fragment is embedded in the source code, in which case you would have to restart the kernel for any changes made in the HTML fragment.</p></div></div><p>It is also important to note that <code class="literal">self._addHTMLTemplate()</code> and <code class="literal">self._addHTMLTemplateString()</code> accept keyword arguments that will be passed to the Jinja2 template. For example:</p><div><pre class="programlisting">self._addHTMLTemplate('simpleTable.html', custom_arg = "Some value")</pre></div><p>We can now run a cell that displays, for example, the <code class="literal">cars</code> dataset:</p><div><div><h3 class="title"><a id="note105"/>Note</h3><p>
<strong>Note</strong>: The <strong>Simple Table</strong> extension only works with pandas, not Spark DataFrame. Therefore, you would need to use <code class="literal">forcePandas = True</code> when calling <code class="literal">sampleData()</code> if your Notebook is connected to Spark.</p></div></div><div><img src="img/B09699_05_09.jpg" alt="Extending PixieDust visualizations" width="1000" height="444"/><div><p>Running a custom visualization plugin on a pandas DataFrame</p></div></div><p>As shown in the PixieDust extension layer architecture diagram, you can also extend PixieDust using the <strong>Renderer Extension Layer</strong>, which is more prescriptive than the <strong>Display Extension Layer</strong> but provides many more capabilities out of the box, such as options management and interim data computation caching. From the user interface perspective, users can switch between renderers <a id="id280" class="indexterm"/>using a <strong>Renderer</strong> drop-down in the upper right-hand corner of the chart area.</p><p>PixieDust comes with a few built-in renderers, such as Matplotlib, Seaborn, Bokeh, Mapbox, Brunel, and Google Maps, but it doesn't declare any hard dependency on the underlying visualization libraries, including Bokeh, Brunel, or Seaborn. Therefore, it is incumbent on the user to manually install them, otherwise, they won't show up in the menus.</p><p>The following screenshot illustrates the mechanism to switch between renderers for a given chart:</p><div><img src="img/B09699_05_10.jpg" alt="Extending PixieDust visualizations" width="1000" height="725"/><div><p>Switching between renderers</p></div></div><p>Adding a new renderer is similar to adding a display visualization (it's using the same APIs), though it's actually simpler since you only have to build one class (no need to build the metadata class). Here are the steps you need to follow:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a Display class that inherits from the specialized <code class="literal">BaseChartDisplay class</code>. Implement the required <code class="literal">doRenderChart()</code> method.</li><li class="listitem">Use the <code class="literal">@PixiedustRenderer</code> decorator to register the <code class="literal">rendererId</code> (which must be unique <a id="id281" class="indexterm"/>across all renderers) and the type of chart being rendered.<p>Note that the same <code class="literal">rendererId</code> can be reused for all the charts included in the renderer. PixieDust provides a set of core chart types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">tableView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">barChart</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">lineChart</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">scatterPlot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">pieChart</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mapView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">histogram</code></li></ul></div></li><li class="listitem"><em>(Optional)</em> Create a set of dynamic options using the <code class="literal">@commonChartOptions</code> decorator.</li><li class="listitem"><em>(Optional)</em> Customize the options dialog by overriding the <code class="literal">get_options_dialog_pixieapp()</code> method to return the fully qualified name of a PixieApp class inheriting from the <code class="literal">BaseOptions</code> class in the <code class="literal">pixiedust.display.chart.options.baseOptions</code> package.</li></ol></div><p>As an example, let's rewrite <a id="id282" class="indexterm"/>the preceding custom <code class="literal">SimpleDisplay</code> table visualization using the renderer extension layer:</p><div><pre class="programlisting">from pixiedust.display.chart.renderers import PixiedustRenderer
from pixiedust.display.chart.renderers.baseChartDisplay import BaseChartDisplay

@PixiedustRenderer(rendererId="simpletable", id="tableView")
class SimpleDisplayWithRenderer(BaseChartDisplay):
    def get_options_dialog_pixieapp(self):
        return None #No options needed

    def doRenderChart(self):
        return self.renderTemplateString("""
&lt;table class="table table-striped"&gt;
   &lt;thead&gt;
       {%for column in entity.columns.tolist()%}
       &lt;th&gt;{{column}}&lt;/th&gt;
       {%endfor%}
   &lt;/thead&gt;
   &lt;tbody&gt;
       {%for _, row in entity.iterrows()%}
       &lt;tr&gt;
           {%for value in row.tolist()%}
           &lt;td&gt;{{value}}&lt;/td&gt;
           {%endfor%}
       &lt;/tr&gt;
       {%endfor%}
   &lt;/tbody&gt;
&lt;/table&gt;
        """)</pre></div><div><div><h3 class="title"><a id="note106"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode17.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode17.py</a>
</p></div></div><p>We decorate the class with the <code class="literal">@PixiedustRenderer</code> decorator, specifying a unique <code class="literal">rendererId</code> called <code class="literal">simpletable,</code> and associating it with the <code class="literal">tableView</code> chart type defined by the PixieDust framework. We return <code class="literal">None</code> for the <code class="literal">get_options_dialog_pixieapp()</code> method to signify that this extension does not support custom options. As <a id="id283" class="indexterm"/>a result, the <strong>Options</strong> button will not be shown. In the <code class="literal">doRenderChart()</code> method, we return the HTML fragment. Since we want to use Jinja2, we need to render it using the <code class="literal">self.renderTemplateString</code> method.</p><p>We can now test this new renderer using the <code class="literal">cars</code> dataset.</p><div><div><h3 class="title"><a id="note107"/>Note</h3><p>Again, when running the code, make sure that you're loading the <code class="literal">cars</code> dataset as a pandas DataFrame. If you have already run the first implementation of the <strong>Simple Table</strong> and are reusing the Notebook, it is possible that you will still see the old <strong>Simple Table</strong> menu. If that's the case, you will need to restart the kernel and try again.</p></div></div><p>The following screenshot shows the simple table visualization as a renderer:</p><div><img src="img/B09699_05_11.jpg" alt="Extending PixieDust visualizations" width="1000" height="478"/><div><p>Testing the renderer implementation of the Simple Table</p></div></div><p>You can find more material about this topic at: <a class="ulink" href="https://pixiedust.github.io/pixiedust/develop.html">https://pixiedust.github.io/pixiedust/develop.html</a>. Hopefully, by now, you have a good idea about the type of customization <a id="id284" class="indexterm"/>you can write to integrate your own visualization in the <code class="literal">display()</code> framework.</p><p>In the next section, we'll discuss a very important topic for developers: debugging.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Debugging</h2></div></div></div><p>Being able to rapidly debug an application is critical to the success of your project. If not, most—if not all—of the gains we've made in term of productivity and collaboration, by breaking the silo between <a id="id285" class="indexterm"/>data science and engineering, will be lost. It is also important to note that our code runs in different places, that is, Python on the server side, and JavaScript on the client side, and that debugging must take place in both places. For Python code, let's look at two ways to troubleshoot programming errors.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Debugging on the Jupyter Notebook using pdb</h3></div></div></div><p>pdb (<a class="ulink" href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a>) is an interactive command- line <a id="id286" class="indexterm"/>Python debugger that comes as standard with every Python distribution.</p><p>There are <a id="id287" class="indexterm"/>multiple ways to invoke the debugger:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At launch, from <a id="id288" class="indexterm"/>the command line:<div><pre class="programlisting">
<strong>python -m pdb &lt;script_file&gt;</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">Programmatically, in the code:<div><pre class="programlisting">import pdb
pdb.run("&lt;insert a valid python statement here&gt;")</pre></div></li><li class="listitem" style="list-style-type: disc">By setting an explicit breakpoint in the code with the <code class="literal">set_trace()</code> method:<div><pre class="programlisting">import pdb
def my_function(arg1, arg2):
    pdb.set_trace()
    do_something_here()</pre></div><div><div><h3 class="title"><a id="note108"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode18.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode18.py</a>
</p></div></div></li><li class="listitem" style="list-style-type: disc">Post-mortem, after an exception has occurred, by calling <code class="literal">pdb.pm()</code>.</li></ul></div><p>Once in the interactive debugger, you can invoke commands, inspect variables, run statements, set breakpoints, and so on.</p><div><div><h3 class="title"><a id="note109"/>Note</h3><p>A complete list of commands can be found here:</p><p>
<a class="ulink" href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a>
</p></div></div><p>The great news is that Jupyter Notebooks provide first-class support for the interactive debugger. To invoke the debugger, simply use the <code class="literal">%pdb</code> cell magic command to turn it on/off, and, if an exception is triggered, then the debugger will automatically stop execution at the offending line.</p><p>Magic commands (<a class="ulink" href="http://ipython.readthedocs.io/en/stable/interactive/magics.html">http://ipython.readthedocs.io/en/stable/interactive/magics.html</a>) are constructs <a id="id289" class="indexterm"/>specific to the IPython kernel. They are language <a id="id290" class="indexterm"/>agnostic <a id="id291" class="indexterm"/>and therefore can theoretically be available in any language supported by the kernel (for example, Python, Scala, and R).</p><p>There are two types of magic commands:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line magics</strong>: The syntax is <code class="literal">%&lt;magic_command_name&gt; [optional arguments]</code>for example, <code class="literal">%matplotlib inline</code>, which configures Matplotlib to output the charts inline in the Notebook output cell.<p>They can be invoked <a id="id292" class="indexterm"/>anywhere in the cell code, and can even return values that can be assigned to Python variables, for example:</p><div><pre class="programlisting">#call the pwd line magic to get the current working directory
#and assign the <a id="id293" class="indexterm"/>result into a Python variable called pwd
pwd = %pwd
print(pwd)</pre></div><div><div><h3 class="title"><a id="note110"/>Note</h3><p>You can find a list of all the line magics here:</p><p>
<a class="ulink" href="http://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics">http://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics</a>
</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Cell magics</strong>: The syntax is <code class="literal">%%&lt;magic_command_name&gt; [optional arguments]</code>. For example, we call the HTML cell magic to display HTML on the output cell:<div><pre class="programlisting">%%html
&lt;div&gt;Hello World&lt;/div&gt;</pre></div><p>Cell magics must <a id="id294" class="indexterm"/>be located at the top of the cell; any other location would result in an execution error. Everything below the cell magic is passed as an argument to the handler to be interpreted according to the cell magic specification. For example, the HTML cell magic expects the rest of the cell content to be HTML.</p></li></ul></div><p>The following code example calls a function that raises a <code class="literal">ZeroDivisionError</code> exception, with <code class="literal">pdb</code> automatic calling activated:</p><div><div><h3 class="title"><a id="note111"/>Note</h3><p>
<strong>Note</strong>: Once you turn <code class="literal">pdb</code> on, it stays on for the duration of the Notebook session.</p></div></div><div><img src="img/B09699_05_12.jpg" alt="Debugging on the Jupyter Notebook using pdb" width="1000" height="839"/><div><p>Interactive command-line debugging</p></div></div><p>Here are some important <code class="literal">pdb</code> commands that can be used to troubleshoot an issue:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">s(tep)</code>: Step into the function being called and stop at the next statement line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">n(ext)</code>: Continue to <a id="id295" class="indexterm"/>the next line, without <a id="id296" class="indexterm"/>entering into a nest function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">l(list)</code>: List code surrounding the current line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">c(ontinue)</code>: Keep running the program and stop at the next breakpoint, or if another exception is raised.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d(own)</code>: Move down the stack frame.</li><li class="listitem" style="list-style-type: disc"><code class="literal">u(p)</code>: Move up the stack frame.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;any expression&gt;</code>: Evaluate and display an expression within the context of the current frame. For example, you can use <code class="literal">locals()</code> to get a list of all the local variables scoped to the current frame.</li></ul></div><p>If an exception occurred and you didn't set the automatic <code class="literal">pdb</code> calling, you can still invoke the debugger after the fact by using <code class="literal">%debug</code> magic in another cell, as shown in the following screenshot:</p><p> </p><div><img src="img/B09699_05_13.jpg" alt="Debugging on the Jupyter Notebook using pdb" width="498" height="209"/><div><p>Doing a post-mortem debugging session with %debug</p></div></div><p>
</p><p>Similar to a regular <a id="id297" class="indexterm"/>Python script, you can also <a id="id298" class="indexterm"/>explicitly set a breakpoint programmatically with the <code class="literal">pdb.set_trace()</code> method. However, it is recommended using the enhanced version of <code class="literal">set_trace()</code> provided by the IPython core module that provides syntax coloring:</p><div><img src="img/B09699_05_14.jpg" alt="Debugging on the Jupyter Notebook using pdb" width="485" height="258"/><div><p>Explicit breakpoint</p></div></div><p>In the next topic, we look at an enhanced version of the Python debugger provided by PixieDust.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec03"/>Visual debugging with PixieDebugger</h3></div></div></div><p>Using the standard <a id="id299" class="indexterm"/>command line-oriented Python pdb to debug your code is a nice tool to have in our tool belt, but it has two <a id="id300" class="indexterm"/>major limitations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's command line-oriented, which means that commands have to be entered manually and results are sequentially appended to the cell output, making it impractical when it comes to advanced debugging</li><li class="listitem" style="list-style-type: disc">It doesn't work with PixieApps</li></ul></div><p>The PixieDebugger capability addresses both issues. You can use it with any Python code running in a Jupyter Notebook cell to visually debug the code. To invoke the PixieDebugger in a cell, simply add the <code class="literal">%%pixie_debugger</code> cell magic at the top of the cell.</p><div><div><h3 class="title"><a id="note112"/>Note</h3><p>
<strong>Note</strong>: If you have not already done so, don't forget to always import <code class="literal">pixiedust</code> in a separate cell before attempting to use <code class="literal">%%pixie_debugger</code>.</p></div></div><p>As an example, the following code is trying to compute how many cars have the name <code class="literal">chevrolet</code> in the <code class="literal">cars</code> dataset:</p><div><pre class="programlisting">
<strong>%%pixie_debugger</strong>
import pixiedust
cars = pixiedust.sampleData(1, forcePandas=True)

def count_cars(name):
    count = 0
    for row in cars.itertuples():
        if name in row.name:
            count += 1     return count

count_cars('chevrolet')</pre></div><div><div><h3 class="title"><a id="note113"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode19.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode19.py</a>
</p></div></div><p>Running the cell with the preceding code will trigger the visual debugger shown in the following screenshot. The user interface lets you step into the code line by line, with the ability to <a id="id301" class="indexterm"/>inspect local variables, evaluate Python expressions, and set breakpoints. The code execution toolbar <a id="id302" class="indexterm"/>provides buttons for managing code execution: resume execution, step over the current line, step into the code a particular function, run to the end of the current function, and display the stack frame up and down one level:</p><div><img src="img/B09699_05_15.jpg" alt="Visual debugging with PixieDebugger" width="1000" height="487"/><div><p>PixieDebugger in action</p></div></div><p>With no parameter, the <code class="literal">pixie_debugger</code> cell magic will stop at the first executable statement in the code. However, you can easily configure it to stop at specific locations using the <code class="literal">-b</code> switch, followed by a list of breakpoints that could be either a line number or a method name.</p><p>Starting from the <a id="id303" class="indexterm"/>preceding example code, let's add breakpoints at the <code class="literal">count_cars()</code> method <a id="id304" class="indexterm"/>and line <strong>11</strong>:</p><div><pre class="programlisting">
<strong>%%pixie_debugger -b count_cars 11</strong>
import pixiedust
cars = pixiedust.sampleData(1, forcePandas=True)

def count_cars(name):
    count = 0
    for row in cars.itertuples():
        if name in row.name:
            count += 1
    return count

count_cars('chevrolet')</pre></div><div><div><h3 class="title"><a id="note114"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode20.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode20.py</a>
</p></div></div><p>Running the preceding code will now trigger the PixieDebugger <a id="id305" class="indexterm"/>to stop at the first executable statement of the <code class="literal">count_cars()</code> method. It also added a breakpoint at line 11, which will cause <a id="id306" class="indexterm"/>the execution flow to stop there if the user resumes, as can be seen in the following screenshot:</p><div><img src="img/B09699_05_16.jpg" alt="Visual debugging with PixieDebugger" width="1000" height="297"/><div><p>PixieDebugger with predefined breakpoints</p></div></div><div><div><h3 class="title"><a id="note115"/>Note</h3><p>
<strong>Note</strong>: To run to a specific line of code without setting an explicit breakpoint, simply hover over the line number in the gutter in the left-hand pane and click on the icon that appears.</p><p>Like the <code class="literal">%debug</code> line magic, you can also invoke the PixieDebugger to do post-mortem debugging by using the <code class="literal">%pixie_debugger</code> line magic.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec04"/>Debugging PixieApp routes with PixieDebugger</h3></div></div></div><p>PixieDebugger is fully <a id="id307" class="indexterm"/>integrated into the PixieApp framework. Whenever an exception happens while triggering a route, the <a id="id308" class="indexterm"/>resulting traceback is augmented with two extra buttons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Post Mortem</strong>: Invoke the PixieDebugger to start a post-mortem troubleshooting session that lets you inspect variables and analyses the stack frames</li><li class="listitem" style="list-style-type: disc"><strong>Debug Route</strong>: Replay the current route stopping at the first executable statement in the PixieDebugger</li></ul></div><p>As an example, let's <a id="id309" class="indexterm"/>consider the following code for implementing a PixieApp that lets the user search the <code class="literal">cars</code> dataset by <a id="id310" class="indexterm"/>providing a column name and a search query:</p><div><pre class="programlisting">from pixiedust.display.app import *

import pixiedust
cars = pixiedust.sampleData(1, forcePandas=True)

@PixieApp
class DisplayCars():
    @route()
    def main_screen(self):
        return """
        &lt;div&gt;
            &lt;label&gt;Column to search&lt;/label&gt;
            &lt;input id="column{{prefix}}" value="name"&gt;
            &lt;label&gt;Query&lt;/label&gt;
            &lt;input id="search{{prefix}}"&gt;
            &lt;button type="submit" pd_options="col=$val(column{{prefix}});query=$val(search{{prefix}})"
                pd_target="target{{prefix}}"&gt;
                Search
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;div id="target{{prefix}}"&gt;&lt;/div&gt;
        """
    @route(col="*", query="*")
    def display_screen(self, col, query):
        self.pdf = cars.loc[cars[col].str.contains(query)]
        return """
        &lt;div pd_render_onload pd_entity="pdf"&gt;
            &lt;pd_options&gt;
            {
              "handlerId": "tableView",
              "table_noschema": "true",
              "table_nosearch": "true",
              "table_nocount": "true"
            }
            &lt;/pd_options&gt;
        &lt;/div&gt;
        """
app = DisplayCars()
app.run()</pre></div><div><div><h3 class="title"><a id="note116"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode21.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode21.py</a>
</p></div></div><p>The <a id="id311" class="indexterm"/>default value for the search column is <code class="literal">name</code>, but if the user enters a column name that doesn't exist, a traceback is <a id="id312" class="indexterm"/>generated as follows:</p><div><img src="img/B09699_05_17.jpg" alt="Debugging PixieApp routes with PixieDebugger" width="1000" height="588"/><div><p>Enhanced traceback with buttons for invoking the PixieDebugger</p></div></div><p>Clicking on the <strong>Debug Route</strong> will automatically start the PixieDebugger and stop at the first executable statement of the route, as shown in the following screenshot:</p><div><img src="img/B09699_05_18.jpg" alt="Debugging PixieApp routes with PixieDebugger" width="1000" height="482"/><div><p>Debugging a PixieApp route</p></div></div><p>You could also deliberately have the PixieDebugger stop at the <code class="literal">display_screen()</code> route without waiting for a traceback to happen by using the <code class="literal">debug_route</code> keyword argument to the <code class="literal">run</code> method:</p><div><pre class="programlisting">...
app = DisplayCars()
app.run(debug_route="display_screen")</pre></div><p>PixieDebugger is the first visual Python debugger for Jupyter Notebook, providing a feature that has long <a id="id313" class="indexterm"/>been requested by the Jupyter user community. However, using live debugging is not the only tool <a id="id314" class="indexterm"/>that developers use. In the next section, we will look at debugging by inspecting logging messages.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec05"/>Troubleshooting issues using PixieDust logging</h3></div></div></div><p>It is always good <a id="id315" class="indexterm"/>practice to instrument your code with logging messages, and the PixieDust framework provides an easy way to create and read back logging messages directly from the Jupyter Notebook. To start off, you'll need to create a logger by calling the <code class="literal">getLogger()</code> method as follows:</p><div><pre class="programlisting">import pixiedust
my_logger = pixiedust.getLogger(__name__)</pre></div><div><div><h3 class="title"><a id="note117"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode22.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode22.py</a>
</p></div></div><p>You can use anything as an argument to the <code class="literal">getLogger()</code> method. However, to better identify where a particular message comes from, it is recommended using the <code class="literal">__name__</code> variable, which returns the name of the current module. The <code class="literal">my_logger</code> variable is a standard Python logger object that provides logging methods with various levels:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">debug(msg, *args, **kwargs)</code>: Logs a message with the <code class="literal">DEBUG</code> level.</li><li class="listitem" style="list-style-type: disc"><code class="literal">info(msg, *args, **kwargs)</code>: Logs a message with the <code class="literal">INFO</code> level.</li><li class="listitem" style="list-style-type: disc"><code class="literal">warning(msg, *args, **kwargs)</code>: Logs a message with the <code class="literal">WARNING</code> level.</li><li class="listitem" style="list-style-type: disc"><code class="literal">error(msg, *args, **kwargs)</code>: Logs a message with the <code class="literal">ERROR</code> level.</li><li class="listitem" style="list-style-type: disc"><code class="literal">critical(msg, *args, **kwargs)</code>: Logs a message with the <code class="literal">CRITICAL</code> level.</li><li class="listitem" style="list-style-type: disc"><code class="literal">exception(msg, *args, **kwargs)</code>: Logs a message with the <code class="literal">EXCEPTION</code> level. This <a id="id316" class="indexterm"/>method should only be called from within an exception handler.</li></ul></div><div><div><h3 class="title"><a id="note118"/>Note</h3><p>
<strong>Note</strong>: You can find more information about the Python logging framework here:</p><p>
<a class="ulink" href="https://docs.python.org/2/library/logging.html">https://docs.python.org/2/library/logging.html</a>
</p></div></div><p>You can then query the log messages directly from the Jupyter Notebook using the <code class="literal">%pixiedustLog</code> cell magic, which takes the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-l</code>: Filter by log level, for example, <code class="literal">CRITICAL</code>, <code class="literal">FATAL</code>, <code class="literal">ERROR</code>, <code class="literal">WARNING</code>, <code class="literal">INFO</code>, and <code class="literal">DEBUG</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">-f</code>: Filter a message that contains a given string, for example, <code class="literal">Exception</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">-m</code>: Maximum <a id="id317" class="indexterm"/>number of log messages returned</li></ul></div><p>In the following example, we use the <code class="literal">%pixiedustLog</code> magic to display all the debug messages, limiting these to the last five messages:</p><div><img src="img/B09699_05_19.jpg" alt="Troubleshooting issues using PixieDust logging" width="1000" height="244"/><div><p>Display the last five log messages</p></div></div><p>For convenience, when working with Python classes, you can also use the <code class="literal">@Logger</code> decorator, which automatically creates a logger using the class name as its identifier.</p><p>Here is a code example that uses the <code class="literal">@Logger</code> decorator:</p><div><pre class="programlisting">from pixiedust.display.app import *
from pixiedust.utils import Logger

@PixieApp
@Logger()
class AppWithLogger():
    @route()
    def main_screen(self):
        self.info("Calling default route")
        return "&lt;div&gt;hello world&lt;/div&gt;"

app = AppWithLogger()
app.run()</pre></div><div><div><h3 class="title"><a id="note119"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode23.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode23.py</a>
</p></div></div><p>After running the preceding PixieApp in a cell, you can invoke the <code class="literal">%pixiedustLog</code> magic to display the messages:</p><div><img src="img/B09699_05_20.jpg" alt="Troubleshooting issues using PixieDust logging" width="1000" height="120"/><div><p>Querying the log with a specific term</p></div></div><p>This completes our <a id="id318" class="indexterm"/>discussion on server-side debugging. In the next section, we look at a technique for performing client-side debugging</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec06"/>Client-side debugging</h3></div></div></div><p>One of the design principles of the PixieApp programming model is to minimize the need for developers to write JavaScript. The framework will automatically trigger kernel requests by listening to user <a id="id319" class="indexterm"/>input events, such as click or change events. However, there will be cases where writing a little bit of JavaScript is inevitable. These JavaScript snippets are usually part of a particular route HTML fragment and are dynamically injected into the browser, which makes it very difficult to debug.</p><p>One popular technique is to sprinkle <code class="literal">console.log</code> calls in the JavaScript code in order to print messages to the browser developer console.</p><div><div><h3 class="title"><a id="note120"/>Note</h3><p>
<strong>Note</strong>: Each browser flavor has its own way of invoking the developer console. For example, in Google Chrome, you would use <strong>View</strong> | <strong>Developer</strong> | <strong>JavaScript Console,</strong> or the <em>Command</em> + <em>Alt</em> + <em>J</em> shortcut.</p></div></div><p>One other debugging technique that I particularly like is to programmatically insert in a breakpoint in the JavaScript code using the <code class="literal">debugger;</code> statement. This statement has no effect unless the browser developer tools are open and source debugging is enabled, in which case, the execution will automatically break at the <code class="literal">debugger;</code> statement.</p><p>The following PixieApp example uses a JavaScript function to resolve a dynamic value referenced by the <code class="literal">$val()</code> directive:</p><div><pre class="programlisting">from pixiedust.display.app import *

@PixieApp
class TestJSDebugger():
    @route()
    def main_screen(self):
        return """
&lt;script&gt;
function FooJS(){
    <strong>debugger;</strong>
    return "value"
}
&lt;/script&gt;
&lt;button type="submit" pd_options="state=$val(FooJS)"&gt;Call route&lt;/button&gt;
        """

    @route(state="*")
    def my_route(self, state):
        return "&lt;div&gt;Route called with state &lt;b&gt;{{state}}&lt;/b&gt;&lt;/div&gt;"

app = TestJSDebugger()
app.run()</pre></div><div><div><h3 class="title"><a id="note121"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode24.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode24.py</a>
</p></div></div><p>In the preceding code, the button is dynamically setting the value of a state using the <code class="literal">FooJS</code> JavaScript function <a id="id320" class="indexterm"/>that contains a debugger statement. Executing the app and clicking on the button while the developer tool is open will automatically start a debugging session on the browser:</p><div><img src="img/B09699_05_21.jpg" alt="Client-side debugging" width="1000" height="776"/><div><p>Debugging JavaScript code on the client side with a debugger; statement</p></div></div></div></div></div></div>



  
<div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Run Node.js inside a Python Notebook</h1></div></div></div><p>Even though I've clearly stated at the beginning of this book that Python has emerged as a clear leader in the <a id="id321" class="indexterm"/>field of data science, it is still only marginally used by the developer community where traditional languages, such as Node.js, are still preferred. Recognizing <a id="id322" class="indexterm"/>that, for some developers, learning a new language, such as Python, is a cost of entry to data science that may be too high, I partnered with my IBM colleague, Glynn Bird, to build an extension library to PixieDust called <code class="literal">pixiedust_node</code> (<a class="ulink" href="https://github.com/pixiedust/pixiedust_node">https://github.com/pixiedust/pixiedust_node</a>) that would let developers run Node.js/JavaScript code inside cells in a Python Notebook. The goal of this library is to ease developers into the Python world by allowing them to reuse their favourite Node.js libraries, for example, to load and process data from existing data sources.</p><p>To install the <code class="literal">pixiedust_node</code> library, simply run the following command in its own cell:</p><div><pre class="programlisting">
<strong>!pip install pixiedust_node</strong>
</pre></div><div><div><h3 class="title"><a id="note122"/>Note</h3><p>
<strong>Note</strong>: Don't forget to restart the kernel once the installation is complete.</p><p>
<strong>Important</strong>: You need to make sure that a Node.js runtime version 6 or higher is installed on the same machine as the Jupyter Notebook Server.</p></div></div><p>Once the kernel has restarted, we import the <code class="literal">pixiedust_node</code> module:</p><div><pre class="programlisting">import pixiedust_node</pre></div><p>You should see information about both PixieDust and <code class="literal">pixiedust_node</code> in the output as follows:</p><div><img src="img/B09699_05_22.jpg" alt="Run Node.js inside a Python Notebook" width="732" height="243"/><div><p>pixiedust_node welcome output</p></div></div><p>When <code class="literal">pixiedust_node</code> is imported, a <a id="id323" class="indexterm"/>Node subprocess is created from the Python side along with a special thread that reads the output of the subprocess and passes it to the Python side to be <a id="id324" class="indexterm"/>displayed in the cell currently executing in the Notebook. This subprocess is responsible for starting an <strong>REPL</strong> session (<strong>Read-Eval-Print Loop</strong>: <a class="ulink" href="https://en.wikipedia.org/wiki/Read-eval-print_loop">https://en.wikipedia.org/wiki/Read-eval-print_loop</a>) that will execute all the scripts sent from the Notebook and make any created classes, functions, and variables reusable <a id="id325" class="indexterm"/>across all executions.</p><p>It also defines a set of functions that are designed to interact with the Notebook and the PixieDust <code class="literal">display()</code> API:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">print(data)</code>: Outputs the value of data in the cell currently executing in the Notebook.</li><li class="listitem" style="list-style-type: disc"><code class="literal">display(data)</code>: Calls the PixieDust <code class="literal">display()</code> API with a pandas DataFrame converted from data. If data cannot be converted into a pandas DataFrame, then it defaults to the <code class="literal">print</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">html(data)</code>: Displays the data as HTML in the cell currently executing in the Notebook.</li><li class="listitem" style="list-style-type: disc"><code class="literal">image(data)</code>: Expects data to be a URL to an image and displays it in the cell currently executing in the Notebook.</li><li class="listitem" style="list-style-type: disc"><code class="literal">help()</code>: Displays a list of all the preceding methods.</li></ul></div><p>In addition, <code class="literal">pixiedust_node</code> makes two variables, called <code class="literal">npm</code> and <code class="literal">node,</code> globally available in the Notebook:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">node.cancel()</code>: Stops the current execution of code in the Node.js subprocess.</li><li class="listitem" style="list-style-type: disc"><code class="literal">node.clear()</code>: Resets the Node.js session; all existing variables will be deleted.</li><li class="listitem" style="list-style-type: disc"><code class="literal">npm.install(package)</code>: Installs an npm package and makes it available to the Node.js session. The package is persisted across sessions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">npm.uninstall(package)</code>: Removes the npm package from the system and the current Node.js session.</li><li class="listitem" style="list-style-type: disc"><code class="literal">npm.list()</code>: Lists all npm packages currently installed.</li></ul></div><p>
<code class="literal">pixiedust_node</code> creates a <a id="id326" class="indexterm"/>cell magic that lets you run arbitrary JavaScript code. Simply use the <code class="literal">%%node</code> magic at the top <a id="id327" class="indexterm"/>of the cell and run it as usual. The code will then be executed in the Node.js subprocess REPL session.</p><p>The following code displays a <a id="id328" class="indexterm"/>string that includes the current datetime using the JavaScript <code class="literal">Date</code> object (<a class="ulink" href="https://www.w3schools.com/Jsref/jsref_obj_date.asp">https://www.w3schools.com/Jsref/jsref_obj_date.asp</a>):</p><div><pre class="programlisting">%%node
var date = new Date()
print("Today's date is " + date)</pre></div><p>This outputs the following:</p><div><pre class="programlisting">"Today's date is Sun May 27 2018 20:36:35 GMT-0400 (EDT)"</pre></div><p>The following diagram illustrates the execution flow of the preceding cell:</p><div><img src="img/B09699_05_23.jpg" alt="Run Node.js inside a Python Notebook" width="1000" height="307"/><div><p>The life cycle of a Node.js script execution</p></div></div><p>The JavaScript code is processed by the <code class="literal">pixiedust_node</code> magic and sent to the Node subprocess for execution. As the code is being executed, its output is read by the special thread and displayed back in the cell currently executing in the Notebook. Note that the JavaScript code may make an asynchronous call, in which case the execution will return right away before the asynchronous calls <a id="id329" class="indexterm"/>have finished. In this case, the Notebook will indicate that the cell code is done, even though more output may be generated later by the asynchronous code. There is no <a id="id330" class="indexterm"/>way to deterministically know when an asynchronous code is done. Therefore it is incumbent upon the developer to manage this state carefully.</p><p>
<code class="literal">pixiedust_node</code> also has the ability to share variables between the Python side and the JavaScript side, and vice-versa. Therefore, you could declare a Python variable (such as an array of integers, for example), apply a transformation in JavaScript (perhaps using your favorite library), and have it processed back in Python.</p><p>The following code is run in two cells, one in pure Python declaring an array of integers, and one in JavaScript that multiplies each element by 2:</p><div><img src="img/B09699_05_24.jpg" alt="Run Node.js inside a Python Notebook" width="838" height="416"/></div><p>The reverse direction also works the same. The following code starts by creating a JSON variable in JavaScript in a node <a id="id331" class="indexterm"/>cell, and then creates and displays a pandas DataFrame in the Python cell:</p><div><pre class="programlisting">%%node
data = {
    "name": ["Bob","Alice","Joan","Christian"],
    "age": [20, 25, 19, 45]
}
print(data)</pre></div><p>The results are as follows:</p><div><pre class="programlisting">{"age": [20, 25, 19, 45], "name": ["Bob", "Alice", "Joan", "Christian"]}</pre></div><p>Then, in a Python cell, we use PixieDust <code class="literal">display()</code>:</p><div><pre class="programlisting">df = pandas.DataFrame(data)
display(df)</pre></div><p>Using the <a id="id332" class="indexterm"/>following options:</p><div><img src="img/B09699_05_25.jpg" alt="Run Node.js inside a Python Notebook" width="890" height="790"/><div><p>display() options for data created from a node cell</p></div></div><p>And we get the following results:</p><div><img src="img/B09699_05_26.jpg" alt="Run Node.js inside a Python Notebook" width="1000" height="648"/><div><p>Bar chart from data created in a node cell</p></div></div><p>We could also have arrived at the same results directly from the Node cell by using the <code class="literal">display()</code> method made <a id="id333" class="indexterm"/>available by <code class="literal">pixiedust_node</code>, as shown in the following code:</p><div><pre class="programlisting">%%node
data = {
    "name": ["Bob","Alice","Joan","Christian"],
    "age": [20, 25, 19, 45]
}
display(data)</pre></div><p>If you are interested in <a id="id334" class="indexterm"/>knowing more about <code class="literal">pixiedust_node</code>, I strongly recommend this blog post: <a class="ulink" href="https://medium.com/ibm-watson-data-lab/nodebooks-node-js-data-science-notebooks-aa140bea21ba">https://medium.com/ibm-watson-data-lab/nodebooks-node-js-data-science-notebooks-aa140bea21ba</a>. As always, I encourage the reader to get involved with improving these tools, either by <a id="id335" class="indexterm"/>contributing code or ideas for enhancement.</p></div></div>



  
<div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we've explored various advanced concepts, tools, and best practices that added more tools to our toolbox, ranging from advanced techniques for PixieApps (Streaming, how to implement a route by integrating third-party libraries with <code class="literal">@captureOutput</code>, PixieApp events, and better modularity with <code class="literal">pd_app</code>), to essential developer tools like the PixieDebugger. We've also covered the details of how to create your own custom visualization using the PixieDust <code class="literal">display()</code> API. We also discussed <code class="literal">pixiedust_node,</code> which is an extension of the PixieDust framework that lets developers who are more comfortable with JavaScript work with data in their favorite language.</p><p>Throughout the remainder of this book, we are going to put all these lessons learned to good use by building industry use case data pipelines, starting with a <em>Deep Learning Visual Recognition</em> application in <a class="link" href="ch06.xhtml" title="Chapter 6. Analytics Study: AI and Image Recognition with TensorFlow">Chapter 6</a>, <em>Analytics Study: AI and Image Recognition with TensorFlow</em>.</p><p>A developer quick-reference guide for the PixieApp programming model is provided in <a class="link" href="apa.xhtml" title="Appendix A. PixieApp Quick-Reference">Appendix</a>, <em>PixieApp Quick-Reference</em> at the end of this book.</p></div></div>



  </body></html>