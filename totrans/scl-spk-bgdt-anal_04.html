<html><head></head><body>
        <section id="3FIHQ1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collection APIs</h1>
                
            
            <article>
                
<div class="book-info-bottom-author-body">"That we become depends on what we read after all of the professors have finished with us. The greatest university of all is a collection of books."</div>
<p class="cdpalignright">- Thomas Carlyle</p>
<p class="mce-root">One of the features that attract most Scala users in its Collection APIs that are very powerful, flexible, and has lots of operations coupled with it. The wide range of operations will make your life easy dealing with any kind of data. We are going to introduce Scala collections APIs including their different types and hierarchies in order to accommodate different types of data and solve a wide range of different problems. In a nutshell, the following topics will be covered in this chapter:</p>
<ul class="calibre9">
<li class="mce-root1">Scala collection APIs</li>
<li class="mce-root1">Types and hierarchies</li>
<li class="mce-root1">Performance characteristics</li>
<li class="mce-root1">Java interoperability</li>
<li class="mce-root1">Using Scala implicits</li>
</ul>


            </article>

            
        </section>
    

        <section id="3GH2C1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scala collection APIs</h1>
                
            
            <article>
                
<p class="mce-root">The Scala collections are a well-understood and frequently used programming abstraction that can be distinguished between mutable and immutable collections. Like a mutable variable, a <em class="calibre8">mutable</em> collection can be changed, updated, or extended when necessary. However, like an immutable variable, i<em class="calibre8">mmutable</em> collections cannot be changed. Most collection classes to utilize them are located in the packages <kbd class="calibre11">scala.collection</kbd>, <kbd class="calibre11">scala.collection.immutable</kbd>, and <kbd class="calibre11">scala.collection.mutable</kbd>, respectively.</p>
<p class="mce-root">This extremely powerful feature of Scala provides you with the following facility to use and manipulate your data:</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Easy to use</strong>: For example, it helps you eliminate the interference between iterators and collection updates. As a result, a small vocabulary consisting of 20-50 methods should be enough to solve most of your collection problem in your data analytics solution.</li>
<li class="mce-root1"><strong class="calibre1">Concise</strong>: You can use functional operations with a light-weight syntax and combine operations and, at the end, you will feel like that you're using custom algebra.</li>
<li class="mce-root1"><strong class="calibre1">Safe</strong>: Helps you deal with most errors while coding.</li>
<li class="mce-root1"><strong class="calibre1">Fast</strong>: most collection objects are carefully tuned and optimized; this enables you data computation in a faster way.</li>
<li class="mce-root1"><strong class="calibre1">Universal</strong>: Collections enable you to use and perform the same operations on any type, anywhere.</li>
</ul>
<p class="mce-root">In the next section, we will explore the types and associated <span>hierarchies</span> of Scala collection APIs. We will see several examples of using most features in the collection APIs.</p>


            </article>

            
        </section>
    

        <section id="3HFIU1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Types and hierarchies</h1>
                
            
            <article>
                
<p class="mce-root">Scala collections are a well-understood and frequently-used programming abstraction that can be distinguished between mutable and immutable collections. Like a mutable variable, a mutable collection can be changed, updated, or extended when necessary. Like an immutable variable, immutable collections; cannot be changed. Most collection classes that utilize them are located in the packages <kbd class="calibre11">scala.collection</kbd>, <kbd class="calibre11">scala.collection.immutable</kbd>, and <kbd class="calibre11">scala.collection.mutable</kbd>, respectively.</p>
<p class="mce-root">The following hierarchical diagram (<em class="calibre8">Figure 1</em>) shows the Scala collections API hierarchy according to the official documentation of Scala. These all are either high-level abstract classes or traits. These have mutable as well as immutable implementations.</p>
<div class="cdpaligncenter"><img class="image-border29" src="../images/00091.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 1:</strong> Collections under package scala.collection</div>


            </article>

            
        </section>
    

        <section id="3IE3G1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traversable</h1>
                
            
            <article>
                
<p class="cdpalignleft1"><strong class="calibre1">Traversable</strong> is the root of the collections' hierarchy. In Traversable, there are definitions for a wide range of operations that the Scala Collections API offers. There is only one abstract method in Traversable, which is the <kbd class="calibre11">foreach</kbd> method.</p>
<pre class="calibre19">
<strong class="calibre1">def foreach[U](f: Elem =&gt; U): Unit</strong>
</pre>
<p class="mce-root">This method is essential to all the operations contained in Traversable. If you have studied data structures, you will be familiar with traversing a data structure's elements and executing a function on each element. The <kbd class="calibre11">foreach</kbd> method does exactly so that, it traverses the elements in the collection and executes a function <kbd class="calibre11">f</kbd> on each element. As we mentioned, this is an abstract method and it was designed to have different definitions according to the underlying collection that will make use of it, to ensure highly optimized code for each collection.</p>


            </article>

            
        </section>
    

        <section id="3JCK21-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Iterable</h1>
                
            
            <article>
                
<p class="mce-root"><strong class="calibre1">Iterable</strong> is the second root in the hierarchy diagram of the Scala collections API. It has an abstract method called iterator that must be implemented/defined in all other subcollections. It also implements the <kbd class="calibre11">foreach</kbd> method from the root, which is Traversable. But as we mentioned, all the descendent subcollections will override this implementation to make specific optimizations related to this subcollection.</p>


            </article>

            
        </section>
    

        <section id="3KB4K1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Seq, LinearSeq, and IndexedSeq</h1>
                
            
            <article>
                
<p class="mce-root">A sequence has some differences from the usual Iterable, and it has a defined length and order. Seq has two sub-traits such as <kbd class="calibre11">LinearSeq</kbd> and <kbd class="calibre11">IndexedSeq</kbd>. Let's have a quick overview on them.</p>
<p class="mce-root"><kbd class="calibre11">LinearSeq</kbd> is a base trait for linear sequences. Linear sequences have reasonably efficient head, tail, and <kbd class="calibre11">isEmpty</kbd> methods. If these methods provide the fastest way to traverse the collection, a collection <kbd class="calibre11">Coll</kbd> that extends this trait should also extend <kbd class="calibre11">LinearSeqOptimized[A, Coll[A]]</kbd>. <kbd class="calibre11">LinearSeq</kbd> has three concrete methods:</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">isEmpty:</strong> This checks if the list is empty or not</li>
<li class="mce-root1"><strong class="calibre1">head</strong>: This returns the first element in the list/sequence</li>
<li class="mce-root1"><strong class="calibre1">tail</strong>: This returns all the elements of the list but the first one. Each of the subcollections that inherit the <kbd class="calibre11">LinearSeq</kbd> will have its own implementation of these methods to ensure good performance. Two collections that inherit/extend are streams and lists.</li>
</ul>
<div class="packt_infobox">For more on this topic, refer to this URL at <a href="http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html" class="calibre21">http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html.</a></div>
<p class="mce-root">Finally, <kbd class="calibre11">IndexedSeq</kbd> has two methods that it's defined in terms of them:</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Apply</strong>: This finds elements by index.</li>
<li class="mce-root1"><strong class="calibre1">length</strong>: This returns the length of the sequence. Finding an element by its index requires well performing implementation by the subcollections. Two of these indexed sequences are <kbd class="calibre11">Vector</kbd> and <kbd class="calibre11">ArrayBuffer</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section id="3L9L61-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mutable and immutable</h1>
                
            
            <article>
                
<p class="mce-root">In Scala, you will find mutable and immutable collections. A collection can have a mutable implementation and an immutable implementation. That's the reason why, in Java, a <kbd class="calibre11">List</kbd> can't be both a <kbd class="calibre11">LinkedList</kbd> and an <kbd class="calibre11">ArrayList</kbd>, but <kbd class="calibre11">List</kbd> has a <kbd class="calibre11">LinkedList</kbd> implementation and an <kbd class="calibre11">ArrayList</kbd> implementation. The following figure shows all collections in the package <kbd class="calibre11">scala.collection.immutable</kbd>:</p>
<div class="cdpaligncenter"><img class="image-border30" src="../images/00099.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 2:</strong> All collections in package scala.collection.immutable</div>
<p class="cdpalignleft1">Scala imports the immutable collections by default, and if you need to use a mutable one, then you need to import it yourself. Now to get a brief overview of all collections in package <kbd class="calibre11">scala.collection.mutable</kbd>, refer to the following diagram:</p>
<div class="cdpaligncenter1"><img class="image-border31" src="../images/00103.jpeg"/></div>
<div class="cdpaligncenter1"><strong class="calibre1">Figure 3:</strong> All collections in package Scala.collection.mutable</div>
<p class="cdpalignleft1">In every OOP and functional programming language, an array is an important collection package that helps us to store data objects so that, later on, we can access them very easily as well. In the next subsection, we will see a detailed discussion on arrays with some examples.</p>


            </article>

            
        </section>
    

        <section id="3M85O1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Arrays</h1>
                
            
            <article>
                
<p class="mce-root">An array is a mutable collection. In arrays, the order of the elements will be preserved and duplicated elements will be kept. Being mutable, you can change the value of any element of the array by accessing it by its index number. Let's demonstrate arrays with several examples. Use the following line of code to just declare a simple array:</p>
<pre class="calibre19">
val numbers: Array[Int] = Array[Int](1, 2, 3, 4, 5, 1, 2, 3, 3, 4, 5) // A simple array
</pre>
<p class="mce-root">Now, print all the elements of the array:</p>
<pre class="calibre19">
println("The full array is: ")<br class="title-page-name"/>  for (i &lt;- numbers) {<br class="title-page-name"/>    print(" " + i)<br class="title-page-name"/>  }
</pre>
<p class="mce-root">Now, print a particular element: for example, element 3:</p>
<pre class="calibre19">
println(numbers(2))
</pre>
<p class="mce-root">Let's sum all the elements and print the sum:</p>
<pre class="calibre19">
var total = 0;<br class="title-page-name"/>for (i &lt;- 0 to (numbers.length - 1)) {<br class="title-page-name"/>  total = total + numbers(i)<br class="title-page-name"/>}<br class="title-page-name"/>println("Sum: = " + total)
</pre>
<p class="mce-root">Finding the smallest element:</p>
<pre class="calibre19">
var min = numbers(0)<br class="title-page-name"/>for (i &lt;- 1 to (numbers.length - 1)) {<br class="title-page-name"/>  if (numbers(i) &lt; min) min = numbers(i)<br class="title-page-name"/>}<br class="title-page-name"/>println("Min is: " + min)
</pre>
<p class="mce-root">Finding the largest element:</p>
<pre class="calibre19">
var max = numbers(0);<br class="title-page-name"/>for (i &lt;- 1 to (numbers.length - 1)) {<br class="title-page-name"/>  if (numbers(i) &gt; max) max = numbers(i)<br class="title-page-name"/>}<br class="title-page-name"/>println("Max is: " + max)
</pre>
<p class="mce-root">Another way of creating and defining an array is using the <kbd class="calibre11">range ()</kbd> method that goes as follows:</p>
<pre class="calibre19">
//Creating array using range() method<br class="title-page-name"/>var myArray1 = range(5, 20, 2)<br class="title-page-name"/>var myArray2 = range(5, 20)
</pre>
<p class="mce-root">The preceding line of code means that I have created an array with elements between 5 and 20 with the range difference 2. If you don't specify the 3<sup class="calibre26">rd</sup> parameter, Scala will assume the range difference is:</p>
<pre class="calibre19">
//Creating array using range() method without range difference<br class="title-page-name"/>var myArray1 = range(5, 20, 2)
</pre>
<p class="mce-root">Now, let's see how to access the elements as follows:</p>
<pre class="calibre19">
// Print all the array elements<br class="title-page-name"/>for (x &lt;- myArray1) {<br class="title-page-name"/>  print(" " + x)<br class="title-page-name"/>}<br class="title-page-name"/>println()<br class="title-page-name"/>for (x &lt;- myArray2) {<br class="title-page-name"/>  print(" " + x)<br class="title-page-name"/>}
</pre>
<p class="mce-root">It's even possible to concatenate two arrays using the <kbd class="calibre11">concat()</kbd> method as follows:</p>
<pre class="calibre19">
//Array concatenation<br class="title-page-name"/>var myArray3 =  concat( myArray1, myArray2)      <br class="title-page-name"/>// Print all the array elements<br class="title-page-name"/>for ( x &lt;- myArray3 ) {<br class="title-page-name"/>  print(" "+ x)<br class="title-page-name"/>}
</pre>
<p class="mce-root">Note that for using the <kbd class="calibre11">range()</kbd> and the <kbd class="calibre11">concat()</kbd> method, you will need to import the Scala <kbd class="calibre11">Array</kbd> package as follows:</p>
<pre class="calibre19">
Import Array._
</pre>
<p class="mce-root">Lastly, it's even possible to define and use a multi-dimensional array as follows:</p>
<pre class="calibre19">
var myMatrix = ofDim[Int](4,4)
</pre>
<p class="mce-root">Now, first create a matrix using the preceding array as follows:</p>
<pre class="calibre19">
var myMatrix = ofDim[Int](4, 4)<br class="title-page-name"/>// build a matrix<br class="title-page-name"/>for (i &lt;- 0 to 3) {<br class="title-page-name"/>  for (j &lt;- 0 to 3) {<br class="title-page-name"/>    myMatrix(i)(j) = j<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/>println()
</pre>
<p class="mce-root">Print the earlier matrix as follows:</p>
<pre class="calibre19">
// Print two dimensional array<br class="title-page-name"/>for (i &lt;- 0 to 3) {<br class="title-page-name"/>  for (j &lt;- 0 to 3) {<br class="title-page-name"/>    print(" " + myMatrix(i)(j))<br class="title-page-name"/>  }<br class="title-page-name"/>  println()<br class="title-page-name"/>}
</pre>
<p class="mce-root">The complete source code of the previous example can be seen as follows:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>import Array._                                                                                         object ArrayExample {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val numbers: Array[Int] = Array[Int](1, 2, 3, 4, 5, 1, 2, 3, 3, 4, 5)<br class="title-page-name"/>    // A simple array<br class="title-page-name"/>    // Print all the element of the array<br class="title-page-name"/>    println("The full array is: ")<br class="title-page-name"/>    for (i &lt;- numbers) {<br class="title-page-name"/>      print(" " + i)<br class="title-page-name"/>    }<br class="title-page-name"/>    //Print a particular element for example element 3<br class="title-page-name"/>    println(numbers(2))<br class="title-page-name"/>    //Summing all the elements<br class="title-page-name"/>    var total = 0<br class="title-page-name"/>    for (i &lt;- 0 to (numbers.length - 1)) {<br class="title-page-name"/>      total = total + numbers(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    println("Sum: = " + total)<br class="title-page-name"/>    // Finding the smallest element<br class="title-page-name"/>    var min = numbers(0)<br class="title-page-name"/>    for (i &lt;- 1 to (numbers.length - 1)) {<br class="title-page-name"/>      if (numbers(i) &lt; min) min = numbers(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    println("Min is: " + min)<br class="title-page-name"/>    // Finding the largest element<br class="title-page-name"/>    var max = numbers(0)<br class="title-page-name"/>    for (i &lt;- 1 to (numbers.length - 1)) {<br class="title-page-name"/>      if (numbers(i) &gt; max) max = numbers(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    println("Max is: " + max)<br class="title-page-name"/>    //Creating array using range() method<br class="title-page-name"/>    var myArray1 = range(5, 20, 2)<br class="title-page-name"/>    var myArray2 = range(5, 20)<br class="title-page-name"/>    // Print all the array elements<br class="title-page-name"/>    for (x &lt;- myArray1) {<br class="title-page-name"/>      print(" " + x)<br class="title-page-name"/>    }<br class="title-page-name"/>    println()<br class="title-page-name"/>    for (x &lt;- myArray2) {<br class="title-page-name"/>      print(" " + x)<br class="title-page-name"/>    }<br class="title-page-name"/>    //Array concatenation<br class="title-page-name"/>    var myArray3 = concat(myArray1, myArray2)<br class="title-page-name"/>    // Print all the array elements<br class="title-page-name"/>    for (x &lt;- myArray3) {<br class="title-page-name"/>      print(" " + x)<br class="title-page-name"/>    }<br class="title-page-name"/>    //Multi-dimensional array<br class="title-page-name"/>    var myMatrix = ofDim[Int](4, 4)<br class="title-page-name"/>    // build a matrix<br class="title-page-name"/>    for (i &lt;- 0 to 3) {<br class="title-page-name"/>      for (j &lt;- 0 to 3) {<br class="title-page-name"/>        myMatrix(i)(j) = j<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>    println();<br class="title-page-name"/>    // Print two dimensional array<br class="title-page-name"/>    for (i &lt;- 0 to 3) {<br class="title-page-name"/>      for (j &lt;- 0 to 3) {<br class="title-page-name"/>        print(" " + myMatrix(i)(j))<br class="title-page-name"/>      }<br class="title-page-name"/>      println();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">The full array is: 1 2 3 4 5 1 2 3 3 4 53 </strong><br class="title-page-name"/><strong class="calibre1">Sum: = 33 </strong><br class="title-page-name"/><strong class="calibre1">Min is: 1 </strong><br class="title-page-name"/><strong class="calibre1">Max is: 5 </strong><br class="title-page-name"/><strong class="calibre1">5 7 9 11 13 15 17 19 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 5 7 9 11 13 15 17 19 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 </strong><br class="title-page-name"/><strong class="calibre1">0 1 2 3 </strong><br class="title-page-name"/><strong class="calibre1">0 1 2 3 </strong><br class="title-page-name"/><strong class="calibre1">0 1 2 3 </strong><br class="title-page-name"/><strong class="calibre1">0 1 2 3</strong>
</pre>
<p class="mce-root">In Scala, lists preserve order, keep duplicated elements, and also check their immutability. Now, let's see some examples of using lists in Scala in the next subsection.</p>


            </article>

            
        </section>
    

        <section id="3N6MA1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lists</h1>
                
            
            <article>
                
<p class="mce-root">As discussed earlier, Scala provides mutable and immutable collections. The Immutable collections are imported by default, but if you need to use a mutable one you need to import yourself. A list is an immutable collections, and it can be used if you want order between the elements to be preserved and duplicates to be kept. Let's demonstrate an example and see how lists preserve order and keep duplicated elements, and also check its immutability:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val numbers = List(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)</strong><br class="title-page-name"/><strong class="calibre1">numbers: List[Int] = List(1, 2, 3, 4, 5, 1, 2, 3, 4, 5) <br class="title-page-name"/>scala&gt; numbers(3) = 10 </strong><br class="title-page-name"/><strong class="calibre1">&lt;console&gt;:12: error: value update is not a member of List[Int] </strong><br class="title-page-name"/><strong class="calibre1">numbers(3) = 10 ^</strong>
</pre>
<p class="mce-root">You can define lists using two different building blocks. <kbd class="calibre11">Nil</kbd> represents the tail of the <kbd class="calibre11">List</kbd> and, afterwards, an empty <kbd class="calibre11">List</kbd>. So, the preceding example can be rewritten as:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val numbers = 1 :: 2 :: 3 :: 4 :: 5 :: 1 :: 2 :: 3:: 4:: 5 :: Nil</strong><br class="title-page-name"/><strong class="calibre1">numbers: List[Int] = List(1, 2, 3, 4, 5, 1, 2, 3,4, 5</strong>
</pre>
<p class="mce-root">Let's check lists with its method in the following detailed example:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/><br class="title-page-name"/>object ListExample {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    // List of cities<br class="title-page-name"/>    val cities = "Dublin" :: "London" :: "NY" :: Nil<br class="title-page-name"/><br class="title-page-name"/>    // List of Even Numbers<br class="title-page-name"/>    val nums = 2 :: 4 :: 6 :: 8 :: Nil<br class="title-page-name"/><br class="title-page-name"/>    // Empty List.<br class="title-page-name"/>    val empty = Nil<br class="title-page-name"/><br class="title-page-name"/>    // Two dimensional list<br class="title-page-name"/>    val dim = 1 :: 2 :: 3 :: Nil ::<br class="title-page-name"/>                   4 :: 5 :: 6 :: Nil ::<br class="title-page-name"/>                   7 :: 8 :: 9 :: Nil :: Nil<br class="title-page-name"/>    val temp = Nil<br class="title-page-name"/>            <br class="title-page-name"/>    // Getting the first element in the list<br class="title-page-name"/>    println( "Head of cities : " + cities.head )<br class="title-page-name"/><br class="title-page-name"/>    // Getting all the elements but the last one<br class="title-page-name"/>    println( "Tail of cities : " + cities.tail )<br class="title-page-name"/><br class="title-page-name"/>    //Checking if cities/temp list is empty<br class="title-page-name"/>    println( "Check if cities is empty : " + cities.isEmpty )<br class="title-page-name"/>    println( "Check if temp is empty : " + temp.isEmpty )<br class="title-page-name"/>     <br class="title-page-name"/>    val citiesEurope = "Dublin" :: "London" :: "Berlin" :: Nil<br class="title-page-name"/>    val citiesTurkey = "Istanbul" :: "Ankara" :: Nil<br class="title-page-name"/><br class="title-page-name"/>    //Concatenate two or more lists with :::<br class="title-page-name"/>    var citiesConcatenated = citiesEurope ::: citiesTurkey<br class="title-page-name"/>    println( "citiesEurope ::: citiesTurkey : "+citiesConcatenated )<br class="title-page-name"/>      <br class="title-page-name"/>    // using the concat method<br class="title-page-name"/>    citiesConcatenated = List.concat(citiesEurope, citiesTurkey)<br class="title-page-name"/>    println( "List.concat(citiesEurope, citiesTurkey) : " +<br class="title-page-name"/>             citiesConcatenated  )<br class="title-page-name"/><br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">Head of cities : Dublin</strong><br class="title-page-name"/><strong class="calibre1">Tail of cities : List(London, NY)</strong><br class="title-page-name"/><strong class="calibre1">Check if cities is empty : false</strong><br class="title-page-name"/><strong class="calibre1">Check if temp is empty : true</strong><br class="title-page-name"/><strong class="calibre1">citiesEurope ::: citiesTurkey : List(Dublin, London, Berlin, Istanbul, Ankara)</strong><br class="title-page-name"/><strong class="calibre1">List.concat(citiesEurope, citiesTurkey) : List(Dublin, London, Berlin, Istanbul, Ankara)</strong>
</pre>
<p class="mce-root">Now, let's see another quick overview of how to use sets in your Scala application in the next subsection.</p>


            </article>

            
        </section>
    

        <section id="3O56S1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sets</h1>
                
            
            <article>
                
<p class="mce-root">A set is one of the most widely used collections. In sets order will not be preserved and sets don't allow duplicate elements. You can think of it as the mathematical notation of sets. Let's demonstrate this by an example, and we will see how sets don't preserve ordering and don't allow duplicates:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val numbers = Set( 1, 2, 3, 4, 5, 1, 2, 3, 4, 5)</strong><br class="title-page-name"/><strong class="calibre1">numbers: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)</strong>
</pre>
<p class="mce-root">The following source code shows the different uses of sets in a Scala program:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>object SetExample {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    // Empty set of integer type<br class="title-page-name"/>    var sInteger : Set[Int] = Set()<br class="title-page-name"/>    // Set of even numbers<br class="title-page-name"/>    var sEven : Set[Int] = Set(2,4,8,10)<br class="title-page-name"/>    //Or you can use this syntax<br class="title-page-name"/>    var sEven2 = Set(2,4,8,10)<br class="title-page-name"/>    val cities = Set("Dublin", "London", "NY")<br class="title-page-name"/>    val tempNums: Set[Int] = Set()<br class="title-page-name"/>    //Finding Head, Tail, and checking if the sets are empty<br class="title-page-name"/>    println( "Head of cities : " + cities.head )<br class="title-page-name"/>    println( "Tail of cities : " + cities.tail )<br class="title-page-name"/>    println( "Check if cities is empty : " + cities.isEmpty )<br class="title-page-name"/>    println( "Check if tempNums is empty : " + tempNums.isEmpty )<br class="title-page-name"/>    val citiesEurope = Set("Dublin", "London", "NY")<br class="title-page-name"/>    val citiesTurkey = Set("Istanbul", "Ankara")<br class="title-page-name"/>    // Sets Concatenation using ++ operator<br class="title-page-name"/>    var citiesConcatenated = citiesEurope ++ citiesTurkey<br class="title-page-name"/>    println( "citiesEurope ++ citiesTurkey : " + citiesConcatenated )<br class="title-page-name"/>    //Also you can use ++ as a method<br class="title-page-name"/>    citiesConcatenated = citiesEurope.++(citiesTurkey)<br class="title-page-name"/>    println( "citiesEurope.++(citiesTurkey) : " + citiesConcatenated )<br class="title-page-name"/>    //Finding minimum and maximum elements in the set<br class="title-page-name"/>    val evenNumbers = Set(2,4,6,8)<br class="title-page-name"/>    // Using the min and max methods<br class="title-page-name"/>    println( "Minimum element in Set(2,4,6,8) : " + evenNumbers.min )<br class="title-page-name"/>    println( "Maximum element in Set(2,4,6,8) : " + evenNumbers.max )<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">Head of cities : Dublin</strong><br class="title-page-name"/><strong class="calibre1">Tail of cities : Set(London, NY)</strong><br class="title-page-name"/><strong class="calibre1">Check if cities is empty : false</strong><br class="title-page-name"/><strong class="calibre1">Check if tempNums is empty : true</strong><br class="title-page-name"/><strong class="calibre1">citiesEurope ++ citiesTurkey : Set(London, Dublin, Ankara, Istanbul, NY)</strong><br class="title-page-name"/><strong class="calibre1">citiesEurope.++(citiesTurkey) : Set(London, Dublin, Ankara, Istanbul, NY)</strong><br class="title-page-name"/><strong class="calibre1">Minimum element in Set(2,4,6,8) : 2</strong><br class="title-page-name"/><strong class="calibre1">Maximum element in Set(2,4,6,8) : 8</strong>
</pre>
<p class="mce-root">From my personal experience while developing Spark applications using Java or Scala, I found very frequent uses of tuples, especially for grouping collections of elements without using any explicit classes. In the next subsection, we will see how to get started with Tuples in Scala.</p>


            </article>

            
        </section>
    

        <section id="3P3NE1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tuples</h1>
                
            
            <article>
                
<p class="mce-root">Scala tuples are used to combine a fixed number of items together. The ultimate target of this grouping is to help in the anonymous function and so that they can be passed around as a whole. The real difference with an array or list is that a tuple can hold objects of different types while maintaining the information of the type of each element, while a collection doesn't and uses, as the type, the common type (for instance, in the previous example, the type of that set would be <kbd class="calibre11">Set[Any]</kbd>).</p>
<p class="mce-root">From the computational point of view, Scala tuples are also immutable. In other words, Tuples do use a classes to store elements (for example, <kbd class="calibre11">Tuple2</kbd>, <kbd class="calibre11">Tuple3</kbd>, <kbd class="calibre11">Tuple22</kbd>, and so on).</p>
<p class="mce-root">The following is an example of a tuple holding an integer, a string, and the console:</p>
<pre class="calibre19">
val tuple_1 = (20, "Hello", Console)
</pre>
<p class="mce-root">Which is syntactic sugar (shortcut) for the following:</p>
<pre class="calibre19">
val t = new Tuple3(20, "Hello", Console)
</pre>
<p class="mce-root">Another example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val cityPop = ("Dublin", 2)</strong><br class="title-page-name"/><strong class="calibre1">cityPop: (String, Int) = (Dublin,2)</strong>
</pre>
<p class="mce-root">There are no named accessors for you to access the tuple data but instead you need to use accessors that are based on the position and are 1-based not 0-based. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val cityPop = ("Dublin", 2)</strong><br class="title-page-name"/><strong class="calibre1">cityPop: (String, Int) = (Dublin,2)<br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">scala&gt; cityPop._1</strong><br class="title-page-name"/><strong class="calibre1">res3: String = Dublin<br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">scala&gt; cityPop._2</strong><br class="title-page-name"/><strong class="calibre1">res4: Int = 2</strong>
</pre>
<p class="mce-root">Moreover, tuples can fit perfectly in pattern matching. For example:</p>
<pre class="calibre19">
cityPop match {<br class="title-page-name"/>  case ("Dublin", population) =&gt; ...<br class="title-page-name"/>  case ("NY", population) =&gt; ...<br class="title-page-name"/>}
</pre>
<p class="mce-root">You can even use the special operator <kbd class="calibre11">-&gt;</kbd> in order to write a compact syntax for 2-values tuples. For example:</p>
<pre class="calibre19">
scala&gt; "Dublin" -&gt; 2<br class="title-page-name"/>res0: (String, Int) = (Dublin,2)
</pre>
<p class="mce-root">The following is a more detailed example to demonstrate tuple functionality:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>object TupleExample {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val evenTuple = (2,4,6,8)<br class="title-page-name"/>    val sumTupleElements =evenTuple._1 + evenTuple._2 + evenTuple._3 + evenTuple._4<br class="title-page-name"/>    println( "Sum of Tuple Elements: "  + sumTupleElements )      <br class="title-page-name"/>    // You can also iterate over the tuple and print it's element using the foreach method<br class="title-page-name"/>    evenTuple.productIterator.foreach{ evenTuple =&gt;println("Value = " + evenTuple )}<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">Sum of Tuple Elements: 20 Value = 2 Value = 4 Value = 6 Value = 8</strong>
</pre>
<p class="mce-root">Now, let's delve into the world of using maps in Scala, these are widely used to hold basic datatypes.</p>


            </article>

            
        </section>
    

        <section id="3Q2801-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Maps</h1>
                
            
            <article>
                
<p class="mce-root">A map is an <kbd class="calibre11">Iterable</kbd> consisting of pairs of keys and values (also named mappings or associations). A map is also one of the most widely used connections as it can be used to hold basic datatypes. For example:</p>
<pre class="calibre19">
scala&gt; Map(1 -&gt; 2)<br class="title-page-name"/>res7: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 2)                                                scala&gt; Map("X" -&gt; "Y")<br class="title-page-name"/>res8: scala.collection.immutable.Map[String,String] = Map(X -&gt; Y)
</pre>
<p class="mce-root">Scala's <kbd class="calibre11">Predef</kbd> object offers an implicit conversion that lets you write <kbd class="calibre11">key -&gt; value</kbd> as an alternate syntax for the <kbd class="calibre11">pair (key, value)</kbd>. For instance, <kbd class="calibre11">Map("a" -&gt; 10, "b" -&gt; 15, "c" -&gt; 16)</kbd> means exactly the same as <kbd class="calibre11">Map(("a", 10), ("b", 15), ("c", 16))</kbd>, but reads better.</p>
<p class="mce-root">Moreover, a <kbd class="calibre11">Map</kbd> can be simply considered a collection of <kbd class="calibre11">Tuple2s</kbd>:</p>
<pre class="calibre19">
Map(2 -&gt; "two", 4 -&gt; "four")
</pre>
<p class="mce-root">The preceding line will be understood as:</p>
<pre class="calibre19">
Map((2, "two"), (4, "four"))
</pre>
<p class="mce-root">In the example, we can state that using <kbd class="calibre11">Map</kbd> a function can be stored, and this is the whole point of functions in a Functional Programming language: they are first-class citizens and can be used anywhere.</p>
<p class="mce-root">Suppose you have a method for finding the max element in an array as follows:</p>
<pre class="calibre19">
var myArray = range(5, 20, 2)<br class="title-page-name"/>  def getMax(): Int = {<br class="title-page-name"/>    // Finding the largest element<br class="title-page-name"/>    var max = myArray(0)<br class="title-page-name"/>    for (i &lt;- 1 to (myArray.length - 1)) {<br class="title-page-name"/>      if (myArray(i) &gt; max)<br class="title-page-name"/>        max = myArray(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    max<br class="title-page-name"/>  }
</pre>
<p class="mce-root">Now, let's map it such that using the <kbd class="calibre11">Map</kbd> the method can be stored:</p>
<pre class="calibre19">
scala&gt; val myMax = Map("getMax" -&gt; getMax()) <br class="title-page-name"/>scala&gt; println("My max is: " + myMax )
</pre>
<p class="mce-root">Let's another of using maps as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; Map( 2 -&gt; "two", 4 -&gt; "four")</strong><br class="title-page-name"/><strong class="calibre1">res9: scala.collection.immutable.Map[Int,String] = Map(2 -&gt; two, 4 -&gt; four)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; Map( 1 -&gt; Map("X"-&gt; "Y"))</strong><br class="title-page-name"/><strong class="calibre1">res10: scala.collection.immutable.Map[Int,scala.collection.immutable.Map[String,String]] = Map(1 -&gt; Map(X -&gt; Y))</strong>
</pre>
<p class="mce-root">The following is a detailed example to demonstrate <kbd class="calibre11">Map</kbd> functionality:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>import Array._<br class="title-page-name"/><br class="title-page-name"/>object MapExample {<br class="title-page-name"/>  var myArray = range(5, 20, 2)<br class="title-page-name"/>  <br class="title-page-name"/>  def getMax(): Int = {<br class="title-page-name"/>    // Finding the largest element<br class="title-page-name"/>    var max = myArray(0)<br class="title-page-name"/>    for (i &lt;- 1 to (myArray.length - 1)) {<br class="title-page-name"/>      if (myArray(i) &gt; max)<br class="title-page-name"/>        max = myArray(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    max<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val capitals = Map("Ireland" -&gt; "Dublin", "Britain" -&gt; "London", <br class="title-page-name"/>    "Germany" -&gt; "Berlin")<br class="title-page-name"/><br class="title-page-name"/>    val temp: Map[Int, Int] = Map()<br class="title-page-name"/>    val myMax = Map("getMax" -&gt; getMax())<br class="title-page-name"/>    println("My max is: " + myMax )<br class="title-page-name"/><br class="title-page-name"/>    println("Keys in capitals : " + capitals.keys)<br class="title-page-name"/>    println("Values in capitals : " + capitals.values)<br class="title-page-name"/>    println("Check if capitals is empty : " + capitals.isEmpty)<br class="title-page-name"/>    println("Check if temp is empty : " + temp.isEmpty)<br class="title-page-name"/><br class="title-page-name"/>    val capitals1 = Map("Ireland" -&gt; "Dublin", "Turkey" -&gt; "Ankara",<br class="title-page-name"/>    "Egypt" -&gt; "Cairo")<br class="title-page-name"/>    val capitals2 = Map("Germany" -&gt; "Berlin", "Saudi Arabia" -&gt;<br class="title-page-name"/>    "Riyadh")<br class="title-page-name"/><br class="title-page-name"/>    // Map concatenation using ++ operator<br class="title-page-name"/>    var capitalsConcatenated = capitals1 ++ capitals2<br class="title-page-name"/>    println("capitals1 ++ capitals2 : " + capitalsConcatenated)<br class="title-page-name"/><br class="title-page-name"/>    // use two maps with ++ as method<br class="title-page-name"/>    capitalsConcatenated = capitals1.++(capitals2)<br class="title-page-name"/>    println("capitals1.++(capitals2)) : " + capitalsConcatenated)<br class="title-page-name"/><br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">My max is: Map(getMax -&gt; 19)</strong><br class="title-page-name"/><strong class="calibre1">Keys in capitals : Set(Ireland, Britain, Germany)</strong><br class="title-page-name"/><strong class="calibre1">Values in capitals : MapLike(Dublin, London, Berlin)</strong><br class="title-page-name"/><strong class="calibre1">Check if capitals is empty : false</strong><br class="title-page-name"/><strong class="calibre1">Check if temp is empty : true</strong><br class="title-page-name"/><strong class="calibre1">capitals1 ++ capitals2 : Map(Saudi Arabia -&gt; Riyadh, Egypt -&gt; Cairo, Ireland -&gt; Dublin, Turkey -&gt; Ankara, Germany -&gt; Berlin)</strong><br class="title-page-name"/><strong class="calibre1">capitals1.++(capitals2)) : Map(Saudi Arabia -&gt; Riyadh, Egypt -&gt; Cairo, Ireland -&gt; Dublin, Turkey -&gt; Ankara, Germany -&gt; Berlin)</strong>
</pre>
<p class="mce-root">Now, let's take a quick overview of using option in Scala; this is basically a data container that can hold data.</p>


            </article>

            
        </section>
    

        <section>

                            <header id="3R0OI2-21aec46d8593429cacea59dbdcd64e1c">
                    </header><h1 class="header-title" id="calibre_pb_0">Option</h1>
                
            
            <article>
                
<p class="mce-root">The <kbd class="calibre11">Option</kbd> type is used frequently in Scala programs, and you can compare this with the null value available in Java, which indicates no value. Scala <kbd class="calibre11">Option [T]</kbd> is a container for zero or one element for a given type. An <kbd class="calibre11">Option [T]</kbd> can be either a <kbd class="calibre11">Some [T]</kbd> or <kbd class="calibre11">None</kbd> object, which represents a missing value. For instance, the get method of Scala's <kbd class="calibre11">Map</kbd> produces <kbd class="calibre11">Some</kbd> (value) if a value corresponding to a given key has been found, or <kbd class="calibre11">None</kbd> if the given key is not defined in the <kbd class="calibre11">Map</kbd>.</p>
<p class="mce-root">The basic trait for an <kbd class="calibre11">Option</kbd> looks like this:</p>
<pre class="calibre19">
trait Option[T] {<br class="title-page-name"/>  def get: A // Returns the option's value.<br class="title-page-name"/>  def isEmpty: Boolean // Returns true if the option is None, false<br class="title-page-name"/>  otherwise.<br class="title-page-name"/>  def productArity: Int // The size of this product. For a product<br class="title-page-name"/>  A(x_1, ..., x_k), returns k<br class="title-page-name"/>  def productElement(n: Int): Any // The nth element of this product,<br class="title-page-name"/>  0-based<br class="title-page-name"/>  def exists(p: (A) =&gt; Boolean): Boolean // Returns true if this option<br class="title-page-name"/>  is nonempty <br class="title-page-name"/>  def filter(p: (A) =&gt; Boolean): Option[A] // Returns this Option if it<br class="title-page-name"/>  is nonempty <br class="title-page-name"/>  def filterNot(p: (A) =&gt; Boolean): Option[A] // Returns this Option if<br class="title-page-name"/>  it is nonempty or return None.<br class="title-page-name"/>  def flatMap[B](f: (A) =&gt; Option[B]): Option[B] // Returns result of<br class="title-page-name"/>  applying f to this Option's <br class="title-page-name"/>  def foreach[U](f: (A) =&gt; U): Unit // Apply given procedure f to the<br class="title-page-name"/>  option's value, if it is nonempty.  <br class="title-page-name"/>  def getOrElse[B &gt;: A](default: =&gt; B): B // Returns the option's value<br class="title-page-name"/>  if the option is nonempty, <br class="title-page-name"/>  def isDefined: Boolean // Returns true if the option is an instance<br class="title-page-name"/>  of Some, false otherwise.<br class="title-page-name"/>  def iterator: Iterator[A] // Returns a singleton iterator returning<br class="title-page-name"/>  Option's value if it is nonempty<br class="title-page-name"/>  def map[B](f: (A) =&gt; B): Option[B] // Returns a Some containing<br class="title-page-name"/>  result of applying f to this Option's <br class="title-page-name"/>  def orElse[B &gt;: A](alternative: =&gt; Option[B]): Option[B] // Returns<br class="title-page-name"/>  this Option if it is nonempty<br class="title-page-name"/>  def orNull // Returns the option's value if it is nonempty,<br class="title-page-name"/>                or null if it is empty.  <br class="title-page-name"/>}
</pre>
<p class="mce-root">For example, in the following code, we are trying to map and show some meagacities that are located in some countries such as <kbd class="calibre11">India</kbd>, <kbd class="calibre11">Bangladesh</kbd>, <kbd class="calibre11">Japan</kbd>, and <kbd class="calibre11">USA</kbd>:</p>
<pre class="calibre19">
object ScalaOptions {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val megacity = Map("Bangladesh" -&gt; "Dhaka", "Japan" -&gt; "Tokyo",<br class="title-page-name"/>    "India" -&gt; "Kolkata", "USA" -&gt; "New York")<br class="title-page-name"/>    println("megacity.get( \"Bangladesh\" ) : " + <br class="title-page-name"/>    show(megacity.get("Bangladesh")))<br class="title-page-name"/>    println("megacity.get( \"India\" ) : " + <br class="title-page-name"/>    show(megacity.get("India")))<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, to make the preceding code work, we need to have the <kbd class="calibre11">show()</kbd> method defined somewhere. Here, we can do it by Scala pattern matching using <kbd class="calibre11">Option</kbd> as follows:</p>
<pre class="calibre19">
def show(x: Option[String]) = x match {<br class="title-page-name"/>  case Some(s) =&gt; s<br class="title-page-name"/>  case None =&gt; "?"<br class="title-page-name"/>}
</pre>
<p class="mce-root">Combining these as follows should print the accurate and desired result that we are expecting:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>object ScalaOptions {<br class="title-page-name"/>  def show(x: Option[String]) = x match {<br class="title-page-name"/>    case Some(s) =&gt; s<br class="title-page-name"/>    case None =&gt; "?"<br class="title-page-name"/>  } <br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val megacity = Map("Bangladesh" -&gt; "Dhaka", "Japan" -&gt; "Tokyo",<br class="title-page-name"/>    "India" -&gt; "Kolkata", "USA" -&gt; "New York")<br class="title-page-name"/>    println("megacity.get( \"Bangladesh\" ) : " +<br class="title-page-name"/>    show(megacity.get("Bangladesh")))<br class="title-page-name"/>    println("megacity.get( \"India\" ) : " +<br class="title-page-name"/>    show(megacity.get("India")))<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">megacity.get( "Bangladesh" ) : Dhaka</strong><br class="title-page-name"/><strong class="calibre1">megacity.get( "India" ) : Kolkata</strong>
</pre>
<p class="mce-root">Using the <kbd class="calibre11">getOrElse()</kbd> method, it is possible to access a value or a default when no value is present. For example:</p>
<pre class="calibre19">
// Using getOrElse() method: <br class="title-page-name"/>val message: Option[String] = Some("Hello, world!")<br class="title-page-name"/>val x: Option[Int] = Some(20)<br class="title-page-name"/>val y: Option[Int] = None<br class="title-page-name"/>println("message.getOrElse(0): " + message.getOrElse(0))<br class="title-page-name"/>println("x.getOrElse(0): " + x.getOrElse(0))<br class="title-page-name"/>println("y.getOrElse(10): " + y.getOrElse(10))
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">message.getOrElse(0): Hello, world!</strong><br class="title-page-name"/><strong class="calibre1">x.getOrElse(0): 20</strong><br class="title-page-name"/><strong class="calibre1">y.getOrElse(10): 10</strong>
</pre>
<p class="mce-root">Moreover, using the <kbd class="calibre11">isEmpty()</kbd> method, you can check if the option is <kbd class="calibre11">None</kbd> or not. For example:</p>
<pre class="calibre19">
println("message.isEmpty: " + message.isEmpty)<br class="title-page-name"/>println("x.isEmpty: " + x.isEmpty)<br class="title-page-name"/>println("y.isEmpty: " + y.isEmpty)
</pre>
<p class="mce-root">Now, here's the complete program:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>object ScalaOptions {<br class="title-page-name"/>  def show(x: Option[String]) = x match {<br class="title-page-name"/>    case Some(s) =&gt; s<br class="title-page-name"/>    case None =&gt; "?"<br class="title-page-name"/>  }<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val megacity = Map("Bangladesh" -&gt; "Dhaka", "Japan" -&gt; "Tokyo",<br class="title-page-name"/>    "India" -&gt; "Kolkata", "USA" -&gt; "New York")<br class="title-page-name"/>    println("megacity.get( \"Bangladesh\" ) : " +<br class="title-page-name"/>    show(megacity.get("Bangladesh")))<br class="title-page-name"/>    println("megacity.get( \"India\" ) : " +<br class="title-page-name"/>    show(megacity.get("India")))<br class="title-page-name"/><br class="title-page-name"/>    // Using getOrElse() method: <br class="title-page-name"/>    val message: Option[String] = Some("Hello, world")<br class="title-page-name"/>    val x: Option[Int] = Some(20)<br class="title-page-name"/>    val y: Option[Int] = None<br class="title-page-name"/><br class="title-page-name"/>    println("message.getOrElse(0): " + message.getOrElse(0))<br class="title-page-name"/>    println("x.getOrElse(0): " + x.getOrElse(0))<br class="title-page-name"/>    println("y.getOrElse(10): " + y.getOrElse(10))<br class="title-page-name"/><br class="title-page-name"/>    // Using isEmpty()<br class="title-page-name"/>    println("message.isEmpty: " + message.isEmpty)<br class="title-page-name"/>    println("x.isEmpty: " + x.isEmpty)<br class="title-page-name"/>    println("y.isEmpty: " + y.isEmpty)<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">megacity.get( "Bangladesh" ) : Dhaka</strong><br class="title-page-name"/><strong class="calibre1">megacity.get( "India" ) : Kolkata</strong><br class="title-page-name"/><strong class="calibre1">message.getOrElse(0): Hello, world</strong><br class="title-page-name"/><strong class="calibre1">x.getOrElse(0): 20</strong><br class="title-page-name"/><strong class="calibre1">y.getOrElse(10): 10</strong><br class="title-page-name"/><strong class="calibre1">message.isEmpty: false</strong><br class="title-page-name"/><strong class="calibre1">x.isEmpty: false</strong><br class="title-page-name"/><strong class="calibre1">y.isEmpty: true</strong>
</pre>
<p class="mce-root">Let's take a look at other examples on when to use <kbd class="calibre11">Option</kbd>. For example, the <kbd class="calibre11">Map.get()</kbd> method uses <kbd class="calibre11">Option</kbd> in order to tell the user if the element that he tries to access exists or not. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val numbers = Map("two" -&gt; 2, "four" -&gt; 4)</strong><br class="title-page-name"/><strong class="calibre1">numbers: scala.collection.immutable.Map[String,Int] = Map(two -&gt; 2, four -&gt; 4)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; numbers.get("four")</strong><br class="title-page-name"/><strong class="calibre1">res12: Option[Int] = Some(4)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; numbers.get("five")</strong><br class="title-page-name"/><strong class="calibre1">res13: Option[Int] = None</strong>
</pre>
<p class="mce-root">Now, we will see how to use exists, which is used to check if a predicate holds for a subset of a set of elements in the Traversal collection.</p>


            </article>

            
        </section>
    

        <section id="3RV941-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exists</h1>
                
            
            <article>
                
<p class="mce-root">Exists checks if a predicate holds for at least one element in the Traversable collection. For example:</p>
<pre class="calibre19">
def exists(p: ((A, B))  Boolean): Boolean  
</pre>
<div class="packt_infobox"><strong class="calibre27">Using the fat arrow:</strong> <kbd class="calibre22">=&gt;</kbd> is called the <em class="calibre25">right arrow</em>, <em class="calibre25">fat arrow,</em> or <em class="calibre25">rocket</em> and is used for passing parameters by name. That means the expression will be evaluated when a parameter is accessed. It is actually syntactic sugar for a zero parameter function <kbd class="calibre22">call: x: () =&gt; Boolean</kbd>. Let's see an example using this operator is as follows:<br class="calibre23"/>
<kbd class="calibre22">package com.chapter4.CollectionAPI</kbd><br class="calibre23"/>
<kbd class="calibre22">object UsingFatArrow {</kbd><br class="calibre23"/>
<kbd class="calibre22">def fliesPerSecond(callback: () =&gt; Unit) {</kbd><br class="calibre23"/>
<kbd class="calibre22">while (true) { callback(); Thread sleep 1000 }</kbd><br class="calibre23"/>
<kbd class="calibre22">}</kbd><br class="calibre23"/>
<kbd class="calibre22">def main(args: Array[String]): Unit= {</kbd><br class="calibre23"/>
<kbd class="calibre22">fliesPerSecond(() =&gt; println("Time and tide wait for none but fly like arrows ..."))</kbd><br class="calibre23"/>
<kbd class="calibre22">}</kbd><br class="calibre23"/>
<kbd class="calibre22">}</kbd><br class="calibre23"/>
You will get the following output:<br class="calibre23"/>
<kbd class="calibre22">Time and tide wait for none but flies like an arrow...</kbd><br class="calibre23"/>
<kbd class="calibre22">Time and tide wait for none but flies like an arrow...</kbd><br class="calibre23"/>
<kbd class="calibre22">Time and tide wait for none but flies like an arrow...</kbd><br class="calibre23"/>
<kbd class="calibre22">Time and tide wait for none but flies like an arrow...</kbd><br class="calibre23"/>
<kbd class="calibre22">Time and tide wait for none but flies like an arrow...</kbd><br class="calibre23"/>
<kbd class="calibre22">Time and tide wait for none but flies like an arrow...</kbd></div>
<p class="mce-root">A detailed example can be seen in the following code as follows:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/><br class="title-page-name"/>object ExistsExample {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    // Given a list of cities and now check if "Dublin" is included in<br class="title-page-name"/>    the list     <br class="title-page-name"/>    val cityList = List("Dublin", "NY", "Cairo")<br class="title-page-name"/>    val ifExisitsinList = cityList exists (x =&gt; x == "Dublin")<br class="title-page-name"/>    println(ifExisitsinList)<br class="title-page-name"/><br class="title-page-name"/>    // Given a map of countries and their capitals check if Dublin is<br class="title-page-name"/>    included in the Map <br class="title-page-name"/>    val cityMap = Map("Ireland" -&gt; "Dublin", "UK" -&gt; "London")<br class="title-page-name"/>    val ifExistsinMap =  cityMap exists (x =&gt; x._2 == "Dublin")<br class="title-page-name"/>    println(ifExistsinMap)<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">true</strong><br class="title-page-name"/><strong class="calibre1">true</strong>
</pre>
<div class="title-page-name"><strong class="calibre1">Note: Using the infix operator in Scala</strong>:</div>
<p class="mce-root">In the earlier example and in a subsequent section, we used the Scala infix notation. Suppose you would like to perform some operation with complex numbers and have a case class with an add method for adding two complex numbers:</p>
<pre class="calibre19">
case class Complex(i: Double, j: Double) {<br class="title-page-name"/>   def plus(other: Complex): Complex = Complex(i + other.i, j + other.j)<br class="title-page-name"/> }
</pre>
<p class="mce-root">Now in order to access the properties of this class, you need to create an object like this:</p>
<pre class="calibre19">
val obj = Complex(10, 20)
</pre>
<p class="mce-root">Moreover, suppose you have the following two complex numbers defined:</p>
<pre class="calibre19">
val a = Complex(6, 9)<br class="title-page-name"/> val b = Complex(3, -6)
</pre>
<p class="mce-root">Now to access the <kbd class="calibre11">plus()</kbd> method from the case class, you will do <span>something like this:</span></p>
<pre class="calibre19">
val z = obj.plus(a)
</pre>
<p class="mce-root">This should give you output: <kbd class="calibre11">Complex(16.0,29.0)</kbd>. However, isn't it good if you just call the method like this:</p>
<pre class="calibre19">
val c = a plus b
</pre>
<p class="mce-root">And it really works like a charm. Here is the complete example:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/> object UsingInfix {<br class="title-page-name"/>   case class Complex(i: Double, j: Double) {<br class="title-page-name"/>     def plus(other: Complex): Complex = Complex(i + other.i, j + other.j)<br class="title-page-name"/>   }  <br class="title-page-name"/>   def main(args: Array[String]): Unit = {    <br class="title-page-name"/>     val obj = Complex(10, 20)<br class="title-page-name"/>     val a = Complex(6, 9)<br class="title-page-name"/>     val b = Complex(3, -6)<br class="title-page-name"/>     val c = a plus b<br class="title-page-name"/>     val z = obj.plus(a)<br class="title-page-name"/>     println(c)<br class="title-page-name"/>     println(z)<br class="title-page-name"/>   }<br class="title-page-name"/> }
</pre>
<p class="mce-root"><strong class="calibre1">The precedence of an infix operator</strong>: This is determined by the operator's first character. Characters are listed below in increasing order of precedence, with characters on the same line having the same precedence:</p>
<pre class="calibre19">
(all letters)<br class="title-page-name"/> |<br class="title-page-name"/> ^<br class="title-page-name"/> &amp;<br class="title-page-name"/> = !<br class="title-page-name"/> &lt; &gt;<br class="title-page-name"/> :<br class="title-page-name"/> + -<br class="title-page-name"/> * / %<br class="title-page-name"/> (all other special characters)
</pre>
<div class="packt_infobox"><br class="calibre23"/>
<strong class="calibre27">General warning</strong>: Using the infix notation for calling regular, non-symbolic methods is discouraged and should be used only if it significantly increases readability. One example of a sufficiently motivated use of infix notation is matchers and other parts of the tests definition in <kbd class="calibre22">ScalaTest</kbd>.</div>
<p class="mce-root">Another interesting element in the Scala collection package is using <kbd class="calibre11">forall</kbd>. It is used to check if a predicate holds for each element in a <kbd class="calibre11">Traversable</kbd> collection. In the next subsection, we will see an example of it.</p>


            </article>

            
        </section>
    

        <section id="3STPM1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Forall</h1>
                
            
            <article>
                
<p class="mce-root">Forall checks if a predicate holds for each element in a <kbd class="calibre11">Traversable</kbd> collection. It can be defined formally as follows:</p>
<pre class="calibre19">
def forall (p: (A)  Boolean): Boolean  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; Vector(1, 2, 8, 10) forall (x =&gt; x % 2 == 0)</strong><br class="title-page-name"/><strong class="calibre1">res2: Boolean = false</strong>
</pre>
<p class="mce-root">While writing Scala code for preprocessing especially, we often need to filter selected data objects. The filter feature of the Scala collection API is used for that. In the next sub-section, we will see an example of using filter.</p>


            </article>

            
        </section>
    

        <section id="3TSA81-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Filter</h1>
                
            
            <article>
                
<p class="mce-root"><kbd class="calibre11">filter</kbd> selects all the elements that satisfy a specific predicate. It can be defined formally as follows:</p>
<pre class="calibre19">
def filter(p: (A)  Boolean): Traversable[A]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; //Given a list of tuples (cities, Populations)</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; // Get all cities that has population more than 5 million</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; List(("Dublin", 2), ("NY", 8), ("London", 8)) filter (x =&gt;x._2 &gt;= 5)</strong><br class="title-page-name"/><strong class="calibre1">res3: List[(String, Int)] = List((NY,8), (London,8))</strong>
</pre>
<p class="mce-root">A map is used to build a new collection or set of elements by traversing a function to all elements of the collection. In the next subsection, we will see an example of using <kbd class="calibre11">Map</kbd>.</p>


            </article>

            
        </section>
    

        <section id="3UQQQ1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Map</h1>
                
            
            <article>
                
<p class="mce-root">Map is used to build a new collection or set of elements by traversing a function to all elements of the collection. It can be defined formally as follows:</p>
<pre class="calibre19">
def map[B](f: (A)  B): Map[B]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; // Given a list of integers</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; // Get a list with all the elements square.</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; List(2, 4, 5, -6) map ( x=&gt; x * x)</strong><br class="title-page-name"/><strong class="calibre1">res4: List[Int] = List(4, 16, 25, 36)</strong>
</pre>
<p class="mce-root">While using the collection API in Scala, you often need to select the n<sup class="calibre26">th</sup> elements of the list or array for example. In the next sub-section, we will explore examples of using take.</p>


            </article>

            
        </section>
    

        <section id="3VPBC1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Take</h1>
                
            
            <article>
                
<p class="mce-root">Take is used to take the first n elements of a collection. The formal definition of using <kbd class="calibre11">take</kbd> is as follows:</p>
<pre class="calibre19">
def take(n: Int): Traversable[A]
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
// Given an infinite recursive method creating a stream of odd numbers.<br class="title-page-name"/>def odd: Stream[Int] = {<br class="title-page-name"/>  def odd0(x: Int): Stream[Int] =<br class="title-page-name"/>    if (x%2 != 0) x #:: odd0(x+1)<br class="title-page-name"/>    else odd0(x+1)<br class="title-page-name"/>      odd0(1)<br class="title-page-name"/>}// Get a list of the 5 first odd numbers.<br class="title-page-name"/>odd take (5) toList
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">res5: List[Int] = List(1, 3, 5, 7, 9)</strong>
</pre>
<p class="mce-root">In Scala, if want to partition specific collections into a map of an other <kbd class="calibre11">Traversable</kbd> collection according to a specific partitioning function, you can use the <kbd class="calibre11">groupBy()</kbd> method. In the next subsection, we will show some examples of using <kbd class="calibre11">groupBy()</kbd>.</p>


            </article>

            
        </section>
    

        <section id="40NRU1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">GroupBy</h1>
                
            
            <article>
                
<p class="mce-root">GroupBy is used to partition specific collections into a map of other Traversable collections according to a specific partitioning function. It can be defined formally as follows:</p>
<pre class="calibre19">
def groupBy[K](f: ((A, B))  K): Map[K, Map[A, B]]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; // Given a list of numbers</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; // Group them as positive and negative numbers.</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; List(1,-2,3,-4) groupBy (x =&gt; if (x &gt;= 0) "positive" else "negative")</strong><br class="title-page-name"/><strong class="calibre1">res6: scala.collection.immutable.Map[String,List[Int]] = Map(negative -&gt; List(-2, -4), positive -&gt; List(1, 3))</strong>
</pre>
<p class="mce-root">In Scala, if you want to select all the elements in a Traversable collection but the last one, you can use <kbd class="calibre11">init</kbd>. In the next subsection, we will see examples of it.</p>


            </article>

            
        </section>
    

        <section id="41MCG1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Init</h1>
                
            
            <article>
                
<p class="mce-root"><kbd class="calibre11">init</kbd> selects all the elements in a <kbd class="calibre11">Traversable</kbd> collection but the last one. It can be defined formally as follows:</p>
<pre class="calibre19">
def init: Traversable[A]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; List(1,2,3,4) init</strong><br class="title-page-name"/><strong class="calibre1">res7: List[Int] = List(1, 2, 3)</strong>
</pre>
<p class="mce-root">In Scala, if you want to select all elements except the first n elements, you should use drop. In the next subsection, we will see how to use drop.</p>


            </article>

            
        </section>
    

        <section id="42KT21-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Drop</h1>
                
            
            <article>
                
<p class="mce-root"><kbd class="calibre11">drop</kbd> is used to select all elements except the first n elements. It can be defined formally as follows:</p>
<pre class="calibre19">
def drop(n: Int): Traversable[A]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">// Drop the first three elements</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; List(1,2,3,4) drop 3</strong><br class="title-page-name"/><strong class="calibre1">res8: List[Int] = List(4)</strong>
</pre>
<p class="mce-root">In Scala, if you want take a set of elements until a predicate is satisfied, you should use <kbd class="calibre11">takeWhile</kbd>. In the next subsection, we will see how to use <kbd class="calibre11">takeWhile</kbd>.</p>


            </article>

            
        </section>
    

        <section id="43JDK1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TakeWhile</h1>
                
            
            <article>
                
<p class="mce-root">TakeWhile is used to take a set of elements until a predicate is satisfied. It can be defined formally as follows:</p>
<pre class="calibre19">
def takeWhile(p: (A)  Boolean): Traversable[A]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
// Given an infinite recursive method creating a stream of odd numbers.<br class="title-page-name"/>def odd: Stream[Int] = {<br class="title-page-name"/>  def odd0(x: Int): Stream[Int] =<br class="title-page-name"/>    if (x%2 != 0) x #:: odd0(x+1)<br class="title-page-name"/>    else odd0(x+1)<br class="title-page-name"/>      odd0(1)<br class="title-page-name"/>}<br class="title-page-name"/>// Return a list of all the odd elements until an element isn't less then 9. <br class="title-page-name"/>odd takeWhile (x =&gt; x &lt; 9) toList
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">res11: List[Int] = List(1, 3, 5, 7)</strong>
</pre>
<p class="mce-root">In Scala, if you want to omit a set of elements till a predicate is satisfied, you should use <kbd class="calibre11">dropWhile</kbd>. We will see some examples of this in the next subsection.</p>


            </article>

            
        </section>
    

        <section id="44HU61-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DropWhile</h1>
                
            
            <article>
                
<p class="mce-root"><kbd class="calibre11">dropWhile</kbd> is used to omit a set of elements till a predicate is satisfied. It can be defined formally as follows:</p>
<pre class="calibre19">
def dropWhile(p: (A)  Boolean): Traversable[A]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">//Drop values till reaching the border between numbers that are greater than 5 and less than 5</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; List(2,3,4,9,10,11) dropWhile(x =&gt; x &lt;5)</strong><br class="title-page-name"/><strong class="calibre1">res1: List[Int] = List(9, 10, 11)</strong>
</pre>
<p class="mce-root">In Scala, if you want to use your <strong class="calibre1">User Defined Functions</strong> (<strong class="calibre1">UDF</strong>) such that it takes a function as an argument in the nested list and combines the output back together, <kbd class="calibre11">flatMap()</kbd> is a perfect candidate. We will see examples of using <kbd class="calibre11">flatMap()</kbd> in the next section.</p>


            </article>

            
        </section>
    

        <section id="45GEO1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">FlatMap</h1>
                
            
            <article>
                
<p class="mce-root">FltatMap takes a function as an argument. The function given to <kbd class="calibre11">flatMap()</kbd> doesn't work on nested lists but it produces a new collection. It can be defined formally as follows:</p>
<pre class="calibre19">
def flatMap[B](f: (A)  GenTraversableOnce[B]): Traversable[B]  
</pre>
<p class="mce-root">Let's see an example as follows:</p>
<pre class="calibre19">
<strong class="calibre1">//Applying function on nested lists and then combining output back together</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; List(List(2,4), List(6,8)) flatMap(x =&gt; x.map(x =&gt; x * x))</strong><br class="title-page-name"/><strong class="calibre1">res4: List[Int] = List(4, 16, 36, 64)</strong>
</pre>
<p class="mce-root">We have just about finished covering the uses of Scala collection features. Also note that methods such as <kbd class="calibre11">Fold()</kbd>, <kbd class="calibre11">Reduce()</kbd>, <kbd class="calibre11">Aggregate()</kbd>, <kbd class="calibre11">Collect()</kbd>, <kbd class="calibre11">Count()</kbd>, <kbd class="calibre11">Find()</kbd>, and <kbd class="calibre11">Zip()</kbd> can be used to pass from one collection to another (for example, <kbd class="calibre11">toVector</kbd>, <kbd class="calibre11">toSeq</kbd>, <kbd class="calibre11">toSet</kbd>, <kbd class="calibre11">toArray</kbd>). However, we will see such examples in upcoming chapters. For the time being, it's time to see some performance characteristics of different Scala collection APIs.</p>


            </article>

            
        </section>
    

        <section id="46EVA1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Performance characteristics</h1>
                
            
            <article>
                
<p class="mce-root">In Scala, different collections have different performance characteristics and these performance characteristics are the reason you will prefer to choose one collection over the others. In this section, we will judge the performance characteristics of Scala collection objects from the operational and memory usage point of view. At the end of this section, we will provide some guidelines for selecting appropriate collection objects for your code and problem types.</p>


            </article>

            
        </section>
    

        <section>

                            <header id="47DFS2-21aec46d8593429cacea59dbdcd64e1c">
                    </header><h1 class="header-title" id="calibre_pb_0">Performance characteristics of collection objects</h1>
                
            
            <article>
                
<p class="mce-root">The following are the performance characteristics Scala Collections, based on the official documentation of Scala.</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Const</strong>: The operation takes only constant time.</li>
<li class="mce-root1"><strong class="calibre1">eConst</strong>: The operation takes effectively constant time, but this might depend on some assumptions such as the maximum length of a vector or the distribution of hash keys.</li>
<li class="mce-root1"><strong class="calibre1">Linear</strong>: The operation grows linearly with the collection size.</li>
<li class="mce-root1"><strong class="calibre1">Log</strong>: The operation grows logarithmically with the collection size.</li>
<li class="mce-root1"><strong class="calibre1">aConst</strong>: The operation takes the amortized constant time. Some invocations of the operation might take longer, but if many operations are performed on average only constant time per operation is taken.</li>
<li class="mce-root1"><strong class="calibre1">NA</strong>: Operation is not supported.</li>
</ul>
<p class="mce-root">Performance characteristics of sequence types (immutable) are presented in the following table.</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Immutable CO*</strong></td>
<td class="calibre7"><strong class="calibre1">Head</strong></td>
<td class="calibre7"><strong class="calibre1">Tail</strong></td>
<td class="calibre7"><strong class="calibre1">Apply</strong></td>
<td class="calibre7"><strong class="calibre1">Update</strong></td>
<td class="calibre7"><strong class="calibre1">Prepend</strong></td>
<td class="calibre7"><strong class="calibre1">Append</strong></td>
<td class="calibre7"><strong class="calibre1">Insert</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7">List</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">NA</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Stream</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">NA</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Vector</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">NA</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Stack</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Queue</td>
<td class="calibre7">aConst</td>
<td class="calibre7">aConst</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">NA</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Range</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
</tr>
<tr class="calibre6">
<td class="calibre7">String</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">NA</td>
</tr>
</tbody>
</table>
<div class="cdpaligncenter1"><strong class="calibre1">Table 1:</strong> Performance characteristics of sequence types (immutable) [*CO== Collection Object]</div>
<p class="cdpalignleft1">The following table shows the meaning of the operations described in <strong class="calibre1">Table 1</strong> and <strong class="calibre1">Table 3</strong> here:</p>
<div class="cdpalignleft">
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Head</strong></td>
<td class="calibre7">Is used to select the first few elements of an existing sequence.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Tail</strong></td>
<td class="calibre7">Is used to select all elements except the first one and returns a new sequence.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Apply</strong></td>
<td class="calibre7">Is used for indexing purposes.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Update</strong></td>
<td class="calibre7">It is used as the functional update for immutable sequences. For the mutable sequence, it is a side-effecting update (with update for mutable sequences).</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Prepend</strong></td>
<td class="calibre7">It is used to add an element to the front of an existing sequence. A new sequence is produced for immutable sequences. For the mutable sequence, the existing one is modified.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Append</strong></td>
<td class="calibre7">It is used to add an element at the end of an existing sequence. A new sequence is produced for immutable sequences. For a mutable sequence, the existing one is modified.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Insert</strong></td>
<td class="calibre7">It is used to insert an element at an arbitrary position in an existing sequence. This can be done however directly for mutable sequences.</td>
</tr>
</tbody>
</table>
</div>
<div class="cdpaligncenter1"><strong class="calibre1">Table 2:</strong> The meaning of the operation described in table 1</div>
<p class="cdpalignleft1">Performance characteristics of sequence types (mutable) are shown in <strong class="calibre1">Table 3</strong> as follows:</p>
<div class="cdpalignleft">
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Mutable CO*</strong></td>
<td class="calibre7"><strong class="calibre1">Head</strong></td>
<td class="calibre7"><strong class="calibre1">Tail</strong></td>
<td class="calibre7"><strong class="calibre1">Apply</strong></td>
<td class="calibre7"><strong class="calibre1">update</strong></td>
<td class="calibre7"><strong class="calibre1">Prepend</strong></td>
<td class="calibre7"><strong class="calibre1">Append</strong></td>
<td class="calibre7"><strong class="calibre1">Insert</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7">ArrayBuffer</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">aConst</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">ListBuffer</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">StringBuilder</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">aCconst</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">MutableList</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Queue</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">ArraySeq</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Stack</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">ArrayStack</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">aConst</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Array</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Const</td>
<td class="calibre7">Const</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
<td class="calibre7">NA</td>
</tr>
</tbody>
</table>
</div>
<div class="cdpaligncenter1"><strong class="calibre1">Table 3:</strong> Performance characteristics of sequence types (mutable) [*CO== Collection Object]</div>
<div class="cdpalignleft2">For more information about mutable collections and other types of collections, you can refer to this link (<a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html" class="calibre21">http://docs.scala-lang.org/overviews/collections/performance-characteristics.html</a>).</div>
<p class="mce-root">Performance characteristics of set and map types are shown in the following table:</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Collection types</strong></td>
<td class="calibre7"><strong class="calibre1">Lookup</strong></td>
<td class="calibre7"><strong class="calibre1">Add</strong></td>
<td class="calibre7"><strong class="calibre1">Remove</strong></td>
<td class="calibre7"><strong class="calibre1">Min</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">immutable</strong></td>
<td class="calibre7">-</td>
<td class="calibre7">-</td>
<td class="calibre7">-</td>
<td class="calibre7">-</td>
</tr>
<tr class="calibre6">
<td class="calibre7">HashSet/HashMap</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">TreeSet/TreeMap</td>
<td class="calibre7">Log</td>
<td class="calibre7">Log</td>
<td class="calibre7">Log</td>
<td class="calibre7">Log</td>
</tr>
<tr class="calibre6">
<td class="calibre7">BitSet</td>
<td class="calibre7">Const</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">eConst*</td>
</tr>
<tr class="calibre6">
<td class="calibre7">ListMap</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
<td class="calibre7">Linear</td>
</tr>
</tbody>
</table>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Collection types</strong></td>
<td class="calibre7"><strong class="calibre1">Lookup</strong></td>
<td class="calibre7"><strong class="calibre1">Add</strong></td>
<td class="calibre7"><strong class="calibre1">Remove</strong></td>
<td class="calibre7"><strong class="calibre1">Min</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">mutable</strong></td>
<td class="calibre7">-</td>
<td class="calibre7">-</td>
<td class="calibre7">-</td>
<td class="calibre7">-</td>
</tr>
<tr class="calibre6">
<td class="calibre7">HashSet/HashMap</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">WeakHashMap</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">eConst</td>
<td class="calibre7">Linear</td>
</tr>
<tr class="calibre6">
<td class="calibre7">BitSet</td>
<td class="calibre7">Const</td>
<td class="calibre7">aConst</td>
<td class="calibre7">Const</td>
<td class="calibre7">eConst*</td>
</tr>
<tr class="calibre6">
<td class="calibre7">TreeSet</td>
<td class="calibre7">Log</td>
<td class="calibre7">Log</td>
<td class="calibre7">Log</td>
<td class="calibre7">Log</td>
</tr>
</tbody>
</table>
<div class="cdpaligncenter1"><strong class="calibre1">Table 4:</strong> Performance characteristics of set and map types [ * applicable only if bits are densely packed]</div>
<div class="cdpalignleft">The following table shows the meaning of each operation described in <strong class="calibre1">Table 4</strong>:</div>
<div class="cdpalignleft">
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Operation</strong></td>
<td class="calibre7"><strong class="calibre1">Meaning</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Lookup</strong></td>
<td class="calibre7">Is used to test whether an element is contained in a set. Secondly, it is also used to select a value associated with a particular key.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Add</strong></td>
<td class="calibre7">It is used to add a new element to a set. Secondly, it is also used to add a new key/value pair to a map.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Remove</strong></td>
<td class="calibre7">It is used to remove an element from a set or a key from a map.</td>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Min</strong></td>
<td class="calibre7">It is used to select the smallest element of the set or the smallest key of a map.</td>
</tr>
</tbody>
</table>
</div>
<div class="cdpaligncenter1"><strong class="calibre1">Table 5:</strong> The meaning of each operation described in Table 4</div>
<p class="mce-root">One of the basic performance metrics is the memory usage by a particular collection object. In the next section, we will provide some guidelines about how to measure these metrics based on memory usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header id="48C0E2-21aec46d8593429cacea59dbdcd64e1c">
                    </header><h1 class="header-title" id="calibre_pb_0">Memory usage by collection objects</h1>
                
            
            <article>
                
<p class="mce-root">Sometimes, there are several benchmarking questions arrived for example: A <kbd class="calibre11">Lists</kbd> faster than <kbd class="calibre11">Vectors</kbd> for what you're doing or are <kbd class="calibre11">Vectors</kbd> faster than <kbd class="calibre11">Lists</kbd>? How much memory can you save using unboxed Arrays to store primitives? When you do performance tricks such as pre-allocating arrays or using a <kbd class="calibre11">while</kbd> loop instead of a <kbd class="calibre11">foreach</kbd> call, how much does it really matter? <kbd class="calibre11">var l: List</kbd> or val <kbd class="calibre11">b: mutable.Buffer</kbd>? Memory usage can be estimated using different Scala benchmark codes, for example, refer to <a href="https://github.com/lihaoyi/scala-bench" class="calibre10">https://github.com/lihaoyi/scala-bench</a>.</p>
<p class="mce-root">Table 6 here shows the estimated size (bytes) of the various immutable collections of 0-elements, 1- element, 4- elements, and powers of four all the way up to 1,048,576 elements. Although mostse are deterministic, these might be changed depending on your platform:</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Size</strong></td>
<td class="calibre7"><strong class="calibre1">0</strong></td>
<td class="calibre7"><strong class="calibre1">1</strong></td>
<td class="calibre7"><strong class="calibre1">4</strong></td>
<td class="calibre7"><strong class="calibre1">16</strong></td>
<td class="calibre7"><strong class="calibre1">64</strong></td>
<td class="calibre7"><strong class="calibre1">256</strong></td>
<td class="calibre7"><strong class="calibre1">1,024</strong></td>
<td class="calibre7"><strong class="calibre1">4,069</strong></td>
<td class="calibre7"><strong class="calibre1">16,192</strong></td>
<td class="calibre7"><strong class="calibre1">65,536</strong></td>
<td class="calibre7"><strong class="calibre1">262,144</strong></td>
<td class="calibre7"><strong class="calibre1">1,048,576</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
</tr>
<tr class="calibre6">
<td class="calibre7">Vector</td>
<td class="calibre7">56</td>
<td class="calibre7">216</td>
<td class="calibre7">264</td>
<td class="calibre7">456</td>
<td class="calibre7">1,512</td>
<td class="calibre7">5,448</td>
<td class="calibre7">21,192</td>
<td class="calibre7">84,312</td>
<td class="calibre7">334,440</td>
<td class="calibre7">1,353,192</td>
<td class="calibre7">5,412,168</td>
<td class="calibre7">21,648,072</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Object]</td>
<td class="calibre7">16</td>
<td class="calibre7">40</td>
<td class="calibre7">96</td>
<td class="calibre7">336</td>
<td class="calibre7">1,296</td>
<td class="calibre7">5,136</td>
<td class="calibre7">20,496</td>
<td class="calibre7">81,400</td>
<td class="calibre7">323,856</td>
<td class="calibre7">1,310,736</td>
<td class="calibre7">5,242,896</td>
<td class="calibre7">20,971,536</td>
</tr>
<tr class="calibre6">
<td class="calibre7">List</td>
<td class="calibre7">16</td>
<td class="calibre7">56</td>
<td class="calibre7">176</td>
<td class="calibre7">656</td>
<td class="calibre7">2,576</td>
<td class="calibre7">10,256</td>
<td class="calibre7">40,976</td>
<td class="calibre7">162,776</td>
<td class="calibre7">647,696</td>
<td class="calibre7">2,621,456</td>
<td class="calibre7">10,485,776</td>
<td class="calibre7">41,943,056</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Stream (unforced)</td>
<td class="calibre7">16</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
<td class="calibre7">160</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Stream (forced)</td>
<td class="calibre7">16</td>
<td class="calibre7">56</td>
<td class="calibre7">176</td>
<td class="calibre7">656</td>
<td class="calibre7">2,576</td>
<td class="calibre7">10,256</td>
<td class="calibre7">40,976</td>
<td class="calibre7">162,776</td>
<td class="calibre7">647,696</td>
<td class="calibre7">2,621,456</td>
<td class="calibre7">10,485,776</td>
<td class="calibre7">41,943,056</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Set</td>
<td class="calibre7">16</td>
<td class="calibre7">32</td>
<td class="calibre7">96</td>
<td class="calibre7">880</td>
<td class="calibre7">3,720</td>
<td class="calibre7">14,248</td>
<td class="calibre7">59,288</td>
<td class="calibre7">234,648</td>
<td class="calibre7">895,000</td>
<td class="calibre7">3,904,144</td>
<td class="calibre7">14,361,000</td>
<td class="calibre7">60,858,616</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Map</td>
<td class="calibre7">16</td>
<td class="calibre7">56</td>
<td class="calibre7">176</td>
<td class="calibre7">1,648</td>
<td class="calibre7">6,800</td>
<td class="calibre7">26,208</td>
<td class="calibre7">109,112</td>
<td class="calibre7">428,592</td>
<td class="calibre7">1,674,568</td>
<td class="calibre7">7,055,272</td>
<td class="calibre7">26,947,840</td>
<td class="calibre7">111,209,368</td>
</tr>
<tr class="calibre6">
<td class="calibre7">SortedSet</td>
<td class="calibre7">40</td>
<td class="calibre7">104</td>
<td class="calibre7">248</td>
<td class="calibre7">824</td>
<td class="calibre7">3,128</td>
<td class="calibre7">12,344</td>
<td class="calibre7">49,208</td>
<td class="calibre7">195,368</td>
<td class="calibre7">777,272</td>
<td class="calibre7">3,145,784</td>
<td class="calibre7">12,582,968</td>
<td class="calibre7">50,331,704</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Queue</td>
<td class="calibre7">40</td>
<td class="calibre7">80</td>
<td class="calibre7">200</td>
<td class="calibre7">680</td>
<td class="calibre7">2,600</td>
<td class="calibre7">10,280</td>
<td class="calibre7">41,000</td>
<td class="calibre7">162,800</td>
<td class="calibre7">647,720</td>
<td class="calibre7">2,621,480</td>
<td class="calibre7">10,485,800</td>
<td class="calibre7">41,943,080</td>
</tr>
<tr class="calibre6">
<td class="calibre7">String</td>
<td class="calibre7">40</td>
<td class="calibre7">48</td>
<td class="calibre7">48</td>
<td class="calibre7">72</td>
<td class="calibre7">168</td>
<td class="calibre7">552</td>
<td class="calibre7">2,088</td>
<td class="calibre7">8,184</td>
<td class="calibre7">32,424</td>
<td class="calibre7">131,112</td>
<td class="calibre7">524,328</td>
<td class="calibre7">2,097,192</td>
</tr>
</tbody>
</table>
<div class="cdpaligncenter1"><strong class="calibre1">Table 6:</strong> The estimated size (bytes) of the various collections</div>
<p class="mce-root">The following table shows the estimated size (bytes) of the array used in Scala with 0-elements, 1- element, 4- elements, and powers of four all the way up to 1,048,576 elements. Although mostse are deterministic, these might change depending on your platform:</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Size</strong></td>
<td class="calibre7"><strong class="calibre1">0</strong></td>
<td class="calibre7"><strong class="calibre1">1</strong></td>
<td class="calibre7"><strong class="calibre1">4</strong></td>
<td class="calibre7"><strong class="calibre1">16</strong></td>
<td class="calibre7"><strong class="calibre1">64</strong></td>
<td class="calibre7"><strong class="calibre1">256</strong></td>
<td class="calibre7"><strong class="calibre1">1,024</strong></td>
<td class="calibre7"><strong class="calibre1">4,069</strong></td>
<td class="calibre7"><strong class="calibre1">16,192</strong></td>
<td class="calibre7"><strong class="calibre1">65,536</strong></td>
<td class="calibre7"><strong class="calibre1">262,144</strong></td>
<td class="calibre7"><strong class="calibre1">1,048,576</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Object]</td>
<td class="calibre7">16</td>
<td class="calibre7">40</td>
<td class="calibre7">96</td>
<td class="calibre7">336</td>
<td class="calibre7">1,296</td>
<td class="calibre7">5,136</td>
<td class="calibre7">20,496</td>
<td class="calibre7">81,400</td>
<td class="calibre7">323,856</td>
<td class="calibre7">1,310,736</td>
<td class="calibre7">5,242,896</td>
<td class="calibre7">20,971,536</td>
</tr>
<tr class="calibre6">
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
</tr>
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Size</strong></td>
<td class="calibre7"><strong class="calibre1">0</strong></td>
<td class="calibre7"><strong class="calibre1">1</strong></td>
<td class="calibre7"><strong class="calibre1">4</strong></td>
<td class="calibre7"><strong class="calibre1">16</strong></td>
<td class="calibre7"><strong class="calibre1">64</strong></td>
<td class="calibre7"><strong class="calibre1">256</strong></td>
<td class="calibre7"><strong class="calibre1">1,024</strong></td>
<td class="calibre7"><strong class="calibre1">4,069</strong></td>
<td class="calibre7"><strong class="calibre1">16,192</strong></td>
<td class="calibre7"><strong class="calibre1">65,536</strong></td>
<td class="calibre7"><strong class="calibre1">262,144</strong></td>
<td class="calibre7"><strong class="calibre1">1,048,576</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
<td class="calibre7"/>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Boolean]</td>
<td class="calibre7">16</td>
<td class="calibre7">24</td>
<td class="calibre7">24</td>
<td class="calibre7">32</td>
<td class="calibre7">80</td>
<td class="calibre7">272</td>
<td class="calibre7">1,040</td>
<td class="calibre7">4,088</td>
<td class="calibre7">16,208</td>
<td class="calibre7">65,552</td>
<td class="calibre7">262,160</td>
<td class="calibre7">1,048,592</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Byte]</td>
<td class="calibre7">16</td>
<td class="calibre7">24</td>
<td class="calibre7">24</td>
<td class="calibre7">32</td>
<td class="calibre7">80</td>
<td class="calibre7">272</td>
<td class="calibre7">1,040</td>
<td class="calibre7">4,088</td>
<td class="calibre7">16,208</td>
<td class="calibre7">65,552</td>
<td class="calibre7">262,160</td>
<td class="calibre7">1,048,592</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Short]</td>
<td class="calibre7">16</td>
<td class="calibre7">24</td>
<td class="calibre7">24</td>
<td class="calibre7">48</td>
<td class="calibre7">144</td>
<td class="calibre7">528</td>
<td class="calibre7">2,064</td>
<td class="calibre7">8,160</td>
<td class="calibre7">32,400</td>
<td class="calibre7">131,088</td>
<td class="calibre7">524,304</td>
<td class="calibre7">2,097,168</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Int]</td>
<td class="calibre7">16</td>
<td class="calibre7">24</td>
<td class="calibre7">32</td>
<td class="calibre7">80</td>
<td class="calibre7">272</td>
<td class="calibre7">1,040</td>
<td class="calibre7">4,112</td>
<td class="calibre7">16,296</td>
<td class="calibre7">64,784</td>
<td class="calibre7">262,160</td>
<td class="calibre7">1,048,592</td>
<td class="calibre7">4,194,320</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Array[Long]</td>
<td class="calibre7">16</td>
<td class="calibre7">24</td>
<td class="calibre7">48</td>
<td class="calibre7">144</td>
<td class="calibre7">528</td>
<td class="calibre7">2,064</td>
<td class="calibre7">8,208</td>
<td class="calibre7">32,568</td>
<td class="calibre7">129,552</td>
<td class="calibre7">524,304</td>
<td class="calibre7">2,097,168</td>
<td class="calibre7">8,388,624</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Boxed Array[Boolean]</td>
<td class="calibre7">16</td>
<td class="calibre7">40</td>
<td class="calibre7">64</td>
<td class="calibre7">112</td>
<td class="calibre7">304</td>
<td class="calibre7">1,072</td>
<td class="calibre7">4,144</td>
<td class="calibre7">16,328</td>
<td class="calibre7">64,816</td>
<td class="calibre7">262,192</td>
<td class="calibre7">1,048,624</td>
<td class="calibre7">4,194,352</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Boxed Array[Byte]</td>
<td class="calibre7">16</td>
<td class="calibre7">40</td>
<td class="calibre7">96</td>
<td class="calibre7">336</td>
<td class="calibre7">1,296</td>
<td class="calibre7">5,136</td>
<td class="calibre7">8,208</td>
<td class="calibre7">20,392</td>
<td class="calibre7">68,880</td>
<td class="calibre7">266,256</td>
<td class="calibre7">1,052,688</td>
<td class="calibre7">4,198,416</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Boxed Array[Short]</td>
<td class="calibre7">16</td>
<td class="calibre7">40</td>
<td class="calibre7">96</td>
<td class="calibre7">336</td>
<td class="calibre7">1,296</td>
<td class="calibre7">5,136</td>
<td class="calibre7">20,496</td>
<td class="calibre7">81,400</td>
<td class="calibre7">323,856</td>
<td class="calibre7">1,310,736</td>
<td class="calibre7">5,230,608</td>
<td class="calibre7">20,910,096</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Boxed Array[Int]</td>
<td class="calibre7">16</td>
<td class="calibre7">40</td>
<td class="calibre7">96</td>
<td class="calibre7">336</td>
<td class="calibre7">1,296</td>
<td class="calibre7">5,136</td>
<td class="calibre7">20,496</td>
<td class="calibre7">81,400</td>
<td class="calibre7">323,856</td>
<td class="calibre7">1,310,736</td>
<td class="calibre7">5,242,896</td>
<td class="calibre7">20,971,536</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Boxed Array[Long]</td>
<td class="calibre7">16</td>
<td class="calibre7">48</td>
<td class="calibre7">128</td>
<td class="calibre7">464</td>
<td class="calibre7">1,808</td>
<td class="calibre7">7,184</td>
<td class="calibre7">28,688</td>
<td class="calibre7">113,952</td>
<td class="calibre7">453,392</td>
<td class="calibre7">1,835,024</td>
<td class="calibre7">7,340,048</td>
<td class="calibre7">29,360,144</td>
</tr>
</tbody>
</table>
<div class="cdpaligncenter1"><strong class="calibre1">Table 7</strong>: The estimated size (bytes) of the arrays in Scala</div>
<p class="mce-root">However, this book does not set out to distinguish them in a broad way and hence we will omit any discussion on these topics. Refer to the following information box for further guidelines on these:</p>
<div class="packt_infobox">For very detailed benchmarking for Scala Collections with timed code, refer to this link on GitHub (<a href="https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench" class="calibre21">https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench</a>).</div>
<p class="mce-root">As we mentioned in <a href="part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 1</a>, <em class="calibre8">Introduction to Scala</em>, Scala has a very rich Collection API. The same applies for Java but there are lots of differences between the two Collection APIs. In the next section, we will see some examples on Java interoperability.</p>


            </article>

            
        </section>
    

        <section id="49AH01-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java interoperability</h1>
                
            
            <article>
                
<p class="mce-root">As we mentioned earlier, Scala has very rich collection API. The same applies for Java but there are lots of differences between the two collection APIs. For example, both APIs have iterable, iterators, maps, sets, and sequences. But Scala has advantages; it pays more attention to immutable collections and provides more operations for you in order to produce another collection. Sometimes, you want to use or access Java collections or vice versa.</p>
<div class="packt_tip"><kbd class="calibre22">JavaConversions</kbd> is no longer a sound choice. <kbd class="calibre22">JavaConverters</kbd> makes the conversion between Scala and Java collection explicit and you'll be much less likely to experience implicit conversions you didn't intend to use.</div>
<p class="mce-root">As a matter of fact, it's quite trivial to do so because Scala offers in an implicit way to convert between both APIs in the <kbd class="calibre11">JavaConversion</kbd> object. So, you might find bidirectional conversions for the following types:</p>
<pre class="calibre19">
<strong class="calibre1">Iterator               &lt;=&gt;     java.util.Iterator</strong><br class="title-page-name"/><strong class="calibre1">Iterator               &lt;=&gt;     java.util.Enumeration</strong><br class="title-page-name"/><strong class="calibre1">Iterable               &lt;=&gt;     java.lang.Iterable</strong><br class="title-page-name"/><strong class="calibre1">Iterable               &lt;=&gt;     java.util.Collection</strong><br class="title-page-name"/><strong class="calibre1">mutable.Buffer         &lt;=&gt;     java.util.List</strong><br class="title-page-name"/><strong class="calibre1">mutable.Set            &lt;=&gt;     java.util.Set</strong><br class="title-page-name"/><strong class="calibre1">mutable.Map            &lt;=&gt;     java.util.Map</strong><br class="title-page-name"/><strong class="calibre1">mutable.ConcurrentMap  &lt;=&gt;     java.util.concurrent.ConcurrentMap</strong>
</pre>
<p class="mce-root">In order to be able to use these kinds of conversion, you need to import them from the <kbd class="calibre11">JavaConversions</kbd> object. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; import collection.JavaConversions._</strong><br class="title-page-name"/><strong class="calibre1">import collection.JavaConversions._</strong>
</pre>
<p class="mce-root">By this, you have automatic conversions between Scala collections and their corresponding in Java:</p>
<pre class="calibre19">
scala&gt; import collection.mutable._<br class="title-page-name"/>import collection.mutable._<br class="title-page-name"/>scala&gt; val jAB: java.util.List[Int] = ArrayBuffer(3,5,7)<br class="title-page-name"/>jAB: java.util.List[Int] = [3, 5, 7]<br class="title-page-name"/>scala&gt; val sAB: Seq[Int] = jAB<br class="title-page-name"/>sAB: scala.collection.mutable.Seq[Int] = ArrayBuffer(3, 5, 7)<br class="title-page-name"/>scala&gt; val jM: java.util.Map[String, Int] = HashMap("Dublin" -&gt; 2, "London" -&gt; 8)<br class="title-page-name"/>jM: java.util.Map[String,Int] = {Dublin=2, London=8}
</pre>
<p class="mce-root">You can also try to convert other Scala collections into Java ones. For example:</p>
<pre class="calibre19">
<strong class="calibre1">Seq           =&gt;    java.util.List</strong><br class="title-page-name"/><strong class="calibre1">mutable.Seq   =&gt;    java.utl.List</strong><br class="title-page-name"/><strong class="calibre1">Set           =&gt;    java.util.Set</strong><br class="title-page-name"/><strong class="calibre1">Map           =&gt;    java.util.Map  </strong>
</pre>
<p class="mce-root">Java doesn't provide the functionality to distinguish between immutable and mutable collections. The <kbd class="calibre11">List</kbd> will be <kbd class="calibre11">java.util.List</kbd> where all attempts to mutate its elements will throw an <kbd class="calibre11">Exception</kbd>. The following is an example to demonstrate this:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val jList: java.util.List[Int] = List(3,5,7)</strong><br class="title-page-name"/><strong class="calibre1">jList: java.util.List[Int] = [3, 5, 7]</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; jList.add(9)</strong><br class="title-page-name"/><strong class="calibre1">java.lang.UnsupportedOperationException</strong><br class="title-page-name"/><strong class="calibre1">  at java.util.AbstractList.add(AbstractList.java:148)</strong><br class="title-page-name"/><strong class="calibre1">  at java.util.AbstractList.add(AbstractList.java:108)</strong><br class="title-page-name"/><strong class="calibre1">  ... 33 elided</strong>
</pre>
<p class="mce-root">In <a href="part0058.html#1NA0K1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 2</a>, <em class="calibre8">Object-Oriented Scala</em>, we briefly discussed using implicits. However, we will provide a detailed discussion on using implicits in the next section.</p>


            </article>

            
        </section>
    

        <section id="4A91I1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Scala implicits</h1>
                
            
            <article>
                
<p class="mce-root">We have addressed implicits in the previous chapters, but here we are going to see more examples. Implicit parameters are very similar to default parameters but they use different mechanisms in order to find the default value.</p>
<p class="mce-root">An implicit parameter is one that is passed to a constructor or a method and is marked as implicit, which means that the compiler will search for an implicit value within the scope if you don't provide a value for this parameter. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def func(implicit x:Int) = print(x) </strong><br class="title-page-name"/><strong class="calibre1">func: (implicit x: Int)Unit</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; func</strong><br class="title-page-name"/><strong class="calibre1">&lt;console&gt;:9: error: could not find implicit value for parameter x: Int</strong><br class="title-page-name"/><strong class="calibre1">              func</strong><br class="title-page-name"/><strong class="calibre1">              ^</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; implicit val defVal = 2</strong><br class="title-page-name"/><strong class="calibre1">defVal: Int = 2</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; func(3)</strong><br class="title-page-name"/><strong class="calibre1">3</strong>
</pre>
<p class="mce-root">Implicits are very useful for the collection API. For example, the collections API use implicit parameters to supply <kbd class="calibre11">CanBuildFrom</kbd> objects for many methods in these collections. This happens usually because users aren't concerned with these parameters.</p>
<p class="mce-root">One constraint is that you can't have more than one implicit keyword per method and it must be at the start of the parameter list. Here are some invalid examples:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def func(implicit x:Int, y:Int)(z:Int) = println(y,x)</strong><br class="title-page-name"/><strong class="calibre1">&lt;console&gt;:1: error: '=' expected but '(' found.</strong><br class="title-page-name"/><strong class="calibre1">       def func(implicit x:Int, y:Int)(z:Int) = println(y,x)</strong><br class="title-page-name"/><strong class="calibre1">                                      ^</strong>
</pre>
<div class="packt_infobox"><strong class="calibre27">Number of implicit parameters:</strong> Note that you can have more than one implicit parameter. But, you cannot have more than one group of implicit parameters.</div>
<p class="mce-root">The following is for more than 1 implicit parameter:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def func(implicit x:Int, y:Int)(implicit z:Int, f:Int) = println(x,y)</strong><br class="title-page-name"/><strong class="calibre1">&lt;console&gt;:1: error: '=' expected but '(' found.</strong><br class="title-page-name"/><strong class="calibre1">       def func(implicit x:Int, y:Int)(implicit z:Int, f:Int) = println(x,y)</strong><br class="title-page-name"/><strong class="calibre1">                                      ^</strong>
</pre>
<p class="mce-root">The final parameter list on a function can be identified or marked as implicit. This means the values will be taken from the context as they are being called. In other words, if there is no implicit value of the exact type in the scope, the source code using implicit will not be compiled. The reason is simple: since the implicit value must be resolved to a single value type, it would be a better idea to make the type specific to its purpose to avoid implicit clashes.</p>
<p class="mce-root">Moreover, you do not require methods to find an implicit. For example:</p>
<pre class="calibre19">
// probably in a library<br class="title-page-name"/>class Prefixer(val prefix: String)<br class="title-page-name"/>def addPrefix(s: String)(implicit p: Prefixer) = p.prefix + s<br class="title-page-name"/>// then probably in your application<br class="title-page-name"/>implicit val myImplicitPrefixer = new Prefixer("***")<br class="title-page-name"/>addPrefix("abc")  // returns "***abc"
</pre>
<p class="mce-root">When your Scala compiler finds an expression of wrong types for the context it is feeding, it will look for an implicit function value instead for type-checking. So, the difference between your regular methods is that the one marked implicit will be inserted for you by the compiler when a <kbd class="calibre11">Double</kbd> is found but an <kbd class="calibre11">Int</kbd> is required. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; implicit def doubleToInt(d: Double) = d.toInt</strong><br class="title-page-name"/><strong class="calibre1">val x: Int = 42.0</strong>
</pre>
<p class="mce-root">The earlier code will work the same as:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def doubleToInt(d: Double) = d.toInt</strong><br class="title-page-name"/><strong class="calibre1">val x: Int = doubleToInt(42.0)</strong>
</pre>
<p class="mce-root">In the second we've inserted the conversion manually. At first, the compiler did this automatically. The conversion is required because of the type annotation on the left-hand side.</p>
<p class="mce-root">While working with data, we will often need to convert one type to another. Scala implicit type conversion gives us this facility. We will see several examples of it in the next section.</p>


            </article>

            
        </section>
    

        <section id="4B7I41-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implicit conversions in Scala</h1>
                
            
            <article>
                
<p class="mce-root">An implicit conversion from type <kbd class="calibre11">S</kbd> to type <kbd class="calibre11">T</kbd> is defined by an implicit value that has function type <kbd class="calibre11">S =&gt; T</kbd>, or by an implicit method convertible to a value of that type. Implicit conversions are applied in two situations (source: <a href="http://docs.scala-lang.org/tutorials/tour/implicit-conversions" class="calibre10">http://docs.scala-lang.org/tutorials/tour/implicit-conversions</a>):</p>
<ul class="calibre9">
<li class="mce-root1">If an expression e is of type <kbd class="calibre11">S</kbd>, and S does not conform to the expression's expected type <kbd class="calibre11">T</kbd></li>
<li class="mce-root1">In a selection <kbd class="calibre11">e.m</kbd> with <kbd class="calibre11">e</kbd> of type <kbd class="calibre11">S</kbd>, if the selector <kbd class="calibre11">m</kbd> does not denote a member of <kbd class="calibre11">S</kbd>.</li>
</ul>
<p class="mce-root">Well, we have seen how to use infix operator in Scala. Now, let's see some use cases of Scala implicit conversion. Suppose we have the following code segment:</p>
<pre class="calibre19">
class Complex(val real: Double, val imaginary: Double) {<br class="title-page-name"/>  def plus(that: Complex) = new Complex(this.real + that.real, this.imaginary + that.imaginary)<br class="title-page-name"/>  def minus(that: Complex) = new Complex(this.real - that.real, this.imaginary - that.imaginary)<br class="title-page-name"/>  def unary(): Double = {<br class="title-page-name"/>    val value = Math.sqrt(real * real + imaginary * imaginary)<br class="title-page-name"/>    value<br class="title-page-name"/>  }<br class="title-page-name"/>  override def toString = real + " + " + imaginary + "i"<br class="title-page-name"/>}<br class="title-page-name"/>object UsingImplicitConversion {<br class="title-page-name"/>  def main(args: Array[String]): Unit = {<br class="title-page-name"/>    val obj = new Complex(5.0, 6.0)<br class="title-page-name"/>    val x = new Complex(4.0, 3.0)<br class="title-page-name"/>    val y = new Complex(8.0, -7.0)<br class="title-page-name"/><br class="title-page-name"/>    println(x) // prints 4.0 + 3.0i<br class="title-page-name"/>    println(x plus y) // prints 12.0 + -4.0i<br class="title-page-name"/>    println(x minus y) // -4.0 + 10.0i<br class="title-page-name"/>    println(obj.unary) // prints 7.810249675906654<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">In the preceding code, we defined some methods for performing addition, subtraction, and a unary operation for complex numbers (that is, both real and imaginary numbers). Inside the <kbd class="calibre11">main()</kbd> method, we called these methods with real values. The output is given as follows:</p>
<pre class="calibre19">
<strong class="calibre1">4.0 + 3.0i</strong><br class="title-page-name"/><strong class="calibre1">12.0 + -4.0i</strong><br class="title-page-name"/><strong class="calibre1">-4.0 + 10.0i</strong><br class="title-page-name"/><strong class="calibre1">7.810249675906654</strong>
</pre>
<p class="mce-root"><br class="title-page-name"/>
But what if we want to support adding a normal number to a complex number, how would we do that? We could certainly overload our <kbd class="calibre11">plus</kbd> method to take a <kbd class="calibre11">Double</kbd> argument so that it's going to support the following expression.</p>
<pre class="calibre19">
val sum = myComplexNumber plus 6.5
</pre>
<p class="mce-root">For this, we can use Scala implicit conversion. It supports implicit conversion for both real and complex numbers for mathematical operation. So, we can just use that tuple as the parameter for our implicit conversion and convert it into a <kbd class="calibre11">Complex</kbd> refer to the following:</p>
<pre class="calibre19">
implicit def Tuple2Complex(value: Tuple2[Double, Double]) = new Complex(value._1, value._2)
</pre>
<p class="mce-root">Alternatively, for double to complex conversion as follows:</p>
<pre class="calibre19">
implicit def Double2Complex(value : Double) = new Complex(value,0.0) 
</pre>
<p class="mce-root">To take the advantage of this conversion, we need to import the following:</p>
<pre class="calibre19">
import ComplexImplicits._ // for complex numbers<br class="title-page-name"/>import scala.language.implicitConversions // in general
</pre>
<p class="mce-root">Now, we can execute something like this on Scala REPL/IDE:</p>
<pre class="calibre19">
val z = 4 plus y<br class="title-page-name"/>println(z) // prints 12.0 + -7.0i<br class="title-page-name"/>val p = (1.0, 1.0) plus z<br class="title-page-name"/>println(p) // prints 13.0 + -6.0i 
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">12.0 + -7.0i</strong><br class="title-page-name"/><strong class="calibre1">13.0 + -6.0i</strong>
</pre>
<p class="mce-root">The full source code for this example can be seen as follows:</p>
<pre class="calibre19">
package com.chapter4.CollectionAPI<br class="title-page-name"/>import ComplexImplicits._<br class="title-page-name"/>import scala.language.implicitConversions<br class="title-page-name"/>class Complex(val real: Double, val imaginary: Double) {<br class="title-page-name"/>  def plus(that: Complex) = new Complex(this.real + that.real, this.imaginary + that.imaginary)<br class="title-page-name"/>  def plus(n: Double) = new Complex(this.real + n, this.imaginary)<br class="title-page-name"/>  def minus(that: Complex) = new Complex(this.real - that.real, this.imaginary - that.imaginary)<br class="title-page-name"/>  def unary(): Double = {<br class="title-page-name"/>    val value = Math.sqrt(real * real + imaginary * imaginary)<br class="title-page-name"/>    value<br class="title-page-name"/>  }<br class="title-page-name"/>  override def toString = real + " + " + imaginary + "i"<br class="title-page-name"/>}<br class="title-page-name"/>object ComplexImplicits {<br class="title-page-name"/>  implicit def Double2Complex(value: Double) = new Complex(value, 0.0)<br class="title-page-name"/>  implicit def Tuple2Complex(value: Tuple2[Double, Double]) = new Complex(value._1, value._2)<br class="title-page-name"/>}<br class="title-page-name"/>object UsingImplicitConversion {<br class="title-page-name"/>  def main(args: Array[String]): Unit = {<br class="title-page-name"/>    val obj = new Complex(5.0, 6.0)<br class="title-page-name"/>    val x = new Complex(4.0, 3.0)<br class="title-page-name"/>    val y = new Complex(8.0, -7.0)<br class="title-page-name"/>    println(x) // prints 4.0 + 3.0i<br class="title-page-name"/>    println(x plus y) // prints 12.0 + -4.0i<br class="title-page-name"/>    println(x minus y) // -4.0 + 10.0i<br class="title-page-name"/>    println(obj.unary) // prints 7.810249675906654<br class="title-page-name"/>    val z = 4 plus y<br class="title-page-name"/>    println(z) // prints 12.0 + -7.0i<br class="title-page-name"/>    val p = (1.0, 1.0) plus z<br class="title-page-name"/>    println(p) // prints 13.0 + -6.0i<br class="title-page-name"/>  }<br class="title-page-name"/>} 
</pre>
<p class="mce-root">We have now more or less covered Scala collection APIs. There are other features too, but page limitations prevented us from covering them. Interested readers who still want to explore this should refer to this page <a href="http://www.scala-lang.org/docu/files/collections-api/collections.html" class="calibre10">http://www.scala-lang.org/docu/files/collections-api/collections.html</a>.</p>


            </article>

            
        </section>
    

        <section id="4C62M1-21aec46d8593429cacea59dbdcd64e1c">

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">Throughout this chapter, we have seen many examples of using the Scala collections API. It's very powerful, flexible, and has lots of operations coupled with them. This wide range of operations will make your life easy dealing with any kind of data. We introduced the Scala collections API, and its different types and hierarchies. We also demonstrated the capabilities of the Scala collections API and how it can be used in order to accommodate different types of data and solve a wide range of different problems. In summary, you learned about types and hierarchies, performance characteristic, Java interoperability, and the usage of implicits. So, this is more or less the end of the learning Scala. However, you will keep on learning more advanced topics and operations using Scala through the following chapters.</p>
<p class="mce-root">In the next chapter, we will explore data analysis and big data to see the challenges that big data provides and how they are dealt via distributed computing and the approach suggested by functional programming. You will also learn about MapReduce, Apache Hadoop, and finally Apache Spark and see how they embrace this approach and these techniques.</p>


            </article>

            
        </section>
    </body></html>