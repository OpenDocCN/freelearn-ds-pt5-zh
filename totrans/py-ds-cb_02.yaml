- en: Chapter 2. Python Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using NumPy libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting with matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning with scikit-learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce you to the Python environment, which will
    be used extensively throughout this book. We will start with NumPy, which is a
    Python library that is used to handle arrays and matrices efficiently. It forms
    the basis for most of the other libraries used in this book. We will then introduce
    a Python plotting library called matplotlib. Our final recipe is about a machine
    learning library called scikit-learn.
  prefs: []
  type: TYPE_NORMAL
- en: Using NumPy libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy provides an efficient way of handling very large arrays in Python. Most
    of the Python scientific libraries use NumPy internally for the array and matrix
    operations. In this book, we will be using NumPy extensively. We will introduce
    NumPy in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will write a series of Python statements manipulating arrays and matrices,
    and learn how to use NumPy on the way. Our intent is to get you used to working
    with NumPy arrays, as NumPy will serve as the basis for most of the recipes in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating some simple matrices and arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will write a small convenience function in order to inspect our NumPy
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see some alternate ways of creating arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now look at the creation of some special matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with the knowledge of array and matrix creation, let''s see some shaping
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, proceed to see some matrix operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see some reverse, copy, and grid operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at some random number generation routines in the NumPy library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by including the NumPy library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed with looking at the various ways in which we can create an array
    in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An array can be created from a list. In the preceding example, we declared a
    list of three elements. We can then use `np.array()` to convert the list to a
    NumPy one-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The datatype can also be specified, as seen in the last line of the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now move from arrays to matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will create a matrix from a `listoflist`. Once again, we can specify the
    datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move further, we will define a `display_shape` function. We will
    use this function frequently further on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Every NumPy object has the following three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size**: The number of elements in the given NumPy object'
  prefs: []
  type: TYPE_NORMAL
- en: '**ndim**: The number of dimensions'
  prefs: []
  type: TYPE_NORMAL
- en: '**shape**: The shape returns a tuple with the dimensions of the object'
  prefs: []
  type: TYPE_NORMAL
- en: This function prints out all the three properties in addition to printing the
    original element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call this function with the matrix that we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our matrix has nine elements in it, and there are two dimensions.
    Finally, we can see the shape displays both the dimensions and number of elements
    in each dimension. In this case, we have a matrix with three rows and three columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see a couple of other ways of creating arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The NumPy arrange function returns evenly spaced values in the given interval.
    In this case, we want an evenly spaced number between 1 and 10\. Refer to the
    following link for more information about arange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy''s `linspace` is similar to arrange. The difference is how we will request
    the number of samples that are required. With `linspace`, we can say how many
    elements we need between the given range. By default, it returns 50 elements.
    However, in arange, we will need to specify the step size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy provides you with several functions to create special types of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ones()` and `zeros()` functions are used to create a matrix with 1 and
    0 respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Identity that the matrices are created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `k` parameter controls the index where value `1` has to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The shape of the arrays can be controlled by the `reshape` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing `-1`, we can reshape the array to as many dimensions as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ravel` and `flatten` functions can be used to convert a matrix to a one-dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at some matrix operations, such as addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also look at element-wise multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows a matrix multiplication operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will transpose a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `min` and `max` functions can be used to find the minimum and maximum elements
    in a matrix. The `sum` function can be used to find the sum of the rows or columns
    in a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The elements of a matrix can be reversed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy` function can be used to copy a matrix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s look at the mgrid functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mgrid` functionality can be used to get the coordinates in the m-dimension.
    In the preceding example, we have three dimensions. In each dimension, our values
    range from `0` to `3`. Let us print `xx`, `yy`, and `zz` to understand a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see the first element of each array. [`0`,`0`,`0`] is the first coordinate
    in our three-dimensional space. The second element in all three arrays, [`0`,`0`,`1`]
    is another point in our space. Similarly, using `mgrid`, we captured all the points
    in our three-dimensional coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy provides us with a module called random in order to give routines, which
    can be used to generate random numbers. Let''s look at some examples of random
    number generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `randint` function in the random module, we can generate random integer
    numbers. We can pass the `start`, `end`, and `size` parameters. In our case, our
    start is `1`, our end is `100`, and our size is `10`. We want 10 random integers
    between 1 and 100\. Let''s look at the output that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Random numbers from other distributions can also be produced. Let''s see an
    example where we get 10 random numbers from a `normal` distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using the `normal` function, we will generate a random sample from a `normal`
    distribution. The mean and standard deviation parameters of the `normal` distribution
    are specified by the `loc` and `scale` parameters. Finally, `size` determines
    the number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'By passing a tuple with the row and column values, we can generate a random
    matrix as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we generated a 3 x 3 matrix, which is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can refer to the following link for some excellent NumPy documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.numpy.org/](http://www.numpy.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Plotting with matplotlib* recipe in [Chapter 3](ch03.xhtml "Chapter 3. Data
    Analysis – Explore and Wrangle"), *Analyzing Data - Explore & Wrangle*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Machine Learning with Scikit Learn* recipe in [Chapter 3](ch03.xhtml "Chapter 3. Data
    Analysis – Explore and Wrangle"), *Analyzing Data - Explore & Wrangle*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting with matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib Python is a two-dimensional plotting library. All kinds of plots,
    including histograms, scatter plots, line plots, dot plots, heat maps, and others,
    can be generated by Python. In this book, we will use the `pyplot` interface of
    `matplotlib` for all our visualization requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will introduce basic plotting mechanisms using `pyplot`.
    We will use `pyplot` in almost all our recipes for visualization in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used matplotlib version 1.3.1 for all the recipes in this book. In your
    command line, you can invoke the `__version__` attribute to check for the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B04041_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking at how to plot simple graphs using matplotlib''s `pyplot`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will proceed to look at some advanced topics, including generating heat
    maps and labeling the *x* and *y* axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by importing the required modules. While using `pyplot`, it''s
    recommended that you import NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by following the code from the main function. There may be graphs
    from the previously run program. It is good practice to close them all, as we
    will use more graphs in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will proceed by generating some data using NumPy to demonstrate plotting
    using `pyplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We generated 100 elements in both our x and y variables. Our y is a square of
    our x variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to doing a simple line plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When our program has multiple plots, it''s a good practice to number each plot.
    Variable `figure_no` is used to number our plots. Let''s look at the `simple_line_plot`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we started numbering our plots by calling the figure function
    in `pyplot`. We passed the figure no variable from our main program. After this,
    we simply called the plot function with our x and y values. We can make our plot
    meaningful by giving names to our x and y axes using the `xlabel` and `ylabel`
    functions respectively. Finally, we can also give a title to our plot. That is
    it. Our first simple line plot is ready. The plot will not be displayed till the
    `show()` function is called. In our code, we will invoke the `show()` function
    in order to see all the plots together. Our plot will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we plotted the values `x` on the x axis and `x squared` on the y axis.
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple line plot. We can see a nice curve as our **y values** are
    squares of our **x values**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to our next plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will increment our figure number and call the `simple_dots` function. We
    want to plot our *x* and *y* values as dots instead of a line. Let''s look at
    the `simple_dots` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Every line is similar to our previous function except the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `or` parameter says that we need dots `(o)`, and the dots should be in
    in the color red (r). The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's move to our next plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to see a scatter plot. Let''s generate some data using NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We sampled 100 data points from a uniform distribution. Now we will proceed
    to call the `simple_scatter` function in order to generate our scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `simple_scatter` function, all the lines are similar to the previous
    plotting routines except for the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of calling the plot function in `pyplot`, we invoked the `scatter`
    function. Our plot will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move on to our final plot, which is a scatter plot, but the points are
    colored based on the class label that they belong to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We will increment our figure in order to keep track of our graph. In the next
    line, we will assign some random labels, either `1` or `0`, to our points. Finally,
    we will call the `scatter_with_color` function with our *x*, *y*, and label variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function, let''s look at the line that differentiates this code from
    the previous scatter plot code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will pass our labels to a `c` parameter, which stands for color. Each label
    will be assigned a unique color. In our example, all the points that are labeled
    as `0` will get a color that is different from the points that are labeled as
    `1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's move on to plotting some heat maps, and axis labeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we will start with the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As a good practice, we will close all the previous figures by calling the `close`
    function. We will proceed with generating some data. Our x is an array of five
    elements, starting from `1` and ending with `5`. Our y is an array of five elements,
    starting from `100` and ending with `500`. We defined the two `x_label` and `y_label`
    lists, which will serve as the labels for our plot. Finally, we invoked the `x_y_axis_labeling`
    function in order to demonstrate the concept of labeling our tickers in the *x*
    and *y* axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We will do a simple dot plot by calling pyplot's dot function. However, in this
    case, we want our points to be displayed as `+` instead of `o`. Hence, we will
    specify `+r`. Our color of choice is red, hence `r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next two lines, we will specify what our x axis and y axis tickers need
    to be. By calling the `xticks` function, we will pass on our x values and their
    labels. In addition, we will say that we want the text to be rotated vertically
    so that they don''t overlap each other. Similarly, we will specify the tickers
    for the *y* axis. Let''s look at our plot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how to generate heat maps using `pyplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will generate some data for our heat map. In this case, we generated a 10
    x 10 matrix filled with values from a normal distribution of a mean specified
    by a `loc` variable of `0.5` and standard deviation specified by a `scale` variable
    of `0.2`. We will invoke the `plot_heat_map` function with this matrix. The second
    parameter is the figure number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call the `pcolor` function in order to generate a heat map. The next
    line invokes the `colorbar` function to display the color gradients for our range
    of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on matplotlib, you can refer to the general matplotlib
    documentation at [http://matplotlib.org/faq/usage_faq.html](http://matplotlib.org/faq/usage_faq.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link is an excellent tutorial on `pyplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matplotlib provides excellent three-dimensional plotting capabilities. Refer
    to the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html](http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The pylab module in matplotlib combines the name space of NumPy with `pyplot`.
    Pylab can also be used to generate the various types of plots shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning with scikit-learn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scikit-learn is a versatile machine learning library in Python. We will use
    this library extensively in this book. We used scikit-learn version 0.15.2 for
    all the recipes in this book. In the command line, you can invoke the `__version__`
    attribute to check for the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Machine learning with scikit-learn](img/B04041_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate some of the capabilities of scikit-learn
    and learn about some of their API organization so that we can follow it seamlessly
    in our future recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scikit-learn provides us with an inbuilt dataset. Let''s see how to access
    this dataset and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed with seeing how we can invoke some machine learning functionalities
    in scikit-learn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s load the scikit learn library and import the module that contains the
    various functions in order to extract the inbuilt datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The first dataset that we will look at is the iris dataset. Refer to [https://en.wikipedia.org/wiki/Iris_flower_data_set](https://en.wikipedia.org/wiki/Iris_flower_data_set)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduced by Sir Donald Fisher, this is a classic dataset for a classification
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `load_iris` function, when invoked, returns a dictionary object. The predictor
    `x`, response variable `y`, response variable names, and feature names can be
    extracted by querying the dictionary object with the appropriate keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to print them and see their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our predictors have 150 instances and four attributes. Our `response`
    variable has 150 instances and a class label for each of the rows in our predictor
    set. We will then print out the attribute names, petal and sepal width and length,
    and finally, the class labels. In most of our future recipes, we will use this
    dataset extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to inspect another inbuilt dataset called the Boston housing
    dataset used in a regression problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is loaded pretty much the same as was iris, and the various components
    of the data, including the predictors and response variables, are queried using
    the respective keys from the dictionary. Let''s print these variables in order
    to inspect them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our predictor set x has 506 instances and 13 attributes. Our
    response variable has 506 entries. Finally, we will also print out the names of
    our attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scikit-learn also provides us with functions that will help us produce a random
    classification dataset with some desired properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make_classification` function is a function that can be used to generate
    a classification dataset. In our example, we generated a dataset with 50 instances
    that are dictated by the `n_samples` parameter, five attributes, `n_features`
    parameters, and two classes set by the `n_classes` parameter. Let''s inspect the
    output of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works…](img/B04041_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our predictor x has 150 instances with five features. Our response
    variable has 150 instances, with a class label for each of the prediction instances.
  prefs: []
  type: TYPE_NORMAL
- en: We will print out the second record in our predictor set, `x`. You can see that
    we have a vector of dimension `5`, relating to the five features that we requested.
    Finally, we will also print the response variable, `y`. For the second row of
    our predictors, the class label is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scikit-learn also provides us with the functions that can generate data with
    nonlinear relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be familiar with `pyplot` now from the previous recipe. Let''s see
    our plot first to understand the nonlinear relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our classification has produced two concentric circles. Our
    `x` is a dataset with two variables. Variable `y` is the class label. As shown
    by the concentric circle, the relationship between our prediction variable is
    nonlinear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting function to produce a nonlinear relationship is `make_moons`
    from scikit-learn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at its plot in order to understand the nonlinear relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The crescent-shaped plot shows that the attributes in our predictor set x are
    nonlinearly related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let's switch gears to understand the API structure of scikit-learn. One of the
    major advantages of using scikit-learn is its clean API structure. All the data
    modeling classes deriving from the `BaseEstimator` class have to strictly implement
    the `fit` and `transform` functions. We will see some examples to learn more about
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the preprocessing module in scikit-learn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `PolynomialFeatures` class in order to demonstrate the ease
    of using scikit-learn''s SDK. Refer to the following link for polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Polynomial](https://en.wikipedia.org/wiki/Polynomial)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a set of predictor variables, we may want to add some more variables to
    our predictor set in order to see if our model accuracy can be improved. We can
    use the polynomials of the existing features as a new feature. The `PolynomialFeatures`
    class helps us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first create a dataset. In this case, our dataset has two instances
    and two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We will proceed to instantiate our `PolynomialFeatures` class with the required
    degree of polynomials. In this case, it will be a second degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Then, there are two functions, fit and transform. The `fit` function is used
    to do the necessary calculations for the transformation. In this case, fit is
    redundant, but we will see some more examples of how fit is used later in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transform` function takes the input and, based on the calculations performed
    by fit, transforms the given input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, in this case, fit and transform can be called in one shot. Let''s
    look at the value and shape of our original and transformed x variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Any class that implements a machine learning method in scikit-learn has to
    deliver from BaseEstimator. See the following link for BaseEstimator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html](http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html)'
  prefs: []
  type: TYPE_NORMAL
- en: BaseEstimator expects that the implementation class provides both the `fit`
    and `transform` methods. This way the API is kept very clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example. Here, we imported a class called `DecisionTreeClassifier`
    from the module tree. `DecisionTreeClassifier` implements the decision tree algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put this class into action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Let's use the iris dataset to see how the tree algorithm can be used. We will
    load the iris dataset in the `x` and `y` variables. We will then instantiate `DecisonTreeClassifier`.
    We will proceed to build the model by invoking the `fit` function and passing
    our `x predictor` and `y response` variable. This will build the tree model. Now,
    we are ready with our model to do some predictions. We will use the `predict`
    function in order to predict the class labels for the given input. As you can
    see, we leveraged the same fit and predict method as in `PolynomialFeatures`.
    There are two other methods, `predict_proba`, which gives the probability of the
    prediction, and `predict_log_proba`, which provides the logarithm of the prediction
    probability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see another interesting utility called pipe lining. Various machine
    learning methods can be chained together using pipe lining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by instantiating the data processing routines, `PolynomialFeatures`
    and `DecisionTreeClassifier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define a list of tuples to indicate the order of our chaining. We want
    to run the polynomial feature generation, followed by our decision tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We can now instantiate our Pipeline object with the list declared using the
    steps variable. Now, we can proceed to do business as usual by calling the `fit`
    and `predict` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can invoke the `named_steps` attribute in order to inspect the models in
    the various stages of our pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04041_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot more dataset creation functions available in scikit-learn.
    Refer to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://scikit-learn.org/stable/datasets/](http://scikit-learn.org/stable/datasets/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating nonlinear datasets using `make_circle` and `make_moons`, we
    mentioned that a lot of desired properties can be added to the dataset. The data
    can be corrupted slightly by inducing incorrect class labels. Refer to the following
    link for a list of options that are available in order to introduce such nuances
    in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html](http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html](http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Plotting* recipe in [Chapter 2](ch02.xhtml "Chapter 2. Python Environments"),
    *Working with Python Environments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
