<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Publish your Data Analysis to the Web - the PixieApp Tool</h1></div></div></div><div><blockquote class="blockquote"><p>"Data, I think, is one of the most powerful mechanisms for telling stories. I take a huge pile of data and I try to get it to tell stories."</p></blockquote></div><p>                                                       – <em>Steven Levitt</em>, co-author of <em>Freakonomics</em>
</p><p>In the previous chapter, we discussed how Jupyter Notebooks, coupled with PixieDust, accelerate your data science projects with simple APIs that let you load, clean, and visualize data without the need to write extensive code, as well as enable collaboration between data scientists and developers with PixieApps. In this chapter, we'll show how to <em>liberate</em> your PixieApps and associated data analytics from the Jupyter Notebook by publishing them as web applications using the PixieGateway server. This operationalization of the Notebook is particularly attractive to the line of business user persona (business analysts, C-Suite executives, and many more) who would like to use the PixieApps but who, unlike data scientists or developers, may not be comfortable using Jupyter Notebooks to do so. Instead, they would prefer to access it as a classic web application or perhaps, similar to a YouTube video, embed it into a blog post or a GitHub page. Using a website or a blog post, it will be easier to communicate the valuable insights and other results extracted from the data analytics from your data.</p><p>By the end of this chapter, you will be able to install and configure a PixieGateway server instance both locally for testing or in a Kubernetes container on the cloud for production. For those readers who are not familiar with Kubernetes, we'll cover the basics in the next section.</p><p>The other main capability of the PixieGateway server that we'll cover in this chapter, is the ability to easily share a chart created with the PixieDust <code class="literal">display()</code> API. We'll show how to publish it as a web page accessible by your team with a single click of a button. Finally, we'll cover the PixieGateway admin console that lets you manage your applications, charts, kernels, server logs, and a Python console executing ad-hoc code requests against a kernel.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>
<strong>Note</strong>: The PixieGateway server is a subcomponent of PixieDust, its source code can be found here:</p><p>
<a class="ulink" href="https://github.com/pixiedust/pixiegateway">https://github.com/pixiedust/pixiegateway</a>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Overview of Kubernetes</h1></div></div></div><p>Kubernetes (<a class="ulink" href="https://kubernetes.io">https://kubernetes.io</a>) is a <a id="id189" class="indexterm"/>scalable open source <a id="id190" class="indexterm"/>system for automating and orchestrating the deployment and management of containerized applications, which are very popular among <a id="id191" class="indexterm"/>cloud service providers. It is most often used with Docker containers (<a class="ulink" href="https://www.docker.com">https://www.docker.com</a>) although other types of containers are supported. Before you start, you will need access to a set of computers that have been configured <a id="id192" class="indexterm"/>as a Kubernetes cluster; you can find a tutorial on how to create such a cluster here: <a class="ulink" href="https://kubernetes.io/docs/tutorials/kubernetes-basics">https://kubernetes.io/docs/tutorials/kubernetes-basics</a>.</p><p>If you don't have the computer resources, a good solution would be to use a public cloud vendor that provides a Kubernetes service, such as Amazon AWS EKS (<a class="ulink" href="https://aws.amazon.com/eks">https://aws.amazon.com/eks</a>), Microsoft Azure (<a class="ulink" href="https://azure.microsoft.com/en-us/services/container-service/kubernetes">https://azure.microsoft.com/en-us/services/container-service/kubernetes</a>), or IBM Cloud Kubernetes Service (<a class="ulink" href="https://www.ibm.com/cloud/container-service">https://www.ibm.com/cloud/container-service</a>).</p><p>To better understand how a Kubernetes cluster works, let's look at the high-level architecture shown in the following diagram:</p><div><img src="img/B09699_04_01.jpg" alt="Overview of Kubernetes" width="1000" height="649"/><div><p>Kubernetes high-level architecture</p></div></div><p>At the <a id="id193" class="indexterm"/>top of the stack, we have the <code class="literal">kubectl</code> command-line tool <a id="id194" class="indexterm"/>that enables users to manage the Kubernetes cluster by sending commands to the <strong>Kubernetes Master Node</strong>. The <code class="literal">kubectl</code> commands use the following syntax:</p><div><pre class="programlisting">
<strong>kubectl [command] [TYPE] [NAME] [flags]</strong>
</pre></div><p>Where:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">command</code>: This specifies the operation, for example, <code class="literal">create</code>, <code class="literal">get</code>, <code class="literal">describe</code>, and <code class="literal">delete</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TYPE</code>: This specifies the resource type, for example, <code class="literal">pods</code>, <code class="literal">nodes</code>, and <code class="literal">services</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NAME</code>: This specifies the name of the resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">flags</code>: This specifies optional flags specific to the operation</li></ul></div><div><div><h3 class="title"><a id="note59"/>Note</h3><p>For more information on how to use <code class="literal">kubectl,</code> visit the following:</p><p>
<a class="ulink" href="https://kubernetes.io/docs/reference/kubectl/overview">https://kubernetes.io/docs/reference/kubectl/overview</a>
</p></div></div><p>Another <a id="id195" class="indexterm"/>important component present in the worker node is the <strong>kubelet,</strong> which controls the pod's life cyle by reading the pod configuration from the <strong>kube API Server</strong>. It also is responsible for communication with the master node. The kube-proxy <a id="id196" class="indexterm"/>provides load balancing capabilities between all the pods <a id="id197" class="indexterm"/>according to the policy specified in the master node, hence ensuring high-availability of the overall application.</p><p>In the next section, we will discuss the different ways to install and configure the PixieGateway server, including one method that uses a Kubernetes cluster.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Installing and configuring the PixieGateway server</h1></div></div></div><p>Before <a id="id198" class="indexterm"/>we dive into the technical details, it would be a good idea to deploy a PixieGateway server instance to try things out.</p><p>There are <a id="id199" class="indexterm"/>mainly two types of installation you can try: local install and server install.</p><p>
<strong>Local install</strong>: Use this method for testing and development.</p><p>For this part, I strongly recommend using Anaconda virtual environments (<a class="ulink" href="https://conda.io/docs/user-guide/tasks/manage-environments.html">https://conda.io/docs/user-guide/tasks/manage-environments.html</a>) because they provide good isolation between the environments, enabling you to experiment with different versions and configurations of the Python package.</p><p>If you are managing multiple environments, you can get a list of all the available environments by using the following command:</p><div><pre class="programlisting">
<strong>conda env list</strong>
</pre></div><p>First, select the environment of your choice by using the following command from a Terminal:</p><div><pre class="programlisting">
<strong>source activate &lt;&lt;my_env&gt;&gt;</strong>
</pre></div><p>You should see the name of your environment in the Terminal, which is an indication that you've correctly activated it.</p><p>Next, install the <code class="literal">pixiegateway</code> package from PyPi by running the following command:</p><div><pre class="programlisting">
<strong>pip install pixiegateway</strong>
</pre></div><div><div><h3 class="title"><a id="note60"/>Note</h3><p>
<strong>Note</strong>: You can find more information about the <code class="literal">pixiegateway</code> package on PyPi here:</p><p>
<a class="ulink" href="https://pypi.python.org/pypi/pixiegateway">https://pypi.python.org/pypi/pixiegateway</a>
</p></div></div><p>Once all the dependencies have been installed, you're ready to start the server. Assuming that you <a id="id200" class="indexterm"/>want to use the <code class="literal">8899 port</code>, you can start the PixieGateway server using the following command:</p><div><pre class="programlisting">
<strong>jupyter pixiegateway --port=8899</strong>
</pre></div><p>Example <a id="id201" class="indexterm"/>output should look like this:</p><div><pre class="programlisting">
<strong>(dashboard) davids-mbp-8:pixiegateway dtaieb$ jupyter pixiegateway --port=8899</strong>
<strong>Pixiedust database opened successfully</strong>
<strong>Pixiedust version 1.1.10</strong>
<strong>[PixieGatewayApp] Jupyter Kernel Gateway at http://127.0.0.1:8899</strong>
</pre></div><div><div><h3 class="title"><a id="note61"/>Note</h3><p>
<strong>Note</strong>: To stop the PixieGateway server, simply use <em>Ctrl</em> + <em>C</em> from the Terminal.</p></div></div><p>You can now open the PixieGateway admin console at the following URL: <code class="literal">http://localhost:8899/admin</code>.</p><div><div><h3 class="title"><a id="note62"/>Note</h3><p>
<strong>Note</strong>: When challenged, use <code class="literal">admin</code> as the user and blank (no password) as the password. We'll review how to configure security and other properties in the <em>PixieGateway server configuration</em> section later in this chapter.</p></div></div><p>
<strong>Server install using Kubernetes and Docker</strong>: Use this install method if you need to run PixieGateway in a production environment where you want to give access to the deployed PixieApps to multiple users over the web.</p><p>The following instructions will use IBM Cloud Kubernetes Service, but they can easily be adapted to other providers:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an IBM Cloud account if you don't already have one and create a container service instance from the catalog.<div><div><h3 class="title"><a id="note63"/>Note</h3><p>
<strong>Note</strong>: A lite version plan is available for testing at no cost.</p></div></div></li><li class="listitem">Download and install the Kubernetes CLI (<a class="ulink" href="https://kubernetes.io/docs/tasks/tools/install-kubectl">https://kubernetes.io/docs/tasks/tools/install-kubectl</a>) and the IBM Cloud CLI (<a class="ulink" href="https://console.bluemix.net/docs/cli/reference/bluemix_cli/get_started.html#getting-started">https://console.bluemix.net/docs/cli/reference/bluemix_cli/get_started.html#getting-started</a>).<div><div><h3 class="title"><a id="note64"/>Note</h3><p>
<strong>Note</strong>: An additional get started article on Kubernetes containers can be found here:</p><p>
<a class="ulink" href="https://console.bluemix.net/docs/containers/container_index.html#container_index">https://console.bluemix.net/docs/containers/container_index.html#container_index</a>
</p></div></div></li><li class="listitem">Log in <a id="id202" class="indexterm"/>to the IBM Cloud and then target the org and space where your Kubernetes instance resides. Install and initialize the <code class="literal">container-service</code> plugin:<div><pre class="programlisting">
<strong>bx login -a https://api.ng.bluemix.net</strong>
<strong>bx target -o &lt;YOUR_ORG&gt; -s &lt;YOUR_SPACE&gt;&lt;/YOUR_SPACE&gt;</strong>
<strong>bx plugin install container-service -r Bluemix</strong>
<strong>bx cs init</strong>
</pre></div></li><li class="listitem">Check <a id="id203" class="indexterm"/>that your cluster is created and, if not, create one:<div><pre class="programlisting">
<strong>bx cs clusters</strong>
<strong>bx cs cluster-create --name my-cluster</strong>
</pre></div></li><li class="listitem">Download <a id="id204" class="indexterm"/>the cluster configuration that will be used by the <code class="literal">kubectl</code> command, which is executed on your local machine, later on:<div><pre class="programlisting">
<strong>bx cs cluster-config my-cluster</strong>
</pre></div><p>The preceding command will generate a temporary YML file that contains the cluster information and an environment variable export statement that you must run before starting to use the <code class="literal">kubectl</code> command, as in the  example:</p><div><pre class="programlisting">
<strong>   export KUBECONFIG=/Users/dtaieb/.bluemix/plugins/container-</strong>
<strong>   service/clusters/davidcluster/kube-config-hou02-davidcluster.yml</strong>
</pre></div><div><div><h3 class="title"><a id="note66"/>Note</h3><p>
<strong>Note</strong>: YAML is a very popular data serialization format commonly used for system configuration. You can find more information here:</p><p>
<a class="ulink" href="http://www.yaml.org/start.html">http://www.yaml.org/start.html</a>
</p></div></div></li><li class="listitem">You can now use <code class="literal">kubectl</code> to create the deployment and services for your PixieGateway server. For convenience, the PixieGateway GitHub repository already has a generic version of <code class="literal">deployment.yml</code> and <code class="literal">service.yml</code> that you can directly reference. We'll review how to configure these files for Kubernetes in the <em>PixieGateway server configuration</em> section later in this chapter:<div><pre class="programlisting">
<strong>kubectl create -f https://github.com/ibm-watson-data-lab/pixiegateway/raw/master/etc/deployment.yml</strong>
<strong>kubectl create -f https://github.com/ibm-watson-data-lab/pixiegateway/raw/master/etc/service.yml</strong>
</pre></div></li><li class="listitem">It would <a id="id205" class="indexterm"/>be a good idea to verify the state of your clusters using the <code class="literal">kubectl get</code> command:<div><pre class="programlisting">
<strong>kubectl get pods</strong>
<strong>kubectl get nodes</strong>
<strong>kubectl get services</strong>
</pre></div></li><li class="listitem">Finally, you'll <a id="id206" class="indexterm"/>need the public IP address of the server, which you can find by looking at the <code class="literal">Public IP</code> column of the output returned using the following command, in the Terminal:<div><pre class="programlisting">
<strong>bx cs workers my-cluster</strong>
</pre></div></li><li class="listitem">If all goes well, you can now test your deployment by opening the admin console at <code class="literal">http://&lt;server_ip&gt;&gt;:32222/admin</code>. This time, the default credentials for the admin console are <code class="literal">admin</code>/<code class="literal">changeme</code> and we'll show how to change them in the next section.</li></ol></div><p>The <code class="literal">deployment.yml</code> file used in the Kubernetes install instructions is referencing a Docker image <a id="id207" class="indexterm"/>that has the PixieGateway binaries and all its dependencies preinstalled and configured. The PixieGateway Docker image is available at <a class="ulink" href="https://hub.docker.com/r/dtaieb/pixiegateway-python35">https://hub.docker.com/r/dtaieb/pixiegateway-python35</a>.</p><p>When working locally, the recommended method is to follow the steps of the local install described earlier. However, for readers who prefer to work with Docker images, it is possible to try out the PixieGateway Docker image locally without Kubernetes, by directly installing it on your local laptop with a simple Docker command:</p><div><pre class="programlisting">
<strong>docker run -p 9999:8888 dtaieb/pixiegateway-python35</strong>
</pre></div><p>The preceding command assumes that you have already installed Docker and that it is currently running on your local machine. If not, you can download an installer from the following link: <a class="ulink" href="https://docs.docker.com/engine/installation">https://docs.docker.com/engine/installation</a>.</p><p>The Docker image will automatically be pulled if not already present and the container will start, starting <a id="id208" class="indexterm"/>the PixieGateway server at <a id="id209" class="indexterm"/>local port <code class="literal">8888</code>. The <code class="literal">-p</code> switch in the command maps the <code class="literal">8888 port</code> local to the container, to the <code class="literal">9999 port</code> local to the host machine. With the given configuration, you would access the Docker instance of the <a id="id210" class="indexterm"/>PixieGateway server at the following URL: <code class="literal">http://localhost:9999/admin</code>.</p><div><div><h3 class="title"><a id="note67"/>Note</h3><p>You can find more information about the Docker command line here:</p><p>
<a class="ulink" href="https://docs.docker.com/engine/reference/commandline/cli">https://docs.docker.com/engine/reference/commandline/cli</a>
</p></div></div><div><div><h3 class="title"><a id="note68"/>Note</h3><p>
<strong>Note</strong>: Another reason why you would use this method is to provide your own custom Docker image for the PixieGateway server. This can be useful if you have built an extension to PixieGateway and want to provide it to your users as an already configured Docker image. Discussion around how to build a Docker image from a base image is beyond the scope of this book, but you can find detailed information here:</p><p>
<a class="ulink" href="https://docs.docker.com/engine/reference/commandline/image_build">https://docs.docker.com/engine/reference/commandline/image_build</a>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>PixieGateway server configuration</h2></div></div></div><p>Configuring <a id="id211" class="indexterm"/>the PixieGateway server is <a id="id212" class="indexterm"/>very similar to configuring the Jupyter Kernel Gateway. Most options are configured using a Python configuration file; to start things off, you can generate a template configuration file using the following command:</p><div><pre class="programlisting">
<strong>jupyter kernelgateway --generate-config</strong>
</pre></div><p>The <code class="literal">jupyter_kernel_gateway_config.py</code> template file will be generated under the <code class="literal">~/.jupyter</code> directory (<code class="literal">~</code> indicates the user home directory). You can find more information <a id="id213" class="indexterm"/>about the standard Jupyter Kernel Gateway options here: <a class="ulink" href="http://jupyter-kernel-gateway.readthedocs.io/en/latest/config-options.html">http://jupyter-kernel-gateway.readthedocs.io/en/latest/config-options.html</a>.</p><p>Using the <code class="literal">jupyter_kernel_gateway_config.py</code> file is fine when you are working locally and have easy access to the filesystem. When using the Kubernetes install, it is recommended to configure the options as environment variables, which you can set directly in the <code class="literal">deployment.yml</code> file by using the predefined <code class="literal">env</code> category.</p><p>Let's now look at each configuration options for the PixieGateway server. A list is provided here using both the Python and Environment method:</p><div><div><h3 class="title"><a id="note69"/>Note</h3><p>
<strong>Note</strong>: As a reminder, Python method means setting the parameter in the <code class="literal">jupyter_kernel_gateway_config.py</code> Python config file, while the Environment method means setting the parameters in the Kubernetes <code class="literal">deployment.yml</code> file.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Admin console credentials</strong>: Configure <a id="id214" class="indexterm"/>the user ID/password for the admin console:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Python</strong>: <code class="literal">PixieGatewayApp.admin_user_id</code>, <code class="literal">PixieGatewayApp.admin_password</code></li><li class="listitem" style="list-style-type: disc"><strong>Environment</strong>: <code class="literal">ADMIN_USERID</code> and <code class="literal">ADMIN_PASSWORD</code></li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Storage connector</strong>: Configure <a id="id215" class="indexterm"/>a persistent storage for various resources, such as charts, and Notebooks. By default, PixieGateway uses the local filesystem; for example, it will store the published Notebooks under the <code class="literal">~/pixiedust/gateway</code> directory. Using the local filesystem is probably fine for a local test environment, but when using a Kubernetes install, you will need to explicitly use persistent volumes (<a class="ulink" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes</a>), which can be difficult to use. If no persistence strategy is put in place, the persisted files will be deleted when the container is restarted and all your published chart and PixieApps will disappear. PixieGateway provides another option, which is to configure a storage connector that lets you persist the data using the mechanism and backend of your choice.<p>To configure a storage connector for charts, you must specify a fully qualified class name in either one of the following configuration variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Python</strong>: <code class="literal">SingletonChartStorage.chart_storage_class</code></li><li class="listitem" style="list-style-type: disc"><strong>Environment</strong>: <code class="literal">PG_CHART_STORAGE</code></li></ul></div><p>The referenced connector class must inherit from the <code class="literal">ChartStorage</code> abstract class defined in the <code class="literal">pixiegateway.chartsManager</code> package (implementation can be found here: <a class="ulink" href="https://github.com/ibm-watson-data-lab/pixiegateway/blob/master/pixiegateway/chartsManager.py">https://github.com/ibm-watson-data-lab/pixiegateway/blob/master/pixiegateway/chartsManager.py</a>).</p><p>PixieGateway provides an out of the box connector to the Cloudant/CouchDB NoSQL database (<a class="ulink" href="http://couchdb.apache.org">http://couchdb.apache.org</a>). To use this connector, you'll need to set the connector class to <code class="literal">pixiegateway.chartsManager.CloudantChartStorage</code>. You'll also need to specify secondary configuration variables to specify the server and credential information (we show the Python/Environment form):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CloudantConfig.host / PG_CLOUDANT_HOST</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CloudantConfig.port / PG_CLOUDANT_PORT</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CloudantConfig.protocol / PG_CLOUDANT_PROTOCOL</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CloudantConfig.username / PG_CLOUDANT_USERNAME</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CloudantConfig.password / PG_CLOUDANT_PASSWORD</code></li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Remote Kernels</strong>: Specify <a id="id216" class="indexterm"/>the configuration for a remote Jupyter Kernel Gateway.<p>At the moment, this configuration option is only supported in Python mode. The variable name you need to use is <code class="literal">ManagedClientPool.remote_gateway_config</code>. The expected value is a JSON object that contains the server information, which can be specified in two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">protocol</code>, <code class="literal">host</code>, and <code class="literal">port</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">notebook_gateway</code> specifies fully qualified URL to the server</li></ul></div><p>Depending on the kernel configuration, security can also be provided using two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">auth_token</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">user</code> and <code class="literal">password</code></li></ul></div><p>This can be seen in the following example:</p><div><pre class="programlisting">c.ManagedClientPool.remote_gateway_config={
    'protocol': 'http',
    'host': 'localhost',
    'port': 9000,
    'auth_token':'XXXXXXXXXX'
}

c.ManagedClientPool.remote_gateway_config={
    'notebook_gateway': 'https://YYYYY.us-south.bluemix.net:8443/gateway/default/jkg/',
    'user': 'clsadmin',
    'password': 'XXXXXXXXXXX'
}</pre></div><div><div><h3 class="title"><a id="note70"/>Note</h3><p>Notice that, in the preceding example, you need to prefix the variable with <code class="literal">c.</code>. This is a requirement coming from the underlying Jupyter/IPython configuration mechanism.</p></div></div><p>For reference, here are the complete configuration example files using both Python and Kubernetes <a id="id217" class="indexterm"/>Environment variables formats:</p></li><li class="listitem" style="list-style-type: disc">The following are the contents of <code class="literal">jupyter_kernel_gateway_config.py</code>:<div><pre class="programlisting">c.PixieGatewayApp.admin_password = "password"

c.SingletonChartStorage.chart_storage_class = "pixiegateway.chartsManager.CloudantChartStorage"
c.CloudantConfig.host="localhost"
c.CloudantConfig.port=5984
c.CloudantConfig.protocol="http"
c.CloudantConfig.username="admin"
c.CloudantConfig.password="password"

c.ManagedClientPool.remote_gateway_config={
    'protocol': 'http',
    'host': 'localhost',
    'port': 9000,
    'auth_token':'XXXXXXXXXX'
}</pre></div></li><li class="listitem" style="list-style-type: disc">The following are the contents of deployment.yml:<div><pre class="programlisting">apiVersion: extensions/v1beta1
kind: Deployment 
metadata:
  name: pixiegateway-deployment
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: pixiegateway
    spec:
      containers:
        - name: pixiegateway
          image: dtaieb/pixiegateway-python35
          imagePullPolicy: Always
          env:
            - name: ADMIN_USERID
              value: admin
            - name: ADMIN_PASSWORD
              value: changeme
            - name: PG_CHART_STORAGE
              value: pixiegateway.chartsManager.CloudantChartStorage
            - name: PG_CLOUDANT_HOST
              value: XXXXXXXX-bluemix.cloudant.com
            - name: PG_CLOUDANT_PORT
              value: "443"
            - name: PG_CLOUDANT_PROTOCOL
              value: https
            - name: PG_CLOUDANT_USERNAME
              value: YYYYYYYYYYY-bluemix
            - name: PG_CLOUDANT_PASSWORD
              value: ZZZZZZZZZZZZZ</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>PixieGateway architecture</h2></div></div></div><p>Now would <a id="id218" class="indexterm"/>be a good time to look again at the PixieGateway architecture diagram presented in <a class="link" href="ch02.xhtml" title="Chapter 2. Python and Jupyter Notebooks to Power your Data Analysis">Chapter 2</a>, <em>Python and Jupyter Notebooks to Power your Data Analysis</em>. The server is implemented as a custom extension (called Personality) to the Jupyter Kernel Gateway (<a class="ulink" href="https://github.com/jupyter/kernel_gateway">https://github.com/jupyter/kernel_gateway</a>).</p><p>In turn, the PixieGateway server provides extension points to customize some behavior that we'll discuss later in this chapter.</p><p>The high-level architecture diagram for the PixieGateway server is shown here:</p><div><img src="img/B09699_04_02.jpg" alt="PixieGateway architecture" width="1000" height="580"/><div><p>PixieGateway architecture diagram</p></div></div><p>As the diagram indicates, PixieGateway provides a REST interface for three types of clients:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Jupyter Notebook Server</strong>: This <a id="id219" class="indexterm"/>calls a dedicated set of REST APIs for sharing charts and publishing PixieApps as web applications</li><li class="listitem" style="list-style-type: disc"><strong>Browser client running a PixieApp</strong>: A special REST API manages the execution <a id="id220" class="indexterm"/>of Python code in the associated kernel</li><li class="listitem" style="list-style-type: disc"><strong>Browser client running the admin console</strong>: A dedicated set of REST APIs for managing <a id="id221" class="indexterm"/>various server resources and stats, for example, PixieApps and kernel instances</li></ul></div><p>On the backend, the PixieGateway server manages the life cycle of one or more Jupyter Kernel instances responsible for running the PixieApps. At runtime, each PixieApp is deployed on a kernel instance using a specific set of steps. The following diagram shows a typical <a id="id222" class="indexterm"/>topology of all the PixieApp user instances running on the server:</p><div><img src="img/B09699_04_03.jpg" alt="PixieGateway architecture" width="1000" height="581"/><div><p>The topology of running PixieApp instances</p></div></div><p>When a <a id="id223" class="indexterm"/>PixieApp is deployed on the server, the code contained in every cell of the Jupyter Notebook is analyzed and broken into two parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Warmup code</strong>: This is all the <a id="id224" class="indexterm"/>code defined in all the cells above the main PixieApp definition. This code is run only once, when the PixieApp application is first started on the kernel, and will not run again until the kernel is restarted, or until it is called explicitly from the run code. This is important because it will help you better optimize performances; for example, you should always put in the warmup section, code that loads a large amount of data that doesn't change much or that may require a long time to initialize.</li><li class="listitem" style="list-style-type: disc"><strong>Run code</strong>: This is code <a id="id225" class="indexterm"/>that will be run in its own instance for every user session. The run code is typically extracted from the cell that contains the PixieApp class declaration. The publisher automatically discovers this cell by doing a static analysis of the Python code and specifically looking for the following two criteria, which must both be met:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The cell contains a class that has the <code class="literal">@PixieApp</code> annotation</li><li class="listitem" style="list-style-type: disc">The cell instantiates the class and call its <code class="literal">run()</code> method<div><pre class="programlisting">@PixieApp
class MyApp():
    @route()
    def main_screen(self):
    return "&lt;div&gt;Hello World&lt;/div&gt;"

app = MyApp()
app.run()</pre></div></li></ul></div><p>For example, the following code must be in its own cell to qualify as the run code:</p><p>As we've seen in <a class="link" href="ch03.xhtml" title="Chapter 3. Accelerate your Data Analysis with Python Libraries">Chapter 3</a>, <em>Accelerate your Data Analysis with Python Libraries</em>, it is possible to declare multiple PixieApps in the same notebook that will be used as child PixieApp or as base classes to the main PixieApp. In this case, we need to make sure that they are defined in their own cell and that you don't try to instantiate them and call their <code class="literal">run()</code> method.</p><p>The rule is that there can be only one main PixieApp class for which the <code class="literal">run()</code> method will be called and the cell that contains this code is considered the run code by the PixieGateway.</p><div><div><h3 class="title"><a id="note71"/>Note</h3><p>
<strong>Note</strong>: Cells that are not marked as Code, such as Markdown, Raw NBConvert, or Heading are ignored during the static analysis done by the PixieGateway server. Therefore, it is safe to keep them in your Notebook.</p></div></div></li></ul></div><p>For each client session, PixieGateway will instantiate an instance of the main PixieApp class using the run code (represented as colored hexagons in the preceding diagram). Depending <a id="id226" class="indexterm"/>on current load, PixieGateway will decide how many PixieApps should run in a particular kernel instance and, if needed, automatically spawn a new kernel to serve the extra users. For example, if five users are using the same PixieApp, three instances may be running in a particular kernel instance and the two others will be run in another kernel instance. PixieGateway is constantly monitoring the usage patterns to optimize workload distribution by load balancing the instances of PixieApps between multiple kernels.</p><p>To help understand how the Notebook code is broken down, the following diagram reflects how the warmup and run code are extracted from the Notebook and transformed to make sure that multiple instances coexist peacefully within the same kernel:</p><div><div><h3 class="title"><a id="note72"/>Note</h3><p>As a reminder, the cell that contains the main PixieApp must also have code that instantiates it and calls the <code class="literal">run()</code> method.</p></div></div><div><img src="img/B09699_04_04.jpg" alt="PixieGateway architecture" width="1000" height="524"/><div><p>PixieApp life cycle: Warmup and Run Code</p></div></div><p>Because a given kernel instance can host more than one Notebook with its main PixieApp, we need to make sure that there is no accidental name collision when the warmup <a id="id227" class="indexterm"/>code for two main PixieApps is executed. For example, the <code class="literal">title</code> variable may be used in both PixieApps and, if left alone, the value for the second one would override the value for the first one. To avoid this conflict, all the variable names in the warmup code are made unique by injecting a namespace.</p><p>The <code class="literal">title = 'some string'</code> statement becomes <code class="literal">ns1_title = 'some string'</code> after publication. The PixieGateway publisher will also update all references to <code class="literal">title</code> throughout the code to reflect the new name. All of this renaming is automatically done at runtime and there are no specific things that need to be done by the developer.</p><p>We will show real code examples later on when we cover the <em>PixieApp details</em> page of the admin console.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>If you have packaged the code for your main PixieApp as a Python module that is imported in the Notebook, you still need to declare the code for a wrapper PixieApp that inherits from it. This is because the PixieGateway does a static code analysis, looking for the <code class="literal">@PixieApp</code> notation, and if not found, the main PixieApp will not be properly recognized.</p><p>For example, let's assume that you have a PixieApp named <code class="literal">AwesomePixieApp</code> imported from the <code class="literal">awesome package</code>. In this case, you would put the following code in its own cell:</p><div><pre class="programlisting">from awesome import AwesomePixieApp
@PixieApp
class WrapperAwesome(AwesomePixieApp):
    pass
app = WrapperAwesome()
app.run()</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Publishing an application</h2></div></div></div><p>In this <a id="id228" class="indexterm"/>section, we'll publish the <em>GitHub Tracking</em> application that we created in <a class="link" href="ch03.xhtml" title="Chapter 3. Accelerate your Data Analysis with Python Libraries">Chapter 3</a>, <em>Accelerate your Data Analysis with Python Libraries,</em> into a PixieGateway instance.</p><div><div><h3 class="title"><a id="note73"/>Note</h3><p>You can use the completed notebook from this GitHub location:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb</a>
</p></div></div><p>From the Notebook, run the application as usual and use the publish button located on the top-left of the cell output, to start the process:</p><div><img src="img/B09699_04_05.jpg" alt="Publishing an application" width="1000" height="432"/><div><p>Invoke the publish dialog</p></div></div><p>The publish <a id="id229" class="indexterm"/>dialog has multiple tab menus:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Options</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>PixieGateway Server</strong>: For example, <code class="literal">http://localhost:8899</code></li><li class="listitem" style="list-style-type: disc"><strong>Page Title</strong>: A short description that will be used as the page title when displayed in the browser</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Security</strong>: Configure the PixieApp security when accessed through the web:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>No security</strong></li><li class="listitem" style="list-style-type: disc"><strong>Token</strong>: A security token must be added as a query parameter to the URL, for example, <code class="literal">http://localhost:8899/GitHubTracking?token=941b3990d5c0464586d67e48705b9deb</code>.</li></ul></div><div><div><h3 class="title"><a id="note74"/>Note</h3><p>
<strong>Note</strong>: At this time, PixieGateway doesn't provide any authentication/authorization mechanism. Third party authorization, such as OAuth 2.0 (<a class="ulink" href="https://oauth.net/2">https://oauth.net/2</a>), JWT (<a class="ulink" href="https://jwt.io">https://jwt.io</a>), and others will be added in the future.</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Imports</strong>: Display the list of Python package dependencies automatically detected by the PixieDust publisher. These imported packages will be automatically installed, if not already present, on the kernel where the application is running. When detecting a particular dependency, PixieDust looks at the current system to get the version and install location, for example, PyPi or a custom install URL such as a GitHub repo, for example.</li><li class="listitem" style="list-style-type: disc"><strong>Kernel Spec</strong>: This is where you can choose a kernel spec for your PixieApp. By default, PixieDust selects the default kernel available on the PixieGateway server but if, for example, your Notebook relies on Apache Spark, you should be able to pick a kernel that supports it. This option can also be changed after the PixieApp has been deployed using the admin console.</li></ul></div><p>Here's a sample screenshot of the PixieApp publish dialog:</p><div><img src="img/B09699_04_06.jpg" alt="Publishing an application" width="1000" height="478"/><div><p>PixieApp publish dialog</p></div></div><p>Clicking the <strong>Publish</strong> button will start the publishing process. Upon completion (which depending <a id="id230" class="indexterm"/>on the size of the Notebook is pretty fast), you'll see the following screen:</p><div><img src="img/B09699_04_07.jpg" alt="Publishing an application" width="1000" height="358"/><div><p>Successful publish screen</p></div></div><p>You can then test the application by clicking on the provided link, which you can copy and share with users on your team. The following screenshot shows the three main screens of the <em>GitHub Tracking</em> application running as a web application on the PixieGateway:</p><div><img src="img/B09699_04_08.jpg" alt="Publishing an application" width="1000" height="605"/><div><p>PixieApp running as a web application</p></div></div><p>Now that <a id="id231" class="indexterm"/>you know how to publish a PixieApp, let's review a few developer best practices and rules that will help you optimize PixieApps that are intended to be published as web applications:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A PixieApp instance is created for each user session, therefore to improve performances, make sure that it doesn't include code that is long-running or that loads a large amount of static data (data that doesn't change often). Instead, place it in the warmup code section and reference it from the PixieApp as needed.</li><li class="listitem" style="list-style-type: disc">Don't forget to add the code that runs the PixieApp in the same cell. If not, you'll end up with a blank page when running it on the web. As a good practice, it is recommended to assign the PixieApp instance into its own variable. For example, do this:<div><pre class="programlisting">app = GitHubTracking()
app.run()</pre></div><p>That's instead of the following</p><div><pre class="programlisting">GitHubTracking().run()</pre></div></li><li class="listitem" style="list-style-type: disc">You can <a id="id232" class="indexterm"/>have multiple PixieApp classes declared in the same Notebook, which is needed if you are using child PixieApp or PixieApp inheritance. However, only one of them can be the main PixieApp, which the PixieGateway will run. It is the one that has the extra code that instantiates and runs the PixieApp.</li><li class="listitem" style="list-style-type: disc">It's a good idea to add a Docstring (<a class="ulink" href="https://www.python.org/dev/peps/pep-0257">https://www.python.org/dev/peps/pep-0257</a>) to your PixieApp class that gives a short description of the application. As we'll see in the <em>PixieGateway admin Console</em> section, later in this chapter, this docstring will be displayed in the PixieGateway admin console, as in the following example:<div><pre class="programlisting">@PixieApp
class GitHubTracking(RepoAnalysis):
    """
    GitHub Tracking Sample Application
    """
    @route()
    def main_screen(self):
        return """
    ...</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Encoding state in the PixieApp URL</h2></div></div></div><p>In some <a id="id233" class="indexterm"/>cases, you may want to capture the state of a PixieApp in the URL as query parameters so that it can be bookmarked and/or shared with other people. The idea is that, when using query parameters, the PixieApp doesn't start from the main screen but rather automatically activates the route corresponding to the parameters. For example, in the <em>GitHub Tracking</em> application, you could use <code class="literal">http://localhost:8899/pixieapp/GitHubTracking?query=pixiedust</code> to bypass the initial screen and jump directly to the table showing the list of repositories that match the given query.</p><p>You can have the query parameters automatically added to the URL when the route is activated by adding the <code class="literal">persist_args</code> special argument to the route.</p><p>It would look like this for the <code class="literal">do_search()</code> route:</p><div><pre class="programlisting">@route(query="*", <strong>persist_args='true'</strong>)
@templateArgs
def do_search(self, query):
    self.first_url = "https://api.github.com/search/repositories?q={}".format(query)
    self.prev_url = None
    self.next_url = None
    self.last_url = None
    ...</pre></div><div><div><h3 class="title"><a id="note75"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%204/sampleCode1.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%204/sampleCode1.py</a>
</p></div></div><p>The <code class="literal">persist_args</code> keyword argument does not affect how the route is activated. It is only there <a id="id234" class="indexterm"/>to automatically add the proper query arguments to the URL when activated. You can try to make this simple change in the Notebook, republish the PixieApp to the PixieGateway server, and try it out. As soon as you hit the submit button on the first screen, you'll notice that the URL is automatically updated to include the query argument.</p><div><div><h3 class="title"><a id="note76"/>Note</h3><p>
<strong>Note</strong>: The <code class="literal">persist_args</code> argument also works when running in the Notebook although the implementation is different since we don't have a URL. Instead, the parameters are added to the cell metadata using the <code class="literal">pixieapp</code> key, as shown in the following screenshot:</p></div></div><div><img src="img/B09699_04_09.jpg" alt="Encoding state in the PixieApp URL" width="1000" height="521"/><div><p>Cell metadata showing the PixieApp parameters</p></div></div><p>If you are using the <code class="literal">persist_args</code> feature, you may find that, while doing iterative development, it becomes cumbersome to always go to the cell metadata to remove the parameters. As a shortcut, the PixieApp framework adds a home button in the top-right toolbar to reset the arguments with a single click.</p><p>As an <a id="id235" class="indexterm"/>alternative, you could also avoid saving the route arguments in the cell metadata altogether when running in the Notebook (but still save them while running on the web). To do that, you would need to use <code class="literal">web</code> as the value for the <code class="literal">persist_args</code> argument instead of <code class="literal">true</code>:</p><div><pre class="programlisting">@route(query="*", <strong>persist_args='web'</strong>)
…</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Sharing charts by publishing them as web pages</h2></div></div></div><p>In this <a id="id236" class="indexterm"/>section, we show how to easily share a chart created by the <code class="literal">display()</code> API and publish it as a web page.</p><p>Using the example from <a class="link" href="ch02.xhtml" title="Chapter 2. Python and Jupyter Notebooks to Power your Data Analysis">Chapter 2</a>, <em>Python and Jupyter Notebooks to Power your Data Analysis,</em> let's load the cars performance dataset and create a chart using <code class="literal">display()</code>:</p><div><pre class="programlisting">import pixiedust
cars = pixiedust.sampleData(1, forcePandas=True) #car performance data
display(cars)</pre></div><div><div><h3 class="title"><a id="note77"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%204/sampleCode2.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%204/sampleCode2.py</a>
</p></div></div><p>In the PixieDust output interface, select the <strong>Bar Chart</strong> menu, then in the options dialog, select <code class="literal">horsepower</code> for the <strong>Keys</strong> and <code class="literal">mpg</code> for the <strong>Values,</strong> as shown in the following screenshot:</p><div><img src="img/B09699_04_10.jpg" alt="Sharing charts by publishing them as web pages" width="879" height="824"/><div><p>PixieDust Chart options</p></div></div><p>We then <a id="id237" class="indexterm"/>use the <strong>Share</strong> button to invoke the chart sharing dialog as shown in the following screenshot, which uses Bokeh as the renderer:</p><div><div><h3 class="title"><a id="note78"/>Note</h3><p>
<strong>Note</strong>: Chart sharing works with any renderer, and I encourage you to try it with other renderers such as Matplotlib and Mapbox.</p></div></div><div><img src="img/B09699_04_11.jpg" alt="Sharing charts by publishing them as web pages" width="1000" height="508"/><div><p>Invoke the Share Chart dialog</p></div></div><p>In the <strong>Share Chart</strong> dialog, you can specify the PixieGateway server and an optional description <a id="id238" class="indexterm"/>for the chart:</p><div><div><h3 class="title"><a id="note79"/>Note</h3><p>Note that as a convenience, PixieDust will automatically remember the last one used.</p></div></div><div><img src="img/B09699_04_12.jpg" alt="Sharing charts by publishing them as web pages" width="1000" height="529"/><div><p>Share Chart dialog</p></div></div><p>Clicking <a id="id239" class="indexterm"/>on the <strong>Share</strong> button will start the publishing process that takes the chart content to the PixieGateway and then returns a unique URL to the web page. Similar to the PixieApp, you can then share this URL with the team:</p><div><img src="img/B09699_04_13.jpg" alt="Sharing charts by publishing them as web pages" width="1000" height="458"/><div><p>Chart sharing confirmation dialog</p></div></div><p>The confirmation dialog contains the unique URL for the chart and an HTML fragment that lets you embed the chart in your own web page, such as a blog post, and a dashboard.</p><p>Clicking <a id="id240" class="indexterm"/>on the link will show the following PixieGateway page:</p><div><img src="img/B09699_04_14.jpg" alt="Sharing charts by publishing them as web pages" width="1000" height="567"/><div><p>Chart page</p></div></div><p>The preceding page shows metadata about the chart, for example, <strong>Author</strong>, <strong>Description</strong>, and <strong>Date,</strong> as well as the embedded HTML fragment. Notice that if the chart has interactivity (as is the case for Bokeh, Brunel, or Mapbox), then it is preserved in the PixieGateway page.</p><p>For example, in the preceding screenshot, the user can still wheel zoom, box zoom, and pan to explore the chart or download the chart as a PNG file.</p><p>Embedding the chart in your own page is also very easy. Simply copy the embedded HTML fragment anywhere in your HTML, as shown in the following example:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Example page with embedded chart&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt; Embedded a PixieDust Chart in a custom HTML Page&lt;/h1&gt;
        &lt;div&gt;
            &lt;object type="text/html" width="600" height="400"
                data="http://localhost:8899/embed/04089782-7543-42a6-8dd1-e4d1cb06596a/600/400"&gt; 
                &lt;a href="http://localhost:8899/embed/04089782-7543-42a6-8dd1-e4d1cb06596a"&gt;View Chart&lt;/a&gt;
            &lt;/object&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><div><div><h3 class="title"><a id="note80"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%204/sampleCode3.html">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%204/sampleCode3.html</a>
</p></div></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Embedded chart objects must use the same level of security or higher as the browser. If not, the browser will throw a Mixed Content error. For example, if the host page is loaded over HTTPS, then the embedded chart must also be loaded over HTTPS, which means that you'll need to enable HTTPS in the PixieGateway server. You can also visit <a class="ulink" href="http://jupyter-kernel-gateway.readthedocs.io/en/latest/config-options.html">http://jupyter-kernel-gateway.readthedocs.io/en/latest/config-options.html</a> to configure <a id="id241" class="indexterm"/>an SSL/TLS certificate for the PixieGateway server. Another solution that is easier to maintain would be to configure an Ingress service for the Kubernetes cluster that provides TLS termination.</p><p>For convenience, we provide a template ingress YAML file for the PixieGateway service here: <a class="ulink" href="https://github.com/ibm-watson-data-lab/pixiegateway/blob/master/etc/ingress.yml">https://github.com/ibm-watson-data-lab/pixiegateway/blob/master/etc/ingress.yml</a>. You will need to update this file with the TLS host and the secret provided by your provider. For example, if you are using the IBM Cloud Kubernetes Service, you just have to enter the cluster name in the <code class="literal">&lt;your cluster name&gt;</code> placeholder. You can find more information on how to redirect HTTP to HTTPS here: <a class="ulink" href="https://console.bluemix.net/docs/containers/cs_annotations.html#redirect-to-https">https://console.bluemix.net/docs/containers/cs_annotations.html#redirect-to-https</a>. Ingress services are a great way to improve security, reliability, and protect against DDOS attacks. For example, you can set various limits, such as the number of requests/connections per seconds allowed for each unique IP address or maximum bandwidth allowed. For more information please see <a class="ulink" href="https://kubernetes.io/docs/concepts/services-networking/ingress">https://kubernetes.io/docs/concepts/services-networking/ingress</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>PixieGateway admin console</h2></div></div></div><p>The admin <a id="id242" class="indexterm"/>console is a great tool to manage your resources and troubleshoot them. You can access it using the <code class="literal">/admin</code> URL. Notice that you will need to authenticate with the user/password that you configured (see the <em>PixieGateway server configuration</em> section for instructions on how to configure the user/password in this chapter; by default the user is <code class="literal">admin</code> and the password is &lt;blank&gt;).</p><p>The user interface for the admin console is composed of multiple menus focused on a specific task. Let's look at them one by one:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>PixieApps</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Information about all the deployed PixieApps: URL, description, and so on</li><li class="listitem" style="list-style-type: disc">Security management</li><li class="listitem" style="list-style-type: disc">Actions, for example, delete, and download</li></ul></div><div><img src="img/B09699_04_15.jpg" alt="PixieGateway admin console" width="1000" height="476"/><div><p>Admin console PixieApp management page</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Charts</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Information about all the published charts: link, preview, and so on</li><li class="listitem" style="list-style-type: disc">Actions, for <a id="id243" class="indexterm"/>example, delete, download, and embed fragment</li></ul></div><div><img src="img/B09699_04_16.jpg" alt="PixieGateway admin console" width="1000" height="365"/><div><p>Admin console chart management page</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Kernel Stats</strong>:<p>The following screenshot shows the <strong>Kernel Stats</strong> screen:</p><div><img src="img/B09699_04_17.jpg" alt="PixieGateway admin console" width="1000" height="251"/><div><p>Admin console Kernel Stats page</p></div></div><p>This screen shows a live table of all the kernels currently running in the PixieGateway. Each row contains the following information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Kernel Name</strong>: This is the name of the kernel with a drill-down link, which shows the <strong>Kernel Spec</strong>, <strong>Log</strong>, and <strong>Python Console</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Status</strong>: This shows the status as <code class="literal">idle</code> or <code class="literal">busy</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Busy Ratio</strong>: This is a value between 0 and 100% that denotes the kernel utilization since it was started.</li><li class="listitem" style="list-style-type: disc"><strong>Running Apps</strong>: This is a list of running PixieApps. Each PixieApp is a drill-down link that displays the warmup code and runs code for the PixieApp. This is very useful for troubleshooting errors since you can see what code is being run by the PixieGateway.</li><li class="listitem" style="list-style-type: disc"><strong>Users Count</strong>: This is the number of users with open sessions in this kernel.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Server Logs</strong>:<p>Full access <a id="id244" class="indexterm"/>the tornado server log for troubleshooting</p><div><img src="img/B09699_04_18.jpg" alt="PixieGateway admin console" width="1000" height="439"/><div><p>Admin console server logs page</p></div></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Python Console</h2></div></div></div><p>The Python <a id="id245" class="indexterm"/>Console is invoked by clicking on the kernel link in the <strong>Kernel Stats</strong> screen. The admin can use it to execute any code against the kernel, which can be useful to troubleshoot issues.</p><p>For example, the following screenshot shows how to invoke the PixieDust log:</p><div><img src="img/B09699_04_19.jpg" alt="Python Console" width="1000" height="577"/><div><p>Display PixieDust log from the PixieGateway admin Python Console</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Displaying warmup and run code for a PixieApp</h2></div></div></div><p>When an <a id="id246" class="indexterm"/>execution error happens while loading a page, the PixieGateway will show the full Python traceback in the browser. However, the error may be hard to find because its root cause may be in the warmup code that is executed once when the PixieApp starts. One important debugging technique is to look at the warmup and run code executed by the PixieGateway to spot any anomalies.</p><p>If the error is still not obvious, you could, for example, copy the warmup and run code in a temporary Notebook and try to run it from there, with the hope that you can reproduce the error and spot the issue.</p><p>You can access the warmup and run code by clicking on the PixieApp link on the <strong>Kernel Stats</strong> screen, which will take you to the following screen:</p><div><img src="img/B09699_04_20.jpg" alt="Displaying warmup and run code for a PixieApp" width="1000" height="441"/><div><p>Display the warmup and run code</p></div></div><p>Note that <a id="id247" class="indexterm"/>the warmup and run code do not contain the original code formatting and therefore can be harder to read. You can mitigate this issue by copying it and pasting the code into a temporary Notebook and reformatting it again.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Summary</h1></div></div></div><p>After reading this chapter, you should be able to install, configure, and manage a PixieGateway microservice server, publish charts as a web page, and deploy a PixieApp from a Notebook to a web application. Whether you are a data scientist working on analytics in a Jupyter Notebook or a developer writing and deploying applications targeted at the line of a business user, we've shown, in this chapter, how PixieDust can help accomplish your tasks more efficiently and reduce the time it takes to operationalize your analytics.</p><p>In the next chapter, we'll look at advanced topics and best practices related to PixieDust and the PixieApp programming model, which will be useful when we go over the industry use cases and sample data pipelines in the remaining chapters.</p></div></div>



  </body></html>