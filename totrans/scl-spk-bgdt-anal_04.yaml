- en: Collection APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"That we become depends on what we read after all of the professors have finished
    with us. The greatest university of all is a collection of books."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Thomas Carlyle'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the features that attract most Scala users in its Collection APIs that
    are very powerful, flexible, and has lots of operations coupled with it. The wide
    range of operations will make your life easy dealing with any kind of data. We
    are going to introduce Scala collections APIs including their different types
    and hierarchies in order to accommodate different types of data and solve a wide
    range of different problems. In a nutshell, the following topics will be covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Scala collection APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types and hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Scala implicits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala collection APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Scala collections are a well-understood and frequently used programming
    abstraction that can be distinguished between mutable and immutable collections.
    Like a mutable variable, a *mutable* collection can be changed, updated, or extended
    when necessary. However, like an immutable variable, i*mmutable* collections cannot
    be changed. Most collection classes to utilize them are located in the packages
    `scala.collection`, `scala.collection.immutable`, and `scala.collection.mutable`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This extremely powerful feature of Scala provides you with the following facility
    to use and manipulate your data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to use**: For example, it helps you eliminate the interference between
    iterators and collection updates. As a result, a small vocabulary consisting of
    20-50 methods should be enough to solve most of your collection problem in your
    data analytics solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concise**: You can use functional operations with a light-weight syntax and
    combine operations and, at the end, you will feel like that you''re using custom
    algebra.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe**: Helps you deal with most errors while coding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast**: most collection objects are carefully tuned and optimized; this enables
    you data computation in a faster way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal**: Collections enable you to use and perform the same operations
    on any type, anywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will explore the types and associated hierarchies of
    Scala collection APIs. We will see several examples of using most features in
    the collection APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Types and hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala collections are a well-understood and frequently-used programming abstraction
    that can be distinguished between mutable and immutable collections. Like a mutable
    variable, a mutable collection can be changed, updated, or extended when necessary.
    Like an immutable variable, immutable collections; cannot be changed. Most collection
    classes that utilize them are located in the packages `scala.collection`, `scala.collection.immutable`,
    and `scala.collection.mutable`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The following hierarchical diagram (*Figure 1*) shows the Scala collections
    API hierarchy according to the official documentation of Scala. These all are
    either high-level abstract classes or traits. These have mutable as well as immutable
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)**Figure 1:** Collections under package scala.collection'
  prefs: []
  type: TYPE_NORMAL
- en: Traversable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Traversable** is the root of the collections'' hierarchy. In Traversable,
    there are definitions for a wide range of operations that the Scala Collections
    API offers. There is only one abstract method in Traversable, which is the `foreach`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method is essential to all the operations contained in Traversable. If
    you have studied data structures, you will be familiar with traversing a data
    structure's elements and executing a function on each element. The `foreach` method
    does exactly so that, it traverses the elements in the collection and executes
    a function `f` on each element. As we mentioned, this is an abstract method and
    it was designed to have different definitions according to the underlying collection
    that will make use of it, to ensure highly optimized code for each collection.
  prefs: []
  type: TYPE_NORMAL
- en: Iterable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Iterable** is the second root in the hierarchy diagram of the Scala collections
    API. It has an abstract method called iterator that must be implemented/defined
    in all other subcollections. It also implements the `foreach` method from the
    root, which is Traversable. But as we mentioned, all the descendent subcollections
    will override this implementation to make specific optimizations related to this
    subcollection.'
  prefs: []
  type: TYPE_NORMAL
- en: Seq, LinearSeq, and IndexedSeq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sequence has some differences from the usual Iterable, and it has a defined
    length and order. Seq has two sub-traits such as `LinearSeq` and `IndexedSeq`.
    Let's have a quick overview on them.
  prefs: []
  type: TYPE_NORMAL
- en: '`LinearSeq` is a base trait for linear sequences. Linear sequences have reasonably
    efficient head, tail, and `isEmpty` methods. If these methods provide the fastest
    way to traverse the collection, a collection `Coll` that extends this trait should
    also extend `LinearSeqOptimized[A, Coll[A]]`. `LinearSeq` has three concrete methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**isEmpty:** This checks if the list is empty or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**head**: This returns the first element in the list/sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tail**: This returns all the elements of the list but the first one. Each
    of the subcollections that inherit the `LinearSeq` will have its own implementation
    of these methods to ensure good performance. Two collections that inherit/extend
    are streams and lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on this topic, refer to this URL at [http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html.](http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `IndexedSeq` has two methods that it''s defined in terms of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apply**: This finds elements by index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**length**: This returns the length of the sequence. Finding an element by
    its index requires well performing implementation by the subcollections. Two of
    these indexed sequences are `Vector` and `ArrayBuffer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable and immutable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, you will find mutable and immutable collections. A collection can
    have a mutable implementation and an immutable implementation. That''s the reason
    why, in Java, a `List` can''t be both a `LinkedList` and an `ArrayList`, but `List`
    has a `LinkedList` implementation and an `ArrayList` implementation. The following
    figure shows all collections in the package `scala.collection.immutable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)**Figure 2:** All collections in package scala.collection.immutable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala imports the immutable collections by default, and if you need to use
    a mutable one, then you need to import it yourself. Now to get a brief overview
    of all collections in package `scala.collection.mutable`, refer to the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)**Figure 3:** All collections in package Scala.collection.mutable'
  prefs: []
  type: TYPE_NORMAL
- en: In every OOP and functional programming language, an array is an important collection
    package that helps us to store data objects so that, later on, we can access them
    very easily as well. In the next subsection, we will see a detailed discussion
    on arrays with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array is a mutable collection. In arrays, the order of the elements will
    be preserved and duplicated elements will be kept. Being mutable, you can change
    the value of any element of the array by accessing it by its index number. Let''s
    demonstrate arrays with several examples. Use the following line of code to just
    declare a simple array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, print all the elements of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, print a particular element: for example, element 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s sum all the elements and print the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding the smallest element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding the largest element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of creating and defining an array is using the `range ()` method
    that goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code means that I have created an array with elements
    between 5 and 20 with the range difference 2\. If you don''t specify the 3^(rd)
    parameter, Scala will assume the range difference is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how to access the elements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s even possible to concatenate two arrays using the `concat()` method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for using the `range()` and the `concat()` method, you will need
    to import the Scala `Array` package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, it''s even possible to define and use a multi-dimensional array as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, first create a matrix using the preceding array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the earlier matrix as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete source code of the previous example can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, lists preserve order, keep duplicated elements, and also check their
    immutability. Now, let's see some examples of using lists in Scala in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, Scala provides mutable and immutable collections. The
    Immutable collections are imported by default, but if you need to use a mutable
    one you need to import yourself. A list is an immutable collections, and it can
    be used if you want order between the elements to be preserved and duplicates
    to be kept. Let''s demonstrate an example and see how lists preserve order and
    keep duplicated elements, and also check its immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define lists using two different building blocks. `Nil` represents
    the tail of the `List` and, afterwards, an empty `List`. So, the preceding example
    can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check lists with its method in the following detailed example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see another quick overview of how to use sets in your Scala application
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A set is one of the most widely used collections. In sets order will not be
    preserved and sets don''t allow duplicate elements. You can think of it as the
    mathematical notation of sets. Let''s demonstrate this by an example, and we will
    see how sets don''t preserve ordering and don''t allow duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following source code shows the different uses of sets in a Scala program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From my personal experience while developing Spark applications using Java or
    Scala, I found very frequent uses of tuples, especially for grouping collections
    of elements without using any explicit classes. In the next subsection, we will
    see how to get started with Tuples in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala tuples are used to combine a fixed number of items together. The ultimate
    target of this grouping is to help in the anonymous function and so that they
    can be passed around as a whole. The real difference with an array or list is
    that a tuple can hold objects of different types while maintaining the information
    of the type of each element, while a collection doesn't and uses, as the type,
    the common type (for instance, in the previous example, the type of that set would
    be `Set[Any]`).
  prefs: []
  type: TYPE_NORMAL
- en: From the computational point of view, Scala tuples are also immutable. In other
    words, Tuples do use a classes to store elements (for example, `Tuple2`, `Tuple3`,
    `Tuple22`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a tuple holding an integer, a string, and the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is syntactic sugar (shortcut) for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no named accessors for you to access the tuple data but instead you
    need to use accessors that are based on the position and are 1-based not 0-based.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, tuples can fit perfectly in pattern matching. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even use the special operator `->` in order to write a compact syntax
    for 2-values tuples. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a more detailed example to demonstrate tuple functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's delve into the world of using maps in Scala, these are widely used
    to hold basic datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A map is an `Iterable` consisting of pairs of keys and values (also named mappings
    or associations). A map is also one of the most widely used connections as it
    can be used to hold basic datatypes. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Scala's `Predef` object offers an implicit conversion that lets you write `key
    -> value` as an alternate syntax for the `pair (key, value)`. For instance, `Map("a"
    -> 10, "b" -> 15, "c" -> 16)` means exactly the same as `Map(("a", 10), ("b",
    15), ("c", 16))`, but reads better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, a `Map` can be simply considered a collection of `Tuple2s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line will be understood as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we can state that using `Map` a function can be stored, and
    this is the whole point of functions in a Functional Programming language: they
    are first-class citizens and can be used anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a method for finding the max element in an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s map it such that using the `Map` the method can be stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s another of using maps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a detailed example to demonstrate `Map` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a quick overview of using option in Scala; this is basically
    a data container that can hold data.
  prefs: []
  type: TYPE_NORMAL
- en: Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Option` type is used frequently in Scala programs, and you can compare
    this with the null value available in Java, which indicates no value. Scala `Option
    [T]` is a container for zero or one element for a given type. An `Option [T]`
    can be either a `Some [T]` or `None` object, which represents a missing value.
    For instance, the get method of Scala's `Map` produces `Some` (value) if a value
    corresponding to a given key has been found, or `None` if the given key is not
    defined in the `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic trait for an `Option` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, in the following code, we are trying to map and show some meagacities
    that are located in some countries such as `India`, `Bangladesh`, `Japan`, and
    `USA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make the preceding code work, we need to have the `show()` method defined
    somewhere. Here, we can do it by Scala pattern matching using `Option` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining these as follows should print the accurate and desired result that
    we are expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `getOrElse()` method, it is possible to access a value or a default
    when no value is present. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, using the `isEmpty()` method, you can check if the option is `None`
    or not. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here''s the complete program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at other examples on when to use `Option`. For example,
    the `Map.get()` method uses `Option` in order to tell the user if the element
    that he tries to access exists or not. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will see how to use exists, which is used to check if a predicate holds
    for a subset of a set of elements in the Traversal collection.
  prefs: []
  type: TYPE_NORMAL
- en: Exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exists checks if a predicate holds for at least one element in the Traversable
    collection. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**Using the fat arrow:** `=>` is called the *right arrow*, *fat arrow,* or
    *rocket* and is used for passing parameters by name. That means the expression
    will be evaluated when a parameter is accessed. It is actually syntactic sugar
    for a zero parameter function `call: x: () => Boolean`. Let''s see an example
    using this operator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package com.chapter4.CollectionAPI`'
  prefs: []
  type: TYPE_NORMAL
- en: '`object UsingFatArrow {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def fliesPerSecond(callback: () => Unit) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`while (true) { callback(); Thread sleep 1000 }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def main(args: Array[String]): Unit= {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fliesPerSecond(() => println("Time and tide wait for none but fly like arrows
    ..."))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time and tide wait for none but flies like an arrow...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time and tide wait for none but flies like an arrow...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time and tide wait for none but flies like an arrow...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time and tide wait for none but flies like an arrow...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time and tide wait for none but flies like an arrow...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time and tide wait for none but flies like an arrow...`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed example can be seen in the following code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Note: Using the infix operator in Scala**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the earlier example and in a subsequent section, we used the Scala infix
    notation. Suppose you would like to perform some operation with complex numbers
    and have a case class with an add method for adding two complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in order to access the properties of this class, you need to create an
    object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, suppose you have the following two complex numbers defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to access the `plus()` method from the case class, you will do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you output: `Complex(16.0,29.0)`. However, isn''t it good
    if you just call the method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And it really works like a charm. Here is the complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**The precedence of an infix operator**: This is determined by the operator''s
    first character. Characters are listed below in increasing order of precedence,
    with characters on the same line having the same precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**General warning**: Using the infix notation for calling regular, non-symbolic
    methods is discouraged and should be used only if it significantly increases readability.
    One example of a sufficiently motivated use of infix notation is matchers and
    other parts of the tests definition in `ScalaTest`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting element in the Scala collection package is using `forall`.
    It is used to check if a predicate holds for each element in a `Traversable` collection.
    In the next subsection, we will see an example of it.
  prefs: []
  type: TYPE_NORMAL
- en: Forall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Forall checks if a predicate holds for each element in a `Traversable` collection.
    It can be defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: While writing Scala code for preprocessing especially, we often need to filter
    selected data objects. The filter feature of the Scala collection API is used
    for that. In the next sub-section, we will see an example of using filter.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`filter` selects all the elements that satisfy a specific predicate. It can
    be defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A map is used to build a new collection or set of elements by traversing a function
    to all elements of the collection. In the next subsection, we will see an example
    of using `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Map is used to build a new collection or set of elements by traversing a function
    to all elements of the collection. It can be defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: While using the collection API in Scala, you often need to select the n^(th)
    elements of the list or array for example. In the next sub-section, we will explore
    examples of using take.
  prefs: []
  type: TYPE_NORMAL
- en: Take
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take is used to take the first n elements of a collection. The formal definition
    of using `take` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, if want to partition specific collections into a map of an other `Traversable`
    collection according to a specific partitioning function, you can use the `groupBy()`
    method. In the next subsection, we will show some examples of using `groupBy()`.
  prefs: []
  type: TYPE_NORMAL
- en: GroupBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GroupBy is used to partition specific collections into a map of other Traversable
    collections according to a specific partitioning function. It can be defined formally
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, if you want to select all the elements in a Traversable collection
    but the last one, you can use `init`. In the next subsection, we will see examples
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`init` selects all the elements in a `Traversable` collection but the last
    one. It can be defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, if you want to select all elements except the first n elements, you
    should use drop. In the next subsection, we will see how to use drop.
  prefs: []
  type: TYPE_NORMAL
- en: Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`drop` is used to select all elements except the first n elements. It can be
    defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, if you want take a set of elements until a predicate is satisfied,
    you should use `takeWhile`. In the next subsection, we will see how to use `takeWhile`.
  prefs: []
  type: TYPE_NORMAL
- en: TakeWhile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TakeWhile is used to take a set of elements until a predicate is satisfied.
    It can be defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, if you want to omit a set of elements till a predicate is satisfied,
    you should use `dropWhile`. We will see some examples of this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: DropWhile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`dropWhile` is used to omit a set of elements till a predicate is satisfied.
    It can be defined formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, if you want to use your **User Defined Functions** (**UDF**) such
    that it takes a function as an argument in the nested list and combines the output
    back together, `flatMap()` is a perfect candidate. We will see examples of using
    `flatMap()` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: FlatMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FltatMap takes a function as an argument. The function given to `flatMap()`
    doesn''t work on nested lists but it produces a new collection. It can be defined
    formally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We have just about finished covering the uses of Scala collection features.
    Also note that methods such as `Fold()`, `Reduce()`, `Aggregate()`, `Collect()`,
    `Count()`, `Find()`, and `Zip()` can be used to pass from one collection to another
    (for example, `toVector`, `toSeq`, `toSet`, `toArray`). However, we will see such
    examples in upcoming chapters. For the time being, it's time to see some performance
    characteristics of different Scala collection APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Performance characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, different collections have different performance characteristics and
    these performance characteristics are the reason you will prefer to choose one
    collection over the others. In this section, we will judge the performance characteristics
    of Scala collection objects from the operational and memory usage point of view.
    At the end of this section, we will provide some guidelines for selecting appropriate
    collection objects for your code and problem types.
  prefs: []
  type: TYPE_NORMAL
- en: Performance characteristics of collection objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are the performance characteristics Scala Collections, based on
    the official documentation of Scala.
  prefs: []
  type: TYPE_NORMAL
- en: '**Const**: The operation takes only constant time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eConst**: The operation takes effectively constant time, but this might depend
    on some assumptions such as the maximum length of a vector or the distribution
    of hash keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear**: The operation grows linearly with the collection size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log**: The operation grows logarithmically with the collection size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**aConst**: The operation takes the amortized constant time. Some invocations
    of the operation might take longer, but if many operations are performed on average
    only constant time per operation is taken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NA**: Operation is not supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance characteristics of sequence types (immutable) are presented in the
    following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Immutable CO*** | **Head** | **Tail** | **Apply** | **Update** | **Prepend**
    | **Append** | **Insert** |'
  prefs: []
  type: TYPE_TB
- en: '| List | Const | Const | Linear | Linear | Const | Linear | NA |'
  prefs: []
  type: TYPE_TB
- en: '| Stream | Const | Const | Linear | Linear | Const | Linear | NA |'
  prefs: []
  type: TYPE_TB
- en: '| Vector | eConst | eConst | eConst | eConst | eConst | eConst | NA |'
  prefs: []
  type: TYPE_TB
- en: '| Stack | Const | Const | Linear | Linear | Const | Linear | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| Queue | aConst | aConst | Linear | Linear | Const | Const | NA |'
  prefs: []
  type: TYPE_TB
- en: '| Range | Const | Const | Const | NA | NA | NA | NA |'
  prefs: []
  type: TYPE_TB
- en: '| String | Const | Linear | Const | Linear | Linear | Linear | NA |'
  prefs: []
  type: TYPE_TB
- en: '**Table 1:** Performance characteristics of sequence types (immutable) [*CO==
    Collection Object]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the meaning of the operations described in **Table
    1** and **Table 3** here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Head** | Is used to select the first few elements of an existing sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Tail** | Is used to select all elements except the first one and returns
    a new sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| **Apply** | Is used for indexing purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| **Update** | It is used as the functional update for immutable sequences.
    For the mutable sequence, it is a side-effecting update (with update for mutable
    sequences). |'
  prefs: []
  type: TYPE_TB
- en: '| **Prepend** | It is used to add an element to the front of an existing sequence.
    A new sequence is produced for immutable sequences. For the mutable sequence,
    the existing one is modified. |'
  prefs: []
  type: TYPE_TB
- en: '| **Append** | It is used to add an element at the end of an existing sequence.
    A new sequence is produced for immutable sequences. For a mutable sequence, the
    existing one is modified. |'
  prefs: []
  type: TYPE_TB
- en: '| **Insert** | It is used to insert an element at an arbitrary position in
    an existing sequence. This can be done however directly for mutable sequences.
    |'
  prefs: []
  type: TYPE_TB
- en: '**Table 2:** The meaning of the operation described in table 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance characteristics of sequence types (mutable) are shown in **Table
    3** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mutable CO*** | **Head** | **Tail** | **Apply** | **update** | **Prepend**
    | **Append** | **Insert** |'
  prefs: []
  type: TYPE_TB
- en: '| ArrayBuffer | Const | Linear | Const | Const | Linear | aConst | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| ListBuffer | Const | Linear | Linear | Linear | Const | Const | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| StringBuilder | Const | Linear | Const | Const | Linear | aCconst | Linear
    |'
  prefs: []
  type: TYPE_TB
- en: '| MutableList | Const | Linear | Linear | Linear | Const | Const | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| Queue | Const | Linear | Linear | Linear | Const | Const | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| ArraySeq | Const | Linear | Const | Const | NA | NA | NA |'
  prefs: []
  type: TYPE_TB
- en: '| Stack | Const | Linear | Linear | Linear | Const | Linear | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| ArrayStack | Const | Linear | Const | Const | aConst | Linear | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| Array | Const | Linear | Const | Const | NA | NA | NA |'
  prefs: []
  type: TYPE_TB
- en: '**Table 3:** Performance characteristics of sequence types (mutable) [*CO==
    Collection Object]'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about mutable collections and other types of collections,
    you can refer to this link ([http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance characteristics of set and map types are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Collection types** | **Lookup** | **Add** | **Remove** | **Min** |'
  prefs: []
  type: TYPE_TB
- en: '| **immutable** | - | - | - | - |'
  prefs: []
  type: TYPE_TB
- en: '| HashSet/HashMap | eConst | eConst | eConst | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| TreeSet/TreeMap | Log | Log | Log | Log |'
  prefs: []
  type: TYPE_TB
- en: '| BitSet | Const | Linear | Linear | eConst* |'
  prefs: []
  type: TYPE_TB
- en: '| ListMap | Linear | Linear | Linear | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| **Collection types** | **Lookup** | **Add** | **Remove** | **Min** |'
  prefs: []
  type: TYPE_TB
- en: '| **mutable** | - | - | - | - |'
  prefs: []
  type: TYPE_TB
- en: '| HashSet/HashMap | eConst | eConst | eConst | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| WeakHashMap | eConst | eConst | eConst | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| BitSet | Const | aConst | Const | eConst* |'
  prefs: []
  type: TYPE_TB
- en: '| TreeSet | Log | Log | Log | Log |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4:** Performance characteristics of set and map types [ * applicable
    only if bits are densely packed]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the meaning of each operation described in **Table
    4**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| **Lookup** | Is used to test whether an element is contained in a set. Secondly,
    it is also used to select a value associated with a particular key. |'
  prefs: []
  type: TYPE_TB
- en: '| **Add** | It is used to add a new element to a set. Secondly, it is also
    used to add a new key/value pair to a map. |'
  prefs: []
  type: TYPE_TB
- en: '| **Remove** | It is used to remove an element from a set or a key from a map.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Min** | It is used to select the smallest element of the set or the smallest
    key of a map. |'
  prefs: []
  type: TYPE_TB
- en: '**Table 5:** The meaning of each operation described in Table 4'
  prefs: []
  type: TYPE_NORMAL
- en: One of the basic performance metrics is the memory usage by a particular collection
    object. In the next section, we will provide some guidelines about how to measure
    these metrics based on memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Memory usage by collection objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, there are several benchmarking questions arrived for example: A
    `Lists` faster than `Vectors` for what you''re doing or are `Vectors` faster than
    `Lists`? How much memory can you save using unboxed Arrays to store primitives?
    When you do performance tricks such as pre-allocating arrays or using a `while`
    loop instead of a `foreach` call, how much does it really matter? `var l: List`
    or val `b: mutable.Buffer`? Memory usage can be estimated using different Scala
    benchmark codes, for example, refer to [https://github.com/lihaoyi/scala-bench](https://github.com/lihaoyi/scala-bench).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6 here shows the estimated size (bytes) of the various immutable collections
    of 0-elements, 1- element, 4- elements, and powers of four all the way up to 1,048,576
    elements. Although mostse are deterministic, these might be changed depending
    on your platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Vector | 56 | 216 | 264 | 456 | 1,512 | 5,448 | 21,192 | 84,312 | 334,440
    | 1,353,192 | 5,412,168 | 21,648,072 |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
  prefs: []
  type: TYPE_TB
- en: '| List | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696
    | 2,621,456 | 10,485,776 | 41,943,056 |'
  prefs: []
  type: TYPE_TB
- en: '| Stream (unforced) | 16 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 |
    160 | 160 | 160 |'
  prefs: []
  type: TYPE_TB
- en: '| Stream (forced) | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776
    | 647,696 | 2,621,456 | 10,485,776 | 41,943,056 |'
  prefs: []
  type: TYPE_TB
- en: '| Set | 16 | 32 | 96 | 880 | 3,720 | 14,248 | 59,288 | 234,648 | 895,000 |
    3,904,144 | 14,361,000 | 60,858,616 |'
  prefs: []
  type: TYPE_TB
- en: '| Map | 16 | 56 | 176 | 1,648 | 6,800 | 26,208 | 109,112 | 428,592 | 1,674,568
    | 7,055,272 | 26,947,840 | 111,209,368 |'
  prefs: []
  type: TYPE_TB
- en: '| SortedSet | 40 | 104 | 248 | 824 | 3,128 | 12,344 | 49,208 | 195,368 | 777,272
    | 3,145,784 | 12,582,968 | 50,331,704 |'
  prefs: []
  type: TYPE_TB
- en: '| Queue | 40 | 80 | 200 | 680 | 2,600 | 10,280 | 41,000 | 162,800 | 647,720
    | 2,621,480 | 10,485,800 | 41,943,080 |'
  prefs: []
  type: TYPE_TB
- en: '| String | 40 | 48 | 48 | 72 | 168 | 552 | 2,088 | 8,184 | 32,424 | 131,112
    | 524,328 | 2,097,192 |'
  prefs: []
  type: TYPE_TB
- en: '**Table 6:** The estimated size (bytes) of the various collections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the estimated size (bytes) of the array used in Scala
    with 0-elements, 1- element, 4- elements, and powers of four all the way up to
    1,048,576 elements. Although mostse are deterministic, these might change depending
    on your platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Boolean] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 |
    65,552 | 262,160 | 1,048,592 |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Byte] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 | 65,552
    | 262,160 | 1,048,592 |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Short] | 16 | 24 | 24 | 48 | 144 | 528 | 2,064 | 8,160 | 32,400 | 131,088
    | 524,304 | 2,097,168 |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Int] | 16 | 24 | 32 | 80 | 272 | 1,040 | 4,112 | 16,296 | 64,784 |
    262,160 | 1,048,592 | 4,194,320 |'
  prefs: []
  type: TYPE_TB
- en: '| Array[Long] | 16 | 24 | 48 | 144 | 528 | 2,064 | 8,208 | 32,568 | 129,552
    | 524,304 | 2,097,168 | 8,388,624 |'
  prefs: []
  type: TYPE_TB
- en: '| Boxed Array[Boolean] | 16 | 40 | 64 | 112 | 304 | 1,072 | 4,144 | 16,328
    | 64,816 | 262,192 | 1,048,624 | 4,194,352 |'
  prefs: []
  type: TYPE_TB
- en: '| Boxed Array[Byte] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 8,208 | 20,392 |
    68,880 | 266,256 | 1,052,688 | 4,198,416 |'
  prefs: []
  type: TYPE_TB
- en: '| Boxed Array[Short] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400
    | 323,856 | 1,310,736 | 5,230,608 | 20,910,096 |'
  prefs: []
  type: TYPE_TB
- en: '| Boxed Array[Int] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 |
    323,856 | 1,310,736 | 5,242,896 | 20,971,536 |'
  prefs: []
  type: TYPE_TB
- en: '| Boxed Array[Long] | 16 | 48 | 128 | 464 | 1,808 | 7,184 | 28,688 | 113,952
    | 453,392 | 1,835,024 | 7,340,048 | 29,360,144 |'
  prefs: []
  type: TYPE_TB
- en: '**Table 7**: The estimated size (bytes) of the arrays in Scala'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this book does not set out to distinguish them in a broad way and
    hence we will omit any discussion on these topics. Refer to the following information
    box for further guidelines on these:'
  prefs: []
  type: TYPE_NORMAL
- en: For very detailed benchmarking for Scala Collections with timed code, refer
    to this link on GitHub ([https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench](https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench)).
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, Scala has a very rich Collection API. The same applies
    for Java but there are lots of differences between the two Collection APIs. In
    the next section, we will see some examples on Java interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Java interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, Scala has very rich collection API. The same applies
    for Java but there are lots of differences between the two collection APIs. For
    example, both APIs have iterable, iterators, maps, sets, and sequences. But Scala
    has advantages; it pays more attention to immutable collections and provides more
    operations for you in order to produce another collection. Sometimes, you want
    to use or access Java collections or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '`JavaConversions` is no longer a sound choice. `JavaConverters` makes the conversion
    between Scala and Java collection explicit and you''ll be much less likely to
    experience implicit conversions you didn''t intend to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a matter of fact, it''s quite trivial to do so because Scala offers in an
    implicit way to convert between both APIs in the `JavaConversion` object. So,
    you might find bidirectional conversions for the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to use these kinds of conversion, you need to import them
    from the `JavaConversions` object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'By this, you have automatic conversions between Scala collections and their
    corresponding in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also try to convert other Scala collections into Java ones. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Java doesn''t provide the functionality to distinguish between immutable and
    mutable collections. The `List` will be `java.util.List` where all attempts to
    mutate its elements will throw an `Exception`. The following is an example to
    demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 2](part0058.html#1NA0K1-21aec46d8593429cacea59dbdcd64e1c), *Object-Oriented
    Scala*, we briefly discussed using implicits. However, we will provide a detailed
    discussion on using implicits in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Scala implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have addressed implicits in the previous chapters, but here we are going
    to see more examples. Implicit parameters are very similar to default parameters
    but they use different mechanisms in order to find the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implicit parameter is one that is passed to a constructor or a method and
    is marked as implicit, which means that the compiler will search for an implicit
    value within the scope if you don''t provide a value for this parameter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Implicits are very useful for the collection API. For example, the collections
    API use implicit parameters to supply `CanBuildFrom` objects for many methods
    in these collections. This happens usually because users aren't concerned with
    these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'One constraint is that you can''t have more than one implicit keyword per method
    and it must be at the start of the parameter list. Here are some invalid examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '**Number of implicit parameters:** Note that you can have more than one implicit
    parameter. But, you cannot have more than one group of implicit parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is for more than 1 implicit parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The final parameter list on a function can be identified or marked as implicit.
    This means the values will be taken from the context as they are being called.
    In other words, if there is no implicit value of the exact type in the scope,
    the source code using implicit will not be compiled. The reason is simple: since
    the implicit value must be resolved to a single value type, it would be a better
    idea to make the type specific to its purpose to avoid implicit clashes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you do not require methods to find an implicit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When your Scala compiler finds an expression of wrong types for the context
    it is feeding, it will look for an implicit function value instead for type-checking.
    So, the difference between your regular methods is that the one marked implicit
    will be inserted for you by the compiler when a `Double` is found but an `Int`
    is required. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The earlier code will work the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In the second we've inserted the conversion manually. At first, the compiler
    did this automatically. The conversion is required because of the type annotation
    on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: While working with data, we will often need to convert one type to another.
    Scala implicit type conversion gives us this facility. We will see several examples
    of it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An implicit conversion from type `S` to type `T` is defined by an implicit
    value that has function type `S => T`, or by an implicit method convertible to
    a value of that type. Implicit conversions are applied in two situations (source:
    [http://docs.scala-lang.org/tutorials/tour/implicit-conversions](http://docs.scala-lang.org/tutorials/tour/implicit-conversions)):'
  prefs: []
  type: TYPE_NORMAL
- en: If an expression e is of type `S`, and S does not conform to the expression's
    expected type `T`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a selection `e.m` with `e` of type `S`, if the selector `m` does not denote
    a member of `S`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Well, we have seen how to use infix operator in Scala. Now, let''s see some
    use cases of Scala implicit conversion. Suppose we have the following code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined some methods for performing addition, subtraction,
    and a unary operation for complex numbers (that is, both real and imaginary numbers).
    Inside the `main()` method, we called these methods with real values. The output
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: But what if we want to support adding a normal number to a complex number, how
    would we do that? We could certainly overload our `plus` method to take a `Double`
    argument so that it's going to support the following expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we can use Scala implicit conversion. It supports implicit conversion
    for both real and complex numbers for mathematical operation. So, we can just
    use that tuple as the parameter for our implicit conversion and convert it into
    a `Complex` refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for double to complex conversion as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To take the advantage of this conversion, we need to import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute something like this on Scala REPL/IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The full source code for this example can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We have now more or less covered Scala collection APIs. There are other features
    too, but page limitations prevented us from covering them. Interested readers
    who still want to explore this should refer to this page [http://www.scala-lang.org/docu/files/collections-api/collections.html](http://www.scala-lang.org/docu/files/collections-api/collections.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have seen many examples of using the Scala collections
    API. It's very powerful, flexible, and has lots of operations coupled with them.
    This wide range of operations will make your life easy dealing with any kind of
    data. We introduced the Scala collections API, and its different types and hierarchies.
    We also demonstrated the capabilities of the Scala collections API and how it
    can be used in order to accommodate different types of data and solve a wide range
    of different problems. In summary, you learned about types and hierarchies, performance
    characteristic, Java interoperability, and the usage of implicits. So, this is
    more or less the end of the learning Scala. However, you will keep on learning
    more advanced topics and operations using Scala through the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore data analysis and big data to see the challenges
    that big data provides and how they are dealt via distributed computing and the
    approach suggested by functional programming. You will also learn about MapReduce,
    Apache Hadoop, and finally Apache Spark and see how they embrace this approach
    and these techniques.
  prefs: []
  type: TYPE_NORMAL
