["```py\n    import Data.Char (isSpace)\n    ```", "```py\n    trim :: String -> String\n    trim = f . f\n      where f = reverse . dropWhile isSpace\n    ```", "```py\n    main :: IO ()\n    main = putStrLn $ trim \" wahoowa! \"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    wahoowa!\n\n    ```", "```py\n    main :: IO ()\n    main = do\n      let quote = \"Deep Blue plays very good chess-so what?\\ \n        \\Does that tell you something about how we play chess?\\\n        \\No. Does it tell you about how Kasparov envisions,\\ \n        \\understands a chessboard? (Douglas Hofstadter)\"\n      putStrLn $ (removePunctuation.replaceSpecialSymbols) quote\n    ```", "```py\n    punctuations = [ '!', '\"', '#', '$', '%'\n                   , '(', ')', '.', ',', '?']\n\n    removePunctuation = filter (`notElem` punctuations)\n\n    specialSymbols = ['/', '-']\n\n    replaceSpecialSymbols = map $ \n      (\\c ->if c `elem` specialSymbols then ' ' else c)\n    ```", "```py\n    $ runhaskell Main.hs\n    Deep Blue plays very good chess so what Does that tell you something about how we play chess No Does it tell you about how Kasparov envisions understands a chessboard Douglas Hofstadter\n\n    ```", "```py\n$ cabal install MissingH\n\n```", "```py\nPrelude> replace \"hello\" \"goodbye\" \"hello world!\"\n\n\"goodbye world!\"\n\n```", "```py\nPrelude> ((replace \",\" \"\").(replace \"!\" \"\")) \"hello, world!\"\n\n\"hello world\"\n\n```", "```py\nPrelude> (foldr (.) id $ map (flip replace \"\") [\",\", \"!\"]) \"hello, world!\"\n\n\"hello world\"\n\n```", "```py\nremovePunctuation = foldr (.) id $ map (flip replace \"\") \n        [\"!\", \"\\\"\", \"#\", \"$\", \"%\", \"(\", \")\", \".\", \",\", \"?\"]\n\nreplaceSpecialSymbols = foldr (.) id $ map (flip replace \" \") \n        [\"/\", \"-\"]\n```", "```py\n$ ghci\n\nPrelude> :type Just 'c'\nJust 'c' :: Maybe Char\n\nPrelude> :type Nothing\nNothing :: Maybe a\n\n```", "```py\n$ cabal install csv\n\n```", "```py\n    import Text.CSV\n    ```", "```py\n    data Laptop = Laptop { brand :: Maybe String\n                         , model :: Maybe String\n                         , cost :: Maybe Float \n                         } deriving Show\n    ```", "```py\n    main :: IO ()\n    main = do\n      let fileName = \"input.csv\"\n      input <- readFile fileName\n      let csv = parseCSV fileName input\n      let laptops = parseLaptops csv\n      print laptops\n    ```", "```py\n    parseLaptops (Left err) = []\n    parseLaptops (Right csv) = \n      foldl (\\a record -> if length record == 3\n                          then (parseLaptop record):a\n                          else a) [] csv\n\n    parseLaptop record = Laptop{ brand = getBrand $ record !! 0\n                               , model = getModel $ record !! 1\n                               , cost = getCost $ record !! 2 }\n    ```", "```py\n    getBrand :: String -> Maybe String\n    getBrand str = if null str then Nothing else Just str\n\n    getModel :: String -> Maybe String\n    getModel str = if null str then Nothing else Just str\n\n    getCost :: String -> Maybe Float\n    getCost str = case reads str::[(Float,String)] of\n      [(cost, \"\")] -> Just cost\n      _ -> Nothing\n    ```", "```py\n    import Text.Regex.Posix ((=~))\n    ```", "```py\n    looksLikeName :: String -> Bool\n    looksLikeName str = str =~ \"^[A-Z][a-z]{1,30}$\" :: Bool\n    ```", "```py\n    punctuations = [ '!', '\"', '#', '$', '%'\n                   , '(', ')', '.', ',', '?']\n    removePunctuation = filter (`notElem` punctuations)\n\n    specialSymbols = ['/', '-']\n    replaceSpecialSymbols = map $ \n                             (\\c -> if c `elem`  specialSymbols\n                                    then ' ' else c)\n    ```", "```py\n    createTuples (x:y:xs) = (x ++ \" \" ++ y) : \n                              createTuples (y:xs)\n    createTuples _ = [] \n    ```", "```py\n    main :: IO ()\n    main = do\n\n      input <- readFile \"input.txt\"\n      let cleanInput = \n        (removePunctuation.replaceSpecialSymbols) input\n\n      let wordPairs = createTuples $ words cleanInput\n\n      let possibleNames = \n        filter (all looksLikeName . words) wordPairs\n\n      print possibleNames\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [\"Dr Erickson\",\"Mark Norell\",\"American Museum\",\"Natural History\",\"History Philip\",\"Philip Currie\",\"Peter Makovicky\",\"Field Museum\"]\n\n    ```", "```py\n$ cabal install attoparsec\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n    import Data.Attoparsec.Text\n    import Data.Char (isSpace, isAlphaNum)\n    ```", "```py\n    data E-mail = E-mail \n      { user :: String\n      , host :: String\n      } deriving Show\n    ```", "```py\n    e-mail :: Parser E-mail\n    e-mail = do\n      skipSpace\n      user <- many' $ satisfy isAlphaNum\n      at <- char '@'\n      hostName <- many' $ satisfy isAlphaNum\n      period <- char '.'\n      domain <- many' (satisfy isAlphaNum)\n      return $ E-mail user (hostName ++ \".\" ++ domain)\n    ```", "```py\n    main :: IO ()\n    main = print $ parseOnly e-mail \"nishant@shukla.io\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    Right (E-mail {user = \"nishant\", host = \"shukla.io\"})\n\n    ```", "```py\n    import Text.CSV (parseCSV, Record)\n    import Data.Map (fromListWith)\n    import Control.Applicative ((<|>))\n    ```", "```py\n    data Item = Item   { name :: String\n                       , color :: Maybe String\n                       , cost :: Maybe Float\n                       } deriving Show\n    ```", "```py\n    main :: IO ()\n    main = do\n      let fileName = \"input.csv\"\n      input <- readFile fileName\n      let csv = parseCSV fileName input\n      either handleError doWork csv\n    ```", "```py\n    handleError = print\n\n    doWork :: [Record] -> IO ()\n    doWork csv = print $ \n                 fromListWith combine $ \n                 map parseToTuple csv\n    ```", "```py\n    combine :: Item -> Item -> Item\n\n    combine item1 item2 = \n        Item { name = name item1\n             , color = color item1 <|> color item2\n             , cost = cost item1 <|> cost item2 }\n    ```", "```py\n    parseToTuple :: [String] -> (String, Item)\n    parseToTuple record = (name item, item) \n        where item = parseItem record\n\n    parseItem :: Record -> Item\n    parseItem record = \n        Item { name = record !! 0\n          , color = record !! 1\n          , cost = case reads(record !! 2)::[(Float,String)] of\n            [(c, \"\")] -> Just c\n            _ -> Nothing  }\n    ```", "```py\n    $ runhaskell Main.hs\n\n    fromList \n    [ (\"glasses\",\n     Item {name = \"glasses\", color = \"black\", cost = Just 60.0})\n    , (\"jacket\",\n     Item {name = \"jacket\", color = \"brown\", cost = Just 89.99})\n    , (\"shirt\",\n     Item {name = \"shirt\", color = \"red\", cost = Just 15.0})\n    ]\n\n    ```", "```py\n$ ghci\n\nPrelude> import Control.Applicative\n\nPrelude Control.Applicative> (Nothing) <|> (Just 1)\nJust 1\n\nPrelude Control.Applicative> (Just 'a') <|> (Just 'b')\nJust 'a'\n\nPrelude Control.Applicative> \"\" <|> \"hello\"\n\"hello\"\n\nPrelude Control.Applicative> \"\" <|> \"\"\n\"\"\n\n```", "```py\n    import Text.CSV (parseCSV, Record)\n    import Data.Map (fromListWith)\n    import qualified Data.Set as S\n    ```", "```py\n    data Artist = Artist { name :: String\n                         , song :: S.Set String\n                         , genre :: S.Set String\n                         } deriving Show\n    ```", "```py\n    main :: IO ()\n    main = do\n      let fileName = \"input.csv\"\n      input <- readFile fileName\n      let csv = parseCSV fileName input\n      either handleError doWork csv\n    ```", "```py\n    handleError = print\n    ```", "```py\n    doWork :: [Record] -> IO ()\n    doWork csv = print $ \n                 fromListWith combine $ \n                 map parseToTuple csv\n    ```", "```py\n    combine :: Artist -> Artist -> Artist\n    combine artist1 artist2 = \n        Artist { name = name artist1\n               , song = S.union (song artist1) (song artist2)\n               , genre = S.union (genre artist1) (genre artist2) }\n    ```", "```py\n    parseToTuple :: [String] -> (String, Artist)\n    parseToTuple record = (name item, item) \n      where item = parseItem record\n\n    parseItem :: Record -> Artist\n    parseItem record = \n      Artist { name = nameStr\n             , song = if null songStr \n                      then S.empty \n                      else S.singleton songStr\n             , genre = if null genreStr \n                       then S.empty \n                       else S.singleton genreStr\n             }\n      where nameStr  = record !! 0\n            songStr  = record !! 1\n            genreStr = record !! 2\n    ```", "```py\n    fromList [ \n    (\"Daft Punk\", Artist \n      {  name = \"Daft Punk\", \n        song = fromList [\"Get Lucky\",\"Around the World\"], \n        genre = fromList [\"French house\"]}),\n    (\"Junior Boys\", Artist \n      {  name = \"Junior Boys\", \n        song = fromList [\"Bits & Pieces\"], \n        genre = fromList [\"Synthpop\"]}),\n    (\"Justice\", Artist \n      {  name = \"Justice\", \n        song = fromList [\"Genesis\"], \n        genre = fromList [\"Electronic rock\",\"Electro\"]}),\n    (\"Madeon\", Artist \n      {  name = \"Madeon\", \n        song = fromList [\"Icarus\"], \n        genre = fromList [\"French house\"]})]\n    ```", "```py\n    import Data.List (group, sort)\n    ```", "```py\n    data Color = Red | Green | Blue deriving (Show, Ord, Eq)\n    ```", "```py\n    main :: IO ()\n    main = do\n      let items = [Red, Green, Green, Blue, Red, Green, Green]\n    ```", "```py\n      let freq = \n         map (\\x -> (head x, length x)) . group . sort $ items\n      print freq\n    ```", "```py\nPrelude> sort items\n\n[Red,Red,Green,Green,Green,Green,Blue]\nPrelude> group it\n\n[[Red,Red],[Green,Green,Green,Green],[Blue]]\n\nPrelude> map (\\x -> (head x, length x)) it\n\n[(Red,2),(Green,4),(Blue,1)]\n\n```", "```py\n$ cabal install multiset\n\n```", "```py\n    import Data.MultiSet (fromList, toOccurList)\n    ```", "```py\n    data Color = Red | Green | Blue deriving (Show, Ord, Eq)\n    ```", "```py\n    main :: IO ()\n    main = do\n      let items = [Red, Green, Green, Blue, Red, Green, Green]\n    ```", "```py\n      let freq = toOccurList . fromList $ items\n      print freq\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [ (Red, 2), (Green, 4), (Blue, 1) ]\n\n    ```", "```py\n$ cat input.csv\n\n0,0\n10,0\n0,10\n10,10\n5,5\n\n```", "```py\n    import Text.CSV (parseCSV)\n    ```", "```py\n    main :: IO ()\n    main = do\n      let fileName = \"input.csv\"\n      input <- readFile fileName\n      let csv = parseCSV fileName input\n    ```", "```py\n      let points = either (\\e -> []) (map toPoint . myFilter) csv\n    ```", "```py\n      let test1 = [2,1]\n      let test2 = [-10,-10]\n    ```", "```py\n      if (not.null) points then do\n        print $ minimum $ map (manhattanDist test1) points\n        print $ minimum $ map (manhattanDist test2) points\n      else putStrLn \"Error: no points to compare\"\n    ```", "```py\n    toPoint record = map (read :: String -> Float) record\n    ```", "```py\n    manhattanDist p1 p2 = \n      sum $ zipWith (\\x y -> abs (x - y)) p1 p2\n    ```", "```py\n    myFilter = filter (\\x -> length x == 2)\n    ```", "```py\n    $ runhaskell Main.hs \n\n    3.0\n    20.0\n    ```", "```py\n$ cat input.csv\n\n0,0\n10,0\n0,10\n10,10\n5,5\n\n```", "```py\n    import Text.CSV (parseCSV)\n    ```", "```py\n    main :: IO ()\n    main = do\n      let fileName = \"input.csv\"\n      input <- readFile fileName\n      let csv = parseCSV fileName input\n    ```", "```py\n      let points = either (\\e -> []) (map toPoint . myFilter) csv \n    ```", "```py\n      let test1 = [2,1]\n      let test2 = [-10,-10]\n    ```", "```py\n      if (not.null) points then do\n        print $ minimum $ map (euclidianDist test1) points\n        print $ minimum $ map (euclidianDist test2) points\n      else putStrLn \"Error: no points to compare\"\n    ```", "```py\n    toPoint record = map (read String -> Float) record\n    ```", "```py\n    euclidianDist p1 p2 = sqrt $ sum $ \n                          zipWith (\\x y -> (x - y)^2) p1 p2\n    ```", "```py\n    myFilter = filter (\\x -> length x == 2)\n    ```", "```py\n    $ runhaskell Main.hs\n\n    2.236068\n    14.142136\n\n    ```", "```py\n    main :: IO ()\n    main = do\n      let d1 = [3,3,3,4,4,4,5,5,5]\n      let d2 = [1,1,2,2,3,4,4,5,5]\n      let r = pearson d1 d2\n      print r\n    ```", "```py\n     pearson xs ys = (n * sumXY - sumX * sumY) / \n                     sqrt ( (n * sumX2 - sumX*sumX) * \n                            (n * sumY2 - sumY*sumY) )\n\n      where n = fromIntegral (length xs)\n            sumX = sum xs\n            sumY = sum ys\n            sumX2 = sum $ zipWith (*) xs xs\n             sumY2 = sum $ zipWith (*) ys ys\n            sumXY = sum $ zipWith (*) xs ys\n    ```", "```py\n    $ runhaskell Main.hs\n\n    0.9128709291752768\n\n    ```", "```py\n    main :: IO ()\n    main = do\n      let d1 = [3.5, 2, 0, 4.5, 5, 1.5, 2.5, 2]\n      let d2 = [  3, 0, 0,   5, 4, 2.5,   3, 0]\n    ```", "```py\n      let similarity = dot d1 d2 / (eLen d1 * eLen d2)\n      print similarity\n    ```", "```py\n    dot a b = sum $ zipWith (*) a b  \n    eLen a = sqrt $ dot a a\n    ```", "```py\n    $ runhaskell Main.hs\n\n    0.924679432210068\n\n    ```"]