- en: Jupyter Julia Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia is a language that was specifically designed to be used for high-performance,
    numerical computing. Most importantly, it differs from the previous scripting
    languages that have been covered in this book (R and to a certain extent, Python)
    in that Julia is a full language  and not limited to data handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Julia scripting to your installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Julia in Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia limitations in Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard Julia capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia visualizations in Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia Vega plotting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia parallel processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Julia scripting to your installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will install Julia on macOS and Windows. There are very similar steps in
    both environments due to using Anaconda as the basis for the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Julia scripts to Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once Julia is available on your machine, enabling Julia within Jupyter is readily
    accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to install Julia on our Windows machine. Navigate to the Julia
    download page ([http://julialang.org/downloads/](http://julialang.org/downloads/)),
    download the correct version, which is Julia 0.6.1 for most environments, and
    run the installation with the standard default settings.
  prefs: []
  type: TYPE_NORMAL
- en: You must run the Julia installation as an Administrator on your machine. After
    downloading the file, open the `Downloads` folder, right-click on the Julia executable,
    and select Run as administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the install is complete, you should verify that everything worked. Select
    Julia from the programs list and run the Julia program. You should see the command
    line with Julia displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a363cf1-9dbf-4a8e-bcae-c9ccb5070b36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The current version of Julia will not automatically include updates to any
    packages that may be used. For that, we run the following command to add Julia
    to Jupyter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a number of packages being updated or installed on to your
    machine. Your display will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dee0148-eef3-4aad-909c-a0a21180c33a.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia uses font color as feedback. I entered the text `Pkg.update()` in white
    at the top of the screen; successful execution steps are in blue, and possible
    problems are shown in red. You must wait for the installation to complete.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite an involved process, where the system looks to see what packages
    need to be updated and installed, installs each one, verifies that each was successful,
    and then does it all again until there is nothing left to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line should have read the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can close the Julia window (by using the `quit()` command).
  prefs: []
  type: TYPE_NORMAL
- en: 'One last step is to open your Notebook (by using the `jupyter notebook` command),
    and if you open the New menu (in the upper-right corner of the screen), you should
    see a Julia type available, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/245ee21a-58a5-4b84-b320-de633788231c.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding Julia packages to Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard installation for Julia under Jupyter has many packages that are
    commonly used in Julia programming. However, if you do need to add another package,
    a small number of steps are required to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Close down your Notebook (including the server).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Julia command-line program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Restart your Notebook. The package should be available in your Julia script,
    for example,  `library("name of the package you want to add")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I would recommend adding the preceding two packages right away, as they are
    needed for many scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you use a package in Julia, you will see a line highlighted
    in light red that shows Julia is precompiling, such as this: `INFO: Precompiling
    module Dataframes...`'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `Pkg.add(...)` function directly in your script, but that doesn't
    seem correct. Every time you run your script, the system will attempt to validate
    whether you have the specified package, install it into your environment if needed,
    and even tell you whether it is out of date. None of these steps belong to part
    of your script.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Julia in Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will use the Iris dataset for some standard analysis. So,
    start a new Julia Notebook and call it `Julia Iris`. We can enter a small script
    to see how the steps progress for a Julia script.
  prefs: []
  type: TYPE_NORMAL
- en: This script uses another package for plotting, which is called `Gadfly`. You
    will have to go through similar steps as to the ones we went through in the previous
    section to install the package before operating the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following script into separate cells of your Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`RDatasets` is a library that contains several of the commonly used R datasets,
    such as `iris`. This is a simple script—we define the libraries that we are going
    to use, set the size of the `plot` area, and plot out the `iris` data points (`color`
    coded to `Species`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you will end up with a starting screen that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fec1f011-ce80-4f10-8bd2-2221f8b84c4c.png)'
  prefs: []
  type: TYPE_IMG
- en: I have used Markdown cells for the text cells. These serve as documentation
    of the processing and are not interpreted by the engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should take note of a few aspects of the Julia Notebook view:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the Julia logo (the three colored circles) in the upper-right corner.
    You will have seen this logo running in other Julia installations (as we saw earlier
    when we ran the Julia command line previously).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circle to the right of the Julia logo is a busy indicator. When your script
    starts, the title of the table says busy as Julia is starting. When your script
    is running, the circle is filled in black. When it is not running, it is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the menu items are the same as before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On my Windows machine, it took quite a while for the Julia Notebook to start
    for the first time. The Kernel starting, please wait... message was displayed
    for several minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the script (using the **Cell** | Run All menu command), your output
    should look like what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00f085b2-5274-48dc-be8c-311b70c0480a.png)'
  prefs: []
  type: TYPE_IMG
- en: The display continues with other statistics about each of the sets, such as `PetalWidth` and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `WARNING` message about an incompatibility between sublibraries. Even
    with the time it took to install and update packages, there were still unresolved
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more interesting part of this is `plot` of the data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb29c2d4-c038-446b-9b2b-af4de89f89be.png)'
  prefs: []
  type: TYPE_IMG
- en: I noticed that if you hover the mouse over a graphic, you get grid lines displayed
    and a slide bar to adjust the zoom level (as shown in the upper-right part of
    the preceding screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: So, just as if you ran the script in the Julia interpreter, you get your output
    (with the numerical prefix). Jupyter has counted the statements so that we have
    incremental numbering of the cells. Jupyter has not done anything special to print
    out variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started the server, created a new Notebook, and saved it as Julia `iris`.
    If we open the IPYNB file on disk (using a text editor), we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a little different than what we saw in the previous chapters with other
    Notebook language coding. Particularly, `metadata` clearly targets the script
    cells to be Julia script.
  prefs: []
  type: TYPE_NORMAL
- en: Julia limitations in Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have written Julia scripts and accessed different Julia libraries without
    issue in Jupyter. I have not noticed any limitations on its use or any performance
    degradation. I imagine some aspects of Julia that are very screen dependent (such
    as using the **Julia webstack** to build a website) may be hampered by conflicting
    uses of the same concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have repeatedly seen updates being run when I am attempting to run a Julia
    script, as shown in the following screenshot. I am not sure why they decided to
    always update the underlying tool rather than use what is in play and have the
    user specify whether to update libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a15611e-d6ad-47fa-9315-8d08a9bef36c.png)'
  prefs: []
  type: TYPE_IMG
- en: I have also noticed that once a Julia Notebook is opened, even though I have
    closed the page, it will still display Running on the home page. I don't recall
    seeing this behavior with the other script languages that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue has been trying to use a secured package in my script, for example,
    `plotly`. It appears to be a clean process to get credentials, but using the prescribed
    methods for passing your credentials to `plotly` does not work under Windows.
    I am hesitant to provide examples that do not work in both environments.
  prefs: []
  type: TYPE_NORMAL
- en: Further interactions with Windows are also limited, for example, attempting
    to access environment variables by calls to standard C libraries that are not
    normally present on a Windows installation.
  prefs: []
  type: TYPE_NORMAL
- en: I have another issue with Julia itself, regardless of running under Jupyter
    or not. When using a package, it will complain about features that are used in
    the package that have been deprecated or improved. As a user of the package, I
    have no control over this behavior, so it does not help me in my work.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, running some of these scripts takes several minutes. The scripts used
    are small. It seems to take a long time for the Julia kernel to start.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Julia capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to functions that are used in other languages, Julia can perform most
    of the rudimentary statistics on your data by using the `describe` function, as
    shown in the example script that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This script accesses the `iris` dataset and displays summary statistics on the
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to build a Notebook to show `describe` in use against the `iris`
    dataset (which we loaded in the previous example), we would end up with a display
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/861cf12e-30a9-4cb4-bb91-a92d2ec27d20.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the standard statistics that have been generated for each of the
    variables in the dataset. I thought it was interesting that the count and percentage
    of `NA` values in the dataset are provided. I have found that I usually have to
    double-check to exclude this data by using other languages. This is a quick, built-in
    reminder.
  prefs: []
  type: TYPE_NORMAL
- en: The warning message is complaining about a compatibility issue with one of the
    datetime libraries used, even though it is not used in this Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Julia visualizations in Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most popular tool for visualizations in Julia is the `Gadfly` package.
    We can add the `Gadfly` package (as described at the beginning of this chapter)
    by using the `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From then on, we can make reference to the `Gadfly` package in any script by
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Julia Gadfly scatterplot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `plot()` function with standard defaults (no type arguments)
    to generate a scatterplot. For example, with the following simple script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the `srand()` function in all examples that use random results. The `srand()`
    function sets the random number seed value so that all of the results in this
    chapter are reproducible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate a nice, clean scatterplot, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d797e18-a514-4b39-a4ce-8ec5995e18a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I did notice that if you click on the ? symbol that appears in the top-right
    of the graphic if you click on the graphic, a message box is displayed that enables
    finer control over the graphic to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pan across the image (especially if it expands beyond the window)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom in, out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reset:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f328b8f6-425a-4721-87e2-463aa453634b.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia Gadfly histogram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can produce other graph types as well, for example, `histogram`, by using
    the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This script generates `113` random numbers and generates `histogram` of the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4d59d60-d484-40d7-910b-a463ff5b7bd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia Winston plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another graphics package in Julia is `Winston`. It has similar plotting capabilities
    to `Gadfly` (I think `Gadfly` is more up-to-date). We can produce a similar plot
    of random numbers by using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that you have to specifically display the plot. The `Winston` package assumes
    that you want to store the graphic as a file, so the `plot` function generates
    an object for handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving this into a Notebook, we get the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/196c6351-f62d-44de-a52b-068a09c9413a.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia Vega plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another popular graphics package is `Vega`. The main feature of `Vega` is the
    ability to describe your graphic by using language primitives such as JSON. `Vega`
    produces most of the standard plots. Here is an example script using `Vega` for
    a pie chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant output in Jupyter may look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/0ad89c95-c57d-41ff-aae1-e87d7de149ea.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `INFO: Precompiling module Vega.` package. Even though the package
    had been loaded as part of the install or update process, it still needed to adjust
    the library on first use.'
  prefs: []
  type: TYPE_NORMAL
- en: The generated graphic produced under Jupyter is shown in the following screenshot
  prefs: []
  type: TYPE_NORMAL
- en: '`Vega` gives you the option on the resultant display to Save as PNG. I think
    this is a useful feature, allowing you to embed the generated graphic(s) in another
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a64fba07-d41b-4fad-b25f-178c3545a47e.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia PyPlot plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another plotting package available is `PyPlot`. `PyPlot` is one of the standard
    Python visualization libraries and is directly accessible from Julia. We can take
    this small script to produce an interesting visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant output in Jupyter may look like what''s shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85d1bee4-7214-4883-8889-a7cc1ddb3cda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we have Julia updating a package before executing our Notebook until,
    finally, we get the graphic on `Precipitation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5acf802c-ba07-438a-a499-7f18dc9696b9.png)'
  prefs: []
  type: TYPE_IMG
- en: It's interesting that Boston has such diverse precipitation—most of the month
    has none, and then there are a couple of days that have a deluge.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reminder: Jupyter will attempt to put most of the output into a small scrolling
    window. Just clicking in the left-hand side of the display will expand the entire
    contents of the scroll panel.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia parallel processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An advanced built-in feature of Julia is to use parallel processing in your
    script. Normally, you can specify the number of processes that you want to use
    directly in Julia. However, under Jupyter, you would use the `addprocs()` function
    to add an additional process available for use in your script, for example, look
    at this small script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It makes a call to `rand`, the random number generator, with that code executing
    on the second parameter to the function call (process `2`), and then passes the
    remaining arguments to the `rand` function there (making rand generate a 3×4 matrix
    of random numbers). `spawnat` is a macro that evaluates the processes mentioned
    previously. Then, `fetch` accesses the result of the spawned processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the results in the example under Jupyter, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6289b67-d8e3-419b-97fe-6ada0b688915.png)'
  prefs: []
  type: TYPE_IMG
- en: So, this is not a dramatic spawned process type of calculation, but you can
    easily imagine much more involved processes that are readily available in Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: Julia control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia has a complete set of control flows. As an example, we could have a small
    function `larger` that determines the larger of two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several features that you must note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `end` statement for the `if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`, as the closing of the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indentation of the statements within the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indentation of the handling of a true condition within an `if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run this under Jupyter, we would see the expected output, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e24a6fa-8294-4387-be06-278908e5c562.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia has built-in regular expression handling—as would most modern programming
    languages. There is no need for using statements, since regular expressions are
    basic features of strings in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have a small script that validates whether a string is a valid phone
    number, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When run under Jupyter, we would see the expected results. The first number
    is conformant to the format and the second is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faf1873c-efcc-4392-b37a-011139512d54.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a full language, Julia has unit-testing abilities to make sure that your
    code is performing as expected. The unit tests usually reside in the tests folder.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the standard functions available for unit testing in Julia are `FactCheck`
    and `Base.Test`. They both do the same thing, but react differently to failed
    tests. `FactCheck` will generate an error message that will not stop processing
    on a failure. If you provide an error handler, that error handler will take control
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: '`Base.Test` will throw an exception and stop processing on the first test failure.
    In that regard, it is probably not useful as a unit-testing function so much as
    a runtime test that you may put in place to make sure parameters are within reason
    or otherwise. Just stop processing before something bad happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Both packages are built in to the standard Julia distributions.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we can create a unit tests Notebook that does the same tests
    and see the resulting, different responses for errors (meaning, test failures).
  prefs: []
  type: TYPE_NORMAL
- en: 'For `FactCheck`, we will use the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `FactCheck` package. The simple function we are testing is
    cubing a number, but it could be anything. We wrap our tests in a `facts() do...End`
    block. Each of the tests is run within the block which is separate from any other
    block—so as to group our unit tests together—and is prefixed with `@fact`. Also,
    note that we are testing whether the function result following `-->` is the right-hand
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this in Jupyter, we see the expected results, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d06a9fb0-98d5-462e-9f35-c1f1221e77ec.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the failed test, why it failed, what line it was on, and so on,
    as well as the summary for the `facts` block that was executed, that is, the number
    of tests that passed (`Verified`) and the number of tests that `Failed`. Note
    that the script continued to run on to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Base.Test`, we have a similar script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `Base.Test` package. The function definition we are using
    is, again, cubing. Then, each test is individually—not as part of a `test` block—prefixed
    with `@test`. Running this script in Jupyter, we see similar results as the ones
    that are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87a2f1d1-285f-4b6e-a9d9-8e2cacf20a7d.png)'
  prefs: []
  type: TYPE_IMG
- en: The failed test information is displayed. However, in this case, the script
    stopped executing at this point. Hence, I would only consider this for runtime
    checks to validate input formats.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the ability to use Julia scripts in our Jupyter Notebook.
    We added a Julia library that's not included in the standard Julia installation.
    We saw basic features of Julia in use, and also outlined some of the limitations
    that are encountered using Julia in Jupyter. We displayed graphics using some
    of the graphics packages available, including `Gadfly`, `Winston`, `Vega`, and
    `PyPlot`. Finally, we saw parallel processing in action, a small control flow
    example, and how to add unit testing to your Julia script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn all about using JavaScript in a Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
