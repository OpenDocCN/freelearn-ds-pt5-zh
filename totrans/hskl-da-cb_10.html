<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Real-time Data</h1></div></div></div><p>This chapter will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Streaming Twitter for real-time sentiment analysis</li><li class="listitem" style="list-style-type: disc">Reading IRC chat room messages</li><li class="listitem" style="list-style-type: disc">Responding to IRC messages</li><li class="listitem" style="list-style-type: disc">Polling a web server for the latest updates</li><li class="listitem" style="list-style-type: disc">Detecting real-time file directory changes</li><li class="listitem" style="list-style-type: disc">Communicating in real time through sockets</li><li class="listitem" style="list-style-type: disc">Detecting faces and eyes through a camera stream</li><li class="listitem" style="list-style-type: disc">Streaming camera frames for template matching</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec125"/>Introduction</h1></div></div></div><div><img src="img/ch10.jpg" alt="Introduction"/></div><p>It's fairly easy to first collect data and then analyze it later. However, doing both steps together may be necessary for some tasks. The gratifying nature of analyzing data the moment it is received is the core subject of this chapter. We will cover how to manage real-time data input from Twitter tweets, Internet Relay Chat (IRC), web servers, file-change notifications, sockets, and webcams.</p><p>The first three recipes will focus on dealing with real-time data from Twitter. These topics will include streaming posts by users as well as posts related to keywords.</p><p>Next, we will use two separate libraries to interact with IRC servers. The first recipe will demonstrate how to join an IRC chat room and start listening for messages, and the next recipe will show us how to listen for direct messages on an IRC server.</p><p>If real-time data is not supported, a common fallback is to query for that data often. This process is calling<a id="id595" class="indexterm"/> <strong>polling</strong>, and we will learn a quick way to poll a web server in one of the recipes.</p><p>We will also detect changes in a file directory when a file is modified, deleted, or created. Imagine implementing Dropbox, OneDrive, or Google Drive in Haskell.</p><p>Finally, we will create a simple server-client interaction with sockets and play around with real-time webcam streams.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec126"/>Streaming Twitter for real-time sentiment analysis</h1></div></div></div><p>Twitter is flooded <a id="id596" class="indexterm"/>with content that arrives every second. A great way to start investigating real-time data is by examining tweets.</p><p>This recipe will show <a id="id597" class="indexterm"/>how to write code that reacts to tweets relating to a specific search query. We use an external web-endpoint to determine whether the sentiment is positive, neutral, or negative.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec348"/>Getting ready</h2></div></div></div><p>Install<a id="id598" class="indexterm"/> the <code class="literal">twitter-conduit</code> package:</p><div><pre class="programlisting">
<strong>$ cabal install twitter-conduit</strong>
</pre></div><p>For parsing JSON, let's use <code class="literal">yocto</code>:</p><div><pre class="programlisting">
<strong>$ cabal install yocto</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec349"/>How to do it…</h2></div></div></div><p>Follow these <a id="id599" class="indexterm"/>steps to set up the Twitter credentials and begin coding:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Twitter app by navigating to <a class="ulink" href="https://apps.twitter.com">https://apps.twitter.com</a>.</li><li class="listitem">Find the <a id="id600" class="indexterm"/>OAuth Consumer Key and OAuth Consumer Secret <a id="id601" class="indexterm"/>from this Twitter Application Management page. Set the environmental variables on our system for <code class="literal">OAUTH_CONSUMER_KEY</code> and <code class="literal">OAUTH_CONSUMER_SECRET</code> respectively. Most Unix-based systems with sh-compatible shells support the <code class="literal">export</code> command:<div><pre class="programlisting">
<strong>$ export OAUTH_CONSUMER_KEY="Your OAuth Consumer Key"</strong>
<strong>$ export OAUTH_CONSUMER_SECRET="Your OAuth Consumer Secret"</strong>
</pre></div></li><li class="listitem">Moreover, find the OAuth Access Token and OAuth Access Secret through the same Twitter Application Management page and set the environmental variables accordingly:<div><pre class="programlisting">
<strong>$ export OAUTH_ACCESS_TOKEN="Your OAuth Access Token"</strong>
<strong>$ export OAUTH_ACCESS_SECRET="Your OAuth Access Secret"</strong>
</pre></div><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>We put our keys, tokens, and secret pins in the environmental variables instead of simply hardcoding them into the program because these variables are as important as passwords. Just like passwords should never be publicly visible, we try our best to keep these tokens and keys out of direct reach from the source code.</p></div></div></li><li class="listitem">Download<a id="id602" class="indexterm"/> the <code class="literal">Common.hs</code> file from the sample directory of the <code class="literal">twitter-conduit</code> package, which is located at <a class="ulink" href="https://github.com/himura/twitter-conduit/tree/master/sample">https://github.com/himura/twitter-conduit/tree/master/sample</a>. Study the <code class="literal">userstream.hs</code> sample file.</li><li class="listitem">First, we <a id="id603" class="indexterm"/>import all the relevant libraries:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}

import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.Text.IO as T
import qualified Data.Text as T

import Control.Monad.IO.Class (liftIO)
import Network.HTTP (getResponseBody, getRequest, simpleHTTP, urlEncode)
import Text.JSON.Yocto
import Web.Twitter.Conduit (stream, statusesFilterByTrack)
import Common
import Control.Lens ((^!), (^.), act)
import Data.Map ((!))
import Data.List (isInfixOf, or)
import Web.Twitter.Types </pre></div></li><li class="listitem">In <code class="literal">main</code>, run our real-time sentiment analyzer for a search query:<div><pre class="programlisting">main :: IO ()

main = do
  let query = "haskell"
  T.putStrLn $ T.concat [ "Streaming Tweets that match \""
                        , query, "\"..."]
  analyze query</pre></div></li><li class="listitem">Tap into the Twitter real-time stream with our Twitter API credentials by using the <code class="literal">runTwitterFromEnv'</code> function<a id="id604" class="indexterm"/> provided by the <code class="literal">Common</code> module. We will use some crazy syntax such as <code class="literal">$$+-</code> or <code class="literal">^!</code>. Please do not be intimidated by them. They're mainly used for  succinctness. Every time an event is triggered, such as a new tweet or a new follow, we will call our <code class="literal">process</code> function on it:<div><pre class="programlisting">analyze :: T.Text -&gt; IO ()

analyze query = runTwitterFromEnv' $ do
  src &lt;- stream $ statusesFilterByTrack query
  src C.$$+- CL.mapM_ (^! act (liftIO . process))</pre></div></li><li class="listitem">Once we <a id="id605" class="indexterm"/>have our event-triggered input, we will <a id="id606" class="indexterm"/>run <code class="literal">process</code> to obtain an output, such as discovering the sentiment of a text. In this example, we append the sentiment output to a comma-separated file:<div><pre class="programlisting">process :: StreamingAPI -&gt; IO ()

process (SStatus s) = do
  let theUser = userScreenName $ statusUser s
  let theTweet = statusText s
  T.putStrLn $ T.concat [theUser, ": ", theTweet]
  val &lt;- sentiment $ T.unpack theTweet
  let record = (T.unpack theUser) ++ "," ++ 
               (show.fromRational) val ++ "\n"
  appendFile "output.csv" record
  print val</pre></div></li><li class="listitem">If the <a id="id607" class="indexterm"/>event-triggered input is not a tweet but instead a friendship event or something else, do nothing:<div><pre class="programlisting">process s = return ()</pre></div></li><li class="listitem">Define a helper function to clean up the input by removing all <code class="literal">@user</code> mentions, <code class="literal">#hashtags</code>, or <code class="literal">http://websites</code>:<div><pre class="programlisting">clean :: String -&gt; String

clean str = unwords $ filter 
            (\w -&gt; not (or 
                   [ isInfixOf "@" w
                   , isInfixOf "#" w
                   , isInfixOf "http://" w ]))
            (words str)</pre></div></li><li class="listitem">Use an external API to run the sentiment analysis on a body of text. In this example, we use the Sentiment140 API because of its ease and simplicity. Please see <a class="ulink" href="http://help.sentiment140.com/api">http://help.sentiment140.com/api</a> for more information. To prevent getting rate-limited, also supply the <code class="literal">appid</code> parameter with an e-mail address or obtain a commercial license:<div><pre class="programlisting">sentiment :: String -&gt; IO Rational
sentiment str = do 
  let baseURL = "http://www.sentiment140.com/api/classify?text="
  resp &lt;- simpleHTTP $ getRequest $ 
          baseURL ++ (urlEncode.clean) str
  body &lt;- getResponseBody resp
  let p = polarity (decode body) / 4.0
  return p</pre></div></li><li class="listitem">Extract the sentiment value from the JSON response from our API:<div><pre class="programlisting">polarity :: Value -&gt; Rational

polarity (Object m) = polarity' $ m ! "results"
  where polarity' (Object m) = fromNumber $ m ! "polarity"
        fromNumber (Number n) = n
polarity _ = -1</pre></div></li><li class="listitem">Run the <a id="id608" class="indexterm"/>code to see tweets <a id="id609" class="indexterm"/> displayed right as they are posted publicly by anyone worldwide. The sentiment value will be a rational number between 0 and 1, where 0 is a negative sentiment and 1 is a positive sentiment:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
<strong>Streaming Tweets that match "x-men"…</strong>
</pre></div><p>Have a look at the following output:</p><div><img src="img/6331OS_10_01.jpg" alt="How to do it…"/></div></li></ol></div><p>We can also analyze the data in bulk from the <code class="literal">output.csv</code> file. Here's a visual representation of the sentiments:</p><div><img src="img/6331OS_10_02.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec350"/>How it works…</h2></div></div></div><p>The Twitter-conduit <a id="id610" class="indexterm"/>package uses the conduit design pattern from the original package placed at <a class="ulink" href="https://hackage.haskell.org/package/conduit">https://hackage.haskell.org/package/conduit</a>. The<a id="id611" class="indexterm"/> conduit documentation states:</p><p><em>Conduit is a solution to the streaming data problem, allowing for production, transformation, and consumption of streams of data in constant memory. It is an alternative to lazy I/O which guarantees deterministic resource handling, and fits in the same general solution space as enumerator/iteratee and pipes.</em></p><p>To interact with Twitter's Application Programming Interface (API), it is necessary to obtain the access and application tokens and keys. We store these values in our environment variables and let the Haskell code retrieve it from there.</p><p>The <code class="literal">Common.hs</code> file takes care of monotonous authentication code, which should be left untouched.</p><p>The function that reacts to each Twitter event <a id="id612" class="indexterm"/>is <code class="literal">process</code>. We can modify <code class="literal">process</code> to accompany our specific needs. More specifically, we can modify the sentiment function to use a different <code class="literal">sentiment</code> analysis service.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec351"/>There's more…</h2></div></div></div><p>Our code listens to any tweets that match our query. This Twitter-conduit library also supports two other real-time streams: <code class="literal">statusesFilterByFollow</code> and <code class="literal">userstream</code>. The former retrieves all tweets from a list of prescribed users. The latter retrieves all tweets from the users that the account follows.</p><p>For example, modify our code by replacing the <code class="literal">statusesFilterByTrack</code> query with the UIDs of some Twitter users:</p><div><pre class="programlisting">analyze:: IO ()
analyze = runTwitterFromEnv' $ do
  <strong>src &lt;- statusesFilterByFollow [ 103285804, 450331119</strong>
                                , <strong>64895420]</strong>
  src C.$$+- CL.mapM_ (^! act (liftIO . process))</pre></div><p>Moreover, to only retrieve tweets from the users that we are following, we can instead modify our code by replacing the <code class="literal">statusesFilterByTrack</code> query with <code class="literal">userstream</code>:</p><div><pre class="programlisting">analyze :: IO ()
analyze = runTwitterFromEnv' $ do
  <strong>src &lt;- stream userstream</strong>
  src C.$$+- CL.mapM_ (^! act (liftIO . process))</pre></div><p>Many more examples can be found through <a class="ulink" href="https://github.com/himura/twitter-conduit/tree/master/sample">https://github.com/himura/twitter-conduit/tree/master/sample</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec127"/>Reading IRC chat room messages</h1></div></div></div><p>The Internet Relay Chat (IRC) is<a id="id613" class="indexterm"/> one of the <a id="id614" class="indexterm"/>oldest and most vibrant group chat room services out there. The Haskell community has a substantially welcoming presence on the Freenode IRC server (<code class="literal">irc.freenode.org</code>) in the <code class="literal">#haskell</code> channel. </p><p>In this recipe, we will build an IRC bot that joins a room and listens to text conversations. Our program will emulate an IRC client and connect to one of the many existing IRC servers. This recipe requires no external libraries at all.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec352"/>Getting ready</h2></div></div></div><p>Make sure an Internet connection is enabled.</p><p>To test out the IRC bot, it helps to install an IRC client. For instance, one of the top IRC clients is <strong>Hexchat</strong>, which <a id="id615" class="indexterm"/>can be downloaded from <a class="ulink" href="http://hexchat.github.io">http://hexchat.github.io</a>. For a terminal-based IRC client, <strong>Irssi</strong><a id="id616" class="indexterm"/> is a favorite: <a class="ulink" href="http://www.irssi.org">http://www.irssi.org</a>.</p><p>Review the <em>Roll your own IRC bot</em> article on the Haskell wiki: <a class="ulink" href="http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot">http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot</a>. This recipe is heavily based on the code presented on the wiki.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec353"/>How to do it…</h2></div></div></div><p>In a new file<a id="id617" class="indexterm"/> called <code class="literal">Main.hs</code>, insert the following code:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant packages:<div><pre class="programlisting">import Network
import Control.Monad (forever)
import System.IO
import Text.Printf</pre></div></li><li class="listitem">Specify the IRC server specifics:<div><pre class="programlisting">server = "irc.freenode.org"
port   = 6667
chan   = "#haskelldata"
nick   = "awesome-bot"</pre></div></li><li class="listitem">Connect <a id="id618" class="indexterm"/>to the server and listen to all text being passed in a chat room:<div><pre class="programlisting">main = do
  h &lt;- connectTo server (PortNumber (fromIntegral port))
  hSetBuffering h NoBuffering
  write h "NICK" nick
  write h "USER" (nick++" 0 * :tutorial bot")
  write h "JOIN" chan
  listen h
 
write :: Handle -&gt; String -&gt; String -&gt; IO ()
write h s t = do
  hPrintf h "%s %s\r\n" s t
  printf    "&gt; %s %s\n" s t</pre></div></li><li class="listitem">Define our listener. For this recipe, we will just echo all events to the console:<div><pre class="programlisting">listen :: Handle -&gt; IO ()
listen h = forever $ do
  s &lt;- hGetLine h
  putStrLn s</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec354"/>See also</h2></div></div></div><p>To see another way to interact with IRC, see the next recipe, <em>Responding to IRC messages</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec128"/>Responding to IRC messages</h1></div></div></div><p>Another way to<a id="id619" class="indexterm"/> interact with IRC in Haskell is by using the <code class="literal">Network.SimpleIRC</code> package. This package encapsulates much of the low-level networking and also provides useful IRC interfaces.</p><p>In this recipe, we will respond to messages in a channel. If any user types in the trigger phrase, in our case "host?", then we will reply to that user with their host address.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec355"/>Getting ready</h2></div></div></div><p>Install the<a id="id620" class="indexterm"/> <code class="literal">Network.SimpleIRC</code> package:</p><div><pre class="programlisting">
<strong>$ cabal install simpleirc</strong>
</pre></div><p>To test out the IRC bot, it is helpful to install an IRC client. A decent IRC client is Hexchat, which can be downloaded from <a class="ulink" href="http://hexchat.github.io">http://hexchat.github.io</a>. For a terminal-based IRC client, Irssi is one of the best: <a class="ulink" href="http://www.irssi.org">http://www.irssi.org</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec356"/>How to do it…</h2></div></div></div><p>Create a new file, which we call <code class="literal">Main.hs</code>, and do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}

import Network.SimpleIRC
import Data.Maybe
import qualified Data.ByteString.Char8 as B</pre></div></li><li class="listitem">Create an <a id="id621" class="indexterm"/>event handler when a message is received. If the message is "host?", then reply to the user with information about their host:<div><pre class="programlisting">onMessage :: EventFunc
onMessage s m = do
  case msg of
    "host?" -&gt;  sendMsg s chan $ botMsg
    otherwise -&gt; return ()
  where chan = fromJust $ mChan m
        msg = mMsg m
        host = case mHost m of
          Just h -&gt; h
          Nothing -&gt; "unknown"
        nick = case mNick m of
          Just n -&gt; n
          Nothing -&gt; "unknown user"
        botMsg = B.concat [ "Hi ", nick, "
                          , your host is ", host]</pre></div></li><li class="listitem">Define on which events to listen:<div><pre class="programlisting">events = [(Privmsg onMessage)]</pre></div></li><li class="listitem">Set up the IRC server configuration. Connect to any list of channels and bind our event:<div><pre class="programlisting">freenode = 
  (mkDefaultConfig "irc.freenode.net" "awesome-bot")
  { cChannels = ["#haskelldata"]
  , cEvents   = events
  }</pre></div></li><li class="listitem">Connect to<a id="id622" class="indexterm"/> the server. Don't run in a new thread, but print debug messages, as specified by the corresponding Boolean parameters:<div><pre class="programlisting">main = connect freenode False True</pre></div></li><li class="listitem">Run the code, and open an IRC client to test it out:<div><img src="img/6331OS_10_03.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec357"/>See also</h2></div></div></div><p>To connect to an IRC server without using an external library, see the previous recipe, <em>Reading IRC chat room messages</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec129"/>Polling a web server for latest updates</h1></div></div></div><p>Some websites change<a id="id623" class="indexterm"/> dramatically very often. For instance, Google News and Reddit are usually loaded with recent postings the moment we refresh the page. To maintain the latest data at all times, it might be best to run an HTTP request often. </p><p>In this recipe, we poll new Reddit posts every 10 seconds as summarized in the following diagram:</p><div><img src="img/6331OS_10_04.jpg" alt="Polling a web server for latest updates"/></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec358"/>How to do it…</h2></div></div></div><p>In a new file <a id="id624" class="indexterm"/>called <code class="literal">Main.hs</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries:<div><pre class="programlisting">import Network.HTTP
import Control.Concurrent (threadDelay)
import qualified Data.Text as T</pre></div></li><li class="listitem">Define the URL to poll:<div><pre class="programlisting">url = "http://www.reddit.com/r/pics/new.json"</pre></div></li><li class="listitem">Define the function to obtain the latest data from an HTTP GET request:<div><pre class="programlisting">latest :: IO String

latest = simpleHTTP (getRequest url) &gt;&gt;= getResponseBody</pre></div></li><li class="listitem">Polling is simply the act of recursively conducting a task after waiting for a specified amount of time. In this case, we will wait 10 seconds before asking for the latest web data:<div><pre class="programlisting">poll :: IO a

poll = do
  body &lt;- latest
  print $ doWork body
  threadDelay (10 * 10^6)
  poll</pre></div></li><li class="listitem">Run the polling:<div><pre class="programlisting">main :: IO a
main = do
  putStrLn $ "Polling " ++ url ++ " …"
  poll</pre></div></li><li class="listitem">After<a id="id625" class="indexterm"/> each web request, analyze the data. In this recipe, count the number of times Imgur shows up:<div><pre class="programlisting">doWork str = length $ T.breakOnAll 
              (T.pack "imgur.com/") (T.pack str)</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec130"/>Detecting real-time file directory changes</h1></div></div></div><p>In this recipe, we will <a id="id626" class="indexterm"/>instantly detect when a new file is created, modified, or deleted. Similar to the popular file synchronization software Dropbox, we will be able to do interesting actions every time such an event occurs.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec359"/>Getting ready</h2></div></div></div><p>Install the<a id="id627" class="indexterm"/> <code class="literal">fsnotify</code> package:</p><div><pre class="programlisting">
<strong>$ cabal install fsnotify</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec360"/>How to do it…</h2></div></div></div><p>In a new file called <code class="literal">Main.hs</code>, perform these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries:<div><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}
import Filesystem.Path.CurrentOS
import System.FSNotify
import Filesystem
import Filesystem.Path (filename)</pre></div></li><li class="listitem">Run the file watcher on the current directory:<div><pre class="programlisting">main :: IO ()

main = do
  wd &lt;- getWorkingDirectory
  print wd

  man &lt;- startManager
  watchTree man wd (const True) doWork
  putStrLn "press return to stop"

  getLine
  putStrLn "watching stopped, press return to exit"

  stopManager man
  getLine
  return ()</pre></div></li><li class="listitem">Handle each<a id="id628" class="indexterm"/> of the file change events. In this recipe, we just print out the action to the console:<div><pre class="programlisting">doWork :: Event -&gt; IO ()  

doWork (Added filepath time) = 
  putStrLn $ (show $ filename filepath) ++ " added"
doWork (Modified filepath time) = 
  putStrLn $ (show $ filename filepath) ++ " modified"
doWork (Removed filepath time) = 
  putStrLn $ (show $ filename filepath) ++ " removed"</pre></div></li><li class="listitem">Run the code and start modifying some files in the same directory. For example, create a new file, edit it, and then remove it:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>press return to stop</strong>
<strong>FilePath "hello.txt" added</strong>
<strong>FilePath "hello.txt" modified</strong>
<strong>FilePath "hello.txt" removed</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec361"/>How it works…</h2></div></div></div><p>The <code class="literal">fsnotify</code> library <a id="id629" class="indexterm"/>binds to the event-notification services specific to a platform-specific filesystem. On Unix-based systems, this is usually <code class="literal">inotify</code> (<a class="ulink" href="http://dell9.ma.utexas.edu/cgi-bin/man-cgi?inotify">http://dell9.ma.utexas.edu/cgi-bin/man-cgi?inotify</a>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec131"/>Communicating in real time through sockets</h1></div></div></div><p>Sockets <a id="id630" class="indexterm"/>provide a convenient way of communicating<a id="id631" class="indexterm"/> between programs in real time. Think of them as a chat client.</p><p>In this recipe, we will pass messages from one program to another and obtain responses.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec362"/>How to do it…</h2></div></div></div><p>Insert the following code in a new file called <code class="literal">Main.hs</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the server code:<div><pre class="programlisting">import Network ( listenOn, withSocketsDo, accept
               , PortID(..), Socket )
import System.Environment (getArgs)
import System.IO ( hSetBuffering, hGetLine, hPutStrLn
                 , BufferMode(..), Handle )
import Control.Concurrent (forkIO)</pre></div></li><li class="listitem">Create a socket connection to listen on, and attach our handler, <code class="literal">sockHandler</code>, on it:<div><pre class="programlisting">main :: IO ()

main = withSocketsDo $ do
    let port = PortNumber 9001
    sock &lt;- listenOn port
    putStrLn $ "Listening…"
    sockHandler sock</pre></div></li><li class="listitem">Define the handler to process each message received:<div><pre class="programlisting">sockHandler :: Socket -&gt; IO ()

sockHandler sock = do
    (h, _, _) &lt;- accept sock
    putStrLn "Connected!"
    hSetBuffering h LineBuffering
    forkIO $ process h
    forkIO $ respond h
    sockHandler sock</pre></div></li><li class="listitem">Define how to process messages sent by the client:<div><pre class="programlisting">process :: Handle -&gt; IO ()
process h = do
    line &lt;- hGetLine h
    print line
    process h</pre></div></li><li class="listitem">Send messages to the client through user input:<div><pre class="programlisting">respond h = withSocketsDo $ do
  txt &lt;- getLine
  hPutStrLn h txt
  respond h</pre></div></li><li class="listitem">Now, create <a id="id632" class="indexterm"/>the client code in a new file, <code class="literal">client.hs</code>. First, import the libraries:<div><pre class="programlisting">import Network (connectTo, withSocketsDo, PortID(..))
import System.Environment (getArgs)
import System.IO ( hSetBuffering, hPutStrLn
                 , hGetLine, BufferMode(..) )</pre></div></li><li class="listitem">Connect <a id="id633" class="indexterm"/>the client to the corresponding port and set up the responder and listener threads:<div><pre class="programlisting">main = withSocketsDo $ do
  let port = PortNumber 9001
  h &lt;- connectTo "localhost" port
  putStrLn $ "Connected!"
  hSetBuffering h LineBuffering
  forkIO $ respond h
  forkIO $ process h
  loop</pre></div></li><li class="listitem">Get user input and send it as a message:<div><pre class="programlisting">respond h = do
  txt &lt;- getLine
  hPutStrLn h txt
  respond h</pre></div></li><li class="listitem">Listen to incoming messages from the server:<div><pre class="programlisting">process h = do
  line &lt;- hGetLine h
  print line
  process h</pre></div></li><li class="listitem">Test out the code by first running the server:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
</pre></div></li><li class="listitem">Next, on a separate terminal, run the client:<div><pre class="programlisting">
<strong>$ runhaskell client.hs</strong>
</pre></div></li><li class="listitem">We can now send messages between the two by typing and hitting <em>Enter</em>:<div><pre class="programlisting">
<strong>Hello?</strong>
<strong>"yup, I can hear you!"</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec363"/>How it works…</h2></div></div></div><p>The <code class="literal">hGetLine</code> function<a id="id634" class="indexterm"/> is blocking the code execution, which means that code execution halts at that point until a message is received. This allows us to wait for messages to conduct real-time reactions.</p><p>We first specify a port on the computer, which is simply a number that is not yet reserved by other programs. The server sets up the socket, and the client connects to it without needing to set it up. The messages passed between the two happen in real time.</p><p>A visualization of the server-client model is demonstrated in the following diagram:</p><div><img src="img/6331OS_10_05.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec132"/>Detecting faces and eyes through a camera stream</h1></div></div></div><p>The camera is<a id="id635" class="indexterm"/> another source for real-time data. As frames come and go, we can perform powerful analysis using the OpenCV library.</p><p>In this recipe, we conduct facial detection through a live camera stream.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec364"/>Getting ready</h2></div></div></div><p>Install the OpenCV, SDL, and FTGL libraries for image manipulation and computer vision:</p><div><pre class="programlisting">
<strong>sudo apt-get install libopencv-dev libsdl1.2-dev ftgl-dev</strong>
</pre></div><p>Install an OpenCV library using cabal:</p><div><pre class="programlisting">
<strong>cabal install cv-combinators</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec365"/>How to do it…</h2></div></div></div><p>Create a new <a id="id636" class="indexterm"/>source file, <code class="literal">Main.hs</code>, and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries:<div><pre class="programlisting">import AI.CV.ImageProcessors
import qualified AI.CV.OpenCV.CV as CV
import qualified Control.Processor as Processor
import Control.Processor ((--&lt;))
import AI.CV.OpenCV.Types (PImage)
import AI.CV.OpenCV.CxCore (CvRect(..), CvSize(..))
import Prelude hiding (id)
import Control.Arrow ((&amp;&amp;&amp;), (***))
import Control.Category ((&gt;&gt;&gt;), id)</pre></div></li><li class="listitem">Define the source of the camera stream. We will be using the built-in webcam. To instead use a video, we can replace <code class="literal">camera 0</code> with <code class="literal">videoFile "./myVideo.mpeg"</code>:<div><pre class="programlisting">captureDev :: ImageSource
captureDev = camera 0</pre></div></li><li class="listitem">Shrink the size of the stream for faster performance:<div><pre class="programlisting">resizer :: ImageProcessor
resizer = resize 320 240 CV.CV_INTER_LINEAR</pre></div></li><li class="listitem">Detect the faces in an image using the training dataset provided by OpenCV:<div><pre class="programlisting">faceDetect :: Processor.IOProcessor PImage [CvRect]

faceDetect = haarDetect  "/usr/share/opencv/haarcascades/haarcascade_frontalface_alt.xml" 1.1 3 CV.cvHaarFlagNone (CvSize 20 20)</pre></div></li><li class="listitem">Detect the eyes in the image using the training data set provided by OpenCV:<div><pre class="programlisting">eyeDetect :: Processor.IOProcessor PImage [CvRect]
eyeDetect = haarDetect "/usr/share/opencv/haarcascades/haarcascade_eye.xml" 1.1 3 CV.cvHaarFlagNone (CvSize 20 20)</pre></div></li><li class="listitem">Draw rectangles around faces and eyes:<div><pre class="programlisting">faceRects = (id &amp;&amp;&amp; faceDetect) &gt;&gt;&gt; drawRects

eyeRects = (id &amp;&amp;&amp; eyeDetect) &gt;&gt;&gt; drawRects</pre></div></li><li class="listitem">Capture<a id="id637" class="indexterm"/> the camera's stream, detect the faces and eyes, draw rectangles, and display them in two different windows:<div><pre class="programlisting">start = captureDev &gt;&gt;&gt; resizer --&lt; (faceRects *** eyeRects) 
             &gt;&gt;&gt; (window 0 *** window 1)</pre></div></li><li class="listitem">Perform the real-time camera streaming and stop once a key is pressed:<div><pre class="programlisting">main :: IO ()
main = runTillKeyPressed start</pre></div></li><li class="listitem">Run the code and look at the webcam to detect faces and eyes as shown in the screenshot that follows this command:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
</pre></div><div><img src="img/6331OS_10_06.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec366"/>How it works…</h2></div></div></div><p>To detect faces, eyes, or other objects, we <a id="id638" class="indexterm"/>use the <code class="literal">haarDetect</code> function, which performs a classifier trained from many positive and negative test cases. These test cases are provided by OpenCV and are typically located in <code class="literal">/usr/share/opencv/haarcascades/</code> on Unix-based systems.</p><p>The cv-combinator library provides a convenient abstraction to OpenCV's low-level manipulations. To run any useful code, we must define a source, a process, and a final destination (also referred to as a <em>sink</em>). In our case, the source was the machine's built-in camera. We first resize the image to something<a id="id639" class="indexterm"/> more manageable (<code class="literal">resizer</code>), split the stream into two in parallel (<code class="literal">--&lt;</code>), draw boxes around faces in one while drawing boxes around eyes in the other, and finally output the streams to two separate windows. For more documentation of the cv-combinators package, see <a class="ulink" href="https://hackage.haskell.org/package/cv-combinators">https://hackage.haskell.org/package/cv-combinators</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec133"/>Streaming camera frames for template matching</h1></div></div></div><p>Template matching<a id="id640" class="indexterm"/> is a machine-learning technique to find areas of <a id="id641" class="indexterm"/>an image that match a given template image. We<a id="id642" class="indexterm"/> will apply template matching to every frame of a real-time video stream to locate an image.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec367"/>Getting ready</h2></div></div></div><p>Install the <a id="id643" class="indexterm"/>OpenCV and <a id="id644" class="indexterm"/>c2hs toolkits:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install c2hs libopencv-dev</strong>
</pre></div><p>Install the CV library from cabal. Be sure to include the <code class="literal">–fopencv24</code> or <code class="literal">–fopencv23</code> parameter depending on which version of OpenCV is installed:</p><div><pre class="programlisting">
<strong>$ cabal install CV -fopencv24</strong>
</pre></div><p>Also, create a small template image. In this recipe, we use an image of Lena, which is usually used in many image-processing experiments. We name this image file <code class="literal">lena.png</code>:</p><div><img src="img/6331OS_10_07.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec368"/>How to do it…</h2></div></div></div><p>In a new <a id="id645" class="indexterm"/>file, <code class="literal">Main.hs</code>, start with these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant libraries:<div><pre class="programlisting">{-#LANGUAGE ScopedTypeVariables#-}
module Main where
import CV.Image (loadImage, rgbToGray, getSize)
import CV.Video (captureFromCam, streamFromVideo)
import Utils.Stream (runStream_, takeWhileS, sideEffect)
import CV.HighGUI (showImage, waitKey)
import CV.TemplateMatching ( simpleTemplateMatch
                           , MatchType(..) )
import CV.ImageOp ((&lt;#))
import CV.Drawing (circleOp, ShapeStyle(..))</pre></div></li><li class="listitem">Load the template<a id="id646" class="indexterm"/> image and start the template matching on a camera stream:<div><pre class="programlisting">main = do
  Just t &lt;- loadImage "lena.jpg"
  Just c &lt;- captureFromCam 0
  runStream_ . sideEffect (process t) . 
    takeWhileS (\_ -&gt; True) $ streamFromVideo c</pre></div></li><li class="listitem">Perform an action on each frame of the camera stream. Specifically, use template matching to locate the template and draw a circle around it:<div><pre class="programlisting">process t img = do
  let gray = rgbToGray img
  let ((mx, my), _) = 
    simpleTemplateMatch CCOEFF_NORMED gray t
  let circleSize = (fst (getSize t)) `div` 2
  let circleCenter = (mx + circleSize, my + circleSize)
  showImage "test" (img &lt;# circleOp (0,0,0) 
    circleCenter circleSize (Stroked 3))
  waitKey 100
  return ()</pre></div></li><li class="listitem">Run the code using the following command and show an image of the template. A black circle will be drawn around the found image:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
</pre></div><div><img src="img/6331OS_10_08.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec369"/>There's more…</h2></div></div></div><p>More OpenCV examples<a id="id647" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/aleator/CV/tree/master/examples">https://github.com/aleator/CV/tree/master/examples</a>. </p></div></div></body></html>