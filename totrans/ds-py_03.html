<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Accelerate your Data Analysis with Python Libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Accelerate your Data Analysis with Python Libraries</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>"Every vision is a joke until the first man accomplishes it; once realized, it becomes commonplace."</p></blockquote></div><p>                                                                                          – <span class="emphasis"><em>Robert H Goddard</em></span>
</p><p>In this chapter, we will do a technical deep dive into the PixieApp framework. You will be able to use the following information both as a <span class="emphasis"><em>Getting Started</em></span> tutorial and as reference documentation for the PixieApp programming model.</p><p>We will start with a high-level description of the anatomy of a PixieApp before diving in to its foundational concepts, such as routes and requests. To help follow along, we will incrementally build a <span class="emphasis"><em>GitHub Tracking</em></span> sample application that applies the capabilities and best practices as they are being introduced, starting from building the data analytics to integrating them into the PixieApp.</p><p>By the end of this chapter, you should be able to apply the lessons learned to your own use case, including writing your own PixieApp.</p><div class="section" title="Anatomy of a PixieApp"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Anatomy of a PixieApp
</h1></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The PixieApp programming model doesn't require any prior experience with JavaScript, however, it is expected that the reader is familiar with the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Python (<a class="ulink" href="https://www.python.org">https://www.python.org</a>)</li><li class="listitem" style="list-style-type: disc">HTML5 (<a class="ulink" href="https://www.w3schools.com/html">https://www.w3schools.com/html</a>)</li><li class="listitem" style="list-style-type: disc">CSS3 (<a class="ulink" href="https://www.w3schools.com/css">https://www.w3schools.com/css</a>)</li></ul></div></div></div><p>The <a id="id137" class="indexterm"/>term <span class="strong"><strong>PixieApp</strong></span> stands for <span class="strong"><strong>Pixie Application,</strong></span> and is <a id="id138" class="indexterm"/>meant to emphasize its tight integration with the PixieDust capabilities, especially the <code class="literal">display()</code> API. Its main goal is to make it easy for developers to build a user interface that can invoke the data analytics implemented in the Jupyter Notebook.</p><p>A PixieApp follows the <span class="strong"><strong>single-page application</strong></span> (<span class="strong"><strong>SPA</strong></span>) design pattern (<a class="ulink" href="https://en.wikipedia.org/wiki/Single-page_application">https://en.wikipedia.org/wiki/Single-page_application</a>), where the user is presented <a id="id139" class="indexterm"/>with a welcome screen that is dynamically updated to respond to a user interaction. An update can be a partial refresh, such as updating <a id="id140" class="indexterm"/>a graph after the user clicks on a control or a full refresh, such as a new screen in a multistep process. In each case, the update is controlled on the server side by a route that is triggered using a specific mechanism that we'll discuss later. When triggered, the route executes code to handle the request and then emits an HTML fragment, which is applied to the right target DOM element (<a class="ulink" href="https://www.w3schools.com/js/js_htmldom.asp">https://www.w3schools.com/js/js_htmldom.asp</a>) on the client side.</p><p>The following sequence diagram shows how the client side and server side interact with each other when running a PixieApp:</p><div class="mediaobject"><img src="Images/B09699_03_01.jpg" alt="Anatomy of a PixieApp" width="1000" height="573"/><div class="caption"><p>Sequence diagram showing the information flow of a PixieApp</p></div></div><p>When the PixieApp is started (by calling the <code class="literal">run</code> method), the default route is invoked, and the corresponding HTML fragment is returned. As the user interacts with the application, more requests are executed, triggering the associated routes which refresh the UI accordingly.</p><p>From an implementation perspective, a PixieApp is simply a regular Python class that has been decorated with the <code class="literal">@PixieApp</code> decorator. Under the cover, the <code class="literal"> PixieApp</code> decorator <a id="id141" class="indexterm"/>instruments the class to add methods and fields required to run the app, such as the <code class="literal">run</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>More information on Python decorators can be found here:</p><p>
<a class="ulink" href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</p></div></div><p>To get <a id="id142" class="indexterm"/>things started, the following code shows a simple <span class="emphasis"><em>Hello World</em></span> PixieApp:</p><div class="informalexample"><pre class="programlisting">#import the pixieapp decorators
from pixiedust.display.app import *

@PixieApp   #decorator for making the class a PixieApp
class HelloWorldApp():
    @route()  #decorator for making a method a route (no arguments means default route)
    def main_screen(self):
        return """&lt;div&gt;Hello World&lt;/div&gt;"""

#Instantiate the application and run it
app = HelloWorldApp()
app.run()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>You can find the code here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py</a>
</p></div></div><p>The preceding code shows the structure of a PixieApp, how to define the routes, and how to instantiate and run the app. Because PixieApps are regular Python classes, they can inherit from other classes, including other PixieApps, which is convenient for larger projects to make the code modular and reusable.</p><div class="section" title="Routes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec06"/>Routes</h2></div></div></div><p>Routes are <a id="id143" class="indexterm"/>used to dynamically update all or part of the client screen. They can be easily defined by using the <code class="literal">@route</code> decorator on any class method, based on the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A route method is required to return a string that represents the HTML fragment for the update.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: CSS and JavaScript are allowed to be used in the fragment.</p></div></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">@route</code> decorator can have one or more keyword arguments, which are required to be of the String type. These keyword arguments can be thought of as request parameters, which are used internally by the PixieApp framework to dispatch <a id="id144" class="indexterm"/>the request to the route that is the best match according to the following rules:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The routes with most arguments are always evaluated first.</li><li class="listitem" style="list-style-type: disc">All arguments must match for a route to be selected.</li><li class="listitem" style="list-style-type: disc">If the route is not found, then the default route is selected as a fallback.</li><li class="listitem" style="list-style-type: disc">Routes can be configured using a wildcard, that is, <code class="literal">*</code>, in which case, any value for the state argument will be a match.<p>Following is an example:</p><div class="informalexample"><pre class="programlisting">       @route(state1="value1", state2="value2")</pre></div></li></ul></div></li><li class="listitem" style="list-style-type: disc">A PixieApp is required to have one, and only one, default route, which is a route with no argument, that is, <code class="literal">@route()</code>.</li></ul></div><p>It is very important to configure the routes in a way that doesn't cause conflict, especially if your application has hierarchical states. For example, a route associated with <code class="literal">state1="load"</code> could be responsible for loading data and then a second route associated with <code class="literal">(state1="load", state2="graph")</code> could be responsible for plotting the data. In this case, a request with both <code class="literal">state1</code> and <code class="literal">state2</code> specified will match the second route because route evaluation happens from most specific to least specific, stopping at the first matching route.</p><p>To clarify, the following diagram shows how requests are matched with routes:</p><div class="mediaobject"><img src="Images/B09699_03_02.jpg" alt="Routes" width="1000" height="552"/><div class="caption"><p>Matching requests to routes</p></div></div><p>The expected <a id="id145" class="indexterm"/>contract for a method defined as a route is to return an HTML fragment, which can contain Jinja2 templating constructs. Jinja2 is a powerful Python template engine that provides a rich set of features to dynamically generate text, including access to Python variables, methods, and control structures, such as <code class="literal">if...else</code>,<code class="literal"> the for</code> loop, and so on. Covering all its features would be <a id="id146" class="indexterm"/>beyond the scope of this book, but let's discuss a few important constructs that are used frequently:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: If you want to know more about Jinja2, you can read the full documentation here:</p><p>
<a class="ulink" href="http://jinja.pocoo.org/docs/templates">http://jinja.pocoo.org/docs/templates</a>
</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Variables</strong></span>: You can <a id="id147" class="indexterm"/>use the double-curly braces to access variables that are in scope, for example, <code class="literal">"&lt;div&gt;This is my variable {{my_var}}&lt;/div&gt;"</code>. During rendering, the <code class="literal">my_var</code> variable will be replaced with its actual value. You can also use the <code class="literal">.</code> (dot) notation to access complex object, for example, <code class="literal">"&lt;div&gt;This is a nested value {{my_var.sub_value}}&lt;/div&gt;"</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>for loop</strong></span>: You <a id="id148" class="indexterm"/>can use the <code class="literal">{%for ...%}...{%endfor%}</code> notation to dynamically generate text by iterating over a sequence of items (list, tuple, dictionary, and so on), as in the example:<div class="informalexample"><pre class="programlisting">{%for message in messages%}
&lt;li&gt;{{message}}&lt;/li&gt;
{%endfor%}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>if statement</strong></span>: You <a id="id149" class="indexterm"/>can use the <code class="literal">{%if ...%}...{%elif ...%}...{%else%}…{%endif%}</code> notation to conditionally output text, as in the example:<div class="informalexample"><pre class="programlisting">{%if status.error%}
&lt;div class="error"&gt;{{status.error}}&lt;/div&gt;
{%elif status.warning%}
&lt;div class="warning"&gt;{{status.warning}}&lt;/div&gt;
{%else%}
&lt;div class="ok"&gt;{{status.message}}&lt;/div&gt;
{%endif%}</pre></div></li></ul></div><p>It is also important to know how variables and methods come into the scope of the JinJa2 template string returned by the route. PixieApp automatically provides access to three types of variables and methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Class variables and methods</strong></span>: These are <a id="id150" class="indexterm"/>accessible using the <code class="literal">this</code> keyword.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The reason we're not using the more Pythonic <code class="literal">self</code> keyword is that it is unfortunately already taken by Jinja2 itself.</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Method arguments</strong></span>: This is <a id="id151" class="indexterm"/>useful when the route arguments use the <code class="literal">*</code> value and you want to have access to that value at runtime. In this case, you can add arguments to the method itself using the same name as the one defined in the route arguments and the PixieApp framework will automatically pass the correct value.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The order of the arguments actually doesn't matter. You also do not have to use every argument defined in the route, which is convenient if you are only interested in using a subset of the arguments.</p></div></div><p>The variable will also be in the scope of the Jinja2 template string, as shown in the example:</p><div class="informalexample"><pre class="programlisting">@route(state1="*", state2="*")
def my_method(self, state1, state2):
    return "&lt;div&gt;State1 is {{state1}}. State2 is {{state2}}&lt;/div&gt;"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py</a>
</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Local variables to the method</strong></span>: PixieApp will automatically put all the local variables <a id="id152" class="indexterm"/>defined in the method in scope of the Jinja2 template string, provided that you add the <code class="literal">@templateArgs</code> decorator to the method, as shown in the example:<div class="informalexample"><pre class="programlisting">@route()
@templateArgs
def main_screen(self):
    var1 = self.compute_something()
    var2 = self.compute_something_else()
    return "&lt;div&gt;var1 is {{var1}}. var2 is {{var2}}&lt;/div&gt;"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>You can find the code here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py</a>
</p></div></div></li></ul></div></div><div class="section" title="Generating requests to routes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec07"/>Generating requests to routes</h2></div></div></div><p>As mentioned <a id="id153" class="indexterm"/>before, PixieApp follows the SPA design pattern. After the first screen is loaded, all subsequent interactions with the server are done using dynamic requests as opposed to URL links as is the case for multipage web applications. There are three ways to generate a kernel request to a route:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the <code class="literal">pd_options</code> custom attribute to define a list of states to be passed to the server, as in the following example:<div class="informalexample"><pre class="programlisting">pd_options="state1=value1;state2=value2;..;staten=valuen"</pre></div></li><li class="listitem" style="list-style-type: disc">If you already have a JSON object that contains the <code class="literal">pd_options</code> value—as in the case of invoking <code class="literal">display()</code>—you would have to transform it into the format expected by the <code class="literal">pd_options</code> HTML attribute, which can be time-consuming. In this case, it is more convenient to specify <code class="literal">pd_options</code> as a child element, which allows the options to be passed directly as a JSON object (and avoid the extra work of transforming the data), as in the following example:<div class="informalexample"><pre class="programlisting">&lt;div&gt;
    &lt;pd_options&gt;
        {"state1":"value1","state2":"value2",...,
        "staten":"valuen"}
    &lt;/pd_options&gt;
&lt;/div&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Programmatically by calling the <code class="literal">invoke_route</code> method, as in the following example:<div class="informalexample"><pre class="programlisting">self.invoke_route(self.route_method, state1='value1', state2='value2')</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: Remember to use <code class="literal">this</code>, as opposed to <code class="literal">self</code>, if you are calling this method from a Jinja2 template string, as <code class="literal">self</code> is already used by Jinja2 itself.</p></div></div><p>When <a id="id154" class="indexterm"/>the state values passed in <code class="literal">pd_options</code> need to be dynamically computed based on user selections, you need to use the <code class="literal">$val(arg)</code> special directive, which acts as a macro that will be resolved at the time the kernel request is executed.</p><p>The <code class="literal">$val(arg)</code> directive takes one argument that can be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ID of an HTML element on the page, such as an input or a combobox, as in the following example:<div class="informalexample"><pre class="programlisting">&lt;div&gt;
    &lt;pd_options&gt;
        {"state1":"$val(my_element_id)","state2":"value2"}
    &lt;pd_options&gt;
&lt;/div&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">A JavaScript function that must return the desired value, as in the following example:<div class="informalexample"><pre class="programlisting">&lt;script&gt;
    function resValue(){
            return "my_query";
    }
&lt;/script&gt;
...
&lt;div pd_options="state1=$val(resValue)"&gt;&lt;/div&gt;</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: Dynamic value using the <code class="literal">$val</code> directive are supported by most of the PixieDust custom attributes.</p></div></div></div><div class="section" title="A GitHub project tracking sample application"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec08"/>A GitHub project tracking sample application</h2></div></div></div><p>Let's apply <a id="id155" class="indexterm"/>what we learned so far to implementing the sample application. To try things out, we want to use the GitHub Rest APIs (<a class="ulink" href="https://developer.github.com/v3">https://developer.github.com/v3</a>) to search for projects and load the results into a pandas DataFrame for analysis.</p><p>The initial code shows the welcome screen with a simple input box to enter the GitHub query and <a id="id156" class="indexterm"/>a button to submit the request:</p><div class="informalexample"><pre class="programlisting">from pixiedust.display.app import *

@PixieApp
class GitHubTracking():
    @route()
    def main_screen(self):
        return """
&lt;style&gt;
    div.outer-wrapper {
        display: table;width:100%;height:300px;
    }
    div.inner-wrapper {
        display: table-cell;vertical-align: middle;height: 100%;width: 100%;
    }
&lt;/style&gt;
&lt;div class="outer-wrapper"&gt;
    &lt;div class="inner-wrapper"&gt;
        &lt;div class="col-sm-3"&gt;&lt;/div&gt;
        &lt;div class="input-group col-sm-6"&gt;
            &lt;input id="query{{prefix}}" type="text" class="form-control" placeholder="Search projects on GitHub"&gt;
            &lt;span class="input-group-btn"&gt;
                &lt;button class="btn btn-default" type="button"&gt;Submit Query&lt;/button&gt;
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
"""

app = GitHubTracking()
app.run()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py</a>
</p></div></div><p>A few things to note from the preceding code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Bootstrap CSS framework (<a class="ulink" href="https://getbootstrap.com/docs/3.3">https://getbootstrap.com/docs/3.3</a>) and the jQuery JS framework (<a class="ulink" href="https://jquery.com">https://jquery.com</a>) are provided by the Jupyter <a id="id157" class="indexterm"/>Notebook. We can readily use <a id="id158" class="indexterm"/>them in our code without the need to install them.</li><li class="listitem" style="list-style-type: disc">Font <a id="id159" class="indexterm"/>Awesome icons (<a class="ulink" href="https://fontawesome.com">https://fontawesome.com</a>) are also available by default in the Notebook.</li><li class="listitem" style="list-style-type: disc">The PixieApp code could be executed in multiple cells of the Notebook. Since we're relying on DOM element IDs, it is important to make sure that two elements do not have the same ID which would cause undesirable side effects. To that end, it is recommended to always include the unique identifier <code class="literal">{{prefix}}</code>, provided by the PixieDust framework, for example, <code class="literal">"query{{prefix}}"</code>.</li></ul></div><p>The <a id="id160" class="indexterm"/>results are shown in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_03_03.jpg" alt="A GitHub project tracking sample application" width="1000" height="541"/><div class="caption"><p>Welcome screen of our GitHub Tracking application</p></div></div><p>The next step is to create a new route that takes the user value and returns the results. This route will be invoked by the <span class="strong"><strong>Submit Query</strong></span> button.</p><p>To keep things simple, the following code doesn't use a Python library to interface with GitHub, such as PyGithub (<a class="ulink" href="http://pygithub.readthedocs.io/en/latest">http://pygithub.readthedocs.io/en/latest</a>), instead, we'll directly call the REST APIs as documented in the GitHub website:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: When you see the following notation <code class="literal">[[GitHubTracking]]</code>, this means that the code is meant to be added to the <code class="literal">GitHubTracking</code> PixieApp class and, to avoid repeating the surrounding code over and over again, it has been omitted. When in doubt, you can always refer to the complete Notebook specified at the end of the section.</p></div></div><div class="informalexample"><pre class="programlisting">import requests
import pandas
[[GitHubTracking]]
@route(query="*")
@templateArgs
def do_search(self, query):
    response = requests.get( "https://api.github.com/search/repositories?q={}".format(query))
    frames = [pandas.DataFrame(response.json()['items'])]
    while response.ok and "next" in response.links:
        response = requests.get(response.links['next']['url'])
        frames.append(pandas.DataFrame(response.json()['items']))

    pdf = pandas.concat(frames)
    response = requests.get( "https://api.github.com/search/repositories?q={}".format(query))
    if not response.ok:
        return "&lt;div&gt;An Error occurred: {{response.text}}&lt;/div&gt;"
    return """&lt;h1&gt;&lt;center&gt;{{pdf|length}} repositories were found&lt;/center&gt;&lt;/h1&gt;"""</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py</a>
</p></div></div><p>In the <a id="id161" class="indexterm"/>preceding code, we created a route called <code class="literal">do_search</code> that takes one argument called <code class="literal">query</code>, which we use to build an API URL to GitHub. Using the <code class="literal">requests</code> Python module (<a class="ulink" href="http://docs.python-requests.org">http://docs.python-requests.org</a>) to issue a GET request to this URL, we get a JSON payload that we turn into a pandas DataFrame. According to the GitHub documentation, the Search API paginates with the next page being stored in the link's headers. The code uses a <code class="literal">while</code> loop to go over each link and load the next page into a new DataFrame. We then concatenate all the DataFrames into one called <code class="literal">pdf</code>. All we have left to do is build the HTML fragment that will display the results. The fragment uses the Jinja2 notation <code class="literal">{{...}}</code> to access the <code class="literal">pdf</code> variable defined as a local variable, which only works because we used the <code class="literal">@templateArgs</code> decorator in the <code class="literal">do_search</code> method. Notice that we also use a Jinja2 filter called <code class="literal">length</code> to display the number of repositories found: <code class="literal">{{pdf|length}}</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>For more information on filters, visit the following:</p><p>
<a class="ulink" href="http://jinja.pocoo.org/docs/templates/#filters">http://jinja.pocoo.org/docs/templates/#filters</a>
</p></div></div><p>We still <a id="id162" class="indexterm"/>need to invoke the <code class="literal">do_search</code> route when the user clicks on the <span class="strong"><strong>Submit Query</strong></span> button. For that, we add the <code class="literal">pd_options</code> attribute to the <code class="literal">&lt;button&gt;</code> element, as highlighted here:</p><div class="informalexample"><pre class="programlisting">&lt;div class="input-group col-sm-6"&gt;
    &lt;input id="query{{prefix}}" type="text"
     class="form-control"
     placeholder="Search projects on GitHub"&gt;
    &lt;span class="input-group-btn"&gt;
        &lt;button class="btn btn-default" type="button" <span class="strong"><strong>pd_options="query=$val(query{{prefix}})"&gt;</strong></span>
            Submit Query
        &lt;/button&gt;
    &lt;/span&gt;
&lt;/div&gt;</pre></div><p>We use the <code class="literal">$val()</code> directive in the <code class="literal">pd_options</code> attribute to dynamically retrieve the value of the input box with ID equals to <code class="literal">"query{{prefix}}"</code> and store it in the query argument.</p></div><div class="section" title="Displaying the search results in a table"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec09"/>Displaying the search results in a table</h2></div></div></div><p>The preceding <a id="id163" class="indexterm"/>code loads all the data at once, which is not recommended since we could have a huge number of hits. Similarly, displaying it all in one go would make the UI sluggish and non-practical. Thankfully, we can easily build a paginated table without too much effort, using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a route called <code class="literal">do_retrieve_page</code> that takes a URL as an argument and returns the HTML fragment for the table body</li><li class="listitem">Maintain the first, previous, next, and last URLs as fields in the PixieApp class</li><li class="listitem">Create a pagination widget (we'll use Bootstrap since it's available) with <code class="literal">First</code>, <code class="literal">Prev</code>, <code class="literal">Next</code>, and <code class="literal">Last</code> button</li><li class="listitem">Create a table placeholder with the columns headers to be displayed</li></ol></div><p>We'll now update the code for <code class="literal">do_search,</code> as follows:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The following code is referencing the <code class="literal">do_retrieve_page</code> method which we will define a little later. Please do not attempt to run this code as is until you also add the <code class="literal">do_retrieve_page</code> method.</p></div></div><div class="informalexample"><pre class="programlisting">[[GitHubTracking]]
@route(query="*")
@templateArgs
def do_search(self, query):
    self.first_url = "https://api.github.com/search/repositories?q={}".format(query)
    self.prev_url = None
    self.next_url = None
    self.last_url = None

    response = requests.get(self.first_url)
    if not response.ok:
        return "&lt;div&gt;An Error occurred: {{response.text}}&lt;/div&gt;"

    total_count = response.json()['total_count']
    self.next_url = response.links.get('next', {}).get('url', None)
    self.last_url = response.links.get('last', {}).get('url', None)
    return """
&lt;h1&gt;&lt;center&gt;{{total_count}} repositories were found&lt;/center&gt;&lt;/h1&gt;
&lt;ul class="pagination"&gt;
    &lt;li&gt;&lt;a href="#" pd_options="page=first_url" pd_target="body{{prefix}}"&gt;First&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="#" pd_options="page=prev_url" pd_target="body{{prefix}}"&gt;Prev&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="#" pd_options="page=next_url" pd_target="body{{prefix}}"&gt;Next&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="#" pd_options="page=last_url" pd_target="body{{prefix}}"&gt;Last&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="table"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Repo Name&lt;/th&gt;
            &lt;th&gt;Lastname&lt;/th&gt;
            &lt;th&gt;URL&lt;/th&gt;
            &lt;th&gt;Stars&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody id="body{{prefix}}"&gt;
        {{this.invoke_route(this.do_retrieve_page, page='first_url')}}
    &lt;/tbody&gt;
&lt;/table&gt;
"""</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py</a>
</p></div></div><p>The preceding code sample shows a very important property of PixieApps, which is that you can maintain state throughout the life cycle of the application by simply storing the data into class variables. In this case, we use <code class="literal">self.first_url</code>, <code class="literal">self.prev_url</code>, <code class="literal">self.next_url</code>, and <code class="literal">self.last_url</code>. These variables use the <code class="literal">pd_options</code> property for each button in the pagination widget and update each time the <code class="literal">do_retrieve_page</code> route is invoked. The fragment returned by <code class="literal">do_search</code> now returns a table <a id="id164" class="indexterm"/>with a placeholder for the body, identified by <code class="literal">body{{prefix}},</code> which becomes the <code class="literal">pd_target</code> for each button. We also use the <code class="literal">invoke_route</code> method to make sure that we get the first page when the table is first displayed.</p><p>We've seen before that the HTML fragment returned by a route is used to replace the entire page, but in the preceding code, we use the <code class="literal">pd_target="body{{prefix}}"</code> attribute to signify that the HTML fragment will be injected in the body element of the table that has the <code class="literal">body{{prefix}}</code> ID. If needed, you can also define multiple targets for a user action, by creating one or more <code class="literal">&lt;target&gt;</code> elements as children of the clickable source element. Each <code class="literal">&lt;target&gt;</code> element can itself use all the PixieApp custom attributes to configure kernel requests.</p><p>Here is an example:</p><div class="informalexample"><pre class="programlisting">&lt;button type="button"&gt;Multiple Targets
    &lt;target pd_target="elementid1" pd_options="state1=value1"&gt;&lt;/target&gt;
    &lt;target pd_target="elementid2" pd_options="state2=value2"&gt;&lt;/target&gt;
&lt;/button&gt;</pre></div><p>Back to our GitHub sample application, the <code class="literal">do_retrieve_page</code> method now looks like this:</p><div class="informalexample"><pre class="programlisting">[[GitHubTracking]]
@route(page="*")
@templateArgs
def do_retrieve_page(self, page):
    url = getattr(self, page)
    if url is None:
        return "&lt;div&gt;No more rows&lt;/div&gt;"
    response = requests.get(url)
    self.prev_url = response.links.get('prev', {}).get('url', None)
    self.next_url = response.links.get('next', {}).get('url', None)
    items = response.json()['items']
    return """
{%for row in items%}
&lt;tr&gt;
    &lt;td&gt;{{row['name']}}&lt;/td&gt;
    &lt;td&gt;{{row.get('owner',{}).get('login', 'N/A')}}&lt;/td&gt;
    &lt;td&gt;&lt;a href="{{row['html_url']}}" target="_blank"&gt;{{row['html_url']}}&lt;/a&gt;&lt;/td&gt;
    &lt;td&gt;{{row['stargazers_count']}}&lt;/td&gt;
&lt;/tr&gt;
{%endfor%}
        """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py</a>
</p></div></div><p>The <code class="literal">page</code> argument <a id="id165" class="indexterm"/>is a string that contains the name of the <code class="literal">url</code> class variable we want to display. We use the standard <code class="literal">getattr</code> Python function (<a class="ulink" href="https://docs.python.org/2/library/functions.html#getattr">https://docs.python.org/2/library/functions.html#getattr</a>) to get the <code class="literal">url</code> value from the page. We then issue a GET request on the GitHub API <code class="literal">url</code> to retrieve the payload as JSON format which we pass to the Jinja2 template to generate the set of rows that will be injected in the table. For that, we use the <code class="literal">{%for…%}</code> loop control structure available in Jinja2 (<a class="ulink" href="http://jinja.pocoo.org/docs/templates/#for">http://jinja.pocoo.org/docs/templates/#for</a>) to generate a sequence of <code class="literal">&lt;tr&gt;</code> and <code class="literal">&lt;td&gt;</code> HTML tags.</p><p>The following screenshot shows the search results for the query: <code class="literal">pixiedust</code>:</p><div class="mediaobject"><img src="Images/B09699_03_04.jpg" alt="Displaying the search results in a table" width="1000" height="515"/><div class="caption"><p>Screen showing the list of GitHub repo resulting from a query</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>In Part 1, we showed how to create the <code class="literal">GitHubTracking</code> PixieApp, invoke the GitHub query REST API, and display the results in a table using pagination. You can find the complete Notebook with the source code here:</p><p>
<code class="literal">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%201.ipynb</code>
</p></div></div><p>In the <a id="id166" class="indexterm"/>next section, we will explore more PixieApp features that will allow us to improve the application by letting the user drill down into a particular repository and visualize various statistics about the repository.</p><p>The first step is to add a button to each row of the search results table that triggers a new route for visualizing the selected repository statistics.</p><p>The following code is part of the <code class="literal">do_search</code> function and adds a new column in the table header:</p><div class="informalexample"><pre class="programlisting">&lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt;Repo Name&lt;/th&gt;
        &lt;th&gt;Lastname&lt;/th&gt;
        &lt;th&gt;URL&lt;/th&gt;
        &lt;th&gt;Stars&lt;/th&gt;
<span class="strong"><strong>        &lt;th&gt;Actions&lt;/th&gt;</strong></span>
    &lt;/tr&gt;
&lt;/thead&gt;</pre></div><p>To complete the table, we update the <code class="literal">do_retrieve_page</code> method to add a new cell that contains a <code class="literal">&lt;button&gt;</code> element, with <code class="literal">pd_options</code> arguments that match the new route: <code class="literal">analyse_repo_owner</code> and <code class="literal">analyse_repo_name</code>. The values of these arguments are extracted from the <code class="literal">row</code> element used for iterating over the payload received from the GitHub request:</p><div class="informalexample"><pre class="programlisting">{%for row in items%}
&lt;tr&gt;
    &lt;td&gt;{{row['name']}}&lt;/td&gt;
    &lt;td&gt;{{row.get('owner',{}).get('login', 'N/A')}}&lt;/td&gt;
    &lt;td&gt;&lt;a href="{{row['html_url']}}" target="_blank"&gt;{{row['html_url']}}&lt;/a&gt;&lt;/td&gt;
    &lt;td&gt;{{row['stargazers_count']}}&lt;/td&gt;
<span class="strong"><strong>    &lt;td&gt;</strong></span>
<span class="strong"><strong>        &lt;button pd_options=</strong></span>
<span class="strong"><strong>         "analyse_repo_owner={{row["owner"]["login"]}};</strong></span>
<span class="strong"><strong>         analyse_repo_name={{row['name']}}"</strong></span>
<span class="strong"><strong>         class="btn btn-default btn-sm" title="Analyze Repo"&gt;</strong></span>
<span class="strong"><strong>            &lt;i class="fa fa-line-chart"&gt;&lt;/i&gt;</strong></span>
<span class="strong"><strong>        &lt;/button&gt;</strong></span>
<span class="strong"><strong>    &lt;/td&gt;</strong></span>
&lt;/tr&gt;
{%endfor%}</pre></div><p>With this <a id="id167" class="indexterm"/>simple code change in place, restart the PixieApp by running the cell again and we can now see the button for each repo, even though we haven't yet implemented the corresponding route, which we'll implement next. As a reminder, when no matching route is found, the default route is triggered.</p><p>The following screenshot shows the table with the added buttons:</p><div class="mediaobject"><img src="Images/B09699_03_05.jpg" alt="Displaying the search results in a table" width="1000" height="396"/><div class="caption"><p>Adding action buttons for each row</p></div></div><p>The next <a id="id168" class="indexterm"/>step is to create the route associated with the Repo Visualization page. The design for this page is rather simple: from a combobox, the user chooses the type of data they want to visualize on the page. The GitHub REST API provides access to many types of data but, for this sample application, we will use the commit activity data, which is part of the Statistics category (see <a class="ulink" href="https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data">https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data</a> for a detailed description of this API).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>As an exercise, feel free to improve this sample application by adding visualizations for other types of APIs, such as the Traffic API (<a class="ulink" href="https://developer.github.com/v3/repos/traffic">https://developer.github.com/v3/repos/traffic</a>).</p></div></div><p>It's also important to note that, even though most of the GitHub APIs work without authentication, the server may throttle the responses if you don't provide credentials. To authenticate the requests, you will need to use your GitHub password or generate a personal access token by selecting the <span class="strong"><strong>Developer settings</strong></span> menu on your GitHub <span class="strong"><strong>Settings</strong></span> page, then click on <span class="strong"><strong>Personal access tokens</strong></span> menu, followed by the <span class="strong"><strong>Generate new token button</strong></span>.</p><p>In a separate Notebook cell, we will create two variables for the GitHub user ID and token:</p><div class="informalexample"><pre class="programlisting">github_user = "dtaieb"
github_token = "XXXXXXXXXX"</pre></div><p>These variables will be used later on to authenticate the requests. Note that, even though these variables are created in their own cell, they are visible to the entire Notebook, including the PixieApp code.</p><p>To provide <a id="id169" class="indexterm"/>good code modularity and reuse, we'll implement the Repo Visualization page in a new class and have our main PixieApp class inherit from it and automatically reuse its routes. This is a pattern to keep in mind when you start having large projects and want to break it down into multiple classes.</p><p>The main route for the Repo Visualization page returns an HTML fragment that has a drop-down menu and a <code class="literal">&lt;div&gt;</code> placeholder for the visualizations. The drop-down menu is created using Bootstrap <code class="literal">dropdown</code> class (<a class="ulink" href="https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp">https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp</a>). To make the code easier to maintain, the menu items are generated using a Jinja2 <code class="literal">{%for..</code>
<code class="literal">%}</code> loop over an array of tuples (<a class="ulink" href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</a>) called <code class="literal">analyses</code> that contains a description and a function for loading the data into a pandas DataFrame. Again here, we create this array in its own cell, which will be referenced in the PixieApp class:</p><div class="informalexample"><pre class="programlisting">analyses = [("Commit Activity", load_commit_activity)]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The <code class="literal">load_commit_activity</code> function will be discussed later on in this section.</p><p>For the purpose of this sample application, the array only contains one element related to the commit activity, but any element you may add in the future will automatically be picked up by the UI.</p></div></div><p>The <code class="literal">do_analyse_repo</code> route has two arguments: <code class="literal">analyse_repo_owner</code> and <code class="literal">analyse_repo_name,</code> which should be sufficient to access the GitHub APIs. We also need to save these arguments as class variables because they will be needed in the route that generates the visualizations:</p><div class="informalexample"><pre class="programlisting">@PixieApp
class RepoAnalysis():
    @route(analyse_repo_owner="*", analyse_repo_name="*")
    @templateArgs
    def do_analyse_repo(self, analyse_repo_owner, analyse_repo_name):
        self._analyse_repo_owner = analyse_repo_owner
        self._analyse_repo_name = analyse_repo_name
        return """
&lt;div class="container-fluid"&gt;
    &lt;div class="dropdown center-block col-sm-2"&gt;
        &lt;button class="btn btn-primary dropdown-toggle" type="button" data-toggle="dropdown"&gt;
            Select Repo Data Set
            &lt;span class="caret"&gt;&lt;/span&gt;
        &lt;/button&gt;
        &lt;ul class="dropdown-menu" style="list-style:none;margin:0px;padding:0px"&gt;
            {%for analysis,_ in this.analyses%}
                &lt;li&gt;
                    &lt;a href="#" pd_options="analyse_type={{analysis}}" pd_target="analyse_vis{{prefix}}"
                     style="text-decoration: none;background-color:transparent"&gt;
                        {{analysis}}
                    &lt;/a&gt;
                &lt;/li&gt;
            {%endfor%}
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div id="analyse_vis{{prefix}}" class="col-sm-10"&gt;&lt;/div&gt;
&lt;/div&gt;
"""</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>You can find the code file here:</p><p><a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py</a>
</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Two things to note in the preceding code are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Jinja2 template references the <code class="literal">analyses</code> array using the <code class="literal">this</code> keyword, even though the <code class="literal">analyses</code> variable is not defined as a class variable. This works because of another important PixieApp feature: any variable defined in the Notebook itself can be referenced as if they were class variables of the PixieApp.</li><li class="listitem" style="list-style-type: disc">I store <code class="literal">analyse_repo_owner</code> and <code class="literal">analyse_repo_name</code> as class variables with a different name, for example, <code class="literal">_analyse_repo_owner</code> and <code class="literal">_analyse_repo_name</code>. This is important because using the same name would have a side effect on the route matching algorithm, which also looks at class variables to find arguments. Using the same name would then cause this route to always be found, which is not the desired effect.</li></ul></div></div></div><p>The action <a id="id170" class="indexterm"/>button link is defined by the <code class="literal">&lt;a&gt;</code> tag and uses <code class="literal">pd_options</code> to access a route that has one argument called <code class="literal">analyse_type</code>, as well as <code class="literal">pd_target</code> pointing at the <code class="literal">"analyse_vis{{prefix}}"</code> placeholder, <code class="literal">&lt;div&gt;,</code> defined below in the same HTML fragment.</p></div><div class="section" title="Invoking the PixieDust display() API using pd_entity attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Invoking the PixieDust display() API using pd_entity attribute</h2></div></div></div><p>When using the <code class="literal">pd_options</code> attribute to create a kernel request, the PixieApp framework uses the <a id="id171" class="indexterm"/>current PixieApp class as the target. However, you can change this target by specifying a <code class="literal">pd_entity</code> attribute. You could, for example, point at another PixieApp or, more interestingly, point at a data structure supported by the <code class="literal">display()</code> API, such as a pandas or Spark DataFrame. In this case, and provided that you include the correct options as expected by the <code class="literal">display()</code> API, the generated output will be the chart itself (an image in the case of Matplotlib, Iframe in the case of Mapbox, or an SVG in the case of Bokeh). One simple way to get the correct options is to invoke the <code class="literal">display()</code> API in its own cell, configure the chart as desired using the menus and then copy the cell metadata JSON fragment available by clicking on the <span class="strong"><strong>Edit Metadata</strong></span> button. (You may first have to enable the button by using the menu <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Cell Toolbar</strong></span> | <span class="strong"><strong>Edit Metadata</strong></span>).</p><p>You can also specify <code class="literal">pd_entity</code> without any value. In this case, the PixieApp framework will use the entity passed as the first argument to the <code class="literal">run</code> method used to launch the PixieApp application. For example, <code class="literal">my_pixieapp.run(cars)</code> with <code class="literal">cars</code> being a pandas or Spark DataFrame created by the <code class="literal">pixiedust.sampleData()</code> method. The value of <code class="literal">pd_entity</code> can also be a function call that returns the entity. This is useful when you want to dynamically compute the entity before rendering it. As with other variables, the scope of <code class="literal">pd_entity</code> can be either the PixieApp class or any variable declared in the Notebook.</p><p>For example, we can create a function in its own cell that takes a prefix as an argument and returns a pandas DataFrame. We then use it as a <code class="literal">pd_entity</code> value in my PixieApp, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">def compute_pdf(key):
    return pandas.DataFrame([
        {"col{}".format(i): "{}{}-{}".format(key,i,j) for i in range(4)} for j in range(10)
    ])</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py</a>
</p></div></div><p>In the preceding code, we used Python list comprehensions (<a class="ulink" href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions">https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions</a>) to quickly generate mock data based on the <code class="literal">key</code> argument.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Python list comprehensions are one of my favorite features of the Python language as they let you create, transform, and extract data with an expressive and concise syntax.</p></div></div><p>I can <a id="id172" class="indexterm"/>then create a PixieApp that uses the <code class="literal">compute_pdf</code> function as a <code class="literal">pd_entity</code> to render the data as a table:</p><div class="informalexample"><pre class="programlisting">from pixiedust.display.app import *
@PixieApp
class TestEntity():
    @route()
    def main_screen(self):
        return """
        &lt;h1&gt;&lt;center&gt;
            Simple PixieApp with dynamically computed dataframe
        &lt;/center&gt;&lt;/h1&gt;
        &lt;div pd_entity="compute_pdf('prefix')" pd_options="handlerId=dataframe" pd_render_onload&gt;&lt;/div&gt;
        """
test = TestEntity()
test.run()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py</a>
</p></div></div><p>In the preceding code, for simplicity, I hardcoded the key to <code class="literal">'prefix'</code> and I'll leave it as an exercise to use an input control and the <code class="literal">$val()</code> directive to make it user definable.</p><p>Another important thing to notice is the use of the <code class="literal">pd_render_onload</code> attribute in the div that displays the chart. This attribute tells PixieApp to execute the kernel request defined by the element immediately after it is loaded into the browser DOM.</p><p>The results for the preceding PixieApp are shown in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_03_06.jpg" alt="Invoking the PixieDust display() API using pd_entity attribute" width="1000" height="588"/><div class="caption"><p>Dynamic DataFrame creation within a PixieApp</p></div></div><p>Back to our <span class="emphasis"><em>GitHub Tracking</em></span> application, let's now apply the <code class="literal">pd_entity</code> value to the DataFrame <a id="id173" class="indexterm"/>loaded from the GitHub Statistics API. We create a method called <code class="literal">load_commit_activity,</code> responsible for loading the data into a pandas DataFrame and returning it along with the <code class="literal">pd_options</code> needed to display the chart:</p><div class="informalexample"><pre class="programlisting">from datetime import datetime
import requests
import pandas
def load_commit_activity(owner, repo_name):
    response = requests.get(
        "https://api.github.com/repos/{}/{}/stats/commit_activity".format(owner, repo_name),
        auth=(github_user, github_token)
    ).json()
    pdf = pandas.DataFrame([
        {"total": item["total"], "week":datetime.fromtimestamp(item["week"])} for item in response
    ])

    return {
        "pdf":pdf,
        "chart_options": {
          "handlerId": "lineChart",
          "keyFields": "week",
          "valueFields": "total",
          "aggregation": "SUM",
          "rendererId": "bokeh"
        }
    }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py</a>
</p></div></div><p>The preceding code sends a GET request to GitHub, authenticated with the <code class="literal">github_user</code> and <code class="literal">github_token</code> variables set up at the beginning of the Notebook. The response is a JSON payload that we'll use to create a pandas DataFrame. Before we can create the DataFrame, we need to transform the JSON payload in to the right format. Right now, the payload looks like this:</p><div class="informalexample"><pre class="programlisting">[
{"days":[0,0,0,0,0,0,0],"total":0,"week":1485046800},
{"days":[0,0,0,0,0,0,0],"total":0,"week":1485651600},
{"days":[0,0,0,0,0,0,0],"total":0,"week":1486256400},
{"days":[0,0,0,0,0,0,0],"total":0,"week":1486861200}
...
]</pre></div><p>We need to drop the <code class="literal">days</code> key as it's not needed for displaying the chart and, for proper chart display, we need to convert the value of the <code class="literal">week</code> key, which is a Unix timestamp, into a Python <code class="literal">datetime</code> object. This transformation is done using a Python list comprehension with a simple line of code:</p><div class="informalexample"><pre class="programlisting">[{"total": item["total"], "week":datetime.fromtimestamp(item["week"])} for item in response]</pre></div><p>In the <a id="id174" class="indexterm"/>current implementation, the <code class="literal">load_commit_activity</code> function is defined in its own cell, but we could also have defined it as a member method of the PixieApp. As a best practice, using its own cell is very convenient because we can unit test the function and iterate rapidly on it without incurring the overhead of running the full app every time.</p><p>To get the <code class="literal">pd_options</code> value, we can simply run the function with a sample repo information and then call the <code class="literal">display()</code> API in a separate cell:</p><div class="mediaobject"><img src="Images/B09699_03_07.jpg" alt="Invoking the PixieDust display() API using pd_entity attribute" width="1000" height="711"/><div class="caption"><p>Using display() in a separate cell to get the visualization configuration</p></div></div><p>To obtain <a id="id175" class="indexterm"/>the preceding chart, you need to select <span class="strong"><strong>Line Chart</strong></span> and then, in the <span class="strong"><strong>Options</strong></span> dialog, drag and drop the <code class="literal">week</code> column to the <span class="strong"><strong>Keys</strong></span> box and the <code class="literal">total</code> column to the <span class="strong"><strong>Values</strong></span> box. You also need to select Bokeh as the renderer. Once done, notice that PixieDust will automatically detect that the <span class="emphasis"><em>x</em></span> axis is a datetime and will adjust the rendering accordingly.</p><p>Using the <span class="strong"><strong>Edit Metadata</strong></span> button, we can now copy the chart options JSON fragment:</p><div class="mediaobject"><img src="Images/B09699_03_08.jpg" alt="Invoking the PixieDust display() API using pd_entity attribute" width="1000" height="561"/><div class="caption"><p>Capturing the display() JSON configuration</p></div></div><p>And <a id="id176" class="indexterm"/>return it in the <code class="literal">load_commit_activity</code> payload:</p><div class="informalexample"><pre class="programlisting">return {
        "pdf":pdf,
        "chart_options": {
          "handlerId": "lineChart",
          "keyFields": "week",
          "valueFields": "total",
          "aggregation": "SUM",
          "rendererId": "bokeh"
        }
    }</pre></div><p>We are now ready to implement the <code class="literal">do_analyse_type</code> route in the <code class="literal">RepoAnalysis</code> class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">[[RepoAnalysis]]
@route(analyse_type="*")
@templateArgs
def do_analyse_type(self, analyse_type):
    fn = [analysis_fn for a_type,analysis_fn in analyses if a_type == analyse_type]
    if len(fn) == 0:
        return "No loader function found for {{analyse_type}}"
    vis_info = fn[0](self._analyse_repo_owner, self._analyse_repo_name)
    self.pdf = vis_info["pdf"]
    return """
    &lt;div pd_entity="pdf" pd_render_onload&gt;
        &lt;pd_options&gt;{{vis_info["chart_options"] | tojson}}&lt;/pd_options&gt;
    &lt;/div&gt;
    """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py</a>
</p></div></div><p>The route <a id="id177" class="indexterm"/>has one argument called <code class="literal">analyse_type,</code> which we use as a key to find the load function in the <code class="literal">analyses</code> array (notice that I again use a list comprehension to do the search quickly). We then call this function passing the repo owner and name to get the <code class="literal">vis_info</code> JSON payload and store the pandas DataFrame into a class variable called <code class="literal">pdf</code>. The returned HTML fragment will then use <code class="literal">pdf</code> as the <code class="literal">pd_entity</code> value and <code class="literal">vis_info["chart_options"]</code> as <code class="literal">pd_optio</code>
<code class="literal">ns</code>. Here I use the <code class="literal">tojson</code> Jinja2 filter (<a class="ulink" href="http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters">http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters</a>) to ensure that it is properly escaped in the generated HTML. I am also allowed to use the <code class="literal">vis_info</code> variable even though it's been declared on the stack because I used the <code class="literal">@templateArgs</code> decorator for the function.</p><p>The last thing to do before testing our improved application is to make sure the main <code class="literal">GitHubTracking</code> PixieApp class inherits from the <code class="literal">RepoAnalysis</code> PixieApp:</p><div class="informalexample"><pre class="programlisting">@PixieApp
class GitHubTracking(RepoAnalysis):
    @route()
    def main_screen(self):
        &lt;&lt;Code omitted here&gt;&gt;

    @route(query="*")
    @templateArgs
    def do_search(self, query):
        &lt;&lt;Code omitted here&gt;&gt;

    @route(page="*")
    @templateArgs
    def do_retrieve_page(self, page):
        &lt;&lt;Code omitted here&gt;&gt;

app = GitHubTracking()
app.run()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py</a>
</p></div></div><p>A screenshot <a id="id178" class="indexterm"/>of the Repo Analysis page is shown here:</p><div class="mediaobject"><img src="Images/B09699_03_09.jpg" alt="Invoking the PixieDust display() API using pd_entity attribute" width="1000" height="571"/><div class="caption"><p>GitHub repo commit activity visualization</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>If you want to experiment further, you can find the complete Notebook for the <span class="emphasis"><em>GitHub Tracking application</em></span> Part 2 here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb</a>
</p></div></div></div><div class="section" title="Invoking arbitrary Python code with pd_script"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Invoking arbitrary Python code with pd_script</h2></div></div></div><p>In this <a id="id179" class="indexterm"/>section, we look at the <code class="literal">pd_script</code> custom attribute which lets you run arbitrary Python code whenever a kernel request is triggered. There are a few rules that govern how the Python code is executed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code has access to the PixieApp class using the <code class="literal">self</code> keyword, as well as any variables, functions, and classes defined in the Notebook, as in the following example:<div class="informalexample"><pre class="programlisting">&lt;button type="submit" pd_script="self.state='value'"&gt;Click me&lt;/button&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">If a <code class="literal">pd_target</code> is specified, then any statement using the <code class="literal">print</code> function will be output in the <code class="literal">target</code> element. This is not the case if no <code class="literal">pd_target</code> is present. In other words, you cannot use <code class="literal">pd_script</code> to do a full-page refresh (you would have to use the <code class="literal">pd_options</code> attribute instead), as in the example:<div class="informalexample"><pre class="programlisting">from pixiedust.display.app import *

def call_me():
    print("Hello from call_me")

@PixieApp
class Test():
    @route()
    def main_screen(self):
        return """
        &lt;button type="submit" pd_script="call_me()" pd_target="target{{prefix}}"&gt;Click me&lt;/button&gt;

        &lt;div id="target{{prefix}}"&gt;&lt;/div&gt;
        """
Test().run()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py</a>
</p></div></div></li><li class="listitem" style="list-style-type: disc">If the code contains more than one line, it is recommended to use the <code class="literal">pd_script</code> child element, which lets you write the Python code using multiple lines. When using this form, make sure that the code respects the Python language rules for indentation, as in the example:<div class="informalexample"><pre class="programlisting">@PixieApp
class Test():
    @route()
    def main_screen(self):
        return """
        &lt;button type="submit" pd_script="call_me()" pd_target="target{{prefix}}"&gt;
            &lt;pd_script&gt;
                self.name="some value"
                print("This is a multi-line pd_script")
            &lt;/pd_script&gt;
            Click me
        &lt;/button&gt;

        &lt;div id="target{{prefix}}"&gt;&lt;/div&gt;
        """
Test().run()</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py</a>
</p></div></div><p>One common use case for <code class="literal">pd_script</code> is to update some state on the server before triggering a kernel request. Let's apply this technique to our <span class="emphasis"><em>GitHub Tracking</em></span> application by adding <a id="id180" class="indexterm"/>a checkbox to switch the visualization between a line chart and a statistical summary of the data.</p><p>In the fragment HTML returned by <code class="literal">do_analyse_repo</code>, we add the checkbox element used to switch between the chart and the statistics summary:</p><div class="informalexample"><pre class="programlisting">[[RepoAnalysis]]
...
return """
&lt;div class="container-fluid"&gt;
    &lt;div class="col-sm-2"&gt;
        &lt;div class="dropdown center-block"&gt;
            &lt;button class="btn btn-primary
             dropdown-toggle" type="button"
             data-toggle="dropdown"&gt;
                Select Repo Data Set
                &lt;span class="caret"&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;ul class="dropdown-menu"
             style="list-style:none;margin:0px;padding:0px"&gt;
                {%for analysis,_ in this.analyses%}
                    &lt;li&gt;
                        &lt;a href="#"
                        pd_options="analyse_type={{analysis}}"
                        pd_target="analyse_vis{{prefix}}"
                        style="text-decoration: none;background-color:transparent"&gt;
                            {{analysis}}
                        &lt;/a&gt;
                    &lt;/li&gt;
                {%endfor%}
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div class="checkbox"&gt;
            &lt;label&gt;
                &lt;input id="show_stats{{prefix}}" type="checkbox"
                  pd_script="self.show_stats=('$val(show_stats{{prefix}})' == 'true')"&gt;
                Show Statistics
            &lt;/label&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id="analyse_vis{{prefix}}" class="col-sm-10"&gt;&lt;/div&gt;
&lt;/div&gt;
"""</pre></div><p>In the <code class="literal">checkbox</code> element, we include a <code class="literal">pd_script</code> attribute that modifies a variable state on the <a id="id181" class="indexterm"/>server based on the state of the <code class="literal">checkbox</code> element. We use the <code class="literal">$val()</code> directive to retrieve the value of the <code class="literal">show_stats_{{prefix}}</code> element and compare it with the <code class="literal">true string</code>. When the user clicks on the checkbox, the state is immediately changed on the server and, the next time the user clicks on the menu, the stats are showing instead of the charts.</p><p>We now need to change the <code class="literal">do_analyse_type</code> route to dynamically configure <code class="literal">pd_entity</code> and <code class="literal">chart_options</code>:</p><div class="informalexample"><pre class="programlisting">[[RepoAnalysis]]
@route(analyse_type="*")
@templateArgs
def do_analyse_type(self, analyse_type):
    fn = [analysis_fn for a_type,analysis_fn in analyses if a_type == analyse_type]
    if len(fn) == 0:
        return "No loader function found for {{analyse_type}}"
    vis_info = fn[0](self._analyse_repo_owner, self._analyse_repo_name)
    self.pdf = vis_info["pdf"]
    chart_options = {"handlerId":"dataframe"} if self.show_stats else vis_info["chart_options"]
    return """
    &lt;div pd_entity="get_pdf()" pd_render_onload&gt;
        &lt;pd_options&gt;{{chart_options | tojson}}&lt;/pd_options&gt;
    &lt;/div&gt;
    """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>You can find the file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py</a>
</p></div></div><p>
<code class="literal">chart_options</code> is now a local variable that contains options for displaying as a table if <code class="literal">show_stats</code> is <code class="literal">true</code> and regular line chart options if not.</p><p>
<code class="literal">pd_entity</code> is now set to the <code class="literal">get_pdf()</code> method, which is responsible for returning the appropriate DataFrame based on the <code class="literal">show_stats</code> variable:</p><div class="informalexample"><pre class="programlisting">def get_pdf(self):
    if self.show_stats:
        summary = self.pdf.describe()
        summary.insert(0, "Stat", summary.index)
        return summary
    return self.pdf</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py</a>
</p></div></div><p>We use <a id="id182" class="indexterm"/>the pandas <code class="literal">describe()</code> method (<a class="ulink" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html</a>) that returns a DataFrame containing summary statistics, such as count, mean, standard deviation, and so on. We also make sure that the first column of this DataFrame contains the name of the statistic.</p><p>The last change we need to make is to initialize the <code class="literal">show_stats</code> variable because, if we don't, then the first time we check it, we'll get an <code class="literal">AttributeError</code> exception.</p><p>Because of the internal mechanics of using the <code class="literal">@PixieApp</code> decorator, you can't use the <code class="literal">__init__</code> method to initialize variables; instead, the PixieApp programming model requires you to use a method called <code class="literal">setup,</code> which is guaranteed to be called when the application starts:</p><div class="informalexample"><pre class="programlisting">@PixieApp
class RepoAnalysis():
    def setup(self):
        self.show_stats = False
    ...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: If you have a class inheriting from other PixieApps, then the PixieApp framework will automatically call all <code class="literal">setup</code> functions from base classes using their order of appearance.</p></div></div><p>The following <a id="id183" class="indexterm"/>screenshot shows the summary statistics being displayed:</p><div class="mediaobject"><img src="Images/B09699_03_10.jpg" alt="Invoking arbitrary Python code with pd_script" width="1000" height="442"/><div class="caption"><p>Summary statistics for a GitHub repo</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note55"/>Note</h3><p>You can find the complete Notebook for the <span class="emphasis"><em>GitHub Tracking</em></span> application Part 3 here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb</a>
</p></div></div></div><div class="section" title="Making the application more responsive with pd_refresh"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Making the application more responsive with pd_refresh</h2></div></div></div><p>We want <a id="id184" class="indexterm"/>to improve the user experience by making the <span class="strong"><strong>Show Statistics</strong></span> button directly show the statistics table instead of having the user to click on the menu again. Similar to the menu that loads the <span class="strong"><strong>Commit Activity</strong></span>, we could add a <code class="literal">pd_options</code> attribute to the checkbox with the <code class="literal">pd_target</code> attribute pointing at the <code class="literal">analyse_vis{{prefix}}</code> element. Instead of duplicating <code class="literal">pd_options</code> in each of the controls that triggers a new display, we could add it once to <code class="literal">analyse_vis{{prefix}}</code> and have it update itself with the <code class="literal">pd_refresh</code> attribute.</p><p>The following diagram shows the differences between the two designs:</p><div class="mediaobject"><img src="Images/B09699_03_11.jpg" alt="Making the application more responsive with pd_refresh" width="1000" height="658"/><div class="caption"><p>Sequence diagram with and without pd_refresh</p></div></div><p>In both cases, step 1 is to update some state on the server side. In the case of the route being invoked by the <span class="strong"><strong>Control</strong></span> shown in step 2, the request specification is stored in the control itself, triggering step 3, which is to generate the HTML fragment and inject it in the target element. With <code class="literal">pd_refresh</code>, the control doesn't know the <code class="literal">pd_options</code> to invoke <a id="id185" class="indexterm"/>the route, instead, it simply uses <code class="literal">pd_refresh</code> to signal the target element, which in turn will invoke the route. In this design, we only need to specify the request once (in the target element) and user control needs only to update state before triggering a refresh. This makes the implementation much easier to maintain.</p><p>To better understand the differences between the two designs, let's compare both implementations in the <code class="literal">RepoAnalysis</code> class.</p><p>For the <span class="strong"><strong>Analysis</strong></span> menu, the changes are as follows:</p><p>Before, the control triggered the <code class="literal">analyse_type</code> route, passing the <code class="literal">{{analysis}}</code> selection as part of the kernel request, targeting <code class="literal">analyse_vis{{prefix}}</code>:</p><div class="informalexample"><pre class="programlisting">&lt;a href="#" <span class="strong"><strong>pd_options="analyse_type={{analysis}}"</strong></span>
            pd_target="analyse_vis{{prefix}}"
            style="text-decoration: none;background-color:transparent"&gt;
      {{analysis}}
&lt;/a&gt;</pre></div><p>After, the control now stores the selection state as a class field and asks the <code class="literal">analyse_vis{{prefix}}</code> element to refresh itself:</p><div class="informalexample"><pre class="programlisting">&lt;a href="#" <span class="strong"><strong>pd_script="self.analyse_type='{{analysis}}'"</strong></span>
 pd_refresh="analyse_vis{{prefix}}"
 style="text-decoration: none;background-color:transparent"&gt;
    {{analysis}}
&lt;/a&gt;</pre></div><p>Similarly, the changes for the <span class="strong"><strong>Show Statistics</strong></span> checkbox are as follows:</p><p>Before the checkbox simply set the <code class="literal">show_stats</code> state in the class; the user had to click on the menu again to get the visualization:</p><div class="informalexample"><pre class="programlisting">&lt;div class="checkbox"&gt;
    &lt;label&gt;
        &lt;input type="checkbox"
         id="show_stats{{prefix}}"
pd_script="self.show_stats='$val(show_stats{{prefix}})'=='true'"&gt;
        Show Statistics
    &lt;/label&gt;
&lt;/div&gt;</pre></div><p>After, the visualization is updated as soon as the checkbox is selected, thanks to the <code class="literal">pd_refresh</code> attribute:</p><div class="informalexample"><pre class="programlisting">&lt;div class="checkbox"&gt;
    &lt;label&gt;
        &lt;input type="checkbox"
         id="show_stats{{prefix}}"
  pd_script="self.show_stats='$val(show_stats{{prefix}})'=='true'"
         <span class="strong"><strong>pd_refresh="analyse_vis{{prefix}}"</strong></span>&gt;
         Show Statistics
    &lt;/label&gt;
&lt;/div&gt;</pre></div><p>Finally, the changes for the <code class="literal">analyse_vis{{prefix}}</code> element are as follows:</p><p>Before, the element didn't know how to update itself, it relies on other controls to direct a request to the appropriate route:</p><div class="informalexample"><pre class="programlisting">&lt;div id="analyse_vis{{prefix}}" class="col-sm-10"&gt;&lt;/div&gt;</pre></div><p>After, the <a id="id186" class="indexterm"/>element carries the kernel configuration to update itself; any control can now change state and call refresh:</p><div class="informalexample"><pre class="programlisting">&lt;div id="analyse_vis{{prefix}}" class="col-sm-10"
     pd_options="display_analysis=true"
     pd_target="analyse_vis{{prefix}}"&gt;
&lt;/div&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note56"/>Note</h3><p>You can find the complete Notebook for this section for the <span class="emphasis"><em>GitHub Tracking</em></span> application Part 4 here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb</a>
</p></div></div></div><div class="section" title="Creating reusable widgets"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Creating reusable widgets</h2></div></div></div><p>The PixieApp <a id="id187" class="indexterm"/>programming model provides a mechanism for packaging the HTML and logic of a complex UI construct into a widget that can be easily called from other PixieApps. The steps to create a widget are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a PixieApp class that will contain the widget.</li><li class="listitem">Create a route with a special <code class="literal">widget</code> attribute, as in the example:<div class="informalexample"><pre class="programlisting">@route(widget="my_widget")</pre></div><p>It will be the starting route for the widget.</p></li><li class="listitem">Create a consumer PixieApp class that inherits from the widget PixieApp class.</li><li class="listitem">Invoke the widget from a <code class="literal">&lt;div&gt;</code> element by using the <code class="literal">pd_widget</code> attribute.</li></ol></div><p>Here is <a id="id188" class="indexterm"/>an example of how to create a widget and consumer PixieApp class:</p><div class="informalexample"><pre class="programlisting">from pixiedust.display.app import *

@PixieApp
class WidgetApp():
    @route(widget="my_widget")
    def widget_main_screen(self):
        return "&lt;div&gt;Hello World Widget&lt;/div&gt;"

@PixieApp
class ConsumerApp(WidgetApp):
    @route()
    def main_screen(self):
        return """&lt;div pd_widget="my_widget"&gt;&lt;/div&gt;"""

ConsumerApp.run()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note57"/>Note</h3><p>You can find the code here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py</a>
</p></div></div></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we've covered the foundational building blocks of the PixieApp programming model that lets you create powerful tools and dashboards directly in the Notebook.</p><p>We've also illustrated PixieApp concepts and techniques by showing how to build a <span class="emphasis"><em>GitHub Tracking</em></span> sample application, including detailed code examples. Best practices and more advanced PixieApp concepts will be covered in <a class="link" href="ch05.xhtml" title="Chapter 5. Python and PixieDust Best Practices and Advanced Concepts">Chapter 5</a>, <span class="emphasis"><em>Python and PixieDust Best Practices and Advanced Concepts</em></span>, including events, streaming, and debugging.</p><p>By now, you should hopefully have a good idea of how Jupyter Notebooks, PixieDust, and PixieApps can help bridge the gap between data scientists and developers by enabling them to collaborate from within a single tool, such as Jupyter Notebook.</p><p>In the next chapter, we'll show how to free the PixieApp from the Notebook and publish it as a web application using the PixieGateway microservice server.</p></div></div>



  </body></html>