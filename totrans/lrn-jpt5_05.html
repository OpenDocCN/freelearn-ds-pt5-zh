<html><head></head><body>
        

                            
                    <h1 class="header-title">Jupyter Java Coding</h1>
                
            
            
                
<p>Java is a high-level programming language that was originally developed by Sun Microsystems, and is currently owned by Oracle. Java is a cross-platform, compiled language that can be executed on a variety of platforms. Java is cross-platform since it generates <strong>p-code</strong>, which is interpreted by a resident-specific version of Java, the <strong>Java Virtual Machine</strong> (<strong>JVM</strong>).</p>
<p>Java is distributed by using a <strong>Java Runtime Executable</strong> (<strong>JRE</strong>) for those that only need to execute programs that are written. Otherwise, there's a <strong>Java Development Kit</strong> (<strong>JDK</strong>) for those developing Java applications.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Adding the Java kernel to Jupyter</li>
<li>Java Hello World Jupyter Notebook</li>
<li>Basic Java in Jupyter</li>
</ul>
<p>Major caveat is this does not work on a Windows environment. A Java Notebook will not start on Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the Java kernel to your installation</h1>
                
            
            
                
<p>In this section, we will add the Java kernel to your installation. The steps are very similar, regardless of whether you're installing in a Windows or a macOS environment.</p>
<p>The Java kernel, IJava, was developed and maintained by Spence Park at <a href="https://github.com/SpencerPark/IJava">https://github.com/SpencerPark/IJava</a>. There are a couple of requirements for using the Java kernel, which will be covered in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Java 9 or later</h1>
                
            
            
                
<p>You can check the version of Java you have installed by using the following command at a command-line prompt:</p>
<pre><strong>java --version</strong> </pre>
<p>We need version 9 or later.</p>
<p>Also, the installed version must be a JDK. The JRE will not suffice. You can download the latest Java version at <a href="http://www.oracle.com/technetwork/java">www.oracle.com/technetwork/java</a>. At the time of writing this book, version 10 was generally available so I installed that version, as you can see from the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-703 image-border" src="img/27ffc1d4-cef0-44eb-a8df-85c44bd01371.png" style="width:34.83em;height:12.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">A Jupyter environment is required</h1>
                
            
            
                
<p>This may sound redundant, but this is broad, allowing IJava to run in Jupyter, <strong>JupyterLab</strong>, or <strong>nteract</strong> all Jupyter environments, depending on your needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring IJava</h1>
                
            
            
                
<p>Once you have installed Java, you need to configure IJava.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Downloading the IJava project from GitHub</h1>
                
            
            
                
<p>We can download the <kbd>IJava</kbd> extension from GitHub by using the following command:</p>
<pre><strong>&gt; git clone https://github.com/SpencerPark/IJava.git --depth 1</strong></pre>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-708 image-border" src="img/d2707ae9-75c5-469e-9f5d-e2a2e46b0e66.png" style="width:39.92em;height:8.50em;"/></p>
<p>The <kbd>git clone</kbd> command downloads the project files into the <kbd>IJava</kbd> directory where you are located (in my case, this is my default user directory):</p>
<pre><strong>&gt; cd IJava/</strong></pre>
<p>This command just relocates into the <kbd>IJava</kbd> directory that was downloaded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and installing the kernel</h1>
                
            
            
                
<p>Following are the commands for the particular operating system: </p>
<ul>
<li><strong>*nix</strong>: <kbd>chmod u+x gradlew &amp;&amp; ./gradlew installKernel</kbd></li>
<li><strong>Windows</strong>: <kbd>gradlew installKernel</kbd></li>
</ul>
<p><kbd>gradlew</kbd> is a Windows version of Gradle, a popular scripting system. Gradle is adept at installing software. <kbd>gradlew</kbd> was installed as part of the <kbd>git clone</kbd> command that you ran earlier:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-710 image-border" src="img/9997ff61-10d7-4eee-901d-86f57efe3c7b.png" style="width:84.00em;height:23.00em;"/></p>
<p>So, as you can see from the install output, IJava really expects Java 9 to be installed. Java 9 is no longer a supported version from Oracle. We need to configure the tool to use Java 10. In my case, I had previously installed Java and had set the environment variable, <kbd>JAVA_HOME</kbd>, to the older version. Changing the environment variable to point to the Java 10 install worked:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-712 image-border" src="img/d48eff6c-de19-4fd6-b49b-9e6282576503.png" style="width:71.50em;height:21.00em;"/></p>
<p>Now, when we look at the list of kernels, we can see that Java is available by using the following command:</p>
<pre><strong>&gt;jupyter kernelspec list</strong> </pre>
<p>After the execution of the preceding command we will see the following results:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-719 image-border" src="img/1727c709-48b4-479c-8273-20da96bf0679.png" style="width:39.25em;height:10.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Available options</h1>
                
            
            
                
<p>As with other Java installations, we can set a number of Java-specific environment variables as desired:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Setting</strong></p>
</td>
<td>
<p><strong>Default value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>IJAVA_VM_OPTS</kbd></p>
</td>
<td>
<p><kbd>""</kbd></p>
</td>
<td>
<p>A space delimited list of command-line options that would be passed to the <kbd>java</kbd> command if running code. For example, we would use <kbd>-Xmx128m</kbd> to set a limit on the heap size or <kbd>-ea</kbd> to enable <kbd>assert</kbd> statements.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IJAVA_COMPILER_OPTS</kbd></p>
</td>
<td>
<p><kbd>""</kbd></p>
</td>
<td>
<p>A space delimited list of command-line options that would be passed to the <kbd>javac</kbd> command when compiling a project. For example, <kbd>-parameters</kbd> to enable retaining parameter names for reflection.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IJAVA_TIMEOUT</kbd></p>
</td>
<td>
<p><kbd>1</kbd></p>
</td>
<td>
<p>A duration in milliseconds, specifying a timeout on long-running code. If less than zero, the timeout is disabled.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IJAVA_CLASSPATH</kbd></p>
</td>
<td>
<p><kbd>""</kbd></p>
</td>
<td>
<p><kbd>-</kbd>, a file path separator delimited list of <kbd>classpath</kbd> entries that should be available to the user code.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IJAVA_STARTUP_SCRIPTS_PATH</kbd></p>
</td>
<td>
<p><kbd>""</kbd></p>
</td>
<td>
<p>A file path seperator delimited list of <kbd>.jshell</kbd> scripts to run on startup. This includes <kbd>ijava-jshell-init.jshell</kbd> and <kbd>ijava-magics-init.jshell</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IJAVA_STARTUP_SCRIPT</kbd></p>
</td>
<td>
<p><kbd>""</kbd></p>
</td>
<td>
<p>A block of Java code to run when the kernel starts up. This may be something like <kbd>import my.utils;</kbd> to set up some default imports or even <kbd>void sleep(long time) { try {Thread.sleep(time)} catch (InterruptedException e) {}}</kbd> to declare a default <kbd>utility</kbd> method to use in the Notebook.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As you can tell from the preceding descriptions, none of these are required to get a working Java application running. They are normally for special-case handling.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jupyter Java console</h1>
                
            
            
                
<p>You can run Jupyter in <kbd>console</kbd> mode, meaning that command lines can be entered directly rather than in a new Notebook in a browser. The command is as follows:</p>
<pre><strong>jupyter console --kernel=java</strong> </pre>
<p>This means that you can start Jupyter in a console window using the Java kernel. We will see a window like the following one, where we can enter some Java code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-720 image-border" src="img/9d30f72a-f7c9-457e-be03-9b0214e87a3e.png" style="width:45.42em;height:15.75em;"/></p>
<p>Odd interface lines of the command-line interface screen react as if they are part of a Notebook:</p>
<pre>String hello = "Hello, Dan" 
hello </pre>
<p>But this is not normal Java. There are no semicolons at the end of lines. Semicolons are optional for single-line Java statements.</p>
<p>Also, the single line <kbd>hello</kbd> is just the reference to the <kbd>hello</kbd> variable. I am not sure what is causing this to echo into the output.</p>
<p class="mce-root"/>
<p>We can extract this snippet into a Java Notebook with similar results:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3f4f25cf-e749-4888-a248-b253a5c09ad9.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jupyter Java output</h1>
                
            
            
                
<p>The Java implementation is able to differentiate between <kbd>stdout</kbd> and <kbd>stderr</kbd>, as can be seen with the following small code snippet:</p>
<pre>System.out.println("stdout");<br/>System.err.println("stderr");</pre>
<p>When run in a Notebook, the <kbd>stderr</kbd> output is colored red:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6bbc5544-2a45-4982-8502-92e14cfaa512.png"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Java Optional</h1>
                
            
            
                
<p>Many a programmer has been bitten by <kbd>NullPointerException</kbd>. While occurring less in Java than C or C++, it may still occur. Now, Java has the idea of an <kbd>Optional</kbd> field. An <kbd>Optional</kbd> field may or may not contain a value. You can test whether there is a value present or not rather than the awkward <kbd>null</kbd> tests that exist.</p>
<p>We can run through several aspects of <kbd>Optional</kbd> by using the following code snippet:</p>
<pre>import java.util.Optional; 
public class MyOptional { 
    public static void main() { 
        MyOptional program = new MyOptional(); 
        Integer value1 = null; 
        Integer value2 = 123; 
         
        //.ofNullable allows null 
        Optional&lt;Integer&gt; a = Optional.ofNullable(value1); 
         
        //.of does not allow null 
        Optional&lt;Integer&gt; b = Optional.of(value2); 
        System.out.println(program.sum(a,b)); 
    } 
     
    public Integer sum(Optional&lt;Integer&gt; first, Optional&lt;Integer&gt;<br/>      second) { 
        System.out.println("First parameter present " +<br/>          first.isPresent()); 
        System.out.println("Second parameter present " + <br/>          second.isPresent()); 
        Integer value1 = first.orElse(1); 
        Integer value2 = second.orElse(1); 
        return value1 + value2; 
    } 
} 
new MyOptional().main(); </pre>
<p>We have a standard preamble to the class to <kbd>import</kbd> libraries as needed. In this case, we will just use the <kbd>Optional</kbd> package.</p>
<p>We will create a Java class with a static <kbd>main</kbd> function.</p>
<p>The <kbd>main()</kbd> function that we defined previously is also nonstandard Java. The signature should be <kbd>public static void main(String[] args)</kbd>.</p>
<p>First, the <kbd>main</kbd> function creates an instance of the class (as we will want to reference other parts of the class later on).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We then create two variables, one that is the evil <kbd>null</kbd> value.</p>
<p><kbd>Optional</kbd> has two methods which do the same thing, but behave differently:</p>
<ul>
<li><kbd>ofNullable</kbd>: Takes an argument, that may be <kbd>null</kbd>, and creates an <kbd>Optional</kbd> field</li>
<li><kbd>of</kbd>: Takes an argument, which can not be <kbd>null</kbd>, and creates an <kbd>Optional</kbd> field</li>
</ul>
<p>We now have two <kbd>Optional</kbd> fields that we pass to the <kbd>sum()</kbd> function.</p>
<p>The <kbd>sum</kbd> function uses the <kbd>orElse()</kbd> function on each <kbd>Optional</kbd> field, expecting one or both to be <kbd>null</kbd> and providing a safe passage in those cases.</p>
<p>Then, it is a simple case of mathematics:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/34a875f0-38ed-43b7-9752-4e01ed3f0794.png"/></p>
<p class="mce-root"/>
<p>As you can see in the preceding output, the first parameter is <kbd>null</kbd>, but due to the <kbd>orElse</kbd> function, the function continues to process the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java compiler errors</h1>
                
            
            
                
<p>As with any regular Java program, there may be compile-time errors in your coding. Jupyter Java provides similar feedback, with line numbers corresponding to the lines in your Notebook.</p>
<p>For example, when I first entered the snippet for an example that we will look at a little later on in this chapter, there were a couple of errors:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/297808c2-705e-4846-ae7d-9e340e67ed8d.png"/></p>
<p>The first error was attempting to call the <kbd>sort</kbd> function from a <kbd>static</kbd> method. The second error was attempting to use the wrong function name. Both of these errors are typical types of compile errors you may see when developing Java applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java lambdas</h1>
                
            
            
                
<p>Lambdas provide a clear and concise way to represent one method interface using an expression. Lambdas are usually developed singularly. Lambdas can look very close to earlier Java implementations or completely foreign, as can be seen in the following example. We develop lambdas using more and more terse syntax:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6cf9d275-c185-4740-a627-41cb90250ecd.png" style="width:45.92em;height:40.17em;"/></p>
<p class="mce-root"/>
<p>All three lambdas perform the same step (as can be seen in the preceding output). However, the implementation is progressively more non-Java looking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java Collections</h1>
                
            
            
                
<p>Java Collections went through a major rework in the last few releases of Java. You can now use a lambda function to describe your comparison point. If that addressed object has the built-in <kbd>compareTo</kbd> function (all of the standard Java objects do), then you are done.</p>
<p>In this case, we build a list of strings (country names) and pass that list to the <kbd>Collections.sort</kbd> routine. The <kbd>sort</kbd> routine becomes very minor, invoking the built-in <kbd>compareTo</kbd> functions for <kbd>String</kbd> in Java:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/594c971d-c63f-47b4-8b18-77dcb6021a0b.png"/></p>
<p class="mce-root"/>
<p>When we run, we can see the results in a sorted order.</p>
<p>There is likely a way to do this without modifying the passed-in array.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java streams</h1>
                
            
            
                
<p>Java streams was a significant improvement with Java 8. Now, Java is able to deal with streams of information flow in a functional manner. In this example, we will use stream in several small examples to show the power of the feature.</p>
<p>The code snippet we are using is as follows:</p>
<pre>public class MyStreams { 
 
    public static void main(String[] args) { 
          List&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;(); 
          numbers.add(3); 
          numbers.add(-1); 
          numbers.add(3); 
          numbers.add(17); 
          numbers.add(7); 
           
          System.out.println("Numbers greater than 2"); 
          numbers.stream() 
                .filter(number -&gt; number &gt; 2) 
                .forEach(number -&gt; System.out.println(number)); 
           
          System.out.println("number size = " +<br/>            numbers.stream().count()); 
           
          Integer big = numbers.stream().max((n1,n2) -&gt; <br/>            Integer.compare(n1, n2)).get(); 
          System.out.println("biggest number = " + big); 
 
          Integer small = numbers.stream().min((n1,n2) -&gt; <br/>            Integer.compare(n1, n2)).get(); 
          System.out.println("smallest number = " + small); 
           
          System.out.println("Sorted"); 
          numbers.stream() 
                .sorted((n1,n2) -&gt; Integer.compare(n1, n2)) 
                .forEach(number -&gt; System.out.println(number)); 
 
          Integer total = numbers.stream() 
                      .collect(Collectors.summingInt(i -&gt; i)) 
                      .intValue(); 
          System.out.println("Total " + total); 
           
          String summary = numbers.stream() 
                .collect(Collectors.summarizingInt(i -&gt; i)) 
                .toString(); 
          System.out.println("Summary " + summary); 
           
          System.out.println("Squares"); 
          numbers.stream() 
                .map(i -&gt; i * i) 
                .forEach(i -&gt; System.out.println(i)); 
           
          System.out.println("Growth"); 
          numbers.stream() 
                .flatMap(i -&gt; build(i)) 
                .sorted() 
                .forEach(i -&gt; System.out.println(i)); 
           
          System.out.println("Distinct growth"); 
          numbers.stream() 
                .flatMap(i -&gt; build(i)) 
                .sorted() 
                .distinct() 
                .forEach(i -&gt; System.out.println(i)); 
    } 
     
    static Stream&lt;Integer&gt; build(Integer i) { 
          List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(); 
          t.add(i); 
          t.add(i*i); 
          t.add(i*i*i); 
          return t.stream(); 
    } 
} </pre>
<p>The code uses a collection (<kbd>stream</kbd>) of numbers for several stream operations. Streams have many more functions built-in to them:</p>
<ol>
<li>First, we use <kbd>filter</kbd> to pick out the elements of interest</li>
<li>We use count to find out how many elements are in the stream</li>
<li>We use a lambda function to find the smallest element in the stream</li>
<li>Next, we use another lambda to sort the stream elements</li>
<li>Then, we use collect and use <kbd>summingInt</kbd> to add up all of the elements</li>
<li>A summary is produced of the stream—this is a built-in function of streams</li>
<li>Finally, we use <kbd>map</kbd> and <kbd>flatMap</kbd> to perform projections (growth) on the stream elements</li>
</ol>
<p>The coding and output look like the following (I added horizontal lines to break up the output so that it's more readable):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/232c84b1-c470-4381-bec7-7d4b2785f225.png"/></p>
<p>I have cut off the display as the rest is consistent with expectations.</p>
<p>Similarly, in the following output, I have not displayed all of the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/25ddec77-f997-4e13-bec4-7df0242c8842.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Java summary statistics</h1>
                
            
            
                
<p>Java can produce summary statistics for a collection. We can retrieve the <kbd>Iris</kbd> dataset and put it into a collection before producing the statistics directly.</p>
<p>I have copied the file from <a href="http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data">http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data</a> to make the processing a little smoother.</p>
<p>We read in the <kbd>Iris</kbd> data and then call upon collections to produce a summary.</p>
<p>The code for this example is as follows:</p>
<pre>import java.io.IOException; 
import java.nio.file.FileSystems; 
import java.nio.file.Files; 
import java.nio.file.Path; 
import java.text.DateFormat; 
import java.util.ArrayList; 
import java.util.List; 
import java.util.Map; 
import java.util.Optional; 
import java.util.regex.Pattern; 
import java.util.stream.Collectors; 
import java.util.stream.Stream; 
 
public class Iris { 
     
    public Iris(Double sepalLength, Double sepalWidth, Double <br/>     petalLength, Double petalWidth, String irisClass) { 
        this.sepalLength = sepalLength; 
        this.sepalWidth = sepalWidth; 
        this.petalLength = petalLength; 
        this.petalWidth = petalWidth; 
        this.irisClass = irisClass; 
    } 
     
    private Double sepalLength; 
    private Double sepalWidth; 
    private Double petalLength; 
    private Double petalWidth; 
    private String irisClass; 
     
    public Double getSepalLength() { 
        return this.sepalLength; 
    } 
     
    //other getters and setters TBD 
} 
 
public class JavaIris { 
     
    public void test() { 
         
        //file originally at http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data 
        Path path = FileSystems 
            .getDefault() 
            .getPath("/Users/ToomeyD/iris.csv"); 
        List&lt;Iris&gt; irises = load(path); 
         
        //produce summary statistics for sepal length values 
        String sepalLengthSummary = irises.stream() 
            .collect(Collectors.summarizingDouble(Iris::getSepalLength)) 
            .toString(); 
        System.out.println("\nSepal Length Summary " + sepalLengthSummary); 
    } 
         
    public List&lt;Iris&gt; load(Path path) { 
        List&lt;Iris&gt; irises = new ArrayList&lt;Iris&gt;(); 
         
        try (Stream&lt;String&gt; stream = Files.lines(path)) { 
            stream.forEach((line) -&gt; { 
                System.out.println(line); 
 
                //put each field into array 
                List&lt;String&gt; fields = new ArrayList&lt;String&gt;(); 
                Pattern.compile(",") 
                    .splitAsStream(line) 
                    .forEach((field) -&gt; fields.add(field)); 
 
                //build up the iris values 
                Double sepalLength = new Double(fields.get(0)); 
                Double sepalWidth = new Double(fields.get(1)); 
                Double petalLength = new Double(fields.get(2)); 
                Double petalWidth = new Double(fields.get(3)); 
                String irisClass = fields.get(4); 
                Iris iris = new Iris(sepalLength, sepalWidth,<br/>                 petalLength, petalWidth, irisClass); 
 
                //add to array 
                irises.add(iris); 
            }); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
 
        return irises; 
    } 
} 
 
new JavaIris().test(); </pre>
<p>The code is parsing out each row of the <kbd>iris</kbd> data into an <kbd>Iris</kbd> object, and is adding that <kbd>Iris</kbd> object to an array.</p>
<p>The main routine then calls upon the collections to produce a summary.</p>
<p>The coding looks like the following, where we have <kbd>Iris</kbd> as a separate object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/95dd4d7c-8f6b-49c7-962a-55f7a75b8ea2.png" style="width:66.83em;height:27.08em;"/></p>
<p>Then, the main coding of the routine to read in the flower information and produce statistics is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2a6bf48d-1c39-4fe8-a66c-29b2b9c508ac.png" style="width:49.92em;height:39.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The tail of the output looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-721 image-border" src="img/9417a600-7b4d-4457-b7dd-af2e35c483ee.png" style="font-size: 1em;text-align: left;width:53.83em;height:18.25em;"/></p>
<p>This kind of processing is much easier to accomplish in the other engines that are available in Jupyter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we saw the steps to install the Java engine into Jupyter. We saw examples of the different output presentations available from Java in Jupyter. Then, we investigated using <kbd>Optional</kbd> fields. We saw what a compile error looks like in Java in Jupyter. Next, we saw several examples of lambdas. We used collections for several purposes. Lastly, we generated summary statistics for one of the <kbd>Iris</kbd> dataset points.</p>
<p>In the next chapter, we will look at how to create interactive widgets that can be used in your Notebook.</p>


            

            
        
    </body></html>