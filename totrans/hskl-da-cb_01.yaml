- en: Chapter 1. The Hunt for Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing data from various sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulating text data from a file path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching I/O code faults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping and representing data from a CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining a JSON file with the aeson package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading an XML file using the HXT package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing table rows from an HTML page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to perform HTTP GET requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to perform HTTP POST requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing online directories for data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MongoDB queries in Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from a remote MongoDB server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data from a SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Introduction](img/ch01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data is everywhere, logging is cheap, and analysis is inevitable. One of the
    most fundamental concepts of this chapter is based on gathering useful data. After
    building a large collection of usable text, which we call the corpus, we must
    learn to represent this content in code. The primary focus will be first on obtaining
    data and later on enumerating ways of representing it.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering data is arguably as important as analyzing it to extrapolate results
    and form valid generalizable claims. It is a scientific pursuit; therefore, great
    care must and will be taken to ensure unbiased and representative sampling. We
    recommend following along closely in this chapter because the remainder of the
    book depends on having a source of data to work with. Without data, there isn't
    much to analyze, so we should carefully observe the techniques laid out to build
    our own formidable corpus.
  prefs: []
  type: TYPE_NORMAL
- en: The first recipe enumerates various sources to start gathering data online.
    The next few recipes deal with using local data of different file formats. We
    then learn how to download data from the Internet using our Haskell code. Finally,
    we finish this chapter with a couple of recipes on using databases in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing data from various sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information can be described as structured, unstructured, or sometimes a mix
    of the two—semi-structured.
  prefs: []
  type: TYPE_NORMAL
- en: In a very general sense, structured data is anything that can be parsed by an
    algorithm. Common examples include JSON, CSV, and XML. If given structured data,
    we can design a piece of code to dissect the underlying format and easily produce
    useful results. As mining structured data is a deterministic process, it allows
    us to automate the parsing. This in effect lets us gather more input to feed our
    data analysis algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Unstructured data is everything else. It is data not defined in a specified
    manner. Written languages such as English are often regarded as unstructured because
    of the difficulty in parsing a data model out of a natural sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In our search for good data, we will often find a mix of structured and unstructured
    text. This is called semi-structured text.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will primarily focus on obtaining structured and semi-structured
    data from the following sources.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike most recipes in this book, this recipe does not contain any code. The
    best way to read this book is by skipping around to the recipes that interest
    you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will browse through the links provided in the following sections to build
    up a list of sources to harness interesting data in usable formats. However, this
    list is not at all exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these sources have an **Application Programming Interface** (**API**)
    that allows more sophisticated access to interesting data. An API specifies the
    interactions and defines how data is communicated.
  prefs: []
  type: TYPE_NORMAL
- en: News
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The New York Times has one of the most polished API documentation to access
    anything from real-estate data to article search results. This documentation can
    be found at [http://developer.nytimes.com](http://developer.nytimes.com).
  prefs: []
  type: TYPE_NORMAL
- en: The Guardian also supports a massive datastore with over a million articles
    at [http://www.theguardian.com/data](http://www.theguardian.com/data).
  prefs: []
  type: TYPE_NORMAL
- en: USA TODAY provides some interesting resources on books, movies, and music reviews.
    The technical documentation can be found at [http://developer.usatoday.com](http://developer.usatoday.com).
  prefs: []
  type: TYPE_NORMAL
- en: The BBC features some interesting API endpoints including information on BBC
    programs, and music located at [http://www.bbc.co.uk/developer/technology/apis.html](http://www.bbc.co.uk/developer/technology/apis.html).
  prefs: []
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Facebook, Twitter, Instagram, Foursquare, Tumblr, SoundCloud, Meetup, and many
    other social networking sites support APIs to access some degree of social information.
  prefs: []
  type: TYPE_NORMAL
- en: For specific APIs such as weather or sports, Mashape is a centralized search
    engine to narrow down the search to some lesser-known sources. Mashape is located
    at [https://www.mashape.com/](https://www.mashape.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Most data sources can be visualized using the Google Public Data search located
    at [http://www.google.com/publicdata](http://www.google.com/publicdata).
  prefs: []
  type: TYPE_NORMAL
- en: For a list of all countries with names in various data formats, refer to the
    repository located at [https://github.com/umpirsky/country-list](https://github.com/umpirsky/country-list).
  prefs: []
  type: TYPE_NORMAL
- en: Academic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some data sources are hosted openly by universities around the world for research
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: To analyze health care data, the University of Washington has published Institute
    for Health Metrics and Evaluation (IHME) to collect rigorous and comparable measurement
    of the world's most important health problems. Navigate to [http://www.healthdata.org](http://www.healthdata.org)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The MNIST database of handwritten digits from NYU, Google Labs, and Microsoft
    Research is a training set of normalized and centered samples for handwritten
    digits. Download the data from [http://yann.lecun.com/exdb/mnist](http://yann.lecun.com/exdb/mnist).
  prefs: []
  type: TYPE_NORMAL
- en: Nonprofits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Human Development Reports publishes annual updates ranging from international
    data about adult literacy to the number of people owning personal computers. It
    describes itself as having a variety of public international sources and represents
    the most current statistics available for those indicators. More information is
    available at [http://hdr.undp.org/en/statistics](http://hdr.undp.org/en/statistics).
  prefs: []
  type: TYPE_NORMAL
- en: The World Bank is the source for poverty and world development data. It regards
    itself as a free source that enables open access to data about development in
    countries around the globe. Find more information at [http://data.worldbank.org/](http://data.worldbank.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The World Health Organization provides data and analyses for monitoring the
    global health situation. See more information at [http://www.who.int/research/en](http://www.who.int/research/en).
  prefs: []
  type: TYPE_NORMAL
- en: 'UNICEF also releases interesting statistics, as the quote from their website
    suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The UNICEF database contains statistical tables for child mortality, diseases,
    water sanitation, and more vitals. UNICEF claims to play a central role in monitoring
    the situation of children and women—assisting countries in collecting and analyzing
    data, helping them develop methodologies and indicators, maintaining global databases,
    disseminating and publishing data. Find the resources at [http://www.unicef.org/statistics](http://www.unicef.org/statistics)."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The United Nations hosts interesting publicly available political statistics
    at [http://www.un.org/en/databases](http://www.un.org/en/databases).
  prefs: []
  type: TYPE_NORMAL
- en: The United States government
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we crave the urge to discover patterns in the United States (U.S.) government
    like Nicholas Cage did in the feature film National Treasure (2004), then [http://www.data.gov/](http://www.data.gov/)
    is our go-to source. It's the U.S. government's active effort to provide useful
    data. It is described as a place to increase "public access to high-value, machine-readable
    datasets generated by the executive branch of the Federal Government". Find more
    information at [http://www.data.gov](http://www.data.gov).
  prefs: []
  type: TYPE_NORMAL
- en: The United States Census Bureau releases population counts, housing statistics,
    area measurements, and more. These can be found at [http://www.census.gov](http://www.census.gov).
  prefs: []
  type: TYPE_NORMAL
- en: Accumulating text data from a file path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to get started with processing input is by reading raw
    text from a local file. In this recipe, we will be extracting all the text from
    a specific file path. Furthermore, to do something interesting with the data,
    we will count the number of words per line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell is a purely functional programming language, right? Sure, but obtaining
    input from outside the code introduces impurity. For elegance and reusability,
    we must carefully separate pure from impure code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first create an `input.txt` text file with a couple of lines of text
    to be read by the program. We keep this file in an easy-to-access directory because
    it will be referenced later. For example, the text file we''re dealing with contains
    a seven-line quote by Plato. Here''s what our terminal prints when we issue the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. The code will also be
    hosted on GitHub at [https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook](https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file to start coding. We call our file Main.hs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all executable Haskell programs, start by defining and implementing
    the `main` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use Haskell''s `readFile :: FilePath -> IO String` function to extract data
    from an `input.txt` file path. Note that a file path is just a synonym for `String`.
    With the string in memory, pass it into a `countWords` function to count the number
    of words in each line, as shown in the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, define our pure function, `countWords`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The program will print out the number of words per line represented as a list
    of numbers as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell provides useful input and output (I/O) capabilities for reading input
    and writing output in different ways. In our case, we use `readFile` to specify
    a path of a file to be read. Using the `do` keyword in `main` suggests that we
    are joining several IO actions together. The output of `readFile` is an I/O string,
    which means it is an I/O action that returns a `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're about to get a bit technical. Pay close attention. Alternatively,
    smile and nod. In Haskell, the I/O data type is an instance of something called
    a Monad. This allows us to use the `<-` notation to draw the string out of this
    I/O action. We then make use of the string by feeding it into our `countWords`
    function that counts the number of words in each line. Notice how we separated
    the `countWords` function apart from the impure `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we print the output of `countWords`. The `$` notation means we are
    using a function application to avoid excessive parenthesis in our code. Without
    it, the last line of `main` would look like `print (countWords input)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For simplicity''s sake, this code is easy to read but very fragile. If an `input.txt`
    file does not exist, then running the code will immediately crash the program.
    For example, the following command will generate the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To make this code fault tolerant, refer to the *Catching I/O code faults* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Catching I/O code faults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making sure our code doesn't crash in the process of data mining or analysis
    is a substantially genuine concern. Some computations may take hours, if not days.
    Haskell gifts us with type safety and strong checks to help ensure a program will
    not fail, but we must also take care to double-check edge cases where faults may
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a program may crash ungracefully if the local file path is not
    found. In the previous recipe, there was a strong dependency on the existence
    of `input.txt` in our code. If the program is unable to find the file, it will
    produce the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, we should decouple the file path dependency by enabling the user
    to specify his/her file path as well as by not crashing in the event that the
    file is not found.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following revision of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, name it `Main.hs`, and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import a library to catch fatal errors as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, import a library to get command-line arguments so that the file path
    is dynamic. We use the following line of code to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continuing as before, define and implement `main` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `fileName` string depending on the user-provided argument, defaulting
    to `input.txt` if there is no argument. The argument is obtained by retrieving
    an array of strings from the library function, `getArgs :: IO [String]`, as shown
    in the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now apply `readFile` on this path, but catch any errors using the library''s
    `catch :: Exception e => IO a -> (e -> IO a) -> IO a` function. The first argument
    to catch is the computation to run, and the second argument is the handler to
    invoke if an exception is raised, as shown in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `input` string will be empty if there were any errors reading the file.
    We can now use `input` for any purpose using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t forget to define the `countWords` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe demonstrates two ways to catch errors, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we use a case expression that pattern matches against any argument
    passed in. Therefore, if no arguments are passed, the `args` list is empty, and
    the last pattern, `"_"`, is caught, resulting in a default filename of `input.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, we use the catch function to handle an error if something goes wrong.
    When having trouble reading a file, we allow the code to continue running by setting
    `input` to an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conveniently, Haskell also comes with a `doesFileExist :: FilePath -> IO Bool`
    function from the `System.Directory` module. We can simplify the preceding code
    by modifying the `input <- …` line. It can be replaced with the following snippet
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the code reads the file as an input only if it exists. Do not
    forget to add the following `import` line at the top of the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Keeping and representing data from a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Comma Separated Value** (**CSV**) is a format to represent a table of values
    in plain text. It''s often used to interact with data from spreadsheets. The specifications
    for CSV are described in RFC 4180, available at [http://tools.ietf.org/html/rfc4180](http://tools.ietf.org/html/rfc4180).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will read a local CSV file called `input.csv` consisting
    of various names and their corresponding ages. Then, to do something useful with
    the data, we will find the oldest person.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prepare a simple CSV file with a list of names and their corresponding ages.
    This can be done using a text editor or by exporting from a spreadsheet, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The raw `input.csv` file contains the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code also depends on the `csv` library. We may install the library through
    Cabal using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `csv` library using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main`, where we will read and parse the CSV file, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply `parseCSV` to the filename to obtain a list of rows, representing the
    tabulated data. The output of `parseCSV` is `Either ParseError CSV`, so ensure
    that we consider both the `Left` and `Right` cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can work with the CSV data. In this example, we find and print the row
    containing the oldest person, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running `main`, the code should produce the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use the `parseCSVFromFile` function to directly get the CSV representation
    from a filename instead of using `readFile` followed `parseCSV`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CSV data structure in Haskell is represented as a list of records. `Record`
    is merely a list of `Fields`, and `Field` is a type synonym for `String`. In other
    words, it is a collection of rows representing a table, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/6331OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `parseCSV` library function returns an `Either` type, with the `Left` side
    being a `ParseError` and the `Right` side being the list of lists. The `Either
    l r` data type is very similar to the `Maybe a` type which has the `Just a` or
    `Nothing` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `either` function to handle the `Left` and `Right` cases. The `Left`
    case handles the error, and the `Right` case handles the actual work to be done
    on the data. In this recipe, the `Right` side is a `Record`. The fields in `Record`
    are accessible through any list operations such as `head`, `last`, `!!`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Examining a JSON file with the aeson package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a way to represent key-value pairs
    in plain text. The format is described extensively in RFC 4627 ([http://www.ietf.org/rfc/rfc4627](http://www.ietf.org/rfc/rfc4627)).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will parse a JSON description about a person. We often encounter
    JSON in APIs from web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install the `aeson` library from hackage using Cabal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare an `input.json` file representing data about a mathematician, such
    as the one in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will be parsing this JSON and representing it as a usable data type in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `OverloadedStrings` language extension to represent strings as `ByteString`,
    as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `aeson` as well as some helper functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the data type corresponding to the JSON structure, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide an instance for the `parseJSON` function, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the input and decode the JSON, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will do something interesting with the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the code to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aeson takes care of the complications in representing JSON. It creates native
    usable data out of a structured text. In this recipe, we use the `.:` and `.:?`
    functions provided by the `Data.Aeson` module.
  prefs: []
  type: TYPE_NORMAL
- en: As the `Aeson` package uses `ByteStrings` instead of `Strings`, it is very helpful
    to tell the compiler that characters between quotation marks should be treated
    as the proper data type. This is done in the first line of the code which invokes
    the `OverloadedStrings` language extension.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Language extensions such as `OverloadedStrings` are currently supported only
    by the **Glasgow Haskell Compiler** (**GHC**).
  prefs: []
  type: TYPE_NORMAL
- en: We use the `decode` function provided by Aeson to transform a string into a
    data type. It has the type `FromJSON a => B.ByteString -> Maybe a`. Our `Mathematician`
    data type must implement an instance of the `FromJSON` typeclass to properly use
    this function. Fortunately, the only required function for implementing `FromJSON`
    is `parseJSON`. The syntax used in this recipe for implementing `parseJSON` is
    a little strange, but this is because we're leveraging applicative functions and
    lenses, which are more advanced Haskell topics.
  prefs: []
  type: TYPE_NORMAL
- en: The `.:` function has two arguments, `Object` and `Text`, and returns a `Parser
    a` data type. As per the documentation, it retrieves the value associated with
    the given key of an object. This function is used if the key and the value exist
    in the JSON document. The `:?` function also retrieves the associated value from
    the given key of an object, but the existence of the key and value are not mandatory.
    So, we use `.:?` for optional key value pairs in a JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the implementation of the `FromJSON` typeclass is too involved, we can easily
    let GHC automatically fill it out using the `DeriveGeneric` language extension.
    The following is a simpler rewrite of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although Aeson is powerful and generalizable, it may be an overkill for some
    simple JSON interactions. Alternatively, if we wish to use a very minimal JSON
    parser and printer, we can use Yocto, which can be downloaded from [http://hackage.haskell.org/package/yocto](http://hackage.haskell.org/package/yocto).
  prefs: []
  type: TYPE_NORMAL
- en: Reading an XML file using the HXT package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extensible Markup Language** (**XML**) is an encoding of plain text to provide
    machine-readable annotations on a document. The standard is specified by W3C ([http://www.w3.org/TR/2008/REC-xml-20081126/](http://www.w3.org/TR/2008/REC-xml-20081126/)).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will parse an XML document representing an e-mail conversation
    and extract all the dates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first set up an XML file called `input.xml` with the following values,
    representing an e-mail thread between Databender and Princess on December 18,
    2014 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Cabal, install the HXT library which we use for manipulating XML documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We only need one import, which will be for parsing XML, using the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main` and specify the XML location. For this recipe,
    the file is retrieved from `input.xml`. Refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the `readString` function to the input and extract all the date documents.
    We filter items with a specific name using the `hasName :: String -> a XmlTree
    XmlTree` function. Also, we extract the text using the `getText :: a XmlTree String`
    function, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use the list of extracted dates as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By running the code, we print the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library function, `runX`, takes in an **Arrow**. Think of an Arrow as a
    more powerful version of a Monad. Arrows allow for stateful global XML processing.
    Specifically, the `runX` function in this recipe takes in `IOSArrow XmlTree String`
    and returns an `IO` action of the `String` type. We generate this `IOSArrow` object
    using the `readString` function, which performs a series of operations to the
    XML data.
  prefs: []
  type: TYPE_NORMAL
- en: For a deep insight into the XML document, `//>` should be used whereas `/>`
    only looks at the current level. We use the `//>` function to look up the date
    attributes and display all the associated text.
  prefs: []
  type: TYPE_NORMAL
- en: 'As defined in the documentation, the `hasName` function tests whether a node
    has a specific name, and the `getText` function selects the text of a text node.
    Some other functions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isText`: This is used to test for text nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAttr`: This is used to test for an attribute tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasAttr`: This is used to test whether an element node has an attribute node
    with a specific name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElemName`: This is used to select the name of an element node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Arrow functions can be found on the `Text.XML.HXT.Arrow.XmlArrow` documentation
    at [http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html](http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html).
  prefs: []
  type: TYPE_NORMAL
- en: Capturing table rows from an HTML page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mining **Hypertext Markup Language** (**HTML**) is often a feat of identifying
    and parsing only its structured segments. Not all text in an HTML file may be
    useful, so we find ourselves only focusing on a specific subset. For instance,
    HTML tables and lists provide a strong and commonly used structure to extract
    data whereas a paragraph in an article may be too unstructured and complicated
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will find a table on a web page and gather all rows to be
    used in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be extracting the values from an HTML table, so start by creating an
    `input.html` file containing a table as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The HTML behind this table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If not already installed, use Cabal to set up the HXT library and the split
    library, as shown in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need the `htx` package for XML manipulations and the `chunksOf` function
    from the split package, as presented in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define and implement `main` to read the `input.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Feed the HTML data into `readString`, thereby setting `withParseHTML` to `yes`
    and optionally turning off warnings. Extract all the `td` tags and obtain the
    remaining text, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The data is now usable as a list of strings. It can be converted into a list
    of lists similar to how CSV was presented in the previous CSV recipe, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By folding through the data, identify the course with the largest capacity
    using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the code will display the class with the largest capacity as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is very similar to XML parsing, except we adjust the options of `readString`
    to `[withParseHTML yes, withWarnings no]`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to perform HTTP GET requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most resourceful places to find good data is online. **GET requests**
    are common methods of communicating with an HTTP web server. In this recipe, we
    will grab all the links from a Wikipedia article and print them to the terminal.
    To easily grab all the links, we will use a helpful library called `HandsomeSoup`,
    which lets us easily manipulate and traverse a webpage through CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be collecting all links from a Wikipedia web page. Make sure to have
    an Internet connection before running this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `HandsomeSoup` CSS selector package, and also install the HXT library
    if it is not already installed. To do this, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires `hxt` for parsing HTML and requires `HandsomeSoup` for
    the easy-to-use CSS selectors, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass in the URL as a string to HandsomeSoup''s `fromUrl` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select all links within the `bodyContent` field of the Wikipedia page as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HandsomeSoup` package allows easy CSS selectors. In this recipe, we run
    the `#bodyContent a` selector on a Wikipedia article web page. This finds all
    link tags that are descendants of an element with the `bodyContent` ID.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common way to obtain data online is through POST requests. To find out
    more, refer to the *Learning how to perform HTTP POST requests* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to perform HTTP POST requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **POST request** is another very common HTTP server request used by many APIs.
    We will be mining the University of Virginia directory search. When sending a
    POST request for a search query, the **Lightweight Directory Access Protocol**
    (**LDAP**) server replies with a web page of search results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, access to the Internet is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `HandsomeSoup` CSS selector package, and also install the HXT library
    if it is not already installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the POST request specified by the directory search website. Depending
    on the server, the following POST request details would be different. Refer to
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main` to run the POST request on a query as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather the HTML and parse it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the table rows and print it out using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the code will display all search results relating to `"poon"`, such
    as "Poonam" or "Witherspoon".
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A POST request needs the specified URI, headers, and body. By filling out a
    `Request` data type, it can be used to establish a server request.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Understanding how to perform HTTP GET requests* recipe for details
    on how to perform a GET request instead.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing online directories for data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A directory search typically provides names and contact information per query.
    By brute forcing many of these search queries, we can obtain all data stored in
    the directory listing database. This recipe runs thousands of search queries to
    obtain as much data as possible from a directory search. This recipe is provided
    only as a learning tool to see the power and simplicity of data gathering in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure to have a strong Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `hxt` and `HandsomeSoup` packages using Cabal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set up the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `SearchResult` type, which may either fault in an error or result
    in a success, as presented in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the POST request specified by the directory search website. Depending
    on the server, the POST request will be different. Instead of rewriting code,
    we use the `myRequest` function defined in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a helper function to obtain the document from a HTTP POST request, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scan the HTML document and return whether there is an error or provide the
    resulting data. The code in this function is dependent on the error messages produced
    by the web page. In our case, the error messages are the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main`. We will use a helper function, `main''`, as shown
    in the following code snippet, to recursively brute force the directory listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run a search of the query and then recursively again on the next query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write helper functions to define the next logical query as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code starts by searching for "a" in the directory lookup. This will most
    likely fault in an error as there are too many results. So, in the next iteration,
    the code will refine its search by querying for "aa", then "aaa", until there
    is no longer `TooManyResultsErr :: SearchResultErr`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it will enumerate to the next logical search query "aab", and if that
    produces no result, it will search for "aac", and so on. This brute force prefix
    search will obtain all items in the database. We can gather the mass of data,
    such as names and department types, to perform interesting clustering or analysis
    later on. The following figure shows how the program starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/6331OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using MongoDB queries in Haskell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a nonrelational schemaless database. In this recipe, we will obtain
    all data from MongoDB into Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to install MongoDB on our local machine and have a database instance
    running in the background while we run the code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB installation instructions are located at [http://www.mongodb.org](http://www.mongodb.org).
    On Debian-based operating systems, we can use `apt-get` to install MongoDB, using
    the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the database daemon by specifying the database file path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill up a `"people"` collection with dummy data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the MongoDB package from Cabal using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `OverloadedString` and `ExtendedDefaultRules` language extensions to
    make the MongoDB library easier to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and implement `main` to set up a connection to the locally hosted database.
    Run MongoDB queries defined in the `run` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `run`, we can combine multiple operations. For this recipe, `run` will only
    perform one task, that is, gather data from the `"people"` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pipe is established by the driver between the running program and the database.
    This allows running MongoDB operations to bridge the program with the database.
    The `find` function takes a query, which we construct by evoking the `select ::
    Selector -> Collection -> aQueryOrSelection` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Other functions can be found in the documentation at [http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html](http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the MongoDB database is on a remote server, refer to the *Reading from a
    remote MongoDB server* recipe to set up a connection with remote databases.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a remote MongoDB server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, it may be more feasible to set up a MongoDB instance on a remote
    machine. This recipe will cover how to obtain data from a MongoDB hosted remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should create a remote database. MongoLab ([https://mongolab.com](https://mongolab.com))
    and MongoHQ ([http://www.mongohq.com](http://www.mongohq.com)) offer MongoDB as
    a service and have free options to set up a small development database.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These services will require us to accept their terms and conditions. For some
    of us, it may be best to host the database in our own remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the MongoDB package from Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, install the helper following helper libraries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `OverloadedString` and `ExtendedDefaultRules` language extensions required
    by the library. Import helper functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the remote URI for the database connection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The username, password, hostname, port address number, and database name must
    be extracted from the URI, as presented in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a database connection by reading the host port of the remote URI as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Optionally authenticate to the database and obtain data from the `"people"`
    collection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the database is on a local machine, refer to the *Using MongoDB queries in
    Haskell* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data from a SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a relational database that enforces a strict schema. It is simply
    a file on a machine that we can interact with through **Structured Query Language**
    (**SQL**). There is an easy-to-use Haskell library to send these SQL commands
    to our database.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use such a library to extract all data from a SQLite
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to install the SQLite database if it isn''t already set up. It can
    be obtained from [http://www.sqlite.org](http://www.sqlite.org). On Debian systems,
    we can get it from `apt-get` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a simple database to test our code, using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also install the SQLite Haskell package from Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This recipe will dissect the example code presented on the library's documentation
    page available at [http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html](http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `OverloadedStrings` language extension and import the relevant libraries,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a data type for each SQLite table field. Provide it with an instance
    of the `FromRow` typeclass so that we may easily parse it from the table, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And lastly, open the database to import everything as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
