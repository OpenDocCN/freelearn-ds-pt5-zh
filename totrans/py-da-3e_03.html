<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    NumPy and pandas
                </header>
            
            <article>
                
<p class="mce-root">Now that <span>we have understood data analysis, its process, and its installation on different platforms, it's time to learn about NumPy arrays and <kbd>pandas</kbd> DataFrames. This chapter acquaints you with the fundamentals of NumPy arrays and <kbd>pandas</kbd> DataFrames. By the end of this chapter, you will have a basic understanding of NumPy arrays, and <kbd>pandas</kbd> DataFrames and their related functions.</span></p>
<p class="mce-root"><kbd>pandas</kbd> is named after panel data (an econometric term) and Python data analysis and is a popular open-source Python library. We shall learn about basic <kbd>pandas</kbd> functionalities, data structures, and operations in this chapter. The official <kbd>pandas</kbd> documentation insists on naming the project <kbd>pandas</kbd> in all lowercase letters. The other convention the <kbd>pandas</kbd> project insists on is the <kbd>import pandas as pd</kbd> import statement.</p>
<p class="mce-root">In this chapter, our focus will be on the following topics:</p>
<ul>
<li>Understanding NumPy arrays</li>
<li>NumPy array numerical data types</li>
<li>Manipulating array shapes</li>
<li>The stacking of NumPy arrays</li>
<li>Partitioning NumPy arrays</li>
<li>Changing the data type of NumPy arrays</li>
<li>Creating NumPy views and copies</li>
<li>Slicing NumPy arrays</li>
<li>Boolean and fancy indexing</li>
<li>Broadcasting arrays</li>
<li>Creating <kbd>pandas</kbd> DataFrames</li>
<li>Understanding <kbd>pandas</kbd> Series</li>
<li>Reading and querying the Quandl data</li>
<li>Describing <kbd>pandas</kbd> DataFrames</li>
</ul>
<ul>
<li>Grouping and joining <kbd>pandas</kbd> DataFrames</li>
<li>Working with missing values</li>
<li>Creating pivot tables</li>
<li>Dealing with dates</li>
</ul>
<h1 id="uuid-65f5c6be-31f6-4eee-9018-c2a59ed92db8">Technical requirements</h1>
<p>This chapter has the following technical requirements:</p>
<ul>
<li>You can find the code and the dataset at the following GitHub link: <a href="https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02">https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02</a>.</li>
<li>All the code blocks are available at <kbd>ch2.ipynb</kbd>.</li>
<li>This chapter uses four CSV files (<kbd>WHO_first9cols.csv</kbd>, <kbd>dest.csv</kbd>, <kbd>purchase.csv</kbd>, and <kbd>tips.csv</kbd>) for practice purposes.</li>
<li>In this chapter, we will use the NumPy, <kbd>pandas</kbd>, and Q<span>uandl Python libraries.</span></li>
</ul>
<h1 id="uuid-fd8bc309-adaa-48da-8628-305c5c911433" class=""><span>Understanding NumPy arrays</span></h1>
<p class="mce-root">NumPy can be installed on a PC using <kbd>pip</kbd> or <kbd>brew</kbd> but if the user is using the Jupyter Notebook, then there is no need to install it. NumPy is already installed in the Jupyter Notebook. I will suggest to you to please use the Jupyter Notebook as your IDE because we are executing all the code in the Jupyter Notebook. We have already shown in <a href="d6dfd6dc-2d6e-4984-a2d6-e205384cd2a8.xhtml">Chapter 1</a>, <em>Getting Started with Python Libraries</em>, how to install Anaconda, which is a complete suite for data analysis. NumPy arrays are a series of homogenous items. Homogenous means the array will have all the elements of the same data type. Let's create an array using NumPy. You can create an array using the <kbd>array()</kbd> function with a list of items. Users can also fix the data type of an array. Possible data types are <kbd>bool</kbd>, <kbd>int</kbd>, <kbd>float</kbd>, <kbd>long</kbd>, <kbd>double</kbd>, and <kbd>long double</kbd>.</p>
<p class="mce-root">Let's see how to create an empty array:</p>
<pre># Creating an array<br/>import numpy as np<br/>a = np.array([2,4,6,8,10])<br/>print(a)<br/><br/><strong>Output:</strong><br/>[ 2 4 6 8 10]</pre>
<p class="mce-root">Another way to create a NumPy array is with <kbd>arange()</kbd>. It creates an evenly spaced NumPy array. Three values – start, stop, and step – can be passed to the <kbd>arange(start,[stop],step)</kbd> function. The start is the initial value of the range, the stop is the last value of the range, and the step is the increment in that range. The stop parameter is compulsory. In the following example, we have used <kbd>1</kbd> as the start and <kbd>11</kbd> as the stop parameter. The <kbd>arange(1,11)</kbd> function will return 1 to 10 values with one step because the step is, <span>by default,</span> <span>1. The</span> <kbd>arrange()</kbd> <span>function generates a value that is one less than the stop parameter value. Let's understand this through the following example:</span></p>
<pre># Creating an array using arange()<br/>import numpy as np<br/>a = np.arange(1,11)<br/>print(a)<br/><br/><strong>Output:</strong><br/>[ 1 2 3 4 5 6 7 8 9 10]</pre>
<p class="mce-root">Apart from the <kbd>array()</kbd> and <kbd>arange()</kbd> functions, there are other options, such as <kbd>zeros()</kbd>, <kbd>ones()</kbd>, <kbd>full()</kbd>, <kbd>eye()</kbd>, and <kbd>random()</kbd>, which can also be used to create a NumPy array, as these functions are initial placeholders. Here is a detailed description of each function:</p>
<ul>
<li><kbd>zeros()</kbd><span>: The</span> <kbd>zeros()</kbd><span>function creates an array for a given dimension with all zeroes.</span></li>
<li><kbd>ones()</kbd>: The <kbd>ones()</kbd> function creates an <span>array</span> for a given dimension with all ones.</li>
<li><kbd>fulls()</kbd>: The <kbd>full()</kbd> function generates an <span>array</span> with constant values.</li>
<li><kbd>eyes()</kbd>: The <kbd>eye()</kbd> function creates an identity matrix.</li>
<li><kbd>random()</kbd>: The <kbd>random()</kbd> function creates an <span>array</span> with any given dimension.</li>
</ul>
<p><span>Let's understand these functions through the following example:</span></p>
<pre>import numpy as np<br/><br/># Create an array of all zeros<br/>p = np.zeros((3,3)) <br/>print(p) <br/><br/># Create an array of all ones<br/>q = np.ones((2,2)) <br/>print(q)<br/><br/># Create a constant array<br/>r = np.full((2,2), 4) <br/>print(r) <br/><br/># Create a 2x2 identity matrix<br/>s = np.eye(4) <br/>print(s) <br/><br/># Create an array filled with random values<br/>t = np.random.random((3,3))<br/>print(t)</pre>
<p>This results in the following output:</p>
<pre>[[0. 0. 0.]<br/> [0. 0. 0.]<br/> [0. 0. 0.]]<br/><br/>[[1. 1.]<br/> [1. 1.]]<br/><br/>[[4 4]<br/> [4 4]]<br/><br/>[[1. 0. 0. 0.]<br/> [0. 1. 0. 0.]<br/> [0. 0. 1. 0.]<br/> [0. 0. 0. 1.]]<br/><br/>[[0.16681892 0.00398631 0.61954178]<br/> [0.52461924 0.30234715 0.58848138]<br/> [0.75172385 0.17752708 0.12665832]]</pre>
<p>In the preceding code, we have seen some built-in functions for creating arrays with all-zero values, all-one values, and all-constant values. After that, we have created the identity matrix using the <kbd>eye()</kbd> function and a random matrix using the <kbd>random.random()</kbd> function. Let's see some other array features in the next section.</p>
<h2 id="uuid-0ced8d00-887b-4f4d-be2e-3613ba55c776">Array features</h2>
<p><span>In general, NumPy arrays are a homogeneous kind of data structure that has the same types of items. The main benefit of an array is its certainty of storage size because of its same type of items. A Python list uses a loop to iterate the elements and perform operations on them. Another benefit of NumPy arrays is to offer vectorized operations instead of iterating each item and performing operations on it. NumPy arrays are indexed just like a Python list and start from 0. NumPy uses an optimized C API for the fast processing of the array operations.</span></p>
<p><span>Let's make an array using the <kbd>arange()</kbd> function, as we did in the previous section, and let's check its data type:</span></p>
<pre># Creating an array using arange()<br/>import numpy as np<br/>a = np.arange(1,11)<br/><br/>print(type(a))<br/>print(a.dtype)<br/><strong><br/>Output:<br/></strong>&lt;class 'numpy.ndarray'&gt;<br/>int64</pre>
<p class="mce-root"><span>When you use <kbd>type()</kbd>, it returns <kbd>numpy.ndarray</kbd>. This means that the <kbd>type()</kbd> function returns the type of the container. When you use <kbd>dtype()</kbd>, it will return <kbd>int64</kbd>, since it is the type of the elements. You may also get the output as <kbd>int32</kbd> if you are using 32-bit Python. Both cases use integers (32- and 64-bit). One-dimensional NumPy arrays are also known as vectors.</span></p>
<p>Let's find out the shape of the vector that we produced a few minutes ago:</p>
<pre>print(a.shape)<br/><strong>Output:</strong> (10,)</pre>
<p>As you can see, the vector has 10 elements with values ranging from 1 to 10. The <kbd>shape</kbd> property of the array is a tuple; in this instance, it is a tuple of one element, which holds the length in each dimension.</p>
<h2 id="uuid-2e33f6d4-4df3-4ce9-a2e3-74aa2dff1bb3">Selecting array elements</h2>
<p>In this section, we will see how to select the elements of the array. Let's see an example of a 2*2 matrix:</p>
<pre>a = np.array([[5,6],[7,8]])<br/>print(a)<br/><br/><strong>Output:<br/></strong>[[5 6]<br/> [7 8]]</pre>
<p>In the preceding example, the matrix is created using the <kbd>array()</kbd> function with the input list of lists.</p>
<p>Selecting array elements is pretty simple. We just need to specify the index of the matrix as <kbd>a[m,n]</kbd>. Here, <kbd>m</kbd> is the row index and <kbd>n</kbd> is the column index of the matrix. We will now select each item of the matrix one by one as shown in the following code:</p>
<pre>print(a[0,0])<br/><strong>Output:</strong> 5<br/><br/>print(a[0,1])<br/><strong>Output:</strong> 6<br/><br/>printa([1,0])<br/><strong>Output:</strong> 7<br/><br/>printa([1,1])<br/><strong>Output:</strong> 8<br/><br/></pre>
<p>In the preceding code sample, we have tried to access each element of an array using array indices. You can also understand this by the diagram mentioned here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b919f96a-3be5-4592-821a-1f8494af6bbb.png" style=""/></div>
<p>In the preceding diagram, we can see it has four blocks and each block represents the element of an array. The values written in each block show its indices.</p>
<p>In this section, we have understood the fundamentals of arrays. Now, let's jump to arrays of numerical data types.</p>
<h1 id="uuid-7c455e15-01cd-436d-b198-65e9d064530b" class="mce-root">NumPy array numerical data types</h1>
<p class="mce-root">Python offers three types of numerical data types: integer type, float type, and complex type. In practice, we need more data types for scientific computing operations with precision, range, and size. NumPy offers a bulk of data types with mathematical types and numbers. Let's see the following table of NumPy numerical types:</p>
<table style="width: 100%;border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 25.1451%">
<p><strong>Data Type</strong></p>
</td>
<td style="width: 74.1779%">
<p><strong>Details</strong></p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>bool</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This is a Boolean type that stores a bit and takes <kbd>True</kbd> or <kbd>False</kbd> values.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>inti</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Platform integers can be either <kbd>int32</kbd> or <kbd>int64</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>int8</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Byte store values range from <kbd>-128</kbd> to <kbd>127</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>int16</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores integers ranging from <kbd>-32768</kbd> to <kbd>32767</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>int32</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores integers ranging from <kbd>-2 ** 31</kbd> to <kbd>2 ** 31 -1</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>int64</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores integers ranging from <kbd>-2 ** 63</kbd> to <kbd>2 ** 63 -1</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>uint8</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores unsigned integers ranging from <kbd>0</kbd> to <kbd>255</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>uint16</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores unsigned integers ranging from <kbd>0</kbd> to <kbd>65535</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>uint32</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores unsigned integers ranging from <kbd>0</kbd> to <kbd>2 ** 32 – 1</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>uint64</kbd></p>
</td>
<td style="width: 74.1779%">
<p>This stores unsigned integers ranging from <kbd>0</kbd> to <kbd>2 ** 64 – 1</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>float16</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Half-precision float; sign bit with 5 bits exponent and 10 bits mantissa.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>float32</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Single-precision float; sign bit with 8 bits exponent and 23 bits mantissa.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>float64</kbd> or <kbd>float</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Double-precision float; sign bit with 11 bits exponent and 52 bits mantissa.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>complex64</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Complex number stores two 32-bit floats: real and imaginary number.</p>
</td>
</tr>
<tr>
<td style="width: 25.1451%">
<p><kbd>complex128</kbd> or <kbd>complex</kbd></p>
</td>
<td style="width: 74.1779%">
<p>Complex number stores two 64-bit floats: real and imaginary number.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For each data type, there exists a matching conversion function:</p>
<pre>print(np.float64(21))<br/><strong>Output:</strong> 21.0<br/><br/>print(np.int8(21.0))<br/><strong>Output:</strong> 42<br/><br/>print(np.bool(21))<br/><strong>Output:</strong> True<br/><br/>print(np.bool(0))<br/><strong>Output:</strong> False<br/><br/>print(np.bool(21.0))<br/><strong>Output:</strong> True<br/><br/>print(np.float(True))<br/><strong>Output:</strong> 1.0<br/><br/>print(np.float(False))<br/><strong>Output:</strong> 0.0</pre>
<p>Many functions have a data type argument, which is frequently optional:</p>
<pre>arr=np.arange(1,11, dtype<strong>=</strong> np.float32)<br/>print(arr)<br/><strong><br/>Output:</strong>  <br/>[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.]</pre>
<p>It is important to be aware that you are not allowed to change a complex number into an integer. If you try to convert complex data types into integers, then you will get <kbd>TypeError</kbd>. Let's see the following example:</p>
<pre>np.int(42.0 + 1.j)</pre>
<p>This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dcf3bbd1-687f-456d-b900-f5dd18413eb2.png" style=""/></div>
<p>You will get the same error if you try the conversion of a complex number into a floating point.</p>
<p>But you can convert float values into complex numbers by setting individual pieces. You can also pull out the pieces using the <kbd>real</kbd> and <kbd>imag</kbd> attributes. Let's see that using the following example:</p>
<pre>c<strong>=</strong> complex(42, 1)<br/>print(c)<br/><br/><strong>Output:</strong> (42+1j)<br/><br/>print(c.real,c.imag)<br/><strong><br/>Output:</strong> 42.0 1.0</pre>
<p>In the preceding example, you have defined a complex number using the <kbd>complex()</kbd> method. Also, you have extracted the real and imaginary values using the <kbd>real</kbd> and <kbd>imag</kbd> attributes. Let's now jump to <kbd>dtype</kbd> objects.</p>
<h2 id="uuid-15e01832-ef21-424e-b717-490067314bce" class="mce-root">dtype objects</h2>
<p>We have seen in earlier sections of the chapter that <kbd>dtype</kbd> tells us the type of individual elements of an array. NumPy array elements have the same data type, which means that all elements have the same <kbd>dtype</kbd>. <kbd>dtype</kbd> objects are instances of the <kbd>numpy.dtype</kbd> class:</p>
<pre># Creating an array<br/>import numpy as np<br/>a = np.array([2,4,6,8,10])<br/><br/>print(a.dtype)<br/><strong>Output:</strong> 'int64'</pre>
<p><kbd>dtype</kbd> objects also tell us the size of the data type in bytes using the <kbd>itemsize</kbd> property:</p>
<pre>print(a.dtype.itemsize)<br/><strong>Output:</strong>8</pre>
<h2 id="uuid-1a7213e9-d17b-44bb-a234-305b714058b7" class="mce-root"><span>Data type character codes</span></h2>
<div>
<p>Character codes are included for backward compatibility with Numeric. Numeric is the predecessor of NumPy. Its use is not recommended, but the code is supplied here because it pops up in various locations. You should use the <kbd>dtype</kbd> object instead. The following table lists several different data types and the character codes related to them:</p>
<table style="width: 100.247%;border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 59.6321%">
<p><strong>Type</strong></p>
</td>
<td style="width: 39.9376%">
<p><strong>Character Code</strong></p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Integer</p>
</td>
<td style="width: 39.9376%">
<p>i</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Unsigned integer</p>
</td>
<td style="width: 39.9376%">
<p>u</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Single-precision float</p>
</td>
<td style="width: 39.9376%">
<p>f</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Double-precision float</p>
</td>
<td style="width: 39.9376%">
<p>d</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Bool</p>
</td>
<td style="width: 39.9376%">
<p>b</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Complex</p>
</td>
<td style="width: 39.9376%">
<p>D</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>String</p>
</td>
<td style="width: 39.9376%">
<p>S</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Unicode</p>
</td>
<td style="width: 39.9376%">
<p>U</p>
</td>
</tr>
<tr>
<td style="width: 59.6321%">
<p>Void</p>
</td>
<td style="width: 39.9376%">
<p>V</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's take a look at the following code to produce an array of single-precision floats:</p>
<pre># Create numpy array using arange() function<br/>var1=np.arange(1,11, dtype='f')<br/>print(var1)<br/><br/><strong>Output:</strong><br/>[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.]</pre>
<p>Likewise, the following code creates an array of complex numbers:</p>
<pre>print(np.arange(1,6, dtype='D'))<br/><br/><strong>Output:</strong><br/>[1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j, 5.+0.j]</pre></div>
<h2 id="uuid-cb829e98-38cc-423d-8466-a0afce0705b3">dtype constructors</h2>
<p>There are lots of ways to create data types using constructors. Constructors are used to instantiate or assign a value to an object. In this section, we will understand data type creation with the help of a floating-point data example:</p>
<ul>
<li>To try out a general Python float, use the following:</li>
</ul>
<pre style="padding-left: 60px">print(np.dtype(float))<br/><strong>Output:</strong> float64</pre>
<ul>
<li>To try out a single-precision float with a character code, use the following:</li>
</ul>
<pre style="padding-left: 60px">print(np.dtype('f'))<br/><strong>Output:</strong> float32</pre>
<ul>
<li>To try out a double-precision float with a character code, use the following:</li>
</ul>
<pre style="padding-left: 60px">print(np.dtype('d'))<br/><strong>Output:</strong> float64</pre>
<ul>
<li>To try out a <kbd>dtype</kbd> constructor with a two-character code, use the following:</li>
</ul>
<pre style="padding-left: 60px">print(np.dtype('f8'))<br/><strong>Output:</strong> float64</pre>
<p>Here, the first character stands for the type and a second character is a number specifying the number of bytes in the type, for example, 2, 4, or 8.</p>
<h2 id="uuid-db20d4da-55e8-45e8-8872-4c6bc6da427f">dtype attributes</h2>
<p class="mce-root">The <kbd>dtype</kbd> class offers several useful attributes. For example, we can get information about the character code of a data type using the <kbd>dtype</kbd> attribute:</p>
<pre># Create numpy array <br/>var2=np.array([1,2,3],dtype='float64')<br/><br/>print(var2.dtype.char)<br/><br/><strong>Output:</strong> 'd'</pre>
<p>The <kbd>type</kbd> attribute corresponds to the type of object of the array elements:</p>
<pre>print(var2.dtype.type)<br/><br/><strong>Output:</strong> &lt;class 'numpy.float64'&gt;</pre>
<p>Now that we know all about the various data types used in NumPy arrays, let's start manipulating them in the next section.</p>
<h1 id="uuid-988555d7-c7a2-418d-bd67-bd336fd0084e" class="mce-root">Manipulating array shapes</h1>
<p>In this section, our main focus is on array manipulation. Let's learn some new Python functions of NumPy, such as <kbd>reshape()</kbd>, <kbd>flatten()</kbd>, <kbd>ravel()</kbd>, <kbd>transpose()</kbd>, and <kbd>resize()</kbd>:</p>
<ul>
<li><kbd>reshape()</kbd> will change the shape of the array:</li>
</ul>
<pre style="padding-left: 60px"># Create an array<br/>arr = np.arange(12)<br/>print(arr)<br/><strong><br/>Output:</strong> [ 0  1  2  3  4  5  6  7  8  9 10 11]<br/><br/># Reshape the array dimension<br/>new_arr=arr.reshape(4,3)<br/><br/>print(new_arr)<br/><br/><strong>Output:</strong> [[ 0,  1,  2],<br/>               [ 3,  4,  5],<br/>               [ 6,  7,  8],<br/>               [ 9, 10, 11]]<br/><br/># Reshape the array dimension<br/>new_arr2=arr.reshape(3,4)<br/><br/>print(new_arr2)<br/><br/><strong>Output:</strong><br/>array([[ 0,  1,  2,  3],<br/>       [ 4,  5,  6,  7],<br/>       [ 8,  9, 10, 11]])</pre>
<ul>
<li>Another operation that can be applied to arrays is <kbd>flatten()</kbd>. <kbd>flatten()</kbd> transforms an n-dimensional array into a one-dimensional array:</li>
</ul>
<pre style="padding-left: 60px"># Create an array<br/>arr=np.arange(1,10).reshape(3,3)<br/>print(arr)<br/><br/><strong>Output:</strong> <br/>[[1 2 3]<br/> [4 5 6]<br/> [7 8 9]]<br/><br/>print(arr.flatten())<br/><br/><strong>Output:</strong> <br/>[1 2 3 4 5 6 7 8 9]</pre>
<ul>
<li>The <kbd>ravel()</kbd> function is similar to the <kbd>flatten()</kbd> function. It also transforms an n-dimensional array into a one-dimensional array. The main difference is that <kbd>flatten()</kbd> returns the actual array while <kbd>ravel()</kbd> returns the reference of the original array. The <kbd>ravel()</kbd> function is faster than the <kbd>flatten()</kbd> function because it does not occupy extra memory:</li>
</ul>
<pre style="padding-left: 60px">print(arr.ravel())<br/><strong><br/>Output:</strong> <br/>[1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
<ul>
<li>The <kbd>transpose()</kbd> function is a linear algebraic function that transposes the given two-dimensional matrix. The word transpose means converting rows into columns and columns into rows:</li>
</ul>
<pre style="padding-left: 60px"># Transpose the matrix<br/>print(arr.transpose())<br/><strong><br/>Output:</strong><br/>[[1 4 7]<br/> [2 5 8]<br/> [3 6 9]]</pre>
<ul>
<li>The <kbd>resize()</kbd> function changes the size of the NumPy array. It is similar to <kbd>reshape()</kbd> but it changes the shape of the original array:</li>
</ul>
<pre style="padding-left: 60px"># resize the matrix<br/>arr.resize(1,9)<br/>print(arr)<br/><br/><strong>Output:</strong>[[1 2 3 4 5 6 7 8 9]]</pre>
<p>In all the code in this section, we have seen built-in functions such as <kbd>reshape()</kbd>, <span><kbd>flatten()</kbd>, <kbd>ravel()</kbd>, <kbd>transpose()</kbd>, and <kbd>resize()</kbd> for manipulating size. Now, it's time to learn about the stacking of NumPy arrays.</span></p>
<h1 id="uuid-0e50d4d0-b067-4a69-98d9-963fd6b038cf" class="mce-root">The stacking of NumPy arrays</h1>
<p>NumPy offers a stack of arrays. Stacking means joining the same dimensional arrays along with a new axis. Stacking can be done horizontally, vertically, column-wise, row-wise, or depth-wise:</p>
<ul>
<li><strong>Horizontal stacking</strong>: In horizontal stacking, the same dimensional arrays are joined along with a horizontal axis using the <kbd>hstack()</kbd> and <kbd>concatenate()</kbd> functions. Let's see the following example:</li>
</ul>
<pre style="padding-left: 60px">arr1 = np.arange(1,10).reshape(3,3)<br/>print(arr1)<br/><br/><strong>Output:<br/></strong>[[1 2 3]<br/> [4 5 6]<br/> [7 8 9]]</pre>
<p style="padding-left: 60px">We have created one 3*3 array; it's time to create another 3*3 array:</p>
<pre style="padding-left: 60px">arr2 = 2*arr1<br/>print(arr2)<br/><br/><strong>Output:<br/></strong>[[ 2 4 6]<br/> [ 8 10 12]<br/> [14 16 18]]</pre>
<p style="padding-left: 60px">After creating two arrays, we will perform horizontal stacking:</p>
<pre style="padding-left: 60px"># Horizontal Stacking<br/>arr3=np.hstack((arr1, arr2))<br/>print(arr3)<br/><br/><strong>Output:<br/></strong>[[ 1 2 3 2 4 6]<br/> [ 4 5 6 8 10 12]<br/> [ 7 8 9 14 16 18]]</pre>
<p style="padding-left: 60px">In the preceding code, two arrays are stacked horizontally along the <em>x</em> axis. The <kbd>concatenate()</kbd> function can also be used to generate the horizontal stacking with axis parameter value <kbd>1</kbd>:</p>
<pre style="padding-left: 60px"># Horizontal stacking using concatenate() function<br/>arr4=np.concatenate((arr1, arr2), axis=1)<br/>print(arr4)<br/><br/><strong>Output:<br/></strong>[[ 1 2 3 2 4 6]<br/> [ 4 5 6 8 10 12]<br/> [ 7 8 9 14 16 18]]</pre>
<p style="padding-left: 60px">In the preceding code, two arrays have been stacked horizontally using the <kbd>concatenate()</kbd> function.</p>
<ul>
<li><strong>Vertical stacking</strong>: In vertical stacking, the same dimensional arrays are joined along with a vertical axis using the <kbd>vstack()</kbd> and <kbd>concatenate()</kbd> functions. Let's see the following example:</li>
</ul>
<pre style="padding-left: 60px"># Vertical stacking<br/>arr5=np.vstack((arr1, arr2))<br/>print(arr5)<br/><br/><strong>Output:<br/></strong>[[ 1 2 3]<br/> [ 4 5 6]<br/> [ 7 8 9]<br/> [ 2 4 6]<br/> [ 8 10 12]<br/> [14 16 18]]</pre>
<p style="padding-left: 60px"><span>In the preceding code, two arrays are stacked vertically along the <em>y</em> axis. The</span> <kbd>concatenate()</kbd> function can also be used to generate vertical stacking with axis parameter value <kbd>0</kbd>:</p>
<pre style="padding-left: 60px">arr6=np.concatenate((arr1, arr2), axis=0) <br/>print(arr6)<br/><br/><strong>Output:<br/></strong>[[ 1 2 3]<br/> [ 4 5 6]<br/> [ 7 8 9]<br/> [ 2 4 6]<br/> [ 8 10 12]<br/> [14 16 18]]<br/><br/></pre>
<p style="padding-left: 60px">In the preceding code, two arrays are stacked vertically using the <kbd>concatenate()</kbd> function.</p>
<ul>
<li><strong>Depth stacking</strong>: In depth stacking, the same dimensional arrays are joined along with a third axis (depth) using the <kbd>dstack()</kbd> function. Let's see the following example:</li>
</ul>
<pre style="padding-left: 60px">arr7=np.dstack((arr1, arr2))<br/>print(arr7)<br/><br/><strong>Output:<br/></strong>[[[ 1 2]<br/>  [ 2 4]<br/>  [ 3 6]]<br/><br/> [[ 4 8]<br/>  [ 5 10]<br/>  [ 6 12]]<br/><br/> [[ 7 14]<br/>  [ 8 16]<br/>  [ 9 18]]]</pre>
<p style="padding-left: 60px"><span>In the preceding code, two arrays are stacked in depth along with a third axis (depth).</span></p>
<ul>
<li><strong>Column stacking</strong>: Column stacking stacks multiple sequence one-dimensional arrays as columns into a single two-dimensional array. Let's see an example of column stacking:</li>
</ul>
<pre style="padding-left: 60px"># Create 1-D array<br/>arr1 = np.arange(4,7) <br/>print(arr1)<br/><br/><strong>Output:</strong> [4, 5, 6]</pre>
<p style="padding-left: 60px">In the preceding code block, we have created a one-dimensional NumPy array.</p>
<pre style="padding-left: 60px"># Create 1-D array<br/>arr2 = 2 * arr1<br/>print(arr2)<br/><br/><strong>Output:</strong> [ 8, 10, 12]</pre>
<p style="padding-left: 60px">In the preceding code block, we have created another one-dimensional NumPy array.</p>
<pre style="padding-left: 60px"># Create column stack<br/>arr_col_stack=np.column_stack((arr1,arr2))<br/>print(arr_col_stack)<br/><br/><strong>Output:<br/></strong>[[ 4 8]<br/> [ 5 10]<br/> [ 6 12]]</pre>
<p style="padding-left: 60px"><span>In the preceding code, we have created two one-dimensional arrays and stacked them column-wise.</span></p>
<ul>
<li><strong>Row stacking</strong>: Row stacking stacks multiple sequence one-dimensional arrays as rows into a single two-dimensional arrays. <span>Let's see an example of row stacking:</span></li>
</ul>
<pre style="padding-left: 60px"># Create row stack<br/>arr_row_stack = np.row_stack((arr1,arr2)) <br/>print(arr_row_stack)<br/><br/><strong>Output:<br/></strong>[[ 4 5 6]<br/> [ 8 10 12]]</pre>
<p style="padding-left: 60px"><span>In the preceding code, two one-dimensional arrays are stacked row-wise.</span></p>
<p>Let's now see how to partition a NumPy array into multiple sub-arrays.</p>
<h1 id="uuid-7da4a9e1-c6f5-4497-b665-6d3476d4c1b9" class="mce-root">Partitioning NumPy arrays</h1>
<p>NumPy arrays can be partitioned into multiple sub-arrays. NumPy offers three types of split functionality: vertical, horizontal, and depth-wise. All the split functions by default split into the same size arrays but we can also specify the split location. Let's look at each of the functions in detail:</p>
<ul>
<li><strong>Horizontal splitting</strong>: In horizontal split, the given array is divided into <em>N</em> equal sub-arrays along the horizontal axis using the <kbd>hsplit()</kbd> function. Let's see how to split an array:</li>
</ul>
<pre style="padding-left: 60px"># Create an array<br/>arr=np.arange(1,10).reshape(3,3)<br/>print(arr)<br/><br/><strong>Output:</strong> <br/>[[1 2 3]<br/> [4 5 6]<br/> [7 8 9]]<br/><br/># Peroform horizontal splitting<br/>arr_hor_split=np.hsplit(arr, 3)<br/><br/>print(arr_hor_split)<br/><br/><strong>Output:<br/></strong>[array([[1],<br/>       [4],<br/>       [7]]), array([[2],<br/>       [5],<br/>       [8]]), array([[3],<br/>       [6],<br/>       [9]])]<br/><br/></pre>
<p style="padding-left: 60px">In the preceding code, the <kbd>hsplit(arr, 3)</kbd> function divides the array into three <span>sub-arrays</span>. Each part is a column of the original array.</p>
<ul>
<li><strong>Vertical splitting</strong>: In vertical split, the given array is divided into <em>N</em> equal sub-arrays along the vertical axis using the <kbd>vsplit()</kbd> and <kbd>split()</kbd> functions. The <kbd>split</kbd> function with <kbd>axis=0</kbd> performs the same operation as the <kbd>vsplit()</kbd> function:</li>
</ul>
<pre style="padding-left: 60px"># vertical split<br/>arr_ver_split=np.vsplit(arr, 3)<br/><br/>print(arr_ver_split)<br/><br/><strong>Output:<br/></strong>[array([[1, 2, 3]]), array([[4, 5, 6]]), array([[7, 8, 9]])]</pre>
<p style="padding-left: 60px"><span>In the preceding code, the <kbd>vsplit(arr, 3)</kbd> function divides the array into three sub-arrays. Each part is a row of the original array. Let's see another function, <kbd>split()</kbd>, which can be utilized as a vertical and horizontal split, in the following example:</span></p>
<pre style="padding-left: 60px"># split with axis=0<br/>arr_split=np.split(arr,3,axis=0)<br/><br/>print(arr_split)<br/><br/><strong>Output:<br/></strong>[array([[1, 2, 3]]), array([[4, 5, 6]]), array([[7, 8, 9]])]<br/><br/># split with axis=1<br/>arr_split = np.split(arr,3,axis=1)<br/><br/><strong>Output:</strong><br/>[array([[1],<br/>        [4],<br/>        [7]]), array([[2],<br/>        [5],<br/>        [8]]), array([[3],<br/>        [6],<br/>        [9]])]</pre>
<p style="padding-left: 60px"><span>In the preceding code, the <kbd>split(arr, 3)</kbd> function divides the array into three sub-arrays. Each part is a row of the original array. The split output is similar to the <kbd>vsplit()</kbd> function when <kbd>axis=0</kbd> and the split output is similar to the <kbd>hsplit()</kbd> function when <kbd>axis=1</kbd>.</span></p>
<h1 id="uuid-eb96ede7-703d-4170-9319-97e423119aa9" class="mce-root">Changing the data type of NumPy arrays</h1>
<p>As we have seen in the preceding sections, NumPy supports multiple data types, such as <kbd>int</kbd>, <kbd>float</kbd>, and complex numbers. The <kbd>astype()</kbd> function converts the data type of the array. Let's see an example of the <kbd>astype()</kbd> function:</p>
<pre># Create an array<br/>arr=np.arange(1,10).reshape(3,3)<br/>print("Integer Array:",arr)<br/><br/># Change datatype of array<br/>arr=arr.astype(float)<br/><br/># print array<br/>print("Float Array:", arr)<br/><br/># Check new data type of array<br/>print("Changed Datatype:", arr.dtype)</pre>
<p>In the preceding code, we have created one NumPy array and checked its data type using the <kbd>dtype</kbd> attribute.</p>
<p>Let's change the data type of an array using the <kbd>astype()</kbd> function:</p>
<pre># Change datatype of array<br/>arr=arr.astype(float)<br/><br/># Check new data type of array<br/>print(arr.dtype)<br/><br/><strong>Output:<br/></strong>float64</pre>
<p>In the preceding code, we have changed the column data type from integer to float using <kbd>astype()</kbd>.</p>
<p>The <kbd>tolist()</kbd> function converts a NumPy array into a Python list. Let's see an example of the <kbd>tolist()</kbd> function:</p>
<pre># Create an array<br/>arr=np.arange(1,10)<br/><br/># Convert NumPy array to Python List<br/>list1=arr.tolist()<br/>print(list1)<br/><br/><strong>Output:<br/></strong>[1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
<p>In the preceding code, we have converted an <span>array</span> into a Python list object using the <kbd>tolist()</kbd> function.</p>
<h1 id="uuid-fae6d76a-ccd2-4219-8fc0-bbec531d2e96" class="mce-root">Creating NumPy views and copies</h1>
<p>Some of the Python functions return either a copy or a view of the input array. A Python copy stores the array in another location while a view uses the same memory content. This means copies are separate objects and treated as a deep copy in Python. Views are the original base array and are treated as a shallow copy. Here are some properties of copies and views:</p>
<ul>
<li>Modifications in a view affect the original data whereas modifications in a copy do not affect the original array.</li>
<li>Views use the concept of shared memory.</li>
<li>Copies require extra space compared to views.</li>
<li>Copies are slower than views.</li>
</ul>
<p>Let's understand the concept of copy and view using the following example:</p>
<pre># Create NumPy Array<br/>arr = np.arange(1,5).reshape(2,2)<br/>print(arr)<br/><br/><strong>Output:<br/></strong>[[1, 2],<br/>[3, 4]]</pre>
<p>After creating a NumPy array, let's perform object copy operations:</p>
<pre># Create no copy only assignment<br/>arr_no_copy=arr<br/><br/># Create Deep Copy<br/>arr_copy=arr.copy()<br/><br/># Create shallow copy using View<br/>arr_view=arr.view()<br/><strong><br/></strong>print("Original Array: ",id(arr))<br/>print("Assignment: ",id(arr_no_copy))<br/>print("Deep Copy: ",id(arr_copy))<br/>print("Shallow Copy(View): ",id(arr_view))<br/><br/><strong>Output:<br/></strong>Original Array:  140426327484256<br/>Assignment:  140426327484256<br/>Deep Copy:  140426327483856<br/>Shallow Copy(View):  140426327484496</pre>
<p>In the preceding example, you can see the original array and the assigned array have the same object ID, meaning both are pointing to the same object. Copies and views both have different object IDs; both will have different objects, but view objects will reference the same original array and a copy will have a different replica of the object.</p>
<p>Let's continue with this example and update the values of the original array and check its impact on views and copies:</p>
<pre># Update the values of original array<br/>arr[1]=[99,89]<br/><br/># Check values of array view<br/>print("View Array:\n", arr_view)<br/><br/># Check values of array copy<br/>print("Copied Array:\n", arr_copy)<br/><br/><strong>Output:</strong> <br/>View Array:<br/> [[ 1 2]<br/> [99 89]]<br/>Copied Array:<br/> [[1 2]<br/> [3 4]]</pre>
<p>In the preceding example, we can conclude from the results that the view is the original array. The values changed when we updated the original array and the copy is a separate object because its values remain the same.</p>
<h1 id="uuid-eefc0961-a868-4aa7-9736-3e4112b79f16" class="mce-root">Slicing NumPy arrays</h1>
<p>Slicing in NumPy is similar to Python lists. Indexing prefers to select a single value while slicing is used to select multiple values from an array.</p>
<p>NumPy arrays also support negative indexing and slicing. Here, the negative sign indicates the opposite direction and indexing starts from the right-hand side with a starting value of <kbd>-1</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/af682864-72cd-48e8-873c-546195356d50.png" style=""/></div>
<p>Let's check this out using the following code:</p>
<pre># Create NumPy Array<br/>arr = np.arange(0,10)<br/>print(arr)<br/><br/><strong>Output:</strong> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
<p>In the slice operation, we use the colon symbol to select the collection of values. Slicing takes three values: start, stop, and step:</p>
<pre>print(arr[3:6])<br/><strong>Output:</strong> [3, 4, 5]</pre>
<p>This can be represented as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0585afca-cac7-4b8c-8da9-a60acc19ff62.png" style=""/></div>
<p>In the preceding example, we have used <kbd>3</kbd> as the starting index and <kbd>6</kbd> as the stopping index:</p>
<pre>print(arr[3:])<br/><strong>Output:</strong> array([3, 4, 5, 6, 7, 8, 9])</pre>
<p>In the preceding example, only the starting index is given. <kbd>3</kbd> is the starting index. This slice operation will select the values from the starting index to the end of the array:</p>
<pre>print(arr[-3:])<br/><strong>Output:</strong> array([7, 8, 9])</pre>
<p><span>This can be represented as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e19f5cd6-bb53-4eeb-8392-f0303183cd43.png" style=""/></div>
<p>In the preceding example, the slice operation will select values from the third value from the right side of the array to the end of the array:</p>
<pre>print(arr[2:7:2])<br/><strong>Output:</strong> array([2, 4,6])</pre>
<p><span>This can be represented as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61da429a-0f75-4f4a-b18a-61c8bf16dbfe.png" style=""/></div>
<p>In the preceding example, the start, stop, and step index are 2, 7, and 2, respectively. Here, the slice operation selects values from the second index to the sixth (one less than the stop value) index with an increment of 2 in the index value. So, the output will be 2, 4, and 6.</p>
<h1 id="uuid-cf9c3a79-5e5c-4ca6-b578-e1f4bfa8b882" class="mce-root">Boolean and fancy indexing</h1>
<p>Indexing techniques help us to select and filter elements from a NumPy array. In this section, we will focus on Boolean and fancy indexing. Boolean indexing uses a Boolean expression in the place of indexes (in square brackets) to filter the NumPy array. This indexing returns elements that have a true value for the Boolean expression:</p>
<pre># Create NumPy Array<br/>arr = np.arange(21,41,2)<br/>print("Orignial Array:\n",arr)<br/><br/># Boolean Indexing<br/>print("After Boolean Condition:",arr[arr&gt;30])<br/><strong><br/>Output:<br/></strong>Orignial Array:<br/> [21 23 25 27 29 31 33 35 37 39]<br/>After Boolean Condition: [31 33 35 37 39]</pre>
<p>Fancy indexing is a special type of indexing in which elements of an array are selected by an array of indices. This means we pass the array of indices in brackets. Fancy indexing also supports multi-dimensional arrays. This will help us to easily select and modify a complex multi-dimensional set of arrays. Let's see an example as follows to understand fancy indexing:</p>
<pre># Create NumPy Array<br/>arr = np.arange(1,21).reshape(5,4)<br/>print("Orignial Array:\n",arr)<br/><br/># Selecting 2nd and 3rd row<br/>indices = [1,2]<br/>print("Selected 1st and 2nd Row:\n", arr[indices])<br/><br/># Selecting 3nd and 4th row<br/>indices = [2,3]<br/>print("Selected 3rd and 4th Row:\n", arr[indices])<br/><br/><strong>Output:</strong><br/><br/>Orignial Array:<br/> [[ 1 2 3 4]<br/> [ 5 6 7 8]<br/> [ 9 10 11 12]<br/> [13 14 15 16]<br/> [17 18 19 20]]<br/>Selected 1st and 2nd Row:<br/> [[ 5 6 7 8]<br/> [ 9 10 11 12]]<br/>Selected 3rd and 4th Row:<br/> [[ 9 10 11 12]<br/> [13 14 15 16]]</pre>
<p>In the preceding code, we have created a 5*4 matrix and selected the rows using integer indices. You can also visualize or internalize this output from the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bd8c91ee-2ea1-4af4-8120-632f0678b61d.png" style=""/></div>
<p>We can see the code for this as follows:</p>
<pre># Create row and column indices<br/>row = np.array([1, 2])<br/>col = np.array([2, 3])<br/><br/>print("Selected Sub-Array:", arr[row, col])<br/><br/><strong>Output:</strong><br/>Selected Sub-Array: [ 7 12]</pre>
<p>The preceding example results in the first value, <kbd>[1,2]</kbd>, and second value, <kbd>[2,3]</kbd>, as the row and column index. The array will select the value at the first and second index values, which are 7 and 12.</p>
<h1 id="uuid-cfa78bb6-3ec1-4045-b7d3-dd37f229fb87" class="mce-root">Broadcasting arrays</h1>
<p>Python lists do not support direct vectorizing arithmetic operations. NumPy offers a faster-vectorized array operation compared to Python list loop-based operations. Here, all the looping operations are performed in C instead of Python, which makes it faster. Broadcasting functionality checks a set of rules for applying binary functions, such as addition, subtraction, and multiplication, on different shapes of an array.</p>
<p>Let's see an example of broadcasting:</p>
<pre># Create NumPy Array<br/>arr1 = np.arange(1,5).reshape(2,2) <br/>print(arr1)<br/><br/><strong>Output:<br/></strong>[[1 2]<br/> [3 4]]<br/><br/># Create another NumPy Array<br/>arr2 = np.arange(5,9).reshape(2,2) <br/>print(arr2)<strong><br/><br/></strong><strong>Output:<br/></strong>[[5 6]<br/> [7 8]]<br/><br/># Add two matrices<br/>print(arr1+arr2)<br/><br/><strong>Output:<br/></strong>[[ 6 8]<br/> [10 12]]</pre>
<p><span>In all three preceding examples, we can see the addition of two arrays of the same size. This concept is known as broadcasting:</span></p>
<pre># Multiply two matrices<br/>print(arr1*arr2)<br/><br/><strong>Output:<br/></strong>[[ 5 12]<br/> [21 32]]</pre>
<p><span>In the preceding example, two matrices were multiplied. Let's perform addition and multiplication with a scalar value:</span></p>
<pre style="padding-left: 60px"># Add a scaler value<br/>print(arr1 + 3)<br/><br/><strong>Output:<br/></strong>[[4 5]<br/> [6 7]]<br/><br/># Multiply with a scalar value<br/>print(arr1 * 3)<br/><br/><strong>Output:<br/></strong>[[ 3 6]<br/> [ 9 12]]</pre>
<p>In the preceding two examples, the matrix is added and multiplied by a scalar value.</p>
<h1 id="uuid-f7a98ef6-eb33-4aa5-924d-22cbee47b426">Creating pandas DataFrames</h1>
<p>The <kbd>pandas</kbd> library is designed to work with a panel or tabular data. <kbd>pandas</kbd> is a fast, highly efficient, and productive tool for manipulating and analyzing string, <span>numeric,</span> datetime, and time-series data. <kbd>pandas</kbd> provides data structures such as DataFrames and Series. A <kbd>pandas</kbd> DataFrame is a tabular, two-dimensional labeled and indexed data structure with a grid of rows and columns. Its columns are heterogeneous types. It has the capability to work with different types of objects, carry out grouping and joining operations, handle missing values, create pivot tables, and deal with dates. A <kbd>pandas</kbd> DataFrame can be created in multiple ways. Let's create an empty DataFrame:</p>
<pre># Import pandas library<br/>import pandas as pd<br/><br/># Create empty DataFrame<br/>df = pd.DataFrame()<br/><br/># Header of dataframe. <br/>df.head()<br/><br/><strong>Output:</strong><br/>_ </pre>
<p>In the preceding example, we have created an empty DataFrame. Let's create a DataFrame using a dictionary of the list:</p>
<pre># Create dictionary of list<br/>data = {'Name': ['Vijay', 'Sundar', 'Satyam', 'Indira'], 'Age': [23, 45, 46, 52 ]}  <br/><br/># Create the pandas DataFrame<br/>df = pd.DataFrame(data)<br/><br/># Header of dataframe.<br/>df.head()<br/><br/><strong>Output:<br/> </strong> Name Age<strong><br/></strong>0 Vijay 23<strong><br/></strong>1 Sundar 45<br/>2 Satyam 46<br/>3 Indira 52</pre>
<p>In the preceding code, we have used a dictionary of the list to create a DataFrame. Here, the keys of the dictionary are equivalent to columns, and values are represented as a list that is equivalent to the rows of the DataFrame. Let's create a DataFrame using the list of dictionaries:</p>
<pre># Pandas DataFrame by lists of dicts. <br/># Initialise data to lists. <br/>data =[ {'Name': 'Vijay', 'Age': 23},{'Name': 'Sundar', 'Age': 25},{'Name': 'Shankar', 'Age': 26}]<br/><br/># Creates DataFrame. <br/>df = pd.DataFrame(data,columns=['Name','Age']) <br/><br/># Print dataframe header <br/>df.head() </pre>
<p>In the preceding code, the DataFrame is created using a list of dictionaries. In the list, each item is a dictionary. Each key is the name of the column and the value is the cell value for a row. Let's create a DataFrame using a list of tuples:</p>
<pre># Creating DataFrame using list of tuples.<br/>data = [('Vijay', 23),( 'Sundar', 45), ('Satyam', 46), ('Indira',52)]<br/><br/># Create dataframe<br/>df = pd.DataFrame(data, columns=['Name','Age'])<br/><br/># Print dataframe header<br/>df.head() <br/><br/><strong>Output:<br/></strong>  Name Age<br/>0 Vijay 23<br/>1 Sundar 25<br/>2 Shankar 26</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>In the preceding code, the DataFrame is created using a list of tuples. In the list, each item is a tuple and each tuple is equivalent to the row of columns.</span></p>
<h1 id="uuid-0f6153d7-2532-4acc-9cad-5ef8d3b21776" class="mce-root">Understanding pandas Series</h1>
<p><kbd>pandas</kbd> Series is a one-dimensional sequential data structure that is able to handle any type of data, <span>such as string, numeric, datetime, Python lists, and dictionaries</span> with labels and indexes. Series is one of the columns of a DataFrame. We can create a Series using a Python dictionary, NumPy array, and scalar value. We will also see the <kbd>pandas</kbd> Series features and properties in the latter part of the section. Let's create some Python Series:</p>
<p> </p>
<ul>
<li><strong>Using a Python dictionary</strong>: Create a dictionary object and pass it to the Series object. Let's see the following example:</li>
</ul>
<pre style="padding-left: 60px"># Creating Pandas Series using Dictionary<br/>dict1 = {0 : 'Ajay', 1 : 'Jay', 2 : 'Vijay'}<br/><br/># Create Pandas Series<br/>series = pd.Series(dict1)<br/><br/># Show series<br/>series<br/><br/><strong>Output:<br/></strong>0     Ajay<br/>1      Jay<br/>2    Vijay<br/>dtype: object</pre>
<ul>
<li><strong>Using a NumPy array</strong>: Create a NumPy array object and pass it to the Series object. Let's see the following example:</li>
</ul>
<pre style="padding-left: 60px">#Load Pandas and NumPy libraries<br/>import pandas as pd<br/>import numpy as np<br/><br/># Create NumPy array<br/>arr = np.array([51,65,48,59, 68])<br/><br/># Create Pandas Series<br/>series = pd.Series(arr)<br/>series<br/><br/><strong>Output:<br/></strong>0    51<br/>1    65<br/>2    48<br/>3    59<br/>4    68<br/>dtype: int64</pre>
<ul>
<li><strong>Using a single scalar value</strong>: To create a <kbd>pandas</kbd> Series with a scalar value, pass the scalar value and index list to a Series object:</li>
</ul>
<pre style="padding-left: 60px"># load Pandas and NumPy<br/>import pandas as pd<br/>import numpy as np<br/><br/># Create Pandas Series<br/>series = pd.Series(10, index=[0, 1, 2, 3, 4, 5])<br/>series<br/><br/><strong>Output:<br/></strong>0    10<br/>1    10<br/>2    10<br/>3    10<br/>4    10<br/>5    10<br/>dtype: int64</pre>
<p style="padding-left: 60px">Let's explore some features of <kbd>pandas</kbd> Series:</p>
<ul>
<li>We can also create a series by selecting a column, such as <kbd>country</kbd>, which happens to be the first column in the datafile. Then, show the type of the object currently in the local scope:</li>
</ul>
<pre style="padding-left: 60px"># Import pandas<br/>import pandas as pd<br/><br/># Load data using read_csv()<br/>df = pd.read_csv("WHO_first9cols.csv")<br/><br/># Show initial 5 records<br/>df.head()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b78dd324-b22c-4f06-a72e-45d1a2b6763e.png" style=""/></div>
<p style="padding-left: 60px">In the preceding code, we have read the <kbd>WHO_first9cols.csv</kbd> <span>file</span> <span>using the</span> <kbd>read_csv()</kbd> <span>function. You can download this file from the following GitHub location:</span><a href="https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02">https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02</a><span>. In the output, you can see the top five records in the</span> <kbd>WHO_first9cols</kbd> <span>dataset using the</span> <kbd>head()</kbd> <span>function:</span></p>
<pre style="padding-left: 60px"># Select a series<br/>country_series=df['Country']<br/><br/># check datatype of series<br/>type(country_series)<br/><br/><strong>Output:</strong><br/>pandas.core.series.Series</pre>
<ul>
<li>The <kbd>pandas</kbd> Series data structure shares some of the common attributes of DataFrames and also has a <kbd>name</kbd> attribute. Explore these properties as follows:</li>
</ul>
<pre style="padding-left: 60px"># Show the shape of DataFrame<br/>print("Shape:", df.shape)<br/><br/><strong>Output:<br/></strong>Shape: (202, 9)</pre>
<p style="padding-left: 60px"><span>Let's check the column list of a DataFrame:</span></p>
<pre style="padding-left: 60px"># Check the column list of DataFrame<br/>print("List of Columns:", df.columns)<br/><br/><strong>Output:</strong>List of Columns: Index(['Country', 'CountryID', 'Continent', 'Adolescent fertility rate (%)',<br/>       'Adult literacy rate (%)',<br/>       'Gross national income per capita (PPP international $)',<br/>       'Net primary school enrolment ratio female (%)',<br/>       'Net primary school enrolment ratio male (%)',<br/>       'Population (in thousands) total'],<br/>       dtype='object')</pre>
<p style="padding-left: 60px">Let's check the data types of DataFrame columns:</p>
<pre style="padding-left: 60px"># Show the datatypes of columns<br/>print("Data types:", df.dtypes)<br/><br/><strong>Output:<br/></strong>Data types: Country                                                    object<br/>            CountryID                                                   int64<br/>            Continent                                                   int64<br/>            Adolescent fertility rate (%)                             float64<br/>            Adult literacy rate (%)                                   float64<br/>            Gross national income per capita (PPP international $)    float64<br/>            Net primary school enrolment ratio female (%)             float64<br/>            Net primary school enrolment ratio male (%)               float64<br/>            Population (in thousands) total                           float64<br/>            dtype: object</pre>
<ol start="3">
<li>Let's see the slicing of a <kbd>pandas</kbd> Series:</li>
</ol>
<pre style="padding-left: 60px"># Pandas Series Slicing<br/>country_series[-5:]<br/><br/><strong>Output</strong>:<br/>197               Vietnam<br/>198    West Bank and Gaza<br/>199                 Yemen<br/>200                Zambia<br/>201              Zimbabwe<br/>Name: Country, dtype: object</pre>
<p>Now that we know how to use pandas Series, let's move on to using Quandl to work on databases.</p>
<h1 id="uuid-f14af637-dc05-4f51-b6bd-5259a7bdae0b" class="">Reading and querying the Quandl data</h1>
<p>In the last section, we saw <kbd>pandas</kbd> <span>DataFrames</span> that have a tabular structure similar to relational databases. They offer similar query operations on DataFrames. In this section, we will focus on Quandl. Quandl is a Canada-based company that offers commercial and alternative financial data for investment data analyst. Quandl understands the need for investment and financial quantitative analysts. It provides data using API, R, Python, or Excel.</p>
<p class="mce-root">In this section, we will retrieve the Sunspot dataset from Quandl. We can use either an API or download the data manually in CSV format.</p>
<p class="mce-root">Let's first install the Quandl package using <kbd>pip</kbd>:</p>
<pre><strong>$ pip3 install Quandl</strong></pre>
<p class="mce-root">If you want to install the API, you can do so by downloading installers from <a href="https://pypi.python.org/pypi/Quandl">https://pypi.python.org/pypi/Quandl</a> or by running the preceding command.</p>
<div class="mce-root packt_infobox">Using the API is free, but is limited to 50 API calls per day. If you require more API calls, you will have to request an authentication key. The code in this tutorial does not use a key. It should be simple to change the code to either use a key or read a downloaded CSV file. If you have difficulties, refer to the <em>Where to find help and references</em> section in <a href="https://docs.google.com/document/d/1BDrtOc3RwvX2ZzT42tRXvfrzPQ8EMJRy/edit#bookmark=id.4d34og8">Chapter 1,</a> <em>Getting Started with Python Libraries</em>, or search through the Python docs at <a href="https://docs.python.org/2/">https://docs.python.org/2/</a>.</div>
<p class="mce-root">Let's take a look at how to query data in a <kbd>pandas</kbd> DataFrame:</p>
<ol>
<li>As a first step, we obviously have to download the data. After importing the Quandl API, get the data as follows:</li>
</ol>
<pre style="padding-left: 60px">import quandl<br/>sunspots = quandl.get("SIDC/SUNSPOTS_A")</pre>
<ol start="2">
<li>The <kbd>head()</kbd> and <kbd>tail()</kbd> methods have a purpose similar to that of the Unix commands with the same name. Select the first <em>n</em> and last <em>n</em> records of a DataFrame, where <em>n</em> is an integer parameter:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">sunspots.head()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d47b5e81-6d11-4ced-af56-0a425dca7c88.png" style=""/></div>
<p style="padding-left: 60px">Let's check out the <kbd>tail</kbd> function as follows:</p>
<pre style="padding-left: 60px" class="mce-root">sunspots.tail()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5b1a1be7-57e0-4856-bd8e-8f040083cd8e.png" style=""/></div>
<p style="padding-left: 60px" class="mce-root">The <kbd>head()</kbd> and <kbd>tail()</kbd> methods give us the first and last five rows of the Sunspot data, respectively.</p>
<ol start="3">
<li class="mce-root"><strong>Filtering columns</strong>: <kbd>pandas</kbd> offers the ability to select columns. Let's select columns in a <kbd>pandas</kbd> DataFrame:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Select columns<br/>sunspots_filtered=sunspots[['Yearly Mean Total Sunspot Number','Definitive/Provisional Indicator']]<br/><br/># Show top 5 records<br/>sunspots_filtered.head()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a6c945a1-760f-42ba-a419-b90580d3f646.png" style=""/></div>
<ol start="4">
<li class="mce-root"><strong>Filtering rows</strong>: <kbd>pandas</kbd> offers the ability to select rows. Let's select rows in a <kbd>pandas</kbd> DataFrame:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Select rows using index<br/>sunspots["20020101": "20131231"]</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/b792113a-06be-4e84-8328-41459c913d76.png" style=""/></div>
<ol start="5">
<li class="mce-root"><strong>Boolean filtering</strong>: We can query data using Boolean conditions similar to the <kbd>WHERE</kbd> clause condition of SQL. Let's filter the data greater than the arithmetic mean:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Boolean Filter<br/>sunspots[sunspots['Yearly Mean Total Sunspot Number'] &gt; sunspots['Yearly Mean Total Sunspot Number'].mean()]</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/df23803c-0e5b-40e3-b509-9bbcef800199.png" style=""/></div>
<h1 id="uuid-df71baa5-19f5-4010-93e3-f6fa8a25a4f0" class="mce-root">Describing pandas DataFrames</h1>
<p class="mce-root">The <kbd>pandas</kbd> DataFrame has a dozen statistical methods. The following table lists these methods, along with a short description of each:</p>
<table style="width: 100%;border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 11.7887%">
<p><strong>Method</strong></p>
</td>
<td style="width: 87.5336%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>describes</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns a small table with descriptive statistics.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>count</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the number of non-NaN items.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>mad</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method calculates the mean absolute deviation, which is a robust measure similar to standard deviation.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>median</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the median. This is equivalent to the value at the 50<sup>th</sup> percentile.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>min</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the minimum value.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>max</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the maximum value.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>mode</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the mode, which is the most frequently occurring value.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>std</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the standard deviation, which measures dispersion. It is the square root of the variance.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>var</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns the variance.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>skew</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns skewness. Skewness is indicative of the distribution symmetry.</p>
</td>
</tr>
<tr>
<td style="width: 11.7887%">
<p><kbd>kurt</kbd></p>
</td>
<td style="width: 87.5336%">
<p>This method returns kurtosis. Kurtosis is indicative of the distribution shape.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Using the same data used in the previous section, we will demonstrate these statistical methods:</p>
<pre class="mce-root"># Describe the dataset<br/>df.describe()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6340853c-6e5b-4b2c-a4f2-17e208467c60.png" style=""/></div>
<p class="mce-root">The <kbd>describe()</kbd> method will show most of the descriptive statistical measures for all columns:</p>
<pre class="mce-root"># Count number of observation<br/>df.count()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a142316e-f8c3-4cce-8bcf-90d92c61b54f.png" style=""/></div>
<p class="mce-root">The <kbd>count()</kbd> method counts the number of observations in each column. It helps us to check the missing values in the dataset. Except for the initial three columns, all the columns have missing values. Similarly, you can compute the median, standard deviation, mean absolute deviation, variance, skewness, and kurtosis:</p>
<pre class="mce-root"># Compute median of all the columns<br/>df.median()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9b49ad6b-b2be-4ce5-8033-08fb2a7fb89d.png" style=""/></div>
<p>We can compute deviation for all columns as follows:</p>
<pre class="mce-root"># Compute the standard deviation of all the columns<br/>df.std()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/61c3c45e-8bbe-4ea8-bf58-dc2a2149dc4e.png" style=""/></div>
<p>The preceding code example is computing the standard deviation for each numeric column.</p>
<h1 id="uuid-d9bb6713-6327-4349-8004-ae5773d3a51e" class="mce-root">Grouping and joining pandas DataFrame</h1>
<p class="mce-root">Grouping is a kind of data aggregation operation. The grouping term is taken from a relational database. Relational database software uses the <kbd>group by</kbd> keyword to group similar kinds of values in a column. We can apply aggregate functions on groups such as mean, min, max, count, and sum. The <kbd>pandas</kbd> DataFrame also offers similar kinds of capabilities. Grouping operations are based on the split-apply-combine strategy. It first divides data into groups and applies the aggregate operation, such as mean, min, max, count, and sum, on each group and combines results from each group:</p>
<pre class="mce-root"># Group By DataFrame on the basis of Continent column<br/>df.groupby('Continent').mean()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6c0e1cad-5051-4922-bdfc-4ae1665d7423.png" style=""/></div>
<p>Let's now group the DataFrames based on literacy rates as well:</p>
<pre class="mce-root"># Group By DataFrame on the basis of continent and select adult literacy rate(%)<br/>df.groupby('Continent').mean()['Adult literacy rate (%)']</pre>
<p class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/68a9df18-74b9-420f-9c09-79831ab1fd81.png" style=""/></div>
<p class="mce-root">In the preceding example, the continent-wise average adult literacy rate in percentage was computed. You can also group based on multiple columns by passing a list of columns to the <kbd>groupby()</kbd> function.</p>
<p class="mce-root">Join is a kind of merge operation for tabular databases. The join concept is taken from the relational database. In relational databases, tables were normalized or broken down to reduce redundancy and inconsistency, and join is used to select the information from multiple tables. A data analyst needs to combine data from multiple sources. <kbd>pandas</kbd> also offers to join functionality to join multiple DataFrames using the <kbd>merge()</kbd> function.</p>
<p class="mce-root">To understand joining, we will take a taxi company use case. We are using two files: <kbd>dest.csv</kbd> and <kbd>tips.csv</kbd>. Every time a driver drops any passenger at their destination, we will insert a record (employee number and destination) into the <kbd>dest.csv</kbd> file. Whenever drivers get a tip, we insert the record (employee number and tip amount) into the <kbd>tips.csv</kbd> file. You can download both the files from the following GitHub link: <a href="https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2">https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2</a>:</p>
<pre class="mce-root"># Import pandas<br/>import pandas as pd<br/><br/># Load data using read_csv()<br/>dest = pd.read_csv("dest.csv")<br/><br/># Show DataFrame<br/>dest.head()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/9eb01529-0df4-4aa2-9cf5-33c04e76e460.png" style=""/></div>
<p>In the preceding code block, we have read the <kbd>dest.csv</kbd> file using the <kbd>read_csv()</kbd> method:</p>
<pre class="mce-root"># Load data using read_csv()<br/>tips = pd.read_csv("tips.csv")<br/><br/># Show DataFrame<br/>tips.head()</pre>
<p class="mce-root">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/45f599b5-2a83-4787-975e-b5fed56e3225.png" style=""/></div>
<p>In the preceding code block, we have read the <kbd>tips.csv</kbd> file using the <kbd>read_csv()</kbd> method<span><span>. We will now check out the various types of joins as follows:</span></span></p>
<ul>
<li><strong>Inner join</strong>: Inner join is equivalent to the intersection operation of a set. It will select only common records in both the DataFrames. To perform inner join, use the <kbd>merge()</kbd> function with both the DataFrames and common attribute on the parameter and inner value to show the parameter. The <kbd>on</kbd> parameter is used to provide the common attribute based on the join will be performed and <kbd>how</kbd> defines the type of join:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Join DataFrames using Inner Join<br/>df_inner= pd.merge(dest, tips, on='EmpNr', how='inner')<br/>df_inner.head()</pre>
<p style="padding-left: 60px" class="mce-root">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/562d1827-9400-4c6b-baff-47754275b7a0.png" style=""/></div>
<ul>
<li><strong>Full outer join</strong>: Outer join is equivalent to a union operation of the set. It merges the right and left DataFrames. It will have all the records from both DataFrames and fills NaNs where the match will not be found:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Join DataFrames using Outer Join<br/>df_outer= pd.merge(dest, tips, on='EmpNr', how='outer')<br/>df_outer.head()</pre>
<p style="padding-left: 60px" class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eebc7b2f-18f9-451f-a5e9-c2f60cd2f97f.png" style=""/></div>
<ul>
<li><strong>Right outer join</strong>: In the right outer join, all the records from the right side of the DataFrame will be selected. If the matched records cannot be found in the left DataFrame, then it is filled with NaNs:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Join DataFrames using Right Outer Join<br/>df_right= pd.merge(dest, tips, on='EmpNr', how='right')<br/>df_right.head()</pre>
<p style="padding-left: 60px" class="mce-root">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/5f2768a8-e08f-4f2e-9412-e758579c511e.png" style=""/></div>
<ul>
<li><strong>Left outer join</strong>: In the left outer join, all the records from the left side of the DataFrame will be selected. If the matched records cannot be found in the right DataFrame, then it is filled with NaNs:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Join DataFrames using Left Outer Join<br/>df_left= pd.merge(dest, tips, on='EmpNr', how='left')<br/>df_left.head()</pre>
<p style="padding-left: 60px" class="mce-root">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae22b284-1120-404b-8c6d-6fa6253106f0.png" style=""/></div>
<p>We will now move on to checking out missing values in the datasets.</p>
<h1 id="uuid-fa30404b-c1d5-437b-af47-fefe4deb223b" class="mce-root">Working with missing values</h1>
<p class="mce-root">Most real-world datasets are messy and noisy. Due to their messiness and noise, lots of values are either faulty or missing. <kbd>pandas</kbd> offers lots of built-<span>in</span> <span>functions to deal with missing values in DataFrames:</span></p>
<ul>
<li><strong>Check missing values in a DataFrame</strong>: <kbd>pandas</kbd>' <kbd>isnull()</kbd> function checks for the existence of null values and returns <kbd>True</kbd> or <kbd>False</kbd>, where <kbd>True</kbd> is for null and <kbd>False</kbd> is for not-null values. The <kbd>sum()</kbd> function will sum all the <kbd>True</kbd> values and returns the count of missing values. We have tried two ways to count the missing values; both show the same output:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Count missing values in DataFrame<br/>pd.isnull(df).sum()</pre>
<p style="padding-left: 60px" class="mce-root">The following is the second method:</p>
<pre style="padding-left: 60px" class="mce-root">df.isnull().sum()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/3d8d5ea8-250d-4c28-94d2-417bd627526b.png" style=""/></div>
<ul>
<li><strong>Drop missing values</strong>: A very naive approach to deal with missing values is to drop them for analysis purposes. <kbd>pandas</kbd> has the <kbd>dropna()</kbd> function to drop or delete such observations from the DataFrame. Here, the <kbd>inplace=True</kbd> attribute makes the changes in the original DataFrame:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Drop all the missing values<br/>df.dropna(inplace=True)<br/><br/>df.info()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/521ce6a9-094e-418a-98ba-3ec10d0c0d51.png" style=""/></div>
<p style="padding-left: 60px" class="mce-root">Here, the number of observations is reduced to 118 from 202.</p>
<ul>
<li><strong>Fill the missing values</strong>: Another approach is to fill the missing values with zero, mean, median, or constant values:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"># Fill missing values with 0<br/>df.fillna(0,inplace=True)<br/><br/>df.info()</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f523082f-2d4c-4beb-b9a3-ca4ce9b9439e.png" style=""/></div>
<p style="padding-left: 60px">Here, we have filled the missing values with 0. This is all about handling missing values.</p>
<p>In the next section, we will focus on pivot tables.</p>
<h1 id="uuid-4c703611-6a56-43af-b7b8-c66fce7759e4" class="mce-root">Creating pivot tables</h1>
<p>A pivot table is a summary table. It is the most popular concept in Excel. Most data analysts use it as a handy tool to summarize theire results. <kbd>pandas</kbd> offers the <kbd>pivot_table()</kbd> function to summarize DataFrames. A DataFrame is summarized using an aggregate function, such as mean, min, max, or sum. You can download the dataset from the following GitHub link: <a href="https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2">https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2</a>:</p>
<pre># Import pandas<br/>import pandas as pd<br/><br/># Load data using read_csv()<br/>purchase = pd.read_csv("purchase.csv")<br/><br/># Show initial 10 records<br/>purchase.head(10)</pre>
<p>This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f93bf27f-dff2-4d72-aa5e-acd1de1de70e.png" style=""/></div>
<p><span>In the preceding code block, we have read the <kbd>purchase.csv</kbd> file using the <kbd>read_csv()</kbd> method.</span></p>
<p>Now, we will summarize the dataframe using the following code:</p>
<pre class="mce-root"># Summarise dataframe using pivot table<br/>pd.pivot_table(purchase,values='Number', index=['Weather',],<br/>                    columns=['Food'], aggfunc=np.sum)</pre>
<p>This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3c2e812a-3151-48a1-b588-d13de92bfd17.png" style=""/></div>
<p class="mce-root">In the preceding example, the <kbd>purchase</kbd> DataFrame is summarized. Here, <kbd>index</kbd> is the <kbd>Weather</kbd> column, <kbd>columns</kbd> is the <kbd>Food</kbd> column, and <kbd>values</kbd> is the aggregated sum of the <kbd>Number</kbd> column. <kbd>aggfun</kbd> is initialized with the <kbd>np.sum</kbd> parameter. It's time to learn how to deal with dates in <kbd>pandas</kbd> DataFrames.</p>
<h1 id="uuid-5b1bee68-809b-44b1-a2b3-981342b5b1fc" class="mce-root">Dealing with dates</h1>
<p class="mce-root">Dealing with dates is messy and complicated. You can recall the Y2K bug, the upcoming 2038 problem, and time zones dealing with different problems. In time-series datasets, we come across dates. <kbd>pandas</kbd> offers date ranges, resamples time-series data, and performs date arithmetic operations.</p>
<p>Create a range of dates starting from January 1, 2020, lasting for 45 days, as follows:</p>
<pre>pd.date_range('01-01-2000', periods=45, freq='D')<br/><br/><strong>Output:<br/></strong>DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03', '2000-01-04',<br/>               '2000-01-05', '2000-01-06', '2000-01-07', '2000-01-08',<br/>               '2000-01-09', '2000-01-10', '2000-01-11', '2000-01-12',<br/>               '2000-01-13', '2000-01-14', '2000-01-15', '2000-01-16',<br/>               '2000-01-17', '2000-01-18', '2000-01-19', '2000-01-20',<br/>               '2000-01-21', '2000-01-22', '2000-01-23', '2000-01-24',<br/>               '2000-01-25', '2000-01-26', '2000-01-27', '2000-01-28',<br/>               '2000-01-29', '2000-01-30', '2000-01-31', '2000-02-01',<br/>               '2000-02-02', '2000-02-03', '2000-02-04', '2000-02-05',<br/>               '2000-02-06', '2000-02-07', '2000-02-08', '2000-02-09',<br/>               '2000-02-10', '2000-02-11', '2000-02-12', '2000-02-13',<br/>               '2000-02-14'],<br/>              dtype='datetime64[ns]', freq='D')</pre>
<p>January has less than 45 days, so the end date falls in February, as you can check for yourself.</p>
<p><kbd>date_range()</kbd> freq parameters can take values such as <kbd>B</kbd> for business day frequency, <kbd>W</kbd> for weekly frequency, <kbd>H</kbd> for hourly frequency, <kbd>M</kbd> for minute frequency, <kbd>S</kbd> for second frequency, <kbd>L</kbd> for millisecond frequency, and <kbd>U</kbd> for microsecond frequency. For more details, you can refer to the official documentation at <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html</a>.</p>
<ul>
<li><strong>pandas date range:</strong> The <kbd>date_range()</kbd> function generates sequences of date and time with a fixed-frequency interval:</li>
</ul>
<pre style="padding-left: 60px"># Date range function<br/>pd.date_range('01-01-2000', periods=45, freq='D')</pre>
<p style="padding-left: 60px">This results in the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e4093374-fb5b-482d-b37c-3ce27d243884.png" style=""/></div>
<ul>
<li><kbd>to_datetime()</kbd>: <kbd>to_datetime()</kbd> converts a timestamp string into datetime:</li>
</ul>
<pre style="padding-left: 60px"># Convert argument to datetime<br/>pd.to_datetime('1/1/1970')<br/><br/><strong>Output:</strong>  Timestamp('1970-01-01 00:00:00')</pre>
<ul>
<li>We can convert a timestamp string into a datetime object in the specified format:</li>
</ul>
<pre style="padding-left: 60px"># Convert argument to datetime in specified format<br/>pd.to_datetime(['20200101', '20200102'], format='%Y%m%d')<br/><br/><strong>Output:<br/></strong>DatetimeIndex(['2020-01-01', '2020-01-02'], dtype='datetime64[ns]', freq=None)</pre>
<ul>
<li><strong>Handling an unknown format string</strong>: Unknown input format can cause value errors. We can handle this by using an errors parameter with <kbd>coerce</kbd>. <kbd>coerce</kbd> will set invalid strings to NaT:</li>
</ul>
<pre style="padding-left: 60px"># Value Error<br/>pd.to_datetime(['20200101', 'not a date'])<br/><br/><strong>Output:<br/></strong>ValueError: ('Unknown string format:', 'not a date')<br/><br/># Handle value error<br/>pd.to_datetime(['20200101', 'not a date'], errors='coerce')<br/><br/><strong>Output:<br/></strong>DatetimeIndex(['2020-01-01', 'NaT'], dtype='datetime64[ns]', freq=None)</pre>
<p>In the preceding example, the second date is still not valid and cannot be converted into a datetime object. The errors parameter helped us to handle such errors by inputting the value <kbd>NaT</kbd> (not a time).</p>
<h1 id="uuid-74852c40-7157-45e8-83a6-e7488edc5964" class="mce-root">Summary</h1>
<p>In this chapter, we have explored the NumPy and pandas libraries. Both libraries help deal with arrays and DataFrames. NumPy arrays have the capability to deal with n-dimensional arrays. We have learned about various array properties and operations. Our main focus is on data types, data type as an object, reshaping, stacking, splitting, slicing, and indexing.</p>
<p>We also focused on the <kbd>pandas</kbd> library for Python data analysis. We saw how <kbd>pandas</kbd> mimics the relational database table functionality. It offers functionality to query, aggregate, manipulate, and join data efficiently.</p>
<p>NumPy and <kbd>pandas</kbd> work well together as a tool and make it possible to perform basic data analysis. At this point, you might be tempted to think that <kbd>pandas</kbd> is all we need for data analysis. However, there is more to data analysis than meets the eye.</p>
<p>Having picked up the fundamentals, it's time to proceed to data analysis with the commonly used statistics functions in <a href="dec623f2-210e-4cb0-900b-7eb039a4fb91.xhtml">Chapter 3</a>, <em>Statistics</em>. This includes the usage of statistical concepts.</p>
<p>You are encouraged to read the books mentioned in the <em>References</em> section for exploring NumPy and <kbd>pandas</kbd> in further detail and depth.</p>
<h1 id="uuid-2ce2652f-27a6-41fa-89d2-219e8cfc3722" class="mce-root">References</h1>
<ul>
<li>Ivan Idris, <em>NumPy Cookbook – Second Edition</em>, Packt Publishing, 2015.</li>
<li>Ivan Idris, <em>Learning NumPy Array</em>, Packt Publishing, 2014.</li>
<li>Ivan Idris, <em>NumPy: Beginner's Guide</em> <em>– Third Edition</em>, Packt Publishing, 2015.</li>
<li>L. (L.-H.) Chin and T. Dutta, <em>NumPy Essentials</em>, Packt Publishing, 2016.</li>
<li>T. Petrou, <em>Pandas Cookbook</em>, Packt Publishing, 2017.</li>
<li>F. Anthony, <em>Mastering pandas</em>, Packt Publishing, 2015.</li>
<li>M. Heydt, <em>Mastering pandas for Finance</em>, Packt Publishing, 2015.</li>
<li>T. Hauck, <em>Data-Intensive Apps with pandas How-to</em>, Packt Publishing, 2013.</li>
<li>M. Heydt, <em>Learning pandas</em>, Packt Publishing, 2015.</li>
</ul>


            </article>

            
        </section>
    </body></html>