["```py\ninstall.packages(\"ctv\") \nlibrary(\"ctv\") \ninstall.views(\"HighPerformanceComputing\") \n```", "```py\nlibrary(Rmpi) \ndemo() \n```", "```py\n> find.package(\"Rmpi\") \n[1] \"C:/Users/yany/Documents/R/win-library/3.4/Rmpi\" \n```", "```py\nlibrary(plyr) \nd1<-c(rep('A', 8), rep('B', 15), rep('C', 6)) \nd2<-sample(c(\"M\", \"F\"), size = 29, replace = TRUE) \nd3<-runif(n = 29, min = 18, max = 54) \n# \ndfx <- data.frame(group =d1,sex=d2,age=d3) \n# \nddply(dfx, .(group, sex), summarize, \n mean = round(mean(age), 2), \n sd = round(sd(age), 2)) \n# \nddply(baseball[1:100,], ~ year, nrow) \nddply(baseball, .(lg), c(\"nrow\", \"ncol\")) \nrbi<-ddply(baseball, .(year), summarise, \n      mean_rbi=mean(rbi, na.rm = TRUE)) \nplot(mean_rbi~year,type=\"l\",data = rbi) \nbase2<-ddply(baseball,.(id),mutate, \n    career_year = year - min(year) + 1 \n) \n```", "```py\nlibrary(datasets) \nlibrary(plyr) \ndata(mtcars) \n# \nd1<-mtcars[with(mtcars, order(cyl, disp)), ] \nd2<-arrange(mtcars, cyl, disp) \nmyCars = cbind(vehicle=row.names(mtcars), mtcars) \nd3<-arrange(myCars, cyl, disp) \nd4<-arrange(myCars, cyl, desc(disp)) \n```", "```py\n> lapply(1:3,function(x) c(sin(x),x^2)) \n[[1]] \n[1] 0.841471 1.000000 \n[[2]] \n[1] 0.9092974 4.0000000 \n[[3]] \n[1] 0.14112 9.00000 \n```", "```py\nmyFunctions<-c(sin(x),x^2+2,4*x^2-x^3-2) \ninputValue<-1:10 \noutput<-lapply(inputValue,function(x) myFunctions) \n```", "```py\nlibrary(parallel) \nn_cores <- detectCores() - 1 \ncl <- makeCluster(n_cores) \nparLapply(cl, 2:4,function(exponent) 2^exponent) \nstopCluster(cl) \n```", "```py\n [[1]] \n[1] 4 \n\n[[2]] \n[1] 8 \n\n[[3]] \n[1] 16 \n```", "```py\nc2<-makeCluster(n_cores) \nbase <- 2 \nparLapply(c2, 2:4, function(exponent) base^exponent) \nstopCluster(c2) \n```", "```py\nError in checkForRemoteErrors(val) :  \n  3 nodes produced errors; first error: object 'base' not found \n```", "```py\nc3<-makeCluster(n_cores) \nbase <- 2 \nclusterExport(c3, \"base\") \nparLapply(c3, 2:4, function(exponent)  base^exponent) \nstopCluster(c3) \n```", "```py\nlibrary(parallel) \ndetectCores() \nmyFunction<- function(iter=1,n=5){ \n    x<- rnorm(n, mean=0, sd=1 ) \n    eps <- runif(n,-2,2) \n    y <- 1 + 2*x + eps \n    result<-lm( y ~ x ) \n    final<-cbind(result$coef,confint(result)) \n    return(final)  \n} \n# \nm<-5000\nn2<-5000\nsystem.time(lapply(1:m,myFunction,n=n2))\nsystem.time(mclapply(1:m,myFunction,n=n2))\n```", "```py\n> system.time(lapply(1:n,myFunction,n=n2)) \n user  system elapsed  \n  63.97    3.26   22.49\n> system.time(mclapply(1:n,myFunction,n=n2)) \n user  system elapsed  \n  63.33 3.28 22.26 \n```", "```py\nlibrary(snow) \nlibrary(parallel) \n#library(Rmpi) \nmyFunction<-function(n) { \n    a<-rnorm(n) \n    final<-log(abs(a))+a^3+2*a; \n    return(final) \n} \nnCores=11; \n#Using multicore \nsystem.time(mclapply(rep(5E6,11),myFunction,mc.cores=nCores)) \n#Using snow via MPI \nsystem.time(sapply(rep(5E6,11),myFunction)) \n#cl <- getMPIcluster() \ncl <- makeCluster(c(\"localhost\",\"localhost\"), type = \"SOCK\") \nsystem.time(parSapply(cl,rep(5E6,11),myFunction)) \n```", "```py\n> system.time(mclapply(rep(5E6,11),myFunction,mc.cores=nCores)) user  system elapsed \n  4.440   1.075   1.926 > system.time(sapply(rep(5E6,11),myFunction)) user  system elapsed \n 10.294   0.992  11.286 > system.time(parSapply(cl,rep(5E6,11),myFunction)) user  system elapsed \n  0.655   0.626   7.328 > proc.time() user  system elapsed \n 15.621   2.936  22.134 \n```", "```py\nlibrary(snow) \ncl <- makeSOCKcluster(c(\"localhost\",\"localhost\")) \nclusterApply(cl, 1:2, get(\"+\"), 3) \nclusterEvalQ(cl, library(boot)) \nx<-1 \nclusterExport(cl, \"x\") \nclusterCall(cl, function(y) x + y, 2) \n```", "```py\nimport matplotlib.pyplot as plt\nimport sympy\nimport numpy as np \n#\ndef plot_one_digit_freqs(f1):\n    \"\"\"\n    Plot one digit frequency counts using matplotlib.\n    \"\"\"\n    ax = plt.plot(f1,'bo-')\n    plt.title('Single digit counts in pi')\n    plt.xlabel('Digit')\n    plt.ylabel('Count')\n    return ax\n#\ndef one_digit_freqs(digits, normalize=False):\n    \"\"\"\n    Consume digits of pi and compute 1 digit freq. counts.\n    \"\"\"\n    freqs = np.zeros(10, dtype='i4')\n    for d in digits:\n        freqs[int(d)] += 1\n    if normalize:\n        freqs = freqs/freqs.sum()\n    return freqs\n#\npi = sympy.pi.evalf(40)\npi\npi = sympy.pi.evalf(10000)\ndigits = (d for d in str(pi)[2:]) # create a sequence of digits\nfreqs = one_digit_freqs(digits)\nplot_one_digit_freqs(freqs)\nplt.show()\n```", "```py\ntext = open(\"c:/temp/daVinci.txt\",'r').read().lower() \ndef byFreq(pair): \n    return pair[1] \nfor ch in '!\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~': \n    text = text.replace(ch, ' ') \n    words = text.split() \ncounts = {} \nfor w in words: \n    counts[w] = counts.get(w,0) + 1 \nn = 10   # for the first n most frequetly used words \nwords= list(counts.items()) \nwords.sort() \nwords.sort(key=byFreq, reverse=True) \nfor i in range(n): \n    word, count =words[i] \n    print(\"{0:<15}{1:>5}\".format(word, count)) \n```", "```py\nthe            22989 \nof             11232 \nand             8434 \nin              5750 \nto              5313 \na               4725 \nis              4273 \nit              3071 \nthat            2902 \nwhich           2545 \n```", "```py\n%matplotlib inline \nimport matplotlib.pyplot as plt \nimport sys \nimport time \nfrom ipyparallel import Client \nimport numpy as np \nprice = 100.0  # Initial price \nrate = 0.05  # Interest rate \ndays = 260  # Days to expiration \npaths = 10000  # Number of MC paths \nn_strikes = 6  # Number of strike values \nmin_strike = 90.0  # Min strike price \nmax_strike = 110.0  # Max strike price \nn_sigmas = 5  # Number of volatility values \nmin_sigma = 0.1  # Min volatility \nmax_sigma = 0.4  # Max volatility \n# (more ....) \n```", "```py\ninstall.packages(\"ctv\") \nlibrary(\"ctv\") \ninstall.views(\"HighPerformanceComputing\") \n```"]