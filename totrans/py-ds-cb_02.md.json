["```py\n#Recipe_1a.py\n# Importing numpy as np\nimport numpy as np\n# Creating arrays\na_list = [1,2,3]\nan_array = np.array(a_list)\n# Specify the datatype\nan_array = np.array(a_list,dtype=float)\n\n# Creating matrices\na_listoflist = [[1,2,3],[5,6,7],[8,9,10]]\na_matrix = np.matrix(a_listoflist,dtype=float)\n```", "```py\n#Recipe_1b.py\n# A simple function to examine given numpy object \ndef display_shape(a):\n    print \n    print a\n    print\n    print \"Nuber of elements in a = %d\"%(a.size)\n    print \"Number of dimensions in a = %d\"%(a.ndim)\n    print \"Rows and Columns in a \",a.shape\n    print \n\ndisplay_shape(a_matrix)\n```", "```py\n#Recipe_1c.py\n# Alternate ways of creating arrays\n# 1\\. Leverage np.arange to create numpy array\ncreated_array = np.arange(1,10,dtype=float)\ndisplay_shape(created_array)\n\n# 2\\. Using np.linspace to create numpy array\ncreated_array = np.linspace(1,10)\ndisplay_shape(created_array)\n\n# 3\\. Create numpy arrays in using np.logspace\ncreated_array = np.logspace(1,10,base=10.0)\ndisplay_shape(created_array)\n\n# Specify step size in arange while creating\n# an array. This is where it is different\n# from np.linspace\ncreated_array = np.arange(1,10,2,dtype=int)\ndisplay_shape(created_array)\n```", "```py\n#Recipe_1d.py\n# Create a matrix will all elements as 1\nones_matrix = np.ones((3,3))\ndisplay_shape(ones_matrix)\n# Create a matrix with all elements as 0\nzeros_matrix = np.zeros((3,3))\ndisplay_shape(zeros_matrix)\n\n# Identity matrix\n# k parameter  controls the index of 1\n# if k =0, (0,0),(1,1,),(2,2) cell values\n# are set to 1 in a 3 x 3 matrix\nidentity_matrix = np.eye(N=3,M=3,k=0)\ndisplay_shape(identity_matrix)\nidentity_matrix = np.eye(N=3,k=1)\ndisplay_shape(identity_matrix)\n```", "```py\nRecipe_1e.py\n# Array shaping\na_matrix = np.arange(9).reshape(3,3)\ndisplay_shape(a_matrix)\n.\n.\n.\ndisplay_shape(back_array)\n```", "```py\n#Recipe_1f.py\n# Matrix operations\na_matrix = np.arange(9).reshape(3,3)\nb_matrix = np.arange(9).reshape(3,3)\n.\n.\n.\nprint \"f_matrix, row sum\",f_matrix.sum(axis=1)\n```", "```py\n#Recipe_1g.py\n# reversing elements\ndisplay_shape(f_matrix[::-1])\n.\n.\n.\nzz = zz.flatten()\n```", "```py\n#Recipe_1h.py\n# Random numbers\ngeneral_random_numbers = np.random.randint(1,100, size=10)\nprint general_random_numbers\n.\n.\n.\nuniform_rnd_numbers = np.random.normal(loc=0.2,scale=0.2,size=(3,3))\n```", "```py\n# Importing numpy as np\nimport numpy as np\n```", "```py\n# Arrays\na_list = [1,2,3]\nan_array = np.array(a_list)\n# Specify the datatype\nan_array = np.array(a_list,dtype=float)\n```", "```py\n# Matrices\na_listoflist = [[1,2,3],[5,6,7],[8,9,10]]\na_matrix = np.matrix(a_listoflist,dtype=float)\n```", "```py\ndef display_shape(a):\n    print \n    print a\n    print\n    print \"Nuber of elements in a = %d\"%(a.size)\n    print \"Number of dimensions in a = %d\"%(a.ndim)\n    print \"Rows and Columns in a \",a.shape\n    print\n```", "```py\ndisplay_shape(a_matrix)\n```", "```py\ncreated_array = np.arange(1,10,dtype=float)\ndisplay_shape(created_array)\n```", "```py\n# An alternate way to create array\ncreated_array = np.linspace(1,10)\ndisplay_shape(created_array)\n```", "```py\ncreated_array = np.logspace(1,10,base=10.0)\ndisplay_shape(created_array)\n```", "```py\nones_matrix = np.ones((3,3))\ndisplay_shape(ones_matrix)\n\n# Create a matrix with all elements as 0\nzeros_matrix = np.zeros((3,3))\ndisplay_shape(zeros_matrix)\n```", "```py\nidentity_matrix = np.eye(N=3,M=3,k=0)\ndisplay_shape(identity_matrix)\n```", "```py\nidentity_matrix = np.eye(N=3,k=1)\ndisplay_shape(identity_matrix)\n```", "```py\n# Array shaping\na_matrix = np.arange(9).reshape(3,3)\ndisplay_shape(a_matrix)\n```", "```py\n# Paramter -1 refers to as many as dimension needed\nback_to_array = a_matrix.reshape(-1)\ndisplay_shape(back_to_array)\n```", "```py\na_matrix = np.arange(9).reshape(3,3)\nback_array = np.ravel(a_matrix)\ndisplay_shape(back_array)\n\na_matrix = np.arange(9).reshape(3,3)\nback_array = a_matrix.flatten()\ndisplay_shape(back_array)\n```", "```py\nc_matrix = a_matrix + b_matrix\n```", "```py\nd_matrix = a_matrix * b_matrix\n```", "```py\ne_matrix = np.dot(a_matrix,b_matrix)\n```", "```py\nf_matrix = e_matrix.T\n```", "```py\nprint\nprint \"f_matrix,minimum = %d\"%(f_matrix.min())\nprint \"f_matrix,maximum = %d\"%(f_matrix.max())\nprint \"f_matrix, col sum\",f_matrix.sum(axis=0)\nprint \"f_matrix, row sum\",f_matrix.sum(axis=1)\n```", "```py\n# reversing elements\ndisplay_shape(f_matrix[::-1])\n```", "```py\n# Like python all elements are used by reference\n# if copy is needed copy() command is used\nf_copy = f_matrix.copy()\n```", "```py\n# Grid commands\nxx,yy,zz = np.mgrid[0:3,0:3,0:3]\nxx = xx.flatten()\nyy = yy.flatten()\nzz = zz.flatten()\n```", "```py\n# Random numbers\ngeneral_random_numbers = np.random.randint(1,100, size=10)\nprint general_random_numbers\n```", "```py\nuniform_rnd_numbers = np.random.normal(loc=0.2,scale=0.2,size=10)\nprint uniform_rnd_numbers\n```", "```py\nuniform_rnd_numbers = np.random.normal(loc=0.2,scale=0.2,size=(3,3))\n```", "```py\n#Recipe_2a.py\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef simple_line_plot(x,y,figure_no):\n    plt.figure(figure_no)\n    plt.plot(x,y)\n    plt.xlabel('x values')\n    plt.ylabel('y values')\n    plt.title('Simple Line')\n\ndef simple_dots(x,y,figure_no):\n    plt.figure(figure_no)\n    plt.plot(x,y,'or')\n    plt.xlabel('x values')\n    plt.ylabel('y values')\n    plt.title('Simple Dots')\n\ndef simple_scatter(x,y,figure_no):\n    plt.figure(figure_no)\n    plt.scatter(x,y)\n    plt.xlabel('x values')\n    plt.ylabel('y values')\n    plt.title('Simple scatter')\n\ndef scatter_with_color(x,y,labels,figure_no):\n    plt.figure(figure_no)\n    plt.scatter(x,y,c=labels)\n    plt.xlabel('x values')\n    plt.ylabel('y values')\n    plt.title('Scatter with color')\n\nif __name__ == \"__main__\":\n\n    plt.close('all')\n    # Sample x y data for line and simple dot plots\n    x = np.arange(1,100,dtype=float)\n    y = np.array([np.power(xx,2) for xx in x])\n\n    figure_no=1\n    simple_line_plot(x,y,figure_no)\n    figure_no+=1\n    simple_dots(x,y,figure_no)\n\n    # Sample x,y data for scatter plot\n    x = np.random.uniform(size=100)\n    y = np.random.uniform(size=100)\n\n    figure_no+=1\n    simple_scatter(x,y,figure_no)\n    figure_no+=1\n    label = np.random.randint(2,size=100)\n    scatter_with_color(x,y,label,figure_no)\n    plt.show()\n```", "```py\n#Recipe_2b.py\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef x_y_axis_labeling(x,y,x_labels,y_labels,figure_no):\n    plt.figure(figure_no)\n    plt.plot(x,y,'+r')\n    plt.margins(0.2)\n    plt.xticks(x,x_labels,rotation='vertical')\n    plt.yticks(y,y_labels,)\n\ndef plot_heat_map(x,figure_no):\n    plt.figure(figure_no)\n    plt.pcolor(x)\n    plt.colorbar()\n\nif __name__ == \"__main__\":\n\n    plt.close('all')\n    x = np.array(range(1,6))\n    y = np.array(range(100,600,100))\n    x_label = ['element 1','element 2','element 3','element 4','element 5']\n    y_label = ['weight1','weight2','weight3','weight4','weight5']\n\n    x_y_axis_labeling(x,y,x_label,y_label,1)\n\n    x = np.random.normal(loc=0.5,scale=0.2,size=(10,10))\n    plot_heat_map(x,2)\n\n    plt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\n    plt.close('all')\n```", "```py\n    # Sample x y data for line and simple dot plots\n    x = np.arange(1,100,dtype=float)\n    y = np.array([np.power(xx,2) for xx in x])\n```", "```py\n    figure_no=1\n    simple_line_plot(x,y,figure_no)\n```", "```py\ndef simple_line_plot(x,y,figure_no):\n    plt.figure(figure_no)\n    plt.plot(x,y)\n    plt.xlabel('x values')\n    plt.ylabel('y values')\n    plt.title('Simple Line')\n```", "```py\n    figure_no+=1\n    simple_dots(x,y,figure_no)\n```", "```py\ndef simple_dots(x,y,figure_no):\n    plt.figure(figure_no)\n    plt.plot(x,y,'or')\n    plt.xlabel('x values')\n    plt.ylabel('y values')\n    plt.title('Simple Dots')\n```", "```py\n    plt.plot(x,y,'or')\n```", "```py\n    # Sample x,y data for scatter plot\n    x = np.random.uniform(size=100)\n    y = np.random.uniform(size=100)\n```", "```py\n    figure_no+=1\n    simple_scatter(x,y,figure_no)\n```", "```py\n    plt.scatter(x,y)\n```", "```py\n    figure_no+=1\n    label = np.random.randint(2,size=100)\n    scatter_with_color(x,y,label,figure_no)\n```", "```py\n    plt.scatter(x,y,c=labels)\n```", "```py\n    plt.close('all')\n    x = np.array(range(1,6))\n    y = np.array(range(100,600,100))\n    x_label = ['element 1','element 2','element 3','element 4','element 5']\n    y_label = ['weight1','weight2','weight3','weight4','weight5']\n\n    x_y_axis_labeling(x,y,x_label,y_label,1)\n```", "```py\ndef x_y_axis_labeling(x,y,x_labels,y_labels,figure_no):\n    plt.figure(figure_no)\n    plt.plot(x,y,'+r')\n    plt.margins(0.2)\n    plt.xticks(x,x_labels,rotation='vertical')\n    plt.yticks(y,y_labels,)\n```", "```py\n    x = np.random.normal(loc=0.5,scale=0.2,size=(10,10))\n    plot_heat_map(x,2)\n```", "```py\ndef plot_heat_map(x,figure_no):\n    plt.figure(figure_no)\n    plt.pcolor(x)\n    plt.colorbar()\n```", "```py\n#Recipe_3a.py\nfrom sklearn.datasets import load_iris,load_boston,make_classification                         make_circles, make_moons\n\n# Iris dataset\ndata = load_iris()\nx = data['data']\ny = data['target']\ny_labels = data['target_names']\nx_labels = data['feature_names']\n\nprint\nprint x.shape\nprint y.shape\nprint x_labels\nprint y_labels\n\n# Boston dataset\ndata = load_boston()\nx = data['data']\ny = data['target']\nx_labels = data['feature_names']\n\nprint\nprint x.shape\nprint y.shape\nprint x_labels\n\n# make some classification dataset\nx,y = make_classification(n_samples=50,n_features=5, n_classes=2)\n\nprint\nprint x.shape\nprint y.shape\n\nprint x[1,:]\nprint y[1]\n\n# Some non linear dataset\nx,y = make_circles()\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.close('all')\nplt.figure(1)\nplt.scatter(x[:,0],x[:,1],c=y)\n\nx,y = make_moons()\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.figure(2)\nplt.scatter(x[:,0],x[:,1],c=y)\n\nplt.show()\n```", "```py\n#Recipe_3b.py\nimport numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\n# Data Preprocessing routines\nx = np.asmatrix([[1,2],[2,4]])\npoly = PolynomialFeatures(degree = 2)\npoly.fit(x)\nx_poly = poly.transform(x)\n\nprint \"Original x variable shape\",x.shape\nprint x\nprint\nprint \"Transformed x variables\",x_poly.shape\nprint x_poly\n\n#alternatively \nx_poly = poly.fit_transform(x)\n\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\ndata = load_iris()\nx = data['data']\ny = data['target']\n\nestimator = DecisionTreeClassifier()\nestimator.fit(x,y)\npredicted_y = estimator.predict(x)\npredicted_y_prob = estimator.predict_proba(x)\npredicted_y_lprob = estimator.predict_log_proba(x)\n\nfrom sklearn.pipeline import Pipeline\n\npoly = PolynomialFeatures(n=3)\ntree_estimator = DecisionTreeClassifier()\n\nsteps = [('poly',poly),('tree',tree_estimator)]\nestimator = Pipeline(steps=steps)\nestimator.fit(x,y)\npredicted_y = estimator.predict(x)\n```", "```py\nfrom sklearn.datasets import load_iris,load_boston,make_classification\n```", "```py\ndata = load_iris()\nx = data['data']\ny = data['target']\ny_labels = data['target_names']\nx_labels = data['feature_names']\n```", "```py\nprint\nprint x.shape\nprint y.shape\nprint x_labels\nprint y_labels\n```", "```py\n# Boston dataset\ndata = load_boston()\nx = data['data']\ny = data['target']\nx_labels = data['feature_names']\n```", "```py\n# make some classification dataset\nx,y = make_classification(n_samples=50,n_features=5, n_classes=2)\n```", "```py\nprint x.shape\nprint y.shape\n\nprint x[1,:]\nprint y[1]\n```", "```py\n# Some non linear dataset\nx,y = make_circles()\nimport numpy as npimport matplotlib.pyplot as plt\nplt.close('all')\nplt.figure(1)\nplt.scatter(x[:,0],x[:,1],c=y)\n```", "```py\nx,y = make_moons()\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.figure(2)\nplt.scatter(x[:,0],x[:,1],c=y)\n```", "```py\nimport numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\n```", "```py\n# Data Preprocessing routines\nx = np.asmatrix([[1,2],[2,4]])\n```", "```py\npoly = PolynomialFeatures(degree = 2)\n```", "```py\npoly.fit(x)\nx_poly = poly.transform(x)\n```", "```py\n#alternatively \nx_poly = poly.fit_transform(x)\n```", "```py\nfrom sklearn.tree import DecisionTreeClassifier\n```", "```py\nfrom sklearn.datasets import load_iris\n\ndata = load_iris()\nx = data['data']\ny = data['target']\n\nestimator = DecisionTreeClassifier()\nestimator.fit(x,y)\npredicted_y = estimator.predict(x)\npredicted_y_prob = estimator.predict_proba(x)\npredicted_y_lprob = estimator.predict_log_proba(x)\n```", "```py\nfrom sklearn.pipeline import Pipeline\n\npoly = PolynomialFeatures(n=3)\ntree_estimator = DecisionTreeClassifier()\n```", "```py\nsteps = [('poly',poly),('tree',tree_estimator)]\n```", "```py\nestimator = Pipeline(steps=steps)\nestimator.fit(x,y)\npredicted_y = estimator.predict(x)\n```"]