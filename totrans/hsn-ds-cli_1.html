<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Data Science at the Command Line and Setting It Up</h1>
                </header>
            
            <article>
                
<p class="mce-root">"In the beginning... was the command line" Years ago, we didn't have fancy frameworks that handled our distributed computing for us, or applications that could read files intelligently and give us accurate results. If we did, it was very expensive or only worked for a small problem set, very few people had access to this technology, and it was mostly proprietary.</p>
<p class="mce-root">For newcomers to the world of data science, you might have used the command line for a small number of things. Maybe you moved a file from one place to another using<span> </span><kbd>mv</kbd>, or read a file using<span> </span><kbd>cat</kbd>. Or you might have never used the command line at all, or at least not for data science. In this book, we hope to show you a number of tools and ways you can perform some everyday tasks that you can do locally, without using today's buzzword framework.</p>
<p class="mce-root">We created this book for the folks who have little to no experience with the command line, and perform a lot of data extraction, modelling, parsing, and analyzing. This doesn't mean that if you do have a lot of command-line experience (a lot of DevOps and systems folks do), you shouldn't read this book. In fact, you might pick up a couple commands and techniques that you haven't used<span> </span>before.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>The history of the command line</li>
<li>Language-focused shells</li>
<li>Why use the command line?</li>
</ul>
<p class="mce-root"/>
<p class="mce-root">We will also walk through <span>the setup and configuration of the command line with the following operating systems:</span></p>
<ul>
<li style="font-weight: 400">Windows 10</li>
<li style="font-weight: 400">Mac OS X</li>
<li style="font-weight: 400">Ubuntu Linux</li>
</ul>
<p class="mce-root">If you are running a different operating system, we suggest obtaining an instance from a cloud provider or using the Docker container that's provided in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">History of the command line</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since the very first electronic machines, people have strived to communicate with them the same way that we humans talk to each other. But since natural-language processing was beyond the technological grasp of early computer systems, engineers relatively quickly replaced the punch cards, dials, and knobs of early computing machines with teletypes: typewriter-like machines that enabled keyed input and textual output to a display. Teletypes were replaced fairly quickly with video monitors, enabling a world of graphical displays. A novelty of the time, teletypes served a function that was missing in graphical environments, and thus terminal emulators were born for serving as the modern interface to the command line. The programs behind the terminals started out as an ingrained part of the computer itself: resident monitor programs that were able to start a job, detect when it was done, and clean up.</p>
<p class="mce-root">As computers grew in complexity, so did the programs controlling them. Resident monitors gave way to operating systems that were able to share time between multiple jobs. In the early 1960s, Louis Pouzin had the brilliant idea to use the commands being fed to the computer as a kind of program, a <em>shell</em> around the operating system.</p>
<p class="mce-root">"After having written dozens of commands for CTSS, I reached the stage where I felt that commands should be usable as building blocks for writing more commands, just like subroutine libraries. Hence, I wrote RUNCOM, a sort of shell that drives the execution of command scripts, with argument substitution. The tool became instantly popular, as it became possible to go home in the evening and leaving long runcoms to execute overnight."</p>
<p class="mce-root">Scripting in this way, and the reuse of tooling, would become an ingrained trope in the exciting new world of programmable computing. Pouzin's concepts for a programmable shell made their way into the design and philosophy of Multics in the 1960s and its Bell Labs successor, Unix.</p>
<p class="mce-root">In the Bell System Technical Journal from 1978, Doug McIlroy wrote the following regarding the Unix system:</p>
<div class="mce-root packt_quote">"A number of maxims have gained currency among the builders and users of the UNIX system to explain and promote its characteristic style: <span>Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new features."</span></div>
<ul>
<li>Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don't insist on interactive input.</li>
<li>Design and build software, even operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them.</li>
<li>Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them.</li>
</ul>
<p class="mce-root">This is the core of the Unix philosophy and the key tenets that make the command line not just a way to launch programs or list files, but a powerful group of community-built tools that can work together to process data in a clean, simple manner. In fact, McIlroy follows up with this great example of how this had led to success with data processing, even back in 1978:</p>
<div class="mce-root packt_quote">"Unexpected uses of files abound: programs may be compiled to be run and also typeset to be published in a book from the same text without human intervention; text intended for publication serves as grist for statistical studies of English to help in data compression or cryptography; mailing lists turn into maps. The prevalence of free-format text, even in "data" files, makes the text-processing utilities useful for many strictly data processing functions such as shuffling fields, counting, or collating."</div>
<p class="mce-root">Having access to simple yet powerful components, programmers needed an easy way to construct, reuse, and execute more complicated commands and scripts to do the processing specific to their needs. Enter the early fully-featured command line shell: the Bourne shell. Developed by Stephen Bourne (also at Bell Labs) in the late 1970s for Unix's System 7, the Bourne shell was designed from the start with programmers like us in mind: it had all the scripting tools needed to put the community-developed single-purpose tools to good use. It was the right tool, in the right place, at the right time; almost all Unix systems today are based upon System 7 and nearly all still include the original Bourne shell as an option. In this book, we will use a descendant of the venerable Bourne shell, known as Bash, which is a rewrite of the Bourne shell released in 1989 for the GNU project that incorporated the best features of the Bourne shell itself along with several of its earlier spinoffs.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">We don't want to BaSH other shells, but...</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this book, we decided to focus on using the <strong>Bourne-again shell</strong> (<strong>bash</strong>) for multiple reasons. First, it's the most popular shell and you can find it everywhere. In fact, for the majority of Linux distributions, bash is the default shell. It's a great first shell to learn and very easy to work with. There's a number of examples and resources available to help you with bash if you ever get stuck. It's also safe to say that since it's so popular, you can find it on almost any system available today. From a bare-metal installation in a data center to an instance running in the cloud, bash is there, installed, and waiting for input.</p>
<p class="mce-root">There are a number of other shells you can choose from, such as the <em>Z</em> shell (<kbd>zsh</kbd>). The <em>Z</em> shell is fairly new (and by new I mean released in 1990, which is new in shell land) and provides a number of powerful features. Other notable shells are <kbd>tcsh</kbd>, <kbd>ksh</kbd>, and <kbd>fish</kbd>. The <em>C</em> Shell (<kbd>tcsh</kbd>), the Korn Shell (<kbd>ksh</kbd>), and the <strong>Friendly Interactive Shell</strong> (<strong>fish</strong>) are still widely used today. FreeBSD has made <kbd>tcsh</kbd> its default shell for the root user and <kbd>ksh</kbd> is still used for a lot of Solaris operating systems. Fish is also a great starter shell with a lot of features to help the user navigate the shell without feeling lost.</p>
<p class="mce-root">While these shells are still very powerful and stable, we will be focusing on using bash, as we want to focus on consistency across multiple platforms and help you learn a very active and popular shell that's been around for 30 years.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Language-focused shells</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>As a data scientist, I'm sure you do a lot of work with Python and Scala or have at least heard of those two languages. Two of our favorite shell replacements are Xonsh and Ammonite. Xonsh (</span><a href="https://xon.sh/">https://xon.sh/</a><span>) is a Python-powered shell that uses Python 3.4, and Ammonite (</span><a href="http://ammonite.io/">http://ammonite.io/</a><span>) is a Scala-powered shell that uses Scala 2.11.7 (both versions are at time of writing). If you find yourself using a lot of Python or Scala in your day-to-day work, we recommend checking those shell replacements out as well after you've mastered the command line using bash.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">So, why the command line?</h1>
                </header>
            
            <article>
                
<p class="mce-root">As the field of data science is still fairly new (it used to be called <strong>operations research</strong>), the tools and frameworks are also fairly new. With that being said, the command line is almost 50 years old and still one of the most powerful tools used today. If you're familiar with interpreters, the command line will come easy to you. Think of it as a place to experiment and see your results in real time. Every command you enter is executed interactively, and when you call a bash script to run, it executes sequentially (unless you decide not to, more in later chapters). As we know, experimenting and exploring is most of what data science tries to accomplish (and it's the most fun!).</p>
<p class="mce-root">I was having a conversation with a newly-graduated data science student about parsing text and asked, "How would you take a small file and provide a word count on how many time the words appear?" By now everyone is familiar with the infamous Hadoop word-count example. It's considered the "Hello, World" of data science.</p>
<p class="mce-root">The answer I received was a little shocking but expected. The student instantly replied that they'd use Hadoop to read the file, tokenize the words to form a key/value pair, reduce all the keys and values that are grouped together, and add up the occurrences. The student isn't wrong, in fact, that's a perfectly acceptable answer. Especially if the file is too large for a single system (big data), you already have the code in place to scale.</p>
<p class="mce-root">With that being said, what if I told you there's a quicker way to obtain the results that doesn't require programming in Java and setting up a cluster or having Hadoop run locally? In fact, it would only take one line to complete the task? Check out the following code:</p>
<pre><strong>cat file.txt | tr '[:space:]' '[\n*]' | grep -v "^$" | sort | uniq -c | sort -bnr</strong><br/><strong>(tr '[:space:]' '[\n*]' | grep -v "^$" | sort | uniq -c | sort -bnr )&lt;file.txt</strong></pre>
<p class="mce-root">This may seem like a lot, especially if you've never used the command line before, so let's break it down. The<span> </span><kbd>cat</kbd><span> </span>command reads files sequentially and writes them to standard output. <kbd>|</kbd>, also known as pipe or the pipe operator, combines a sequence of commands chained together by their standard streams so that the output of each process (<kbd>stdout</kbd>) feeds directly as input (<kbd>stdin</kbd>) to the next one.<span> </span><kbd>tr</kbd><span> </span>(translate) reads the input from<span> </span><kbd>cat</kbd><span> </span>(via<span> </span><kbd>|</kbd><span> </span>) and writes the result to standard output that replaces spaces with new lines. The<span> </span><kbd>grep</kbd><span> </span>command is very powerful and the most used for a lot of data parsing.<span> </span><kbd>grep</kbd> is used to search plain-text data for lines that match a regular expression. In this example,<span> </span><kbd>grep</kbd><span> </span>trims out the empty lines.<span> </span><kbd>sort</kbd><span> </span>is used for, well, sorting! You'll notice a lot of the commands are named for what they actually do. The<span> </span><kbd>sort</kbd><span> </span>command prints the lines of its input or concatenation of files listed in its argument list in sorted order.<span> </span><kbd>uniq</kbd><span> </span>is a command that, when fed a text file, outputs the file with adjacent identical lines collapsed to one. It usually works well with the <kbd>sort</kbd> command. In this example,<span> </span><kbd>uniq -c</kbd><span> </span>is called to count occurrences. And finally,<span> </span><kbd>sort -bnr</kbd> sorts in numeric reverse order and ignores whitespace.</p>
<p class="mce-root">Don't worry if the example looks foreign to you. The command line also comes with manual pages for each command. All you have to do is<span> </span><kbd>man</kbd><span> </span>the command to view the page. You can even<span> </span><kbd>man man</kbd><span> </span>to get an idea of what the <kbd>man</kbd> command does! Give it a whirl and<span> </span><kbd>man tr</kbd><span> </span>or<span> </span><kbd>man sort</kbd>. Oh, you don't have the command line set up? It's easier than you think, and we can get you up in running in minutes, so let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting set up with Windows 10</h1>
                </header>
            
            <article>
                
<p class="mce-root">We want the readers to keep in mind that PowerShell will not work with the examples listed in this book. However, Microsoft has seen fit to release their Windows Subsystem for Linux as of Windows 10 version 1607 and later. It's also easy to install: open the Microsoft Store, search for <kbd>Ubuntu</kbd> (a Linux distribution), and install it:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-613 image-border" src="assets/e5389436-22c5-435c-befe-9804a4516a01.png" style="width:65.00em;height:43.75em;"/></p>
<p class="mce-root">In Windows 10 version 1607 and later, you have the ability to run Linux natively with your choice of distribution. In this example, we will use Ubuntu on top of Windows 10 to get our workspace set up. Make sure you have the latest version of Windows installed in order to take advantage of WSL (Windows Subsystem for Linux); at a minimum, you need the Windows 10 Fall Creator update to proceed. Also keep in mind that WSL is in beta at the time of writing. If you don't feel comfortable installing beta software, I recommend finding an alternative, such as an EC2 instance on AWS, or skipping ahead to the <em>Docker</em> section of this book:</p>
<ol>
<li>Go to the Start menu and search for PowerShell:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-614 image-border" src="assets/f180f301-e6c7-48d1-a70f-abb501ae6088.png" style="width:22.75em;height:37.00em;"/></p>
<p class="mce-root"/>
<ol start="2">
<li style="font-weight: 400">Double-click <span class="packt_screen">Windows PowerShell</span> and click <span class="packt_screen">Run as</span> <span class="packt_screen">Administrator</span>.</li>
<li class="mce-root"><span>Type the following command to enable WSL:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</strong></pre>
<p class="mce-root" style="padding-left: 90px"><span>The following should be displayed:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-615 image-border" src="assets/c252c57c-b17f-453c-9cf2-348d91ffe433.png" style="width:81.42em;height:18.75em;"/></p>
<ol start="4">
<li class="CDPAlignLeft CDPAlign"><span>You will be asked to confirm your c</span><span>hoice. Use</span> <em>Y</em> <span>or press</span> <em>Enter</em><span>:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-616 image-border" src="assets/c1a8cfbd-f638-496e-9f41-91bca02a5666.png" style="width:81.50em;height:16.50em;"/></p>
<ol start="5">
<li>Press <em>Y</em> to reboot.</li>
</ol>
<p class="mce-root">Once your system has rebooted, do the following:</p>
<ol>
<li style="font-weight: 400">Go to the Start menu and search for Store.</li>
<li style="font-weight: 400"> Search for Ubuntu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-617 image-border" src="assets/b9902b06-f6e2-4cab-8f17-56ecb250c1f9.png" style="width:66.08em;height:40.50em;"/></p>
<p class="mce-root"/>
<ol start="3">
<li style="font-weight: 400">Click <span class="packt_screen">Install</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-618 image-border" src="assets/c7a4523d-722c-423a-8766-1c9f1fd00cca.png" style="width:59.25em;height:44.42em;"/></p>
<p class="mce-root"/>
<ol start="4">
<li>Click <span class="packt_screen">Launch</span>.</li>
<li class="CDPAlignLeft CDPAlign" style="font-weight: 400">When asked to create a username and password, go ahead and create one. Make sure you remember this information as you'll need it throughout this book:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-619 image-border" src="assets/98f6a139-2bba-4acc-826d-15bf51f551c5.png" style="width:82.08em;height:19.83em;"/></p>
<p class="mce-root"/>
<ol start="6">
<li style="font-weight: 400">Success! You now have completed the setup and installation of Linux on Windows 10.</li>
</ol>
<p>Install the following tools as we will be using them throughout this book:</p>
<pre><strong>sudo apt update</strong><br/><strong>sudo apt install jq python-pip gnuplot sqlite3 libsqlite3-dev curl netcat bc</strong><br/><strong>pip install pandas</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting set up on OS X</h1>
                </header>
            
            <article>
                
<p class="mce-root">OS X already has a full command-line system installed using bash as the default shell. To access this shell, click the magnifying glass in the upper-right corner and type <kbd>terminal</kbd> in the dialog box:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-620 image-border" src="assets/d1f9b9a6-592a-4076-be14-879d811fa2a7.png" style="width:56.08em;height:35.33em;"/></p>
<p class="mce-root">This will open a bash Terminal:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-621 image-border" src="assets/e2c0707a-4bfc-4cad-8d5b-62dbefaec631.png" style="width:43.33em;height:6.75em;"/></p>
<p class="mce-root">As in other bash shells, this Terminal doesn't have everything installed, so type the following commands to install the requisite installers and command-line tools that we'll be using in this book:</p>
<pre><strong>/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</strong><br/><strong>brew install jq sqlite gnuplot python netcat bc</strong><br/><strong>pip3 install pandas</strong></pre>
<p class="mce-root">On OS X, this script installs a few installation tools, including <kbd>pip</kbd> and <kbd>homebrew</kbd>. It then uses these tools to install the commands that we use in this book that aren't natively installed, namely <kbd>jq</kbd>, <kbd>gnuplot</kbd>, <kbd>sqlite</kbd>, and <kbd>pandas</kbd>.</p>
<p class="mce-root">One thing to look out for in OS X is that certain standard tools are built a little differently than the ones that come with Debian-based systems like the rest of the systems we talk about in this chapter. In some circumstances, OS X tools work slightly differently or have different options. Where this is the case we have noted it in the text.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting set up on Ubuntu Linux</h1>
                </header>
            
            <article>
                
<p class="mce-root">Ubuntu has a full built-in command-line shell and typically uses bash as the default shell. Different window managers have slightly different ways of opening a Terminal window. For example, in the image of Ubuntu 17.10 Artful (located at <a href="https://www.osboxes.org/ubuntu/" target="_blank">https://www.osboxes.org/ubuntu/</a>), open the Terminal by clicking on <span class="packt_screen">Activities</span> in the upper-left corner and typing <kbd>terminal</kbd> in the dialog:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-622 image-border" src="assets/1b3a32d8-96a6-4e9e-9a8d-2d7ce0ba587d.png" style="width:68.75em;height:37.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root">This will bring up a command-line prompt:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-623 image-border" src="assets/33e324a6-3279-4df3-a3cc-87e03638bedb.png" style="width:28.67em;height:10.92em;"/></p>
<p class="mce-root">As in other bash shells, this shell doesn't have everything installed, so type the following command to install the installers and command-line tools that we will use in this book:</p>
<pre><strong>sudo apt update</strong><br/><strong>sudo apt install jq python-pip gnuplot sqlite3 libsqlite3-dev curl netcat bc</strong><br/><strong>pip install pandas</strong></pre>
<p class="mce-root">On Ubuntu, this script installs a few installation tools, including pip. It then uses these tools to install the commands that we use in this book that aren't natively installed, namely <kbd>jq</kbd>, <kbd>gnuplot</kbd>, <kbd>sqlite</kbd>, <kbd>curl</kbd>, and <kbd>pandas</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting set up with Docker</h1>
                </header>
            
            <article>
                
<p class="mce-root">What if there were a way to obtain an image with all the commands preinstalled and you were able to run it on most major operating systems without any issues? That's exactly what Docker provides, and you can quickly get up and running in a matter of minutes:</p>
<ol>
<li>Visit<span> </span><a href="https://www.docker.com/community-edition">https://www.docker.com/community-edition</a><span> </span>and install the version of Docker for your operating system</li>
<li>Run the following command to obtain the Docker image:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker run -ivt nextrevtech/commandline-book /bin/bash</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">The command line has a long history, and it can be quite foreign to newcomers. In this chapter, we covered the environment setup steps so that you can follow along with the examples in this book. Essential commands will introduce what you need to succeed, followed by acquiring datasets that we can play with. We will cover all the shell magic, such as background processes, writing shell functions, basic shell control-flow constructs, visualizing results, processing strings, simulating database functionality, simple math constructs, and finally a synthesis of all of these in a penultimate chapter of magical fascination.</p>
<p>Everything you need t<span>o explore the rest of the book is now </span><span>installed and configured. As you saw, the command line can run on pretty much anything, which makes it an invaluable tool to have in your toolkit.</span></p>
<p>In the next chapter, we will use our newly-installed command-line environment to run some essential commands, learn how to customize the shell, and look at how to use the built-in help when we get stuck.</p>


            </article>

            
        </section>
    </body></html>