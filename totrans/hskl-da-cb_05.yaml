- en: Chapter 5. The Dance with Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything from creating simple binary trees to practical applications such
    as Huffman encoding is covered in this section:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Defining a binary tree data type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a rose tree (multiway tree) data type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing a tree depth-first
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing a tree breadth-first
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Foldable instance for a tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the height of a tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a binary search tree data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the order property of a binary search tree
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a self-balancing tree
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a min-heap data structure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding a string using a Huffman tree
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding a Huffman code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Introduction](img/ch05.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Trees are a common data structure used in a variety of data analysis techniques.
    A **tree** is a hierarchical connection of nodes under one all-encompassing mighty
    root node. Every node can have zero or more children, but each child node associates
    with only one parent. Also, the root is the only special case that has no parent
    node. All nodes without children are also referred to as **leaf** nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, we can very gracefully represent a tree since the recursive nature
    of the data structure makes use of the recursive nature of functional programming.
    This section will cover creating our own trees as well as using existing implementations
    from libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We will implement heaps and Huffman trees, which are some of the most notable
    examples of trees in data analysis. In other chapters throughout the book, we
    also run into HTML/XML traversal, hierarchical clustering, and decision trees,
    which all depend heavily on the tree data structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Defining a binary tree data type
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a binary tree, each node has at most two children. We will define a data
    structure to encompass the left and right subtrees of each node.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in the recipe will represent the following tree. The root node is labeled
    **n3** with a value of **3**. It has a left node **n1** of value **1**, and a
    right node **n2** of value **2**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code requires no imports. We can jump in and define the data structure
    recursively. A tree can either be a node with values or null/empty:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `main`, create the tree shown in the preceding diagram and print it out:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The full tree is printed out as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the nodes in a tree need more than two children, then see the next section,
    *Defining a rose tree (multiway tree) data type*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Defining a rose tree (multiway tree) data type
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rose tree relaxes the limitation of at most two children per node. It can
    have an arbitrary number of elements. Rose trees are common when parsing HTML
    to represent the **Document Object Model** (**DOM**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be representing the following tree in this recipe. The root node has
    three children:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not need any imports for this recipe:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The rose tree data type is similar to that of the binary tree, except that
    instead of left and right children, it will store an arbitrary list of children:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Construct the tree from the preceding diagram and print it out:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The printed output will be as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using dedicated left and right fields to represent child nodes, a
    rose tree uses a list data structure to represent an arbitrary number of children.
    A rose tree can be used to emulate a binary tree if each node is restricted to
    have at most two children.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To represent a binary tree, it may be simpler to use the previous recipe, *Defining
    a binary tree data type*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a tree depth-first
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate one way to traverse through a tree. The algorithm
    starts at the root node and continues exploring nodes along the entire length
    of a branch before going back to explore more shallow nodes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Since we will examine each node before recursively examining its child nodes,
    we call this a **pre-order traversal**. Instead, if we examine each node afterwards,
    then we call this approach **post-order traversal**. Anything in-between is an
    **in-order traversal**, but naturally, there is no unique in-order traversal for
    rose trees.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage in using the depth-first approach is the minimal space
    complexity. Video game AIs often use depth-first approaches in determining the
    ideal move to take against an opponent. However, in enormous or infinite trees,
    a depth-first search may never terminate if we keep visiting subsequent child
    nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will traverse the following tree in a depth-first fashion. Starting at node
    **r**, we first explore node **n1**, followed by **n2**, then go back up to find
    **n3**, and backtrack all the way to finally end at **n4**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use an existing rose tree implementation from `Data.Tree`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function will traverse a tree depth-first:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s a depth-first implementation of adding all the values in a tree:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a tree to represent the preceding diagram:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Test out the depth-first functions:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will print the following two lines of output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use the built-in rose tree data structure from `Data.Tree`.
    Similar to our implementation in the previous recipe, it has the `Tree` data type
    having the following constructor:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We recursively run the `depthFirst` algorithm on every child node and append
    it to the node's value, thereby creating a list that represents the tree traversal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If traversing a tree by the tree level is preferred, then take a look at the
    next section, *Traversing a tree breadth-first*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a tree breadth-first
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a breadth-first search approach to traversing a tree, nodes are visited in
    the order of the depth of the tree. The root is visited, then its children, then
    each of their children, and so on and so forth. This process requires a greater
    space complexity than the depth-first traversal but comes in handy for optimizing
    search algorithms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine trying to find all relevant topics from a Wikipedia article.
    Traversing all the links within the article in a breadth-first fashion will help
    ensure the topics start out with relevance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examine the tree in the following diagram. A breadth-first traversal will start
    at the root node **r**, then continue to the next level, encountering **n1** and
    **n4**, finally followed by **n2** and **n3**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using an existing implementation of a rose tree from `Data.Tree`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the breadth-first traversal of a tree:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For demonstration, implement a function to add the values of each node in a
    tree.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a tree based on the preceding diagram:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Test out the breadth-first algorithms in `main`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The printed output is as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use the built-in rose tree data structure from `Data.Tree`.
    Similar to our implementation in one of the previous recipes, it has the `Tree`
    data type with the following constructors:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We perform the breadth-first search by creating a list that begins with the
    values of the node's direct children. Then, the values of the children's children
    are appended, and so on until the tree is fully traversed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If space complexity becomes an issue, then the previous recipe, *Traversing
    a tree depth-first*, might offer a better approach.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Foldable instance for a tree
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of traversing a tree can be generalized by implementing a `Foldable`
    instance. Usually, folds are used on lists; for example, `foldr1 (+) [1..10]`
    traverses a list of numbers to produce a grand sum. Similarly, we can apply `foldr1
    (+) tree` to find the sum of all nodes in a tree.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be folding through the following tree to obtain a sum of all node values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following built-in packages:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The tree from `Data.Tree` already implements `Foldable`, so we will define
    our own tree data type for demonstration purposes:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `foldMap` function for the `Foldable` instance. This implementation
    will give us a post-order traversal of the tree:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a function to fold through a tree to find the sum of all nodes:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Construct a tree that represents the one in the preceding diagram:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Test out the folding by running the `add` function on a tree:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result gets printed out as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function that is necessary to define a `Foldable` instance is either `foldMap`
    or `foldr`. In this recipe, we define the `foldMap :: (Foldable t, Data.Monoid.Monoid
    m) => (a -> m) -> t a -> m` function that essentially maps a function `f` over
    every node in a tree, and glues it together using `mappend` from `Data.Monoid`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other ways to traverse through elements of a tree are discussed in the previous
    two sections, *Traversing a tree depth-first* and *Traversing a tree breadth-first*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the height of a tree
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The height of a tree is the length of the longest downward path from the root
    node. For example, the height of a balanced binary tree should be around log to
    the base 2 of the number of nodes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As long as we're consistent, the height of a tree can be defined as either the
    number of nodes or the number of edges in the longest path. In this recipe, we
    will count by using the number of nodes. The longest path of this tree contains
    three nodes and two edges. Therefore, this tree has a height of three units.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `maximum function` from `Data.List` and the built-in tree data structure
    from `Data.Tree`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define a function to calculate the height of a tree:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Construct a tree on which we will run our algorithm:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Test out the function in `main`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The height of the tree will be printed as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `height` function recursively finds the maximum height among its child trees
    and returns one plus that value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a binary search tree data structure
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary search tree restricts an order property on a binary tree. This order
    property requires that among every node, the nodes in the left subtree must not
    be greater, and that the nodes in the right subtree must not be less than the
    current node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a binary `BSTree` module to expose our binary search tree data structure.
    Insert the following code in a file called `BSTree.hs`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the data structure for a binary tree:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define a convenience function to create a one-node tree:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement a function to insert new values in the binary search tree:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement a function to find a node with a specific value in a binary search
    tree:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, test out the `BSTree` module by creating a new file that can be called
    `Main.hs` with the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `main`, construct a binary search tree by calling the `insert` function
    on various values:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Print out the tree and test out the `find` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output should be as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core functions of a binary search tree data structure are `insert` and `find`,
    and are used for inserting and finding elements in a binary search tree respectively.
    Finding a node is accomplished by traversing the tree and taking advantage of
    its order property. If the value is lower than expected, it will check the left
    node; otherwise, if the value is greater, it will check the right node. Eventually,
    this recursive algorithm either finds the desired node or ends up at a leaf node
    and consequently does not find the node.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: A binary search tree does not guarantee the tree to be balanced, and therefore,
    a speedy O(log n) lookup is not to be expected. There is always a possibility
    for a binary search tree to end up looking like a list data structure (consider,
    for example, when we insert nodes in the following order [1,2,3,4,5] and examine
    the resulting structure).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a binary tree, the order property can be verified using the following
    recipe titled *Verifying the order property of a binary search tree*. To use a
    balanced binary tree, refer to the recipe, *Using a self-balancing tree*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the order property of a binary search tree
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a binary tree, this recipe will cover how to verify if it actually satisfies
    the order property such that all elements in the left subtree are of lesser value,
    and that all values of the right subtree are of greater value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be verifying whether or not the following tree is a binary search tree:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No imports are necessary for this recipe. Perform the following steps to find
    if the tree is a binary search tree:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a data structure for a binary tree:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Construct a tree based on the preceding diagram:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the function to verify whether or not a tree obeys the binary order
    property:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Test out the function in `main`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Clearly, the tree does not obey the order property, and therefore, the output
    is as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `valid` function recursively checks if the left subtree contains elements
    less than the current node and if the right subtree contains elements greater
    than the current node.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Using a self-balancing tree
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An AVL tree is a balanced binary search tree. The heights of each subtree differ
    by at most one. On each insertion or deletion, the tree shifts around its nodes
    through a series of rotations to become balanced. A balanced tree ensures the
    height is minimized, which guarantees lookups and insertions to be within *O(log
    n)* time. In this recipe, we will use an AVL tree package directly, but self-balancing
    trees also exist within the `Data.Set` and `Data.Map` implementations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using the `AvlTree` package to use `Data.Tree.AVL`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant AVL tree packages:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Set up an AVL tree from a list of values and read the minimum and maximum values
    from it:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The minimum and maximum values are printed out as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `asTree :: (e -> e -> COrdering e) -> [e] -> AVL` e-function takes in an
    ordering property and a list of elements to produce an AVL tree out of the corresponding
    elements. The function `fstCC :: Ord a => a -> a -> COrdering a` comes from `Data.Cordering`
    and is defined as:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '*A combining comparison for an instance of ''Ord'' which keeps the first argument
    if they are deemed equal. The second argument is discarded in this case.*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of Haskell''s `Data.Set` and `Data.Map` functions efficiently
    uses balanced binary trees. We can rewrite the recipe by simply using `Data.Set`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implementing a min-heap data structure
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap is a binary tree with both a shape property and a heap property. The
    shape property enforces the tree to behave in a balanced way by defining each
    node to have two children unless the node is in the very last level. The heap
    property ensures that each node is less than or equal to either of its child nodes
    if it is a min-heap, and vice versa in case of a max-heap.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Heaps are used for constant time lookups for maximum or minimum elements. We
    will use a heap in the next recipe to implement our own Huffman tree.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the lens library for easy data manipulation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the `MinHeap` module in a file `MinHeap.hs`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will use a list to represent a binary tree data structure for demonstration
    purposes only. It is best to implement the heap as an actual binary tree (as we
    have done in the previous sections), or we should use an actual array that will
    give us constant time access to its elements. For simplicity, we will define the
    root node to start at index 1\. Given a node at index `i`, the left child will
    always be located at *2*i*, and the right child at *2*i + 1*:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We define a convenience function to initiate an empty heap:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Insertion of a node in a heap is done by appending the node to the end of the
    array and percolating it up:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Deleting a node from a heap is done by swapping the root node with the last
    element, and then percolating down from the root node:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a function to view the minimum:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Percolating down from a node means ensuring the heap property holds for the
    current node; otherwise, swap the node with the greater or lesser (depending on
    the max or min heap) child. This process is recursively applied all the way down
    to the leaf nodes:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Define the `left`, `right`, `i''`, `l`, and `r` variables:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Percolating a node up means to recursively swap a node with its parent until
    the heap property of the tree holds:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We define a convenience function to swap items at two indices in a list:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To view the weights of each node in the array representation of a heap, we
    can define the following function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, in a different file that we can name `Main.hs`, we can test out the
    min-heap:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output of the weights in the array representation of the heap is as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's more…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in this recipe is for understanding the heap data structure, but it
    is by no means efficient. Better implementations of heaps exist on Hackage, including
    the `Data.Heap` library that we will explore:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the heap library:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define a helper function to construct a min-heap from a list:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define a helper function to construct a max-heap from a list:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Test out the heaps:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The view functions return a tuple in a `Maybe` data structure. The first element
    of the tuple is the value from performing a lookup, and the second element is
    the new heap with that value removed:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Encoding a string using a Huffman tree
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Huffman tree** allows efficient encoding of data by calculating a probability
    distribution of characters to optimize the space taken per character. Imagine
    compressing this book into one piece of paper and back without any information
    loss. Huffman trees allow this type of optimal lossless data compression based
    on statistics.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement a Huffman tree from a source of text and produce
    a string representation of its Huffman codes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: For example, the string "hello world" contains 11 characters, which, depending
    on the encoding and architecture, may take up as few as 11 bytes of space to represent.
    The code in this recipe will transform the string into just 51 bits, or 6.375
    bytes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure to be connected to the Internet since this recipe will download text
    from [http://norgiv.com/big.txt](http://norgiv.com/big.txt) to analyze probability
    distribution of many characters. We will be using the min-heap that was implemented
    in the previous recipe by importing `MinHeap`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following packages. We will be using our previous `MinHeap` module,
    so be sure to include the code from the previous recipe:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a function to return an association list of characters to its frequency:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The data structure of a Huffman tree is simply a binary tree:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Construct a Huffman tree with one value:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define a function to construct a Huffman tree from a min-heap:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Get a map of Huffman codes from the Huffman tree:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define a function to encode a string to text using the Huffman codes:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Test out the entire process by executing the following in `main`. Downloading
    and calculating the frequency might take a couple of minutes:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The string representation of the Huffman tree is then printed as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we obtain a source of data to analyze by downloading the text from [http://norvig.com/big.txt](http://norvig.com/big.txt).
    Next, we obtain the frequency map of each character and throw it in a heap. The
    Huffman tree is constructed from this min-heap by combining the two lowest frequency
    nodes until only one node is left in the min-heap. Finally, the Huffman codes
    are used on a sample "hello world" string to see the encoding.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read an encoded Huffman value, see the next section, *Decoding a Huffman
    code*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a Huffman code
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This code relies heavily on the previous recipe, *Encoding a string using a
    Huffman tree*. The same Huffman tree data structure is used next to decode a string
    representation of a Huffman coding.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在很大程度上依赖于前面的食谱，*使用哈夫曼树编码字符串*。接下来使用相同的哈夫曼树数据结构来解码哈夫曼编码的字符串表示。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe, *Encoding a string using a Huffman tree*. The same
    `HTree` data structure is used in this recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的食谱，*使用哈夫曼树编码字符串*。本食谱中使用的是相同的`HTree`数据结构。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We traverse down the tree until we hit a leaf node. Then, we prepend the character
    found and restart from the root node. This process continues until no input is
    available:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们沿着树进行遍历，直到遇到叶子节点。然后，前置找到的字符并从根节点重新开始。这个过程会持续进行，直到没有输入可用为止：
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To encode data using a Huffman tree, see the previous recipe, *Encoding a string
    using a Huffman tree*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用哈夫曼树编码数据，请参见前面的食谱，*使用哈夫曼树编码字符串*。
