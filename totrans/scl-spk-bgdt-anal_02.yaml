- en: Object-Oriented Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"The object-oriented model makes it easy to build up programs by accretion.
    What this often means, in practice, is that it provides a structured way to write
    spaghetti code."*'
  prefs: []
  type: TYPE_NORMAL
- en: '- Paul Graham'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to get programming started with Scala.
    Well, if you're writing the procedural program that we followed in the previous
    chapter, you can enforce the code reusability by creating procedures or functions.
    However, if you continue working, consequently, your program gets longer, bigger,
    and more complex. At a certain point, you will not even have any other more simple
    way to organize the entire code before production.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, the **object-oriented programming** (**OOP**) paradigm provides
    a whole new layer of abstraction. You can then modularize your code through defining
    OOP entities such as classes with related properties and methods. You can even
    define the relationship between those entities by utilizing inheritance or an
    interface. You can also group similar classes holding similar functionality together,
    as a helper class maybe; therefore, making your project suddenly feels more spacious
    and extensible. In short, the greatest strengths of OOP languages are discoverability,
    modularity, and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the preceding features of OOP languages, in this chapter, we will
    discuss the basic object-oriented features in Scala. In a nutshell, the following
    topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods, classes, and objects in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages and package objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits and trait linearization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will discuss pattern matching, which is a feature that comes from functional
    programming concepts. Moreover, we will discuss some built-in concepts in Scala,
    such as implicit and generics. Finally, we will discuss some widely used build
    tools that are needed for building our Scala applications into jars.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before entering into the depth of OOP features, first, we need to know details
    about the different types of variables and data types in Scala. To declare a variable
    in Scala, you need to use `var` or `val` keywords. The formal syntax of declaring
    a variable in Scala is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s see how can we declare two variables whose data types are
    explicitly specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even just declare a variable without specifying the `DataType`. For
    example, let''s see how to declare a variable using `val` or `var`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two types of variables in Scala: mutable and immutable that can be
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutable:** The ones whose values you can change later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable:** The ones whose values you cannot change once they have been
    set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, for declaring a mutable variable, a `var` keyword is used. On the
    other hand, for specifying an immutable variable, a `val` keyword is used. To
    show an example of using the mutable and immutable variables, let''s consider
    the following code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works fine until `myVar = 90`, since **`myVar`** is a mutable
    variable. However, if you try to change the value of the immutable variable (that
    is, `myVal`), as shown earlier, your IDE will show a compilation error saying
    reassignment to `val`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00202.jpeg)**Figure 1:** Reassignment of immutable variables is not
    allowed in Scala variable scope'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry looking at the preceding code with the object and method! We will
    discuss classes, methods, and objects later in this chapter, then things will
    become more clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Scala variables, we can have three different scopes, depending on the place
    where you have declared them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fields:** These are variables that belong to an instance of a class of your
    Scala code. The fields are, therefore, accessible from inside every method in
    the object. However, depending on the access modifiers, fields can be accessible
    to instances of the other classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As discussed earlier, object fields can be mutable or they can be immutable
    (based on the declaration types using either `var` or `val`). But, they can't
    be both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method arguments:** These are variables, and when the method is called, these
    can be used to pass the value inside a method. Method parameters are accessible
    only from inside the method. However, the objects being passed in may be accessible
    from the outside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is to be noted that method parameters/arguments are always immutable, no
    matter what is/are the keyword(s) specified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Local variables:** These variables are declared inside a method and are accessible
    from the inside the method itself. However, the calling code can access the returned
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference versus value immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the section earlier, `val` is used to declare immutable variables,
    so can we change the values of these variables? Will it be similar to the final
    keyword in Java? To help us understand more about this, we will use the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding code, an error at compilation time will be noticed,
    which will tell you that you are trying to reassign to a `val` variable. In general,
    mutable variables bring a performance advantage. The reason is that this is closer
    to how the computer behaves and because introducing immutable values forces the
    computer to create a whole new instance of an object whenever a change (no matter
    how small) to a particular instance is required
  prefs: []
  type: TYPE_NORMAL
- en: Data types in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, Scala is a JVM language, so it shares lots in common with Java.
    One of these commonalities is the data types; Scala shares the same data types
    with Java. In short, Scala has all the same data types as Java, with the same
    memory footprint and precision. As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, objects are almost everywhere in Scala. and all data
    types are objects and you can call methods in them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sr.No** | **Data Type and Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | **Byte**: 8 bit signed value. Ranges from -128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **Short**: 16 bit signed value. Ranges -32768 to 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **Int**: 32 bit signed value. Ranges -2147483648 to 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **Long**: 64 bit signed value. -9223372036854775808 to 9223372036854775807
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **Float**: 32 bit IEEE 754 single-precision float |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **Double**: 64 bit IEEE 754 double-precision float |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | **Char**: 16 bit unsigned Unicode character. Range from U+0000 to U+FFFF
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | **String**: A sequence of Chars |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | **Boolean**: Either the literal `true` or the literal `false` |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | **Unit**: Corresponds to no value |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | **Null**: Null or empty reference |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | **Nothing**: The subtype of every other type; includes no values |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | **Any**: The supertype of any type; any object is of type *Any* |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | **AnyRef**: The supertype of any reference type |'
  prefs: []
  type: TYPE_TB
- en: '**Table 1:** Scala data types, description, and range'
  prefs: []
  type: TYPE_NORMAL
- en: All the data types listed in the preceding table are objects. However, note
    that there are no primitive types, as in Java. This means that you can call methods
    on an `Int`, `Long`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can start playing around with these variables. Let's get some ideas
    on how to initialize a variable and work on the type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Variable initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, it''s a good practice to initialize the variables once declared.
    However, it is to be noted that uninitialized variables aren''t necessarily nulls
    (consider types like `Int`, `Long`, `Double`, `Char`, and so on), and initialized
    variables aren''t necessarily non-null (for example, `val s: String = null`).
    The actual reasons are that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Scala, types are inferred from the assigned value. This means that a value
    must be assigned for the compiler to infer the type (how should the compiler consider
    this code: `val a`? Since a value isn''t given, the compiler can''t infer the
    type; since it can''t infer the type, it wouldn''t know how to initialize it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Scala, most of the time, you'll use `val`. Since these are immutable, you
    wouldn't be able to declare them and then initialize them afterward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although, Scala language requires you to initialize your instance variable
    before using it, Scala does not provide a default value for your variable. Instead,
    you have to set up its value manually using the wildcard underscore, which acts
    like a default value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the names, such as `val1`, `val2` and so on, you can define
    your own names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use these names in subsequent expressions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Type annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use a `val` or `var` keyword to declare a variable, its data type will
    be inferred automatically according to the value that you assigned to this variable.
    You also have the luxury of explicitly stating the data type of the variable at
    declaration time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at some other aspects that will be needed while working with
    variables and data types in Scala. We will see how to work with type ascription
    and `lazy` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Type ascription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type ascription is used to tell the compiler what types you expect out of an
    expression, from all possible valid types. Consequently, a type is valid if it
    respects existing constraints, such as variance and type declarations, and it
    is either one of the types the expression it applies to "is a," or there''s a
    conversion that applies in scope. So, technically, `java.lang.String` extends
    `java.lang.Object`, therefore any `String` is also an `Object`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Lazy val
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main characteristic of a `lazy val` is that the bound expression is not
    evaluated immediately, but once on the first access. Here''s where the main difference
    between `val` and `lazy val` lies. When the initial access happens, the expression
    is evaluated and the result is bound to the identifier, the `lazy val`. On subsequent
    access, no further evaluation occurs, instead, the stored result is returned immediately.
    Let''s see an interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the preceding code in Scala REPL, you will notice that the code
    runs very well without throwing any errors, even though you divided an integer
    with 0! Let''s see a better example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This works and, later on, you can access the value of variable `x` when required.
    These are just a few examples of using lazy `val` concepts. Interested readers
    should access this page for more details: [https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/.](https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/)'
  prefs: []
  type: TYPE_NORMAL
- en: Methods, classes, and objects in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to work with Scala variables, different
    data types and their mutability and immutability, along with their usages scopes.
    However, in this section, to get the real flavor of the OOP concept, we are going
    to deal with methods, objects, and classes. These three features of Scala will
    help us understand the object-oriented nature of Scala and its features.
  prefs: []
  type: TYPE_NORMAL
- en: Methods in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part, we are going to talk about methods in Scala. As you dive into
    Scala, you''ll find that there are lots of ways to define methods in Scala. We
    will demonstrate them in some of these ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding declaration of the method takes two variables and returns the
    smallest among them. In Scala, all the methods must start with the def keyword,
    which is then followed by a name for this method. Optionally, you can decide not
    to pass any parameters to the method or even decide not to return anything. You''re
    probably wondering how the smallest value is returned, but we will get to this
    later. Also, in Scala, you can define methods without curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If your method has a small body, you can declare your method like this. Otherwise,
    it''s preferred to use the curly braces in order to avoid confusion. As mentioned
    earlier, you can pass no parameters to the method if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A method with or without parentheses signals the absence or presence of a side
    effect. Moreover, it has a deep connection with the uniform access principle.
    Thus, you can also avoid the braces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also some methods which return the value by explicitly mentioning
    the return types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It should be mentioned that the preceding code works due to the Scala compiler,
    which is able to infer the return type, just as with values and variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will return `Hello` concatenated with the passed person name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The return in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before learning how a Scala method returns a value, let''s recap the structure
    of a method in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding syntax, the return type could be any valid Scala data type
    and a list of parameters will be a list of variables separated by a comma and
    a list of parameters and return type is optional. Now, let''s define a method
    that adds two positive integers and returns the result, which is also an integer
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now call the preceding method from the `main()` method with the real
    values, such as `addInt(10, 30)`, the method will return an integer value sum,
    which is equal to `40`. As using the keyword `return` is optional, the Scala compiler
    is designed such that the last assignment will be returned with the absence of
    the `return` keyword. As in this situation, the greater value will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Well done! We have seen how to use variables and how to declare a method in
    Scala REPL. Now, its time to see how to encapsulate them inside Scala methods
    and classes. The next section discusses Scala objects.
  prefs: []
  type: TYPE_NORMAL
- en: Classes in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes are considered as a blueprint and then you instantiate this class in
    order to create something that will actually be represented in memory. They can
    contain methods, values, variables, types, objects, traits, and classes which
    are collectively called **members**. Let''s demonstrate this with the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have two variables `animalName` and `animalAge` with their setters and getters.
    Now, how do we use them to solve our purpose? Here come the usages of Scala objects.
    Now, we will discuss Scala objects, then we will trace back to our next discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **object** in Scala has a slightly different meaning than the traditional
    OOP one, and this difference should be explained. In particular, in OOP, an object
    is an instance of a class, while in Scala, anything that is declared as an object
    cannot be instantiated! The `object` is a keyword in Scala. The basic syntax for
    declaring an object in Scala is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the preceding syntax, let''s revisit the hello world program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This hello world example is pretty similar to the Java ones. The only big difference
    is that the main method is not inside a class, but instead it''s inside an object.
    In Scala, the keyword object can mean two different things:'
  prefs: []
  type: TYPE_NORMAL
- en: As in OOP, an object can represent an instance of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A keyword for depicting a very different type of instance object called **Singleton**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton and companion objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we will see a comparative analysis between the singleton
    object in Scala and Java. The idea beneath the singleton pattern is to have an
    implementation that makes sure that only a single instance of a class can exist.
    Here''s an example of the Singleton pattern in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala object does a similar thing, and it''s well taken care of by the
    compiler. Since there will be only one instance, there is no way for object creation
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00215.jpeg)**Figure 3:** Object creation in Scala'
  prefs: []
  type: TYPE_NORMAL
- en: Companion objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a `singleton object` is named the same as a class, it is called a `companion
    object`. A companion object must be defined inside the same source file as the
    class. Let''s demonstrate this with the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the way that you will call methods through the companion object
    (preferably with the same name - that is, `Animal`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A Java equivalent would be very similar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Well done! So far, we have seen how to work with Scala objects and classes.
    However, working with the method for implementing and solving your data analytics
    problem is even more important. Thus, we will now see how to work with Scala methods
    in brief.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's have a brief overview on the accessibility and the visibility of
    the Scala classes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing and contrasting: val and final'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like Java, the final keyword also exists in Scala, which works somehow
    similar to the val keyword. In order to differentiate between the `val` and `final`
    keywords in Scala, let''s declare a simple animal class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, while listing Scala features, Scala can override variables
    which don''t exist in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, before going deeper, a quick discussion on the keyword `extends` is a mandate.
    Refer to the following information box for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Scala, classes can be extensible. A subclass mechanism using the extends
    keyword makes it possible to *specialize* a class by inheriting all members of
    a given *superclass* and defining additional class members. Let''s look at an
    example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Coordinate(xc: Int, yc: Int) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`val x: Int = xc`'
  prefs: []
  type: TYPE_NORMAL
- en: '`val y: Int = yc`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def move(dx: Int, dy: Int): Coordinate = new Coordinate(x + dx, y + dy)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class ColorCoordinate(u: Int, v: Int, c: String) extends Coordinate(u, v)
    {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`val color: String = c`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def compareWith(pt: ColorCoordinate): Boolean = (pt.x == x) && (pt.y == y)
    && (pt.color == color)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`override def move(dx: Int, dy: Int): ColorCoordinate = new ColorCoordinate(x
    + dy, y + dy, color)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we declared the age variable as final in the `Animal` class, then
    the `Cat` class will not be able to override it, and it will give the following
    error. For this `Animal` example, you should have learned when to use the `final`
    keyword. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Well done! To achieve the best encapsulation - also called information hiding
    - you should always declare methods with the least visibility that works. In the
    next subsection, we will learn how the access and visibility of classes, companion
    objects, packages, subclasses, and projects work.
  prefs: []
  type: TYPE_NORMAL
- en: Access and visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we will try to understand the access and visibility of
    Scala variables and different data types in the OOP paradigm. Let''s have a look
    at access modifiers in Scala. A similar one for Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Modifier** | **Class** | **Companion Object** | **Package** | **Subclass**
    | **Project** |'
  prefs: []
  type: TYPE_TB
- en: '| Default/No modifier | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Protected | Yes | Yes | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Private | Yes | Yes | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '**Public members**: Unlike a private and protected member, it is not required
    to specify the public keyword for public members. There is no explicit modifier
    for public members. Such members can be accessed from anywhere. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Private members**: A private member is visible only inside the class or object
    that contains the member definition. Let''s see an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Protected members**: A protected member is only accessible from subclasses
    of the class in which the member is defined. Let''s see an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Access modifiers in Scala can be augmented with qualifiers. A modifier of the
    form `private[X]` or `protected[X]` means that access is private or protected
    up to `X`, where `X` designates an enclosing package, class, or singleton object.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a short note on the preceding code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable `jboTitle` will be accessible to any class within the enclosing package
    `Professional`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `friend` will be accessible to any class within the enclosing package
    `Country`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `secret` will be accessible only to the implicit object within instance
    methods (this) only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the preceding examples, we used the keyword `package`. However,
    we have not discussed this so far. But don't worry; there will be a dedicated
    section later in this chapter. The constructor is a strong feature for any objected-oriented
    programming language. Scala is not an exception. Now, let's have a short overview
    of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept and the usage of constructors in Scala are a little different than
    what they are in C# or Java. There are two types of constructors in Scala - primary
    and auxiliary constructors. The primary constructor is the class's body, and it's
    parameter list appears right after the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code segment describes the way to use the primary
    constructor in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to use the preceding constructor, this implementation is similar to the
    previous one, except there are no setters and getters. Instead, we can get the
    animal name and age, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters are given in the class definition time to represent constructors.
    If we declare a constructor, then we cannot create a class without providing the
    default values of the parameters that are specified in the constructor. Moreover,
    Scala allows the instantiation of an object without providing the necessary parameters
    to its constructor: this happens when all constructor arguments have a default
    value defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Although there is a constraint for using the auxiliary constructors, we are
    free to add as many additional auxiliary constructors as we want. An auxiliary
    constructor must, on the first line of its body, call either another auxiliary
    constructor that has been declared before it, or the primary constructor. To obey
    this rule, each auxiliary constructor will, either directly or indirectly, end
    up invoking the primary constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code segment demonstrates the use of the auxiliary
    constructor in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the earlier setting, we included a secondary (that is, 2^(nd)) message in
    the primary constructor. The primary constructor will instantiate a new `Hello`
    object. Method `sayHello()` will print the concatenated message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Auxiliary constructors**: In Scala, defining one or more auxiliary constructors
    for a Scala class gives the consumers of the class different ways to create object
    instances. Define the auxiliary constructors as methods in the class with the
    name this. You can define multiple auxiliary constructors, but they must have
    different signatures (parameter lists). Also, each constructor must call one of
    the previously defined constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's peep into another important but relatively new concept in Scala, called
    **traits**. We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Traits in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the new features in Scala is a trait, which is very similar to the notion
    of an interface in Java, except that it can also contain concrete methods. Although,
    Java 8 already has support for this. On the other hand, traits are one of the
    new concepts in Scala. But the feature already exists in OOP. So, they look like
    abstract classes, except that they don't have constructors.
  prefs: []
  type: TYPE_NORMAL
- en: A trait syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to use the `trait` keyword in order to declare a trait and it should
    be followed by the trait name and body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Extending traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to extend traits or classes, you need to use the `extend` keyword.
    Traits cannot be instantiated because it may contain unimplemented methods. So,
    it''s necessary to implement the abstract members in the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A value class is not allowed to extend traits. To permit value classes to extend
    traits, universal traits are introduced, which extends for `Any`. For example,
    suppose that we have the following trait defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to extend the preceding trait in Scala using the universal trait, we follow
    the following code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, what is the difference between an abstract class and the traits in Scala?
    As you have seen, an abstract class can have constructor parameters, type parameters,
    and multiple parameters. However, a trait in Scala can have only type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A trait is fully interoperable if, and only if, it does not contain any implementation
    code. Furthermore, Scala traits are fully interoperable with Java interfaces in
    Scala 2.12\. Because Java 8 allows method implementations in its interfaces, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'There might be other cases for traits as well, for example, an abstract class
    can extend a trait or, if needed, any normal class (including the case classes)
    can extend an existing trait. For example, an abstract class can also extend traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, a normal Scala class also can extend a Scala trait. Since classes are
    concrete, (that is, instances can be created), the abstract members of the trait
    should be implemented. In the next section, we will discuss the Java interoperability
    of Scala codes. Now let's peep into another important concept in every OOP, called
    **abstract classes**. We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract class in Scala can have constructor parameters as well as type parameters.
    An abstract class in Scala is fully interoperable with Java. In other words, it
    is possible to call them from Java code without any intermediate wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is the difference between an abstract class and the traits in Scala?
    As you have seen, an abstract class can have constructor parameters, type parameters,
    and multiple parameters. However, a trait in Scala can have only type parameters.
    The following is a simple example of an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In order to extend this class by another one, we need to implement the unimplemented
    methods earlier `getAnimalAge`, `getAnimalGender`, and `getAnimalOrigin`. For
    `getAnimalName`, we can override it or not, since its implementation is already
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes and the override keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to override a concrete method from the superclass, the override
    modifier is necessary. However, if you are implementing an abstract method, it
    is not strictly necessary to add the override modifier. Scala uses the `override`
    keyword to override a method from a parent class. For example, suppose you have
    the following abstract class and a method `printContents()` to print your message
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a concrete implementation of the preceding abstract class to print
    the contents on the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, if you want to create a trait to modify the behavior of the preceding
    concrete class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the preceding code segment carefully, you will find two modifiers
    (that is, abstract and override). Now, with the preceding setting, you can do
    the following to use the preceding class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In summary, we can add an `override` keyword in front of the method to work
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Case classes in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **case** class is an instantiable class that includes several automatically
    generated methods. It also includes an automatically generated companion object
    with its own automatically generated methods. The basic syntax of a case class
    in Scala is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: A case class can be pattern matched, and comes with the following methods already
    implemented the method `hashCode` (location/scope is a class), `apply` (location/scope
    is an object), `copy` (location/scope is a class), `equals` (location/scope is
    a class), `toString` (location/scope is a class), and `unapply` (location/scope
    is an object).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a plain class, a case class automatically define, getter methods for the
    constructor arguments. To get a practical insight about the preceding features
    or a case class, let''s see the following code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For the REPL and the output of the regular expression matching, if you execute
    the preceding code (except the `Object` and `main` method), you should be able
    to see the more interactive output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00373.jpeg)**Figure 2:** Scala REPL for case class'
  prefs: []
  type: TYPE_NORMAL
- en: Packages and package objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like Java, a package is a special container or object which contains/defines
    a set of objects, classes, and even packages. Every Scala file has the following
    automatically imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang._`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scala._`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scala.Predef._`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example for basic imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even rename a member while importing, and that''s to avoid a collision
    between packages that have the same member name. This method is also called class
    `alias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, you can also import all the members of a package, but
    some members are also called **member hiding**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tried this in the REPL, it just tells the compiler the full, canonical
    name of the defined class or object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can even use the style of defining packages in curly braces. You can have
    a single package and nested package means package within a package. For example,
    the following code segment defines a single package named `singlePackage` consisting
    of a single class named `Test`. The `Test` class, on the other hand, consists
    of a single method named `toString()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can make the packaging nested. In other words, you can have more than
    one package in a nested way. For example, for the below case, we have two packages,
    namely `NestParentPack` and the `NestChildPack`, each containing their own classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new object (let''s name it `MainProgram`), in which we''ll
    invoke the methods and classes we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You will find more examples on the internet that describe sophisticated use
    cases of packages and package objects. In the next section, we will discuss the
    Java interoperability of Scala codes.
  prefs: []
  type: TYPE_NORMAL
- en: Java interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is one of the most popular languages, and many programmers learn Java programming
    as their first entrance to the programming world. The popularity of Java has increased
    since its initial release back in 1995\. Java has gained in popularity for many
    reasons. One of them is the design of its platform, such that any Java code will
    be compiled to bytecode, which in turn runs on the JVM. With this magnificent
    feature, Java language to be being written once and run anywhere. So, Java is
    a cross-platform language.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Java has lots of support from its community and lots of packages that
    will help you get your idea up and running with the help of these packages. Then
    comes Scala, which has lots of features that Java lacks, such as type inference
    and optional semicolon, immutable collections built right into Scala core, and
    lots more features (addressed in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*). Scala also runs on the JVM, just like Java.
  prefs: []
  type: TYPE_NORMAL
- en: '**Semicolon in Scala:** Semicolons are exactly optional, and they are required
    when more lines of code should be written on a single line. That''s probably the
    reason why the compiler doesn''t complain if a semicolon is put at the end of
    a line: it is considered a piece of code followed by an empty piece of code that,
    coincidentally, lives on the same line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see that both Scala and Java run on the JVM, it makes sense to use
    them simultaneously in the same program without complaints from the compiler.
    Let''s demonstrate this with an example. Consider the following Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to write the same code in Scala, you can make use of Java packages.
    Let''s translate the previous example into Scala with the help of using Java collections
    such as `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The previous mix applies for the standard packages of Java, but you want to
    use libraries that aren't packaged with the standard libraries of Java, or even
    want to use your own classes. Then, you need to make sure that they lie in the
    classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the widely used features of Scala is pattern matching. Each pattern
    match has a set of alternatives, each of them starting with the case keyword.
    Each alternative has a pattern and expression(s), which will be evaluated if the
    pattern matches and the arrow symbol `=>` separates pattern(s) from expression(s).
    The following is an example which demonstrates how to match against an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the preceding program by saving this file in `PatternMatchingDemo1.scala`
    and then using the following commands to run it. Just use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The cases statements are used as a function that maps integers to strings.
    The following is another example which matches against different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this example by doing the same for the example earlier and will
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Pattern matching is a mechanism for checking a value against a pattern. A successful
    match can also deconstruct a value into its constituent parts. It is a more powerful
    version of the switch statement in Java, and it can likewise be used in place
    of a series of `if...else` statements. You can find more on pattern matching by
    referring to the official docs of Scala (URL: [http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html](http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss an important feature in Scala that enables
    us a value that can be passed automatically, so to speak, or a conversion from
    one type to another that is made automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implicit is another exciting and powerful feature introduced by Scala, and
    it can refer to two different things:'
  prefs: []
  type: TYPE_NORMAL
- en: A value that can be automatically passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic conversion from one type to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used for extending the capabilities of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actual automatic conversion can be accomplished with implicit def, as seen
    in the following example (supposing you are using the Scala REPL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, having the preceding code in my scope, it''s possible for me to do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Even if one of the parameters passed to `add()` is a `String` (and `add()` would
    require you to provide two integers), having the implicit conversion in scope
    allows the compiler to automatically convert from `String` to `Int`. Obviously
    enough, this feature could be quite dangerous, because it makes the code less
    readable; moreover, once an implicit conversion is defined, it's not easy to tell
    the compiler when to use it and when to avoid using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first type of implicit is a value that can automatically pass an implicit
    parameter. These parameters are passed while calling a method like any normal
    parameter, but Scala''s compiler tries to fill them automatically. If Scala''s
    compiler fails to automatically fill these parameters, it will complain. The following
    is an example to demonstrate the first type of implicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'By this, you are asking the compiler to look for an implicit value for `num`,
    if not provided during calling the method. You can define implicit value to the
    compiler like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can simply call the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, no parameter is passed, so Scala''s compiler will look for implicit value,
    which is `2`, and then return `4` as the output of the method calling. However,
    a lot of other options have evolved a questions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can a method contain both an explicit and an implicit parameter? The answer
    is YES. Let''s see an example on Scala REPL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Can a method contain more than one implicit parameter? The answer is YES. Let''s
    see an example on Scala REPL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Can an implicit parameter be explicitly provided? The answer is YES. Let''s
    see an example on Scala REPL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: What happens if more implicits are contained in the same scope and how are implicits
    resolved? Is there any order to how implicits are resolved? To get to know the
    answer to these two questions, refer to this URL at [http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala](http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss generics in Scala with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Generic in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic classes are classes which take a type as a parameter. They are particularly
    useful for collection classes. Generic classes can be used in everyday data structure
    implementation, such as stack, queue, linked list, and so on. We will see some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a generic class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generic classes take a type as a parameter within square brackets `[]`. One
    convention is to use the letter `A` as a type parameter identifier, though any
    parameter name may be used. Let''s see a minimal example on Scala REPL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation of a `Stack` class takes any type A as a parameter.
    This means the underlying list, `var elements: List[A] = Nil` can only store elements
    of type `A`. The procedure def push only accepts objects of type `A` (note: `elements
    = x :: elements` reassigns elements to a new list created by prepending `x` to
    the current elements). Let''s see an example of how to use the preceding class
    to implement a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The second use case could be implementing a linked list too. For instance,
    if Scala didn''t have a linked-list class and you wanted to write your own, you
    could write the basic functionality like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how could we use the preceding linked list implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In summary, at the basic level, creating a generic class in Scala is just like
    creating a generic class in Java, with the exception of the brackets. Well! So
    far we have gotten to know some essential features to get started with an object-oriented
    programming language, Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Although, we have not covered some other aspects, however, we still think that
    you can continue working. In [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, we discussed what the available editors for Scala are.
    In the next section, we will see how to set up your build environment. More specifically,
    three build systems, like Maven, SBT, and Gradle will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: SBT and other build systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's necessary to use a build tool for any enterprise software project. There
    are lots of build tools that you can choose from, such as Maven, Gradle, Ant,
    and SBT. A good choice of build tool is the one which will let you focus on coding
    rather than compilation complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Build with SBT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we are going to give a brief introduction to SBT. Before going any further,
    you need to install SBT using the installation method that fits your system from
    their official installations methods (URL: [http://www.scala-sbt.org/release/docs/Setup.html](http://www.scala-sbt.org/release/docs/Setup.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s begin with SBT to demonstrate the use of SBT in a terminal. For
    this build tool tutorial, we assume that your source code files are in a directory.
    You need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and change path to that directory by using `cd`,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a build file called `build.sbt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, populate that build file with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the meaning of these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` defines a name for your project. This name will be used in the generated
    jar files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `organization` is a namespace that's used to prevent collisions between
    projects that have similar names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scalaVersion` sets the version of Scala that you want to build against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Version` specifies the current build version of your project and you can use
    `-SNAPSHOT` for versions that have not been released yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating this build file, you need to `run` the `sbt` command in your
    terminal and then a prompt starting with `>` will be opened for you. In this prompt,
    you can type `compile` in order to compile your Scala or Java source files in
    your code. Also, you can enter the command in the SBT prompt in order to run the
    program if it's runnable. Or you can use the package command in SBT prompt in
    order to generate a `.jar` file, which will exist in a subdirectory called `target`.
    To read more about SBT and more sophisticated examples, you can refer to the official
    site of SBT.
  prefs: []
  type: TYPE_NORMAL
- en: Maven with Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Eclipse as Scala IDE with Maven as a build tool is very easy and straightforward.
    In this section, we will demonstrate with screenshots how to use Scala with Eclipse
    and Maven. To be able to use Maven in Eclipse, you need to install its plugin,
    which will be different across different versions of Eclipse. After installing
    the Maven plugin, you will find that it doesn't support Scala directly. What we
    need to do in order to get this Maven plugin to support Scala projects is to install
    a connector called **m2eclipse-scala**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you paste this URL ([http://alchim31.free.fr/m2e-scala/update-site](http://alchim31.free.fr/m2e-scala/update-site)
    ) while trying to add new software to Eclipse, you will find that Eclipse understands
    the URL and suggests some plugins for you to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)**Figure 4:** Installing Maven plugins on Eclipse to enable
    Maven build'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Maven and the connector for Scala support, we are going to
    create a new Scala Maven project. To create a new Scala Maven project, you need
    to navigate to New | Project | Other and then choose Maven Project. After this,
    select the option that has net.alchim31.maven as Group Id:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)**Figure 5:** Creating a Scala Maven project on Eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: After this selection, you need to follow the wizard and enter the required values,
    such as Group Id, and so on. Then, hit Finish and, with this, you have created
    your first Scala project with Maven support in the workspace. In the project structure,
    you will find something called `pom.xml` where you can add all your dependencies
    and other things.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how to add dependencies to your project, you can
    refer to this link at [http://docs.scala-lang.org/tutorials/scala-with-maven.html](http://docs.scala-lang.org/tutorials/scala-with-maven.html).
  prefs: []
  type: TYPE_NORMAL
- en: As a continuation of this section, we will show you how to build your Spark
    application written in Scala in the upcoming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle with Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gradle Inc. provides the Gradle tools and plugins for the Eclipse IDE. This
    tool allows you to create and import Gradle enabled projects into the Eclipse
    IDE. In addition, it allows you to run Gradle tasks and monitor the execution
    of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse project itself is called **Buildship**. The source code of this
    project is available on GitHub at [https://github.com/eclipse/Buildship](https://github.com/eclipse/Buildship).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options for installing Gradle plugins on Eclipse. These are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Via the Eclipse Marketplace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the Eclipse Update Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s see how to install Buildship plugins for Grade build on Eclipse
    using Marketplace: Eclipse | Help | Eclipse Marketplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.jpeg)**Figure 6:** Installing Buildship plugins for Grade build
    on Eclipse using Marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option for installing the Gradle plugins on Eclipse is from the
    Help | Install New Software... menu path to install the Gradle tooling as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)**Figure 7:** Installing Buildship plugins for Grade build
    on Eclipse using install new software'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following URL can be used for Eclipse 4.6 (Neon) release:
    [http://download.eclipse.org/releases/neon](http://download.eclipse.org/releases/neon).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed the Gradle plugins by following any one of the methods
    described earlier, Eclipse Gradle helps you to set up Scala based Gradle projects:
    File | New | Project | Select a wizard | Gradle | Gradle Project.'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/00196.jpeg)****Figure 8:** Creating a Gradle project on Eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you press Next>, you will get the following wizard to specify the name
    of the project for your purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/00198.jpeg)****Figure 9:** Creating a Gradle project on Eclipse specifying
    the project name'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, press the Finish button to create the project. Pressing the Finish
    button essentially triggers the Gradle `init --type java-library` command and
    imports the project. However, if you would like to get a preview of the configuration
    before the it is created, press Next > to get the following wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)**Figure 10:** Preview of the configuration before it is
    created'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will see the following project structure on Eclipse. However, we
    will see how to build Spark applications using Maven, SBT, and Gradle in a later
    chapter. The reason is that, before starting your project, it is more important
    to learn Scala and Spark together.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)**Figure 11:** The project structure on Eclipse using Gradle'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen three build systems, including SBT, Maven, and
    Gradle. However, throughout the chapters, I will try to mainly use Maven because
    of its simplicity and better code compatibility. However, in later chapters, we
    will use SBT to create JARS from your Spark application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structuring code in a sane way, with classes and traits, enhances the reusability
    of your code with generics, and creates a project with standard and widespread
    tools. Improve on the basics to know how Scala implements the OO paradigm to allow
    the building of modular software systems. In this chapter, we discussed the basic
    object-oriented features in Scala, such as classes and objects, packages and package
    objects, traits, and trait linearization, Java interoperability, pattern matching,
    implicit, and generics. Finally, we discussed SBT and other build systems that
    will be needed to build our Spark application on Eclipse or any other IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss what functional programming is and how
    Scala supports it. We will get to know why it matters and what the advantages
    of using functional concepts are. Continuing, you will learn pure functions, higher-order
    functions, Scala collections basics (map, flatMap, filter), for - comprehensions,
    monadic processing, and for extending higher-order functions outside of collections
    using the standard library of Scala.
  prefs: []
  type: TYPE_NORMAL
