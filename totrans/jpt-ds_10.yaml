- en: Optimizing Jupyter Notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before a Jupyter Notebook is developed you should confront optimizations that
    should occur before the public starts their access. Optimizations cover a gamut
    of options running from language-specific issues (use best practice R coding style)
    to deploying your notebook in a highly available environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Jupyter Notebook is a website. You could host a website on the computer that
    you are using to display this document. There may be a machine available in your
    department that is in use as a web server.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to deploy on a local machine you would have a single user website
    where additional users would be blocked from access or would collide with each
    other. The first step towards publishing your notebook involves using a hosting
    service that provides multiple user access.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to JupyterHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The predominant Jupyter hosting product currently is JupyterHub. To be clear,
    JupyterHub is installed into a machine under your control. It provides multi-user
    access to your notebooks. This means you could install JupyterHub on a machine
    in your environment and only internal users (multiple internal users) could access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: When JupyterHub starts it begins a hub or controlling agent. The hub will start
    an instance of a listener or proxy for Jupyter requests. When the proxy gets requests
    for Jupyter it turns them over to the hub. If the hub decides this is a new user
    it will generate a new instance of the Jupyter server and attach all further interactions
    between that user and Jupyter to their own version of the server. This feature
    provides multi-user access.
  prefs: []
  type: TYPE_NORMAL
- en: Installing JupyterHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JupyterHub requires Python 3.3 or better and we will use the Python tool `pip3`
    to install JupyterHub. The commands to install are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a JupyterHub Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now start JupyterHub directly from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the typical `jupyter notebook` that you have been using.
  prefs: []
  type: TYPE_NORMAL
- en: Again, as discussed, JupyterHub is the entry point for users accessing your
    notebooks. Under the covers it is instantiating Jupyter instances for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are slight differences with the user interface presented as well, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a6619ba-2d9b-4df8-8dc1-ca2391c2899b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the additional buttons on the top right of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Control Panel: For control of JupyterHub'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logout: Logout would be used with the SSL feature of JupyterHub to control
    access to your notebook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Control Panel gives two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop My Server: Stops JupyterHub from responding further. Useful if you need
    to upgrade some part of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My Server: Return to the JupyterHub home page (previous screenshot).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you start two browser instances on your desktop and access the notebook on
    JupyterHub you would be presented different information for each user as the user
    information is separately allocated to each user.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to share your notebook with a larger audience one of the better
    mechanisms is to use a public hosting service for presenting your notebook. This
    alleviates the need for some of the extensive security and availability requirements
    you would incur doing this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are an increasing number of (hosting) vendors that are providing Jupyter
    Notebook hosting as well. A couple of the major vendors are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rackspace**: Rackspace is particularly geared towards education notebooks
    where they provide special handling for clients running from the education sector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure**: The server hosting service by Microsoft—provides full notebook hosting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: One of the primary source repositories for programming artifacts,
    such as your notebook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A great feature of these hosting services is you no longer must install any
    libraries you are accessing from your notebook script. The hosting companies have
    already downloaded (and maintained and updated) all the libraries that you would
    normally use. GitHub does this maintenance. The others are pure web-hosting companies
    and expect you to install any necessary software needed.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are optimizations that you can make to have your notebook scripts run
    more efficiently. The optimizations are script language dependent. We have covered
    using Python and R scripts in our notebooks and will cover optimizations that
    can be made for those two languages.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter does support additional languages, such as Scala and Spark. The other
    languages have their own optimization tools and strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your Python scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Performance tuning your Python scripts can be done using several tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hotshot` profiling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining how long a script takes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `timeit` function in Python takes a line of code and determines how long
    it takes to execute. You can also repeatedly execute the same script to see if
    there are start-up issues that need to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: '`timeit` is used in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `repeat()` function is telling `timeit` to execute the timed instruction
    two times at 2,000,000 times each. The numbers displayed after the `repeat()`
    call are the three of the times taken as representative of the repeated calls.
  prefs: []
  type: TYPE_NORMAL
- en: You would normally use this to test out a complete function, not something that
    interacts with the user in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases where you need your script to evaluate a string of data,
    possibly entered by a user. Yes, you could do this by hand, but the Python regular
    expression processing is extremely efficient and catches all the edge cases that
    you may not be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python string handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are notoriously bad allocations of memory repeatedly as slight changes
    are made to the string. Furthermore, even small things such as capitalizing a
    letter in a larger string means a reallocation. Best off to process an entire
    string, such as capitalizing, in one step as we reduce the reallocation to one
    shot.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing loop operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when you develop a script that you place steps inside of
    a loop as it was convenient to do so when developed and probably did not make
    much difference to performance when running against smaller test data. For example,
    on any of the scripts in this book I would normally extract a small set of rows
    to work with. That would provide confidence that I am accessing the data correctly.
    However, I may have adjusted loop operations to have flagging operations occur.
    On a smaller dataset of 20 rows or so there is no big effect. However, when I
    start using the true dataset, which may have millions of rows, the setting of
    that flag continuously for every row would affect the overall performance of the
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: However, once you are working with larger data those minor operations that are
    occurring every time the loop executes become expensive. There are usually operations
    that can be pulled out of the loop and executed once outside of the loop. For
    example, if we were looking for the largest number in a loop we would initialize
    our result outside of the loop to an unrealistic value and inside the loop, if
    we see the unrealistic value we initialize the result with the first result. This
    test occurs on every loop operation. Instead we could set the result from the
    first record BEFORE entering the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling your script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hotshot profiler is available in Python to give a complete rundown of the
    execution of your script. Hotshot would have to be installed for you to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to view a summary of the profiler''s results use the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing your R scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'R also has tools available that will help pinpoint performance issues with
    your R coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '`microbenchmark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify a function used frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize name lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize data frame value extraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using microbenchmark to profile R script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`microbenchmark` is provided as part of an R library. Once included in your
    script you then surround the code in question with a `microbenchmark` tag and
    once executed the tool will output profiling information for the script in question.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could have this use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would exercise the surrounded code 125 times (100 by default) and output
    profiling information such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Where we are concerned with the mean as a good indication of how long each iteration
    is taking. We should also notice where there is a large divergence from the mean
    with very distant min and max values—which is what we have here.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying provided functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R allows you to change the behavior of most objects, including most well-known
    functions provided. An extreme example would be to rework how the `mean()` function
    works. Maybe you have insight into the exact nature of the data you are working
    with and can increase performance accordingly in your special case.
  prefs: []
  type: TYPE_NORMAL
- en: As with the preceding tool, you could exercise the provided functionality and
    then your implementation, and compare profile information provided by `microbenchmark`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing name lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R allows for dynamic naming of objects, so every time you access a variable
    R must look through a list of scopes to find where the object currently resides.
  prefs: []
  type: TYPE_NORMAL
- en: You may instead use a local cache mechanism to access your exact value directly
    circumventing R looking for a variable in all scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing data frame value extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With its variety of coding styles R allows you to access a particular value
    in a data frame in several manners. If your coding is accessing a large data frame
    frequently to extract singular values it is worthwhile to benchmark different
    alternatives to see which access method provides the most performance.
  prefs: []
  type: TYPE_NORMAL
- en: Changing R Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R is implemented by a handful of different companies. Each has its own performance
    spectrum. It may be worthwhile with severe cases to experiment with different
    R implementations to determine which works best for you. It may be difficult to
    change the R engine used by Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: Changing algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you program your notebook you have taken an approach to solving the
    problem. The approach is referred to as the *algorithm* used. Your algorithm may
    include looping over records or querying records inside of the database directly
    to obtain the records of interest. Many times, you will select an algorithm early
    in the process which appears to work adequately. There may be other algorithms
    which solve the problem in a much more efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: The largest boost to any programming implementation will come by changing the
    overall approach to handling. Unfortunately, this is the hardest change to accomplish
    as redesign and rewrite of your coding is required. And even then, like the other
    techniques, you need to compare benchmarks of your different approaches to make
    sure the new approach is better.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the earlier discussions in this chapter on optimization, you can also
    use programming tools to monitor the overall interactions of your notebook. The
    predominant tool for Linux/Mac environments is `memory_profiler`. If you start
    this tool then your notebook, the profiler will keep track of memory use of your
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: With this record of information points you may be able to adjust your programmatic
    memory allocation to be smaller in profile if you find a large memory use occurring.
    For example, the profiler may highlight that you are creating (and dropping) a
    large memory item continuously inside of a loop. When you go back to your coding
    you realize this memory access could be pulled out of the loop and just done once
    or that size of the allocation could be minimized easily.
  prefs: []
  type: TYPE_NORMAL
- en: Caching your notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is a common programming practice to speed up performance. If the computer
    does not have to reload a section of code or variable or file, but can just access
    directly from a cache this will improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: There is a mechanism to cache your notebook if you are deploying into a Docker
    space. Docker is a mechanism for virtualizing code over many instances in one
    machine. It has become common practice to do so in the Java programming world.
    Luckily, Docker is very flexible and a method has been determined to use Jupyter
    in Docker as well. Once in Docker, it is a minor adjustment to automatically cache
    your pages in Docker. The underlying tool used is `memcached`, yet another widespread
    common tool for caching anything, in this case Jupyter Notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: Securing a notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Securing a notebook can be accomplished by several methods such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing notebook content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing notebook authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A notebook can be secured to use username/password authorization. Authorization
    is on by default in your notebook. Under Jupyter it is token/password instead
    of username/password as a token is more open to interpretation. See Jupyter documentation
    on implementing authorization as this has changed slightly over time.
  prefs: []
  type: TYPE_NORMAL
- en: Securing notebook content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A notebook has possible security issues with several parts of standard content
    that are secured automatically by Jupyter:'
  prefs: []
  type: TYPE_NORMAL
- en: Untrusted HTML is sanitized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Untrusted JavaScript is not executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML and JavaScript in markdown cells is not trusted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notebook output is not trusted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other HTML or JavaScript in the notebook is not trusted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Where trust comes down to the question: Did the user do this or did the Jupyter
    script? Untrusted means it will not be generated.'
  prefs: []
  type: TYPE_NORMAL
- en: Sanitized code is wrapped to force the values to be text display only—no executed
    code will be generated. For example, if your notebook cell were to produce HTML,
    such as an additional `H1` header tag, Jupyter would sanitize the output such
    that the raw HTML, in this case something like `<H1&gt;Additional Heading</H1&gt;` would
    produce the raw HTML with the `H1` tags rather than the desired effect of an HTML
    heading appearing on your page.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Jupyter Notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaling is the process of providing very large numbers of concurrent users to
    a notebook without a degradation in performance. The one vendor that is doing
    this today is Azure. They have thousands of pages and users working at scale daily.
  prefs: []
  type: TYPE_NORMAL
- en: Most amazingly this is a **free** service.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Jupyter Notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jupyter Notebooks can be shared by placing the notebook on a server (there are
    several kinds) or converting the notebook to another format (it will not be interactive,
    but the content will be available).
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Jupyter Notebook on a notebook server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Built into the notebook configuration are extensions that can be used to expose
    a notebook server, directly. The notebook configuration can be generated using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the resulting `jupyter_notebook_config.py` file there are settings that
    can be used to set:'
  prefs: []
  type: TYPE_NORMAL
- en: IP/port address of your notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption certificate location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By setting this and starting Jupyter you should be able to access the notebook
    at the IP address specified from other machines in your network.
  prefs: []
  type: TYPE_NORMAL
- en: You should work with your network security personnel before doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing encrypted Jupyter Notebook on a notebook server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you specify the certificate information correctly in the previous configuration
    file the notebook will only be accessible over HTTPS or a secure, encrypted channel.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing notebook on a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another part of the configuration file is the `tornado_settings`. This set of
    settings describes the web server that will channel web traffic to your notebook.
    Again, once these settings are in place you can access your notebook through the
    web server-using the web servers IP address.
  prefs: []
  type: TYPE_NORMAL
- en: This might be useful to present notebook access as part of your existing website.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing notebook on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a framework that provides for hosting instances of software based
    on a small configuration file, the `Dockerfile`. Docker allows for multiple instances
    of software to be instantiated automatically as needed. So, we would have multiple
    instances of our notebook available to users. Users would not be able to distinguish
    the multiple instances as they just reference the one notebook. Docker redirects
    user traffic to one or the other instances based on initial connection to the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The `Dockerfile` has the environment settings that tell the Docker system what
    system components need to be present in an instance in order for the referenced
    object, in this case a notebook, can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also share a notebook with others by converting the notebook to a readable
    form for recipients. Notebooks can be converted to a number of formats using the
    Download As feature in the notebook File menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notebooks can be converted in this way to the formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<language&gt; format**: This option is dependent on the language used to
    create the notebook. For example, an R notebook would have the choice to Download
    as R script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTML: This representation is the HTML encoding to display the page as it appears
    in your notebook using HTML constructs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markdown: Markdown is a simple display tag format used by some older Linux
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'reST: Another markdown type of format that has simpler display constructs than
    HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning a notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common practice in the programming world is to maintain a history of the changes
    made to a program. Over time the different versions of the program are maintained
    in a software repository where the programmer can retrieve prior versions to return
    to an older, working state of their program.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section we mentioned placing your notebook on GitHub. Git is
    a software repository in wide use. GitHub is an internet-based instance of Git.
    Once you have any software in Git it will automatically be versioned. The next
    time you update your notebook in GitHub. Git will take the current instance, store
    it as a version in your history, and place the new instance as the current—where
    anyone accessing your GitHub repository will see the latest version by default.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we deployed our notebook to a set of different environments.
    We looked into optimizations that can be made to our notebook scripts. We learned
    about different ways to share our notebook. Lastly, we looked into converting
    our notebook for users without access to Jupyter.
  prefs: []
  type: TYPE_NORMAL
