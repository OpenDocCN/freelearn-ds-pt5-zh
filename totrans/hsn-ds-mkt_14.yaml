- en: Data-Driven Customer Segmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In marketing, we often try to understand the behavior of certain subgroups of
    the customer base. Especially in targeted marketing, marketers try to segment
    the customer base in certain ways and focus on each target segment or customer
    group. This concentration on certain target customer segments results in better
    performance, as the needs and interests of those customers in the target group
    align and match better with the business's products, services, or content.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to dive deeper into the concept of customer segmentation.
    We will discuss what customer segmentation is, the importance and benefits of
    having a good understanding of different segments of the customer base, and how
    to utilize customer segment analysis results for different marketing strategies.
    Aside from a more traditional way of segmenting the customer base, which involves
    looking at the key statistics of certain attributes of customers and manually
    cutting the customer base into segments, we can also use machine learning to have
    machines find the best ways to split the customer base into the desired number
    of segments. In this chapter, we will learn how we can use the k-means clustering
    algorithm to build customer segments based on the historical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer segmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmenting customers with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmenting customers with R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer segmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given today's competition within the market, it is critical to understand the
    different behaviors, types, and interests of customers. Especially in targeted
    marketing, understanding and categorizing customers is an essential step in forming
    effective marketing strategies. By segmenting the customer base, marketers can
    focus on one segment of customers at a time. It also helps marketers to tailor
    their marketing messages to one specific audience at a time. Customer segmentation
    is the backbone of successful targeted marketing, with which you can target specific
    groups of customers with different pricing options, promotions, and product placements
    that capture the interests of the target audience in the most cost-effective way.
  prefs: []
  type: TYPE_NORMAL
- en: Any business or industry can benefit from a better understanding of different
    customer segments. For example, television advertisements that are broadcast across
    all over the USA for an outerwear brand that sells winter clothes, such as parkas,
    snow boots, and hats, would not be so cost-effective. People residing in areas
    that never really get cold, such as Florida, Southern California, or Hawaii, would
    most likely not be interested in purchasing winter clothes. However, people residing
    in areas with cold winters, such as Alaska, Minnesota, or North Dakota, would
    most likely want to buy clothes that will keep them warm. So, for this outerwear
    brand, instead of sending out marketing mails or emails to all of their customers,
    it would be better to target those segments of customers, based on their geographic
    information, that live in places where they would need winter clothes more frequently
    than other customers.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, if you own a rental building near a college, you might want
    to target your customers based on their age and education. Marketing to customers
    between 20 and 30 and who are attending surrounding colleges will have higher
    return than marketing to others. For hotel businesses, you might want to target
    those couples who have upcoming anniversaries for romantic package deals. Using
    social media platforms, such as Facebook or Instagram, you can target this segment
    of customers.
  prefs: []
  type: TYPE_NORMAL
- en: As we briefly discussed with these three cases, understanding your customers
    and which segment describes them the best can help you develop effective and efficient
    marketing strategies. When segmenting the customer base into subgroups, you can
    use certain characteristics and their statistics, as shown in [Chapter 7](72e8f4ee-7f95-4acc-928d-d33c9fc31bd6.xhtml),
    *Exploratory Analysis for Customer Behavior*. However, when you are trying to
    segment your customers with multiple attributes, it becomes exponentially more
    difficult. In the following sections, we are going to discuss how we can use machine
    learning for customer segmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Clustering algorithms** are frequently used in marketing for customer segmentation.
    This is a method of unsupervised learning that learns the commonalities between
    groups from data. Unlike supervised learning, where there is a target and a labeled
    variable that you would like to predict, unsupervised learning learns from data
    without any target or labeled variable. Among numerous other clustering algorithms,
    we are going to explore the usage of the k-means clustering algorithm in this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The k-means clustering algorithm splits the records in the data into a pre-defined
    number of clusters, where the data points within each cluster are close to each
    other. In order to group similar records together, the k-means clustering algorithm
    tries to find the centroids, which are the centers or means of clusters, to minimize
    the distances between the data points and the centroids within the clusters. The
    objective equation (from [https://scikit-learn.org/stable/modules/clustering.html#k-means](https://scikit-learn.org/stable/modules/clustering.html#k-means))
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2785420-51f0-409c-80cd-28663ce10950.png)'
  prefs: []
  type: TYPE_IMG
- en: Here *n* is the number of records in the dataset, *x[i]* is the *i*th data point,
    *C* is the number of clusters, and *µ[j]* is the *j*th centroid.
  prefs: []
  type: TYPE_NORMAL
- en: 'One downside or difficulty of using k-means clustering for customer segmentation
    is the fact that you need to know the number of clusters beforehand. However,
    quite often, you do not know what is the optimal number of clusters to create.
    The silhouette coefficient can be used to evaluate and help you make decisions
    on what the best number of clusters will be for your segmentation problem. Simply
    put, the silhouette coefficient measures how close the data points are to their
    clusters compared to other clusters. The equation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58a5fb9b-0539-4e54-ad29-baa5fc082d4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Here `b` is the average of the distance between a point and its closest cluster
    and `a` is the average distance among data points within the same cluster. The
    silhouette coefficient value ranges from -1 to 1, where the closer the values
    are to 1, the better they are. In the following programming exercises, we will
    be segmenting the customer base from our dataset, using the k-means clustering
    algorithm and the silhouette coefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Segmenting customers with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss how to segment the customer base into
    subgroups using the clustering algorithm in Python. By the end of this section,
    we will have built a customer segmentation model using the k-means clustering
    algorithm. We will be mainly using the `pandas`, `matplotlib`, and `scikit-learn` packages
    to analyze, visualize, and build machine learning models. For those readers, who
    would like to use R, instead of Python, for this exercise, you can skip to the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail).
    You can follow this link and download the data, which is available in XLSX format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your Jupyter Notebook by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame, `df`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5468769-a05c-42eb-b78b-b31ed60dd46d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can notice, we have used this dataset a few times in the previous chapters. As
    you might recall from previous chapters, there are a few things we need to clean
    up before we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Data cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start building clustering models, there are five tasks we need
    to do to clean up our data and prepare it for modeling. The clean-up steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dropping canceled orders**: We are going to drop records with negative `Quantity`,
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Dropping records with no `CustomerID`**: There are `133,361` records with
    no `CustomerID` and we are going to drop those records with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Excluding an incomplete month**: As you might recall from previous chapters,
    the data in the month of December, 2011, is incomplete. You can exclude this data
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Computing total sales from** **the Quantity and UnitPrice columns**: For
    our analyses, we need the total sales value, so we are going to multiply the two
    `Quantity` and `UnitPrice` columns, to get the total sales, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Per-customer data**: In order to analyze customer segments, we need to transform
    our data, so that each record represents the purchase history of individual customers.
    Take a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are grouping the `DataFrame`, `df`, by `CustomerID`
    and computing the total sales and the number of orders for each customer. Then,
    we also calculate the average per-order value, `AvgOrderValue`, by dividing the
    `TotalSales` column by the `OrderCount` column. The result is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e9bfddd-62e5-43d9-814c-bcb7fbc4e241.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, as you can see from this data, the three columns, `TotalSales`, `OrderCount`,
    and `AvgOrderValue`, have different scales. `TotalSales` can take any values from
    `0` to `26,848`, while `OrderCount` takes values between `1` and `201`. Clustering
    algorithms are highly affected by the scales of the data, so we need to normalize
    this data to be on the same scale. We are going to take two steps to normalize
    this data. First, we are going to rank the data, so that the values of each column
    range from `1` to `4298`, which is the total number of records. Take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/126f7dc1-1f1c-424d-81f5-686b2e44d060.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are going to normalize this data to center around the mean and have
    a mean of `0` and a standard deviation of `1`. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bad843b-fbd9-471d-b4e5-fc43a62e6cd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the statistics of each of these columns, shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c17e2528-0809-43b9-bf02-5adf9dfeddf4.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the values are centered around at `0` and have a standard deviation
    of `1`. We are going to use this data for the following clustering analyses.
  prefs: []
  type: TYPE_NORMAL
- en: k-means clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **k-means clustering** algorithm is a frequently used algorithm for drawing
    insights into the formations and separations within data. In marketing, it is
    often used to build customer segments and understand the behaviors of these different
    segments. Let's dive into building clustering models in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the k-means clustering algorithm in the `scikit-learn` package,
    we need to import the `kmeans` module, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can build and fit a k-means clustering model, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are building a clustering model that splits
    the data into four segments. You can change the desired number of clusters with
    the `n_clusters` parameter. Using the `fit` function, you can train a k-means
    clustering algorithm to learn to split the given data. In this code, we are building
    four clusters, based on the `TotalSales`, `OrderCount`, and `AvgOrderValue` values.
    The trained model object, `kmeans`, stores the labels and centers of the clusters
    in the `labels_` and `cluster_centers_` attributes of the model object. You can
    retrieve these values as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have built our first clustering model, let''s visualize this data.
    First, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the cluster label information for each record into a newly created
    DataFrame, `four_cluster_df`. With this `DataFrame`, we can visualize the clusters,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are visualizing the data using scatter plots.
    The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf3a60cb-0e8e-416d-bf46-ce464c85d530.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at this plot. The cluster in blue is the group of
    low-value customers, who have not purchased our products so much. On the other
    hand, the cluster in red is the group of high-value customers, who have purchased
    the greatest amount and who have purchased products frequently. We can also visualize
    the clusters with different angles, using the rest of the variables. Take a look
    at the following plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d93eb9d-2344-4996-96e4-05b1163a2fbc.png) ![](img/ff0c9ce9-0012-4d72-8afe-a43c0407c603.png)'
  prefs: []
  type: TYPE_IMG
- en: The first plot shows the clusters visualized based on `AvgOrderValue` and `OrderCount`.
    On the other hand, the second plot shows the clusters visualized based on `AvgOrderValue` and
    `TotalSales`. As you can see from these plots, the cluster in blue has the lowest
    average per-order value and the lowest number of orders. However, the cluster
    in red has the highest average per-order value and the greatest number of orders.
    Visualizing clusters helps you understand the characteristics of different clusters
    much more easily and clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the best number of clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we do not know what the best number of clusters to use is when building
    k-means clustering models. As discussed in an earlier section of this chapter,
    we can use the silhouette coefficient to determine what the best number of clusters
    is to split the data. In the `scikit-learn` package, you can use the `silhouette_score`
    function in the `sklearn.metrics` module to calculate the silhouette score and
    measure the quality of clusters. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are experimenting with five different numbers
    of clusters: `4`, `5`, `6`, `7`, and `8`. For each amount of clusters, we are
    going to measure the silhouette score and choose the amount of clusters with the
    highest score. The output of this code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/120a5ca4-f783-4157-bd15-5ed4d103c34d.png)'
  prefs: []
  type: TYPE_IMG
- en: In our case, of the five different numbers of clusters we have experimented
    with, the best number of clusters with the highest silhouette score was `4`. In
    the following section, we will use `4` as the number of clusters to show how we
    can interpret the results of the clustering analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting customer segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to discuss different ways to draw insights from
    the results of the previous clustering analysis. Let''s first build a k-means
    clustering model with four clusters. You can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are fitting a k-means clustering model with
    `4` clusters, based on three attributes: `TotalSales`, `OrderCount`, and `AvgOrderValue`.
    Then, we store the cluster label information into a DataFrame, `four_cluster_df`.
    This DataFrame is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85420d12-e0cf-4985-a6e9-28b16c9bc6ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we are going to look at is the centers of each cluster. You
    can get the cluster centers using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63a9df3e-69eb-49e5-88e4-2a1505d6a11b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a closer look at this. The fourth cluster has the lowest numbers
    for all three attributes. This suggests that the fourth cluster contains customers
    with the smallest amount of sales, smallest number of orders, and lowest average
    per-order value. This group of customers is one of low-value customers. On the
    other hand, the third cluster has the highest numbers for all three attributes.
    The customers in the third cluster have the greatest amount of sales, greatest
    number of orders, and highest average per-order value. So, these customers in
    the third cluster purchase expensive items and give the business the highest revenue.
    You would typically want to focus your marketing efforts on this segment of customers,
    as it will result in the highest return.
  prefs: []
  type: TYPE_NORMAL
- en: The customers in the second cluster are interesting. They make purchases relatively
    frequently, as they have a medium-to-high cluster center value for `OrderCount`,
    but their average per-order value is low, as the cluster center for `AvgOrderValue`
    is low. These are the customers who make frequent purchases of low-value items.
    So, it would be perfect to market items with low per-item prices to this segment
    of customers. The customers in the first cluster are also interesting. Their contributions
    to the revenue and number of orders are medium to low, looking at the centers
    of this cluster. However, their average per-order value is high. These are the
    customers who buy expensive items infrequently. Thus, it would be perfect to market
    expensive items to this segment of customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from this example, looking at the centers of clusters helps
    us understand different types and segments of customers and how to target them
    differently. Lastly, we can also find out what the best-selling items are for
    each customer segment. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen before, the third cluster was the group of high-value customers,
    and we are going to take a look at the top five best-selling items for this group.
    The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6ce561c-d6b2-4ae2-a2b3-cabc1c3b3d8d.png)'
  prefs: []
  type: TYPE_IMG
- en: For this high-value segment, the best-selling item was `JUMBO BAG RED RETROSPOT`
    and the second best-selling item was `REGENCY CAKESTAND 3 TIER`. You can utilize
    this information in marketing strategies, when you target this customer segment.
    In your marketing campaigns, you can recommend items similar to these best-selling
    items to this segment of customers, as they are the most interested in these types
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full code for this exercise in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/python/CustomerSegmentation.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/python/CustomerSegmentation.ipynb).'
  prefs: []
  type: TYPE_NORMAL
- en: Segmenting customers with R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss how to segment the customer base into
    subgroups using a clustering algorithm in R. By the end of this section, we will
    have built a customer segmentation model using the k-means clustering algorithm. For
    those readers who would like to use Python, instead of R, for this exercise, see
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we will be using one of the publicly available datasets
    from the UCI Machine Learning Repository, which can be found at this link: [http://archive.ics.uci.edu/ml/datasets/online+retail](http://archive.ics.uci.edu/ml/datasets/online+retail).
    You can follow this link and download the data, which is available in XLSX format,
    named `Online Retail.xlsx`. Once you have downloaded this data, you can load it
    into your RStudio by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame, `df`, is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b038be6-75b9-4d33-881a-81dac9d8e3fd.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may have noticed, we have used this dataset a few times in the previous
    chapters. As you might recall from previous chapters, there are a few things we
    need to clean up before we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Data cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start building clustering models, there are five tasks we need
    to do to clean up our data and prepare it for modeling. The clean-up steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dropping canceled orders**: We are going to drop records with negative `Quantity`,
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Dropping records with no CustomerID**: There are `133,361` records with no `CustomerID` and
    we are going to drop those records with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Excluding an incomplete month**: As you might recall from previous chapters,
    the data in the month of December, 2011, is incomplete. You can exclude this data
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Computing total sales from the Quantity and UnitPrice columns**: For our
    analyses, we need the total sales value, so we are going to multiply the `Quantity` and `UnitPrice`
    columns, to get the total sales, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Per-customer data**: In order to analyze customer segments, we need to transform
    our data, so that each record represents the purchase history of individual customers.
    Take a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are grouping the DataFrame, `df`, by `CustomerID` and
    computing the total sales and the number of orders for each customer. Then, we
    also calculate the average per-order value, `AvgOrderValue`, by dividing the `TotalSales` column
    by the `OrderCount` column. The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0592e46-d55e-4294-836c-d066aa92a56f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, as you can see from this data, the `TotalSales`, `OrderCount`, and `AvgOrderValue`
    columns, have different scales. `TotalSales` can take any values from `0` to `26,848`,
    while `OrderCount` takes values between `1` and `201`. Clustering algorithms are
    highly affected by the scales of the data, so we need to normalize this data to
    be on the same scale. We are going to take two steps to normalize this data. First,
    we are going to rank the data, so that the values of each column range from `1` to `4298`,
    which is the total number of records. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1420338-a64d-4835-8315-fd540e09fc3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are going to normalize this data to center around the mean, and have
    a mean of `0` and a standard deviation of `1`, using the `scale` function in R.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc0d9282-7791-4d3d-8532-6e2feafde93f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the statistics of each of these columns, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3565018b-68bc-439f-81a1-793ea6211417.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the values are centered around at `0` and have a standard deviation
    of `1`. We are going to use this data for the following clustering analyses.
  prefs: []
  type: TYPE_NORMAL
- en: k-means clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **k-means clustering** algorithm is a frequently used algorithm to draw
    insights on the formations and separations within the data. In marketing, it is
    often used to build customer segments and understand the behaviors of these different
    segments. Let's dive into building clustering models in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build and fit a k-means clustering model using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are building a clustering model that splits
    the data into `4` segments. The first parameter of the `kmeans` function is for
    the data to be used for k-means clustering and the second parameter is to define
    the desired number of clusters. In this code, we are building `4` clusters, based
    on the `TotalSales`, `OrderCount`, and `AvgOrderValue` values. The trained k-means
    clustering model object, `cluster`, stores the labels and centers of the clusters
    in the `cluster` and `centers` variables of the model object. You can retrieve
    these values, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have built our first clustering model, let''s visualize this data.
    First, we are going to store the cluster labels as a separate column, named `Cluster`,
    in the `normalizedDF` variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can visualize the clusters, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are visualizing the data using scatterplots.
    The result in shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f0fa682-ec51-4a5b-8927-49e536fa1566.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at this plot. The cluster in the bottom left is the
    group of low-value customers, who have not purchased our products so much. On
    the other hand, the cluster in the top right with the darkest color is the group
    of high-value customers, who have purchased the greatest amount and who have purchased
    products frequently. We can also visualize the clusters with different angles,
    using the rest of the variables. Take a look at the following plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6be6df8c-46c0-4f9f-a21a-501922c395ce.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/b59c48f0-4142-4a5a-b1c3-3525d90911d4.png)'
  prefs: []
  type: TYPE_IMG
- en: The first plot shows the clusters visualized based on `AvgOrderValue` and `OrderCount`.
    On the other hand, the second plot the clusters visualized based on `AvgOrderValue` and `TotalSales`.
    As you can see from these plots, the cluster in the bottom left with the second-lightest
    color has the lowest average per-order value and the lowest number of orders.
    However, the cluster in the top right with the darkest color has the highest average
    per-order value and the greatest number of orders. Visualizing clusters helps
    you understand the characteristics of different clusters much more easily and
    clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the best number of clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often, we do not know what the best number of clusters to use is when
    building k-means clustering models. As discussed in an earlier section of this
    chapter, we can use the silhouette coefficient to determine what the best number
    of clusters is to split the data. In R, you can use the `silhouette` function
    in the `cluster` library to calculate the silhouette score and measure the quality
    of clusters. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are experimenting with five different number
    of clusters: `4`, `5`, `6`, `7`, and `8`. For each number of clusters, we are
    going to measure the silhouette score and choose the number of clusters with the
    highest score. The output of this code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71fd5298-4fb1-4576-846a-81667a4b383f.png)'
  prefs: []
  type: TYPE_IMG
- en: In our case, of the five different numbers of clusters we have experimented
    with, the best number of clusters with the highest silhouette score was `4`. In
    the following section, we will use `4` for the number of clusters to show how
    we can interpret the results of clustering analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting customer segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to discuss different ways to draw insights from
    the results of the previous clustering analysis. Let''s first build a k-means
    clustering model with `4` clusters. You can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are fitting a k-means clustering model with `4` clusters,
    based on the three attributes: `TotalSales`, `OrderCount`, and `AvgOrderValue`.
    Then, we store the cluster label information into a DataFrame, `normalizedDF`.
    This DataFrame is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcc5181c-f58a-4f37-a201-47af60d942af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we are going to look at is the centers of each cluster. You
    can get the cluster centers using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8870c2db-382e-497c-af61-322637e57e57.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a closer look at this. The third cluster has the lowest numbers for
    all three attributes. This suggests that the third cluster contains customers
    with the lowest amount of sales, lowest number of orders, and lowest average per-order
    value. This group of customers is a group of low-value customers. On the other
    hand, the fourth cluster has the highest numbers for all three attributes. The
    customers in the fourth cluster have the highest amount of sales, highest number
    of orders, and highest average per-order value. This suggests that these customers
    in the fourth cluster purchase expensive items and give the business the highest
    revenue. You would typically want to focus your marketing efforts on this segment
    of customers, as it will result in the highest return.
  prefs: []
  type: TYPE_NORMAL
- en: The customers in the first cluster are interesting. They make purchases relatively
    frequently, as they have a medium to high cluster center value for `OrderCount`,
    but their average per-order value is low, as the cluster center for `AvgOrderValue` is
    low. These are the type of customers who make frequent purchases of low-value
    items. So, it would be perfect to market items with low per-item prices to this
    segment of customers. The customers in the second cluster are also interesting.
    Their contributions to the revenue and number of orders are low, looking at the
    centers of this cluster. However, their average per-order value is high. These
    are the type of customers who buy expensive items infrequently. Thus, it would
    be perfect to market expensive items to this segment of customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from this example, looking at the centers of clusters helps
    us understand different types and segments of customers and how to target them
    differently. Lastly, we can also find out what the best-selling items are for
    each customer segment. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen before, the fourth cluster was the group of high-value customers
    and we are going to take a look at the best-selling items for this group. The
    output of this code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd6cdcfe-9b9e-44af-997a-f5e24b82267b.png)'
  prefs: []
  type: TYPE_IMG
- en: For this high-value segment, the best-selling item was **JUMBO BAG RED RETROSPOT **and
    the second best-selling item was **REGENCY CAKESTAND 3 TIER**. You can utilize
    this information in the marketing strategies, when you target this customer segment.
    In your marketing campaigns, you can recommend items similar to these best-selling
    items to this segment of customers, as they are the most interested in these types
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full code for this exercise in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/R/CustomerSegmentation.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.10/R/CustomerSegmentation.R).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned more about customer segmentation. We worked
    through three simple scenarios of how customer segmentation could help different
    businesses to form better and more cost-effective marketing strategies. We have
    discussed how having a good understanding of different customer segments, how
    customers in different segments behave, and what they need and are interested
    in can help you target your audience better. We have also learned about the k-means
    clustering algorithm, which is one of the most frequently used clustering algorithms
    for customer segmentation. In order to evaluate the quality of clusters, we have
    shown how we can use the silhouette coefficient.
  prefs: []
  type: TYPE_NORMAL
- en: During programming exercises, we have experimented with how we can build a k-means
    clustering model in Python and R. In Python, we could use the `KMeans` module
    in the `scikit-learn` package and in R, we could use the `kmeans` function to
    build clustering models. Using the `silhouette_score` function in Python and the `silhouette`
    function in R, we have seen how we could use silhouette coefficients to evaluate
    the qualities of clusters and have seen how looking at silhouette scores can help
    us determine the best number of clusters. Lastly, we have discussed how to interpret
    clustering analysis results, using scatter plots and cluster centroids, and we
    have seen how to find out the best-selling items for each customer segment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss customers at risk of churn and
    how to retain those customers. We will work together to build neural network models
    in Python and R, using the `keras` package, to identify those customers who are
    likely to churn.
  prefs: []
  type: TYPE_NORMAL
