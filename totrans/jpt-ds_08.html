<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Statistical Modeling</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">In this chapter we are taking raw data and attempting to interpret the information by building a statistical model. Once we have a model built then it <span class="calibre8">is </span>usually easier to see commonalities. We can determine trends as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Converting JSON to CSV</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">For this chapter, we will be using the Yelp data available from the challenge at <a href="https://www.yelp.com/dataset/challenge" class="pcalibre pcalibre3 pcalibre2 pcalibre1 calibre9">https://www.yelp.com/dataset/challenge</a>. This section uses the dataset from <em class="calibre18">round 9</em> of the challenge. For background, Yelp is a site for rating different products and services where Yelp publishes the ratings to users.</p>
<p class="calibre5">The dataset file is a very large (a few gigabytes) amount of ratings. There are several sets of rating information in the download-for business ratings, reviews, tips (as in this would be a nice place to visit), and a user set. We are interested in the review data.</p>
<p class="calibre5">When dealing with such large files it may be useful to find and use a large file editor so you can poke into the data file. On Windows, most of the standard editors are limited to a few megabytes. I used the Large Text File Viewer program to open these JSON files.</p>
<p class="calibre5">All of the files are in JSON format. JSON is a human readable format with structured elements—for example, a city object containing street objects. While it is convenient to read JSON the format is clumsy when dealing with large numbers of elements. In the <kbd class="calibre21">reviews</kbd> file there are a few million rows. So, we first convert the JSON to a flat CSV format to allow for easier processing using this script:</p>
<pre class="commandlinepackt"><strong class="calibre3">import time<br class="calibre2"/></strong><strong class="calibre3">import datetime<br class="calibre2"/></strong><strong class="calibre3">import json, csv<br class="calibre2"/></strong><strong class="calibre3">print( datetime.datetime.now().time())<br class="calibre2"/></strong><strong class="calibre3">headers = True<br class="calibre2"/></strong><strong class="calibre3">#with open('c:/Users/Dan/reviews.json') as jsonf, open('c:/Users/Dan/reviews.csv', "wb") as csvf:<br class="calibre2"/></strong><strong class="calibre3">filein = 'c:/Users/Dan/yelp_academic_dataset_review.json'<br class="calibre2"/></strong><strong class="calibre3">fileout = 'c:/Users/Dan/yelp_academic_dataset_review.csv'<br class="calibre2"/></strong><strong class="calibre3">with open(filein) as jsonf, open(fileout, "wb") as csvf:<br class="calibre2"/></strong><strong class="calibre3">    for line in jsonf:<br class="calibre2"/></strong><strong class="calibre3">        data = json.loads(line) <br class="calibre2"/></strong><strong class="calibre3">        #remove the review text<br class="calibre2"/></strong><strong class="calibre3">        data.pop('text')<br class="calibre2"/></strong><strong class="calibre3">        if headers:<br class="calibre2"/></strong><strong class="calibre3">            w = csv.DictWriter(csvf, data.keys())<br class="calibre2"/></strong><strong class="calibre3">            w.writeheader()<br class="calibre2"/></strong><strong class="calibre3">            headers = False<br class="calibre2"/></strong><strong class="calibre3">        w.writerow(data)       <br class="calibre2"/></strong><strong class="calibre3">   <br class="calibre2"/></strong><strong class="calibre3">print( datetime.datetime.now().time())</strong></pre>
<p class="calibre5">I am printing out the start and end times to get an idea of how long this takes. For my machine it took 1.5 minutes to convert the file. I had tried several versions of this code before I got the preceding code working at a satisfactory pace. While developing this script I took a small subset of the original data file (2000 rows) and worked with that file until things progressed sufficiently.</p>
<p class="calibre5">As you can see, I am reading the raw JSON file as provided from Yelp and writing out a corresponding CSV file.</p>
<p class="calibre5">The script reads each line of the JSON (one line contains an entire object) and writes out the corresponding CSV. I stripped out the review text as I was not evaluating the text of reviews and the review text took a lot of space. The review file size dropped from 3 gigabytes to 300 megabytes using this coding. Other than that we made sure to write the headers out to the CSV as the first record. I then used a separate script/notebook entry to read in the CSV and process it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Evaluating Yelp reviews</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">We read in the processed Yelp reviews using this script and print out some statistics of the data:</p>
<pre class="commandlinepackt"><strong class="calibre3">reviews &lt;- read.csv("c:/Users/Dan/yelp_academic_dataset_review.csv")</strong> </pre>
<p class="calibre5">I usually take a look at some of the data once loaded to visually check that things are working as expected. We can do this with a <kbd class="calibre21">head()</kbd> function call:</p>
<pre class="commandlinepackt"><strong class="calibre3">head(reviews)</strong></pre>
<div class="packt_figure"><img class="image-border134" src="Images/09cb5819-0baa-4030-a0a9-0dd5f1c0b7b7.png"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary data</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">All of the columns appear to be correctly loading. Now, we can look at summary statistics for the data:</p>
<pre class="commandlinepackt"><strong class="calibre3">summary(reviews)</strong>  </pre>
<div class="packt_figure"><img class="image-border135" src="Images/6c4b4dcb-c158-443d-9ecf-284c2a8e23b8.png"/></div>
<p class="calibre5">There are several points in the summary worth noting:</p>
<ul class="calibre19">
<li class="calibre20">Some of the data points I had assumed would be just <kbd class="calibre21">TRUE</kbd>/<kbd class="calibre21">FALSE</kbd>, <kbd class="calibre21">0</kbd>/<kbd class="calibre21">1</kbd> have ranges instead; for example, <kbd class="calibre21">funny</kbd> has a max value over 600; <kbd class="calibre21">useful</kbd> has a max 1100, <kbd class="calibre21">cool</kbd> has 500.</li>
<li class="calibre20">All of the IDs (users, businesses) have been mangled. We could use the user file and the business file to come up with exact references.</li>
<li class="calibre20">Star ratings are <kbd class="calibre21">1</kbd>-<kbd class="calibre21">5</kbd>, as expected. However, the mean and median are about a <kbd class="calibre21">4</kbd>, which I take as many people only take the time to write good reviews.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Review spread</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">We can get an idea of the spread of the reviews using a simple histogram using:</p>
<pre class="commandlinepackt"><strong class="calibre3">hist(reviews$stars)</strong>  </pre>
<p class="calibre5">Which generates the histogram inline as:</p>
<div class="packt_figure"><img class="image-border136" src="Images/8debff02-3663-4852-bc33-364dfdb5d145.png"/></div>
<p class="calibre5">Again, we see the predilection for only making positive reviews (but the number of bad reviews is pretty large).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Finding the top rated firms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">We can find the businesses with the most top ratings (5's) using the following script. This script uses SQL-like access to data frames. SQL has built-in mechanisms for searching and selecting and ordering of the data components as needed.</p>
<p class="calibre5">In this script we are building a computed data frame with two columns: <kbd class="calibre21">business_id</kbd> and review <kbd class="calibre21">count</kbd>. The data frame is ordered with the top rated firms appearing first. Once created, we display the head of the data frame to get at the top rated businesses in the dataset:</p>
<pre class="commandlinepackt"><strong class="calibre3">#businesses with most 5 star ratings</strong>
<strong class="calibre3">#install.packages("sqldf", repos='http://cran.us.r-project.org')</strong>
<strong class="calibre3">library(sqldf)</strong>
<strong class="calibre3">five_stars = sqldf("select business_id, count(*) from reviews where stars = 5 group by business_id order by 2 desc")</strong>
<strong class="calibre3">head(five_stars)</strong>  </pre>
<div class="packt_figure"><img class="image-border137" src="Images/013b833a-9e6e-48e5-9c9f-e7476e9ed6a5.png"/></div>
<p class="calibre5">It is remarkable that the top five businesses had such a skewed amount of ratings (number <kbd class="calibre21">1</kbd> had close to double the number <kbd class="calibre21">6</kbd> business). You wonder if there is some collusion in the ratings process for such a divergence. Again, the names are mangled so far.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Finding the most rated firms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">So, those companies had the most, best ratings. Which had the most ratings? We can use a similar script to determine the most rated firms:</p>
<pre class="commandlinepackt"><strong class="calibre3">#which places have most ratings</strong>
<strong class="calibre3">library(sqldf)</strong>
<strong class="calibre3">most_ratings = sqldf("select business_id, count(*) from reviews group by business_id order by 2 desc")</strong>
<strong class="calibre3">head(most_ratings)</strong>  </pre>
<p class="calibre5">In this script we do not qualify the rating in order to determine its membership resulting in the set:</p>
<div class="packt_figure"><img class="image-border138" src="Images/b73e0bee-b06e-4043-984a-f77b32ba3d9d.png"/></div>
<p class="calibre5">So, similarly we see a small number of firms with many more ratings than average. Also, the names are mangled, but we do see four of the top-rated firms also being included in the most rated at all list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Finding all ratings for a top rated firm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">What if we looked at one of the top-rated firms to see where the ratings spread is? We could use the following script:</p>
<pre class="commandlinepackt"><strong class="calibre3"># range of ratings for business with most ratings</strong>
<strong class="calibre3">library(sqldf)</strong>
<strong class="calibre3">most_rated = sqldf("select * from reviews where business_id = '4JNXUYY8wbaaDmk3BPzlWw' ")</strong>
<strong class="calibre3">hist(most_rated$stars)</strong>  </pre>
<p class="calibre5">The script takes one of the top rated IDs, accesses all of their ratings, and displays a histogram of the same:</p>
<div class="packt_figure"><img class="image-border139" src="Images/2d273b55-7ee7-4df8-8627-45d6786a1e9e.png"/></div>
<p class="calibre5">So, for one of the top rated firms there are very few low ratings.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Determining the correlation between ratings and number of reviews</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">We could look at the correlation between star rating and just number of reviews using the following script:</p>
<pre class="commandlinepackt"><strong class="calibre3"># correlation number of reviews and number of stars</strong>
<strong class="calibre3">library(sqldf)</strong>
<strong class="calibre3">reviews_stars = sqldf("select stars,count(*) as reviews from reviews group by stars")</strong>
<strong class="calibre3">reviews_stars</strong>
<strong class="calibre3">cor(reviews_stars)</strong>  </pre>
<div class="packt_figure"><img class="image-border140" src="Images/ecff2c15-703b-4421-ac50-96da44de87d6.png"/></div>
<p class="calibre5">So, we see three times as many <kbd class="calibre21">5</kbd> star reviews as <kbd class="calibre21">1</kbd> star reviews. We also see a very high correlation between number of reviews and number of stars (<kbd class="calibre21">0.8632361</kbd>). People are only bothering to rate good firms. That makes it interesting to use Yelp only to determine if the firm is reviewed at all. If the firm is not rated (or not rated much) the unwritten reviews are bad.</p>
<p class="calibre5">We could visualize the relationship between ratings and number of reviews for companies using the following script:</p>
<pre class="commandlinepackt"><strong class="calibre3">#correlation business and rating</strong>
<strong class="calibre3">library(sqldf)</strong>
<strong class="calibre3">business_rating = sqldf("select business_id, avg(stars) as rating from reviews group by business_id order by 2 desc")</strong>
<strong class="calibre3">head(business_rating)</strong>
<strong class="calibre3">hist(business_rating$rating)</strong>  </pre>
<p class="calibre5">Where the <kbd class="calibre21">business_rating</kbd> data frame is a list of businesses and average star ratings. The resultant histogram is as follows:</p>
<div class="packt_figure"><img class="image-border141" src="Images/c655a534-70c4-41dc-a754-c20eb5a58cc0.png"/></div>
<p class="calibre5">This looks like a Poisson distribution. It is interesting that the distribution of firm ratings takes such a natural dispersion.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building a model of reviews</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">We can build a model from the dataset to estimate how many stars a rating may entail. However, the data points available within a review are only:</p>
<ul class="calibre19">
<li class="calibre20"><kbd class="calibre21">funny</kbd></li>
<li class="calibre20"><kbd class="calibre21">useful</kbd></li>
<li class="calibre20"><kbd class="calibre21">cool</kbd></li>
</ul>
<p class="calibre5">These would not appear to be good indicators for a rating number. We can use a model, such as:</p>
<pre class="commandlinepackt"><strong class="calibre3">model &lt;- lm(stars ~ funny + useful + cool, data=reviews)</strong>
<strong class="calibre3">summary(model)</strong>  </pre>
<p class="calibre5">This produces the statistics of the model:</p>
<div class="packt_figure"><img class="image-border142" src="Images/f3f26dfe-c6d7-448c-ab60-667862cebcd3.png"/></div>
<p class="calibre5">As expected, we don't have enough information to work with:</p>
<ul class="calibre19">
<li class="calibre20">Over four million degrees of freedom, just about one per review</li>
<li class="calibre20"><em class="calibre28">P</em> values are very small—the probability that we have estimated correctly is non-existent</li>
<li class="calibre20"><kbd class="calibre21">3.7</kbd> intercept (close to the halfway point of the range)</li>
<li class="calibre20">Such low affect rates (under one times each factor) meaning we aren't moving far from the intercept</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Python to compare ratings</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">In the previous examples we used R to work through data frames that were built from converted JSON to CSV files. If we were to use the Yelp <span class="calibre8">businesses </span>rating file we could use Python directly, as it is much smaller and produces similar results.</p>
<p class="calibre5">In this example, we gather cuisines from the Yelp file based on whether the business category includes restaurants. We accumulate the ratings for all cuisines and then produce averages for each.</p>
<p class="calibre5">We read in the JSON file into separate lines and convert each line into a Python object:</p>
<div class="packt_infobox">We convert each line to Unicode with the <kbd class="calibre21">errors=ignore</kbd> option. This is due to many erroneous characters present in the data file.</div>
<pre class="commandlinepackt"><strong class="calibre3">import json</strong>
<strong class="calibre3">#filein = 'c:/Users/Dan/business.json'</strong>
<strong class="calibre3">filein = 'c:/Users/Dan/yelp_academic_dataset_business.json'</strong>
<strong class="calibre3">lines = list(open(filein))</strong>  </pre>
<p class="calibre5">We use a dictionary for the ratings for a cuisine. The key of the dictionary is the name of the cuisine. The value of the dictionary is a list of ratings for that cuisine:</p>
<pre class="commandlinepackt"><strong class="calibre3">ratings = {}</strong>
<strong class="calibre3">for line in lines:</strong>
<strong class="calibre3">    line = unicode(line, errors='ignore')</strong>
<strong class="calibre3">    obj = json.loads(line)</strong>
<strong class="calibre3">    if obj['categories'] == None:</strong>
<strong class="calibre3">        continue</strong>
<strong class="calibre3">    if 'Restaurants' in obj['categories']:</strong>
<strong class="calibre3">        rating = obj['stars']</strong>
<strong class="calibre3">        for category in obj['categories']:</strong>
<strong class="calibre3">            if category not in ratings:</strong>
<strong class="calibre3">                ratings[category] = []</strong>
<strong class="calibre3">            clist = ratings.get(category)</strong>
<strong class="calibre3">            clist.append(rating)</strong></pre>
<p class="calibre5">Now that we have gathered all of the ratings, we can produce a new dictionary of cuisines with average ratings. We also accumulate a total to produce an overall average and track the highest rated cuisine:</p>
<pre class="commandlinepackt"><strong class="calibre3">cuisines = {}</strong>
<strong class="calibre3">total = 0</strong>
<strong class="calibre3">cmax = ''</strong>
<strong class="calibre3">maxc = 0</strong>
<strong class="calibre3">for cuisine in ratings:</strong>
<strong class="calibre3">    clist = ratings[cuisine]</strong>
<strong class="calibre3">    if len(clist) &lt; 10:</strong>
<strong class="calibre3">        continue</strong>
<strong class="calibre3">    avg = float(sum(clist))/len(clist)</strong>
<strong class="calibre3">    cuisines[cuisine] = avg</strong>
<strong class="calibre3">    total = total + avg</strong>
<strong class="calibre3">    if avg &gt; maxc:</strong>
<strong class="calibre3">        maxc = avg</strong>
<strong class="calibre3">        cmax = cuisine</strong>

<strong class="calibre3">print ("Highest rated cuisine is ",cmax," at ",maxc)</strong>
<strong class="calibre3">print ("Average cuisine rating is ",total/len(ratings))</strong>

<strong class="calibre3">print (cuisines)</strong>  </pre>
<div class="packt_figure"><img class="image-border143" src="Images/e80bdc66-bc55-4baf-820c-2012d9c8af6c.png"/></div>
<p class="calibre5">It is interesting that <kbd class="calibre21">Personal Chefs</kbd> is the highest rated. I have only heard about celebrities having a personal chef, but the data shows it may be worthwhile. An average of 1.6 is abysmal for all cuisines. The data did not appear to have a balance of high and low ratings when we looked earlier. However, looking through the resulting output, there are many items that are not cuisines, even though the <kbd class="calibre21">Restaurants</kbd> key is present. I had tried to eliminate the bad data by only counting cuisines with 10 or more ratings, which eliminated some of the bad data, but there are still many erroneous records in play.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Visualizing average ratings by cuisine</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">Now that we have the cuisine averages computed, we can display them in a histogram to get an idea of their spread. We first convert the dictionary to a data frame. Then plot the <kbd class="calibre21">Rating</kbd> column of the data frame into a histogram:</p>
<div class="packt_infobox">We are using five bins to correspond to the five possible ratings.</div>
<pre class="commandlinepackt"><strong class="calibre3">import pandas as pd</strong>
<strong class="calibre3">import numpy as np</strong>
<strong class="calibre3">df = pd.DataFrame(columns=['Cuisine', 'Rating'])</strong>
<strong class="calibre3">for cuisine in cuisines:</strong>
<strong class="calibre3">    df.loc[len(df)]=[cuisine, cuisines[cuisine]]</strong>
<strong class="calibre3">hist, bin_edges = np.histogram(df['Rating'], bins=range(5))</strong>

<strong class="calibre3">import matplotlib.pyplot as plt</strong>
<strong class="calibre3">plt.bar(bin_edges[:-1], hist, width = 1)</strong>
<strong class="calibre3">plt.xlim(min(bin_edges), max(bin_edges))</strong>
<strong class="calibre3">plt.show()   </strong>  </pre>
<div class="packt_figure"><img class="image-border144" src="Images/a9061c63-4075-4999-ad47-ea9082abf982.png"/></div>
<p class="calibre5">Again, we see a clear mark towards high average values. I had tried to get a better gradient on the data display to no avail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Arbitrary search of ratings</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">Since we have the data in an easily loadable format we can search for arbitrary conditions, such as <kbd class="calibre21">Personal Chefs</kbd> that allow dogs-maybe they will custom cook for your dog.</p>
<p class="calibre5">We could use a script as follows: for line in lines:</p>
<pre class="commandlinepackt"><strong class="calibre3">    line = unicode(line, errors='ignore')</strong>
<strong class="calibre3">    obj = json.loads(line)</strong>
<strong class="calibre3">    if obj['categories'] == None:</strong>
<strong class="calibre3">        continue</strong>
<strong class="calibre3">    if 'Personal Chefs' in obj['categories']:</strong>
<strong class="calibre3">        if obj['attributes'] == None:</strong>
<strong class="calibre3">            continue</strong>
<strong class="calibre3">        for attr in obj['attributes']:</strong>
<strong class="calibre3">            print (attr)</strong></pre>
<p class="calibre5">Where we do something useful with the items that filter out. This script would display the attributes only for <kbd class="calibre21">Personal Chefs</kbd>. As can be seen in the following display:</p>
<div class="packt_figure"><img class="image-border145" src="Images/860a2adf-7ef2-455f-a64c-2ef842363ec6.png"/></div>
<p class="calibre5">We could just as easily performed some calculation or other manipulation to narrow down and focus on a very specific portion of the data easily.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Determining relationships between number of ratings and ratings</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">Given the preceding results it appears that people mostly only vote in a positive manner. We can look to see if there is a relationship between how many votes a company has received and their rating.</p>
<p class="calibre5">First, we accumulate the dataset using the following script, extracting the number of votes and rating for each firm:</p>
<pre class="commandlinepackt"><strong class="calibre3">#determine relationship between number of reviews and star rating</strong>
<strong class="calibre3">import pandas as pd</strong>
<strong class="calibre3">from pandas import DataFrame as df  </strong>
<strong class="calibre3">import numpy as np  </strong>

<strong class="calibre3">dfr2 = pd.DataFrame(columns=['reviews', 'rating'])</strong>
<strong class="calibre3">mynparray = dfr2.values</strong>

<strong class="calibre3">for line in lines:</strong>
<strong class="calibre3">    line = unicode(line, errors='ignore')</strong>
<strong class="calibre3">    obj = json.loads(line)</strong>
<strong class="calibre3">    reviews = int(obj['review_count'])</strong>
<strong class="calibre3">    rating = float(obj['stars'])</strong>
<strong class="calibre3">    arow = [reviews,rating]</strong>
<strong class="calibre3">    mynparray = np.vstack((mynparray,arow)) </strong>

<strong class="calibre3">dfr2 = df(mynparray)</strong>
<strong class="calibre3">print (len(dfr2))</strong>  </pre>
<p class="calibre5">This coding just builds the data frame with our two variables. We are using NumPy as it more easily adds a row to a data frame. Once we are done with all records we convert the NumPy data frame back to a pandas data frame.</p>
<p class="calibre5">The column names have been lost in the translation, so we put those back in and draw some summary statistics:</p>
<pre class="commandlinepackt"><strong class="calibre3">dfr2.columns = ['reviews', 'rating']</strong>
<strong class="calibre3">dfr2.describe()</strong></pre>
<p class="calibre5">In the output shown as follows we see the layout of the reviews and rating data we have collected. Yelp has not constrained its data entry for this dataset. There should 5 unique values for rating:</p>
<div class="packt_figure"><img class="image-border146" src="Images/3d98ddaa-d308-4916-b27c-c22be314918e.png"/></div>
<p class="calibre5">Next, we plot the data for a visual clue to the relationship, using the following:</p>
<pre class="commandlinepackt"><strong class="calibre3">#import matplotlib.pyplot as plt</strong>
<strong class="calibre3">dfr2.plot(kind='scatter', x='rating', y='reviews')</strong>
<strong class="calibre3">plt.show()</strong>  </pre>
<div class="packt_figure"><img class="image-border147" src="Images/38df285c-e486-4332-8705-267f3d36a0f5.png"/></div>
<p class="calibre5">So, the data after all, appears to have a clear Poisson distribution as compared to the earlier <kbd class="calibre21">business_rating</kbd> histogram.</p>
<p class="calibre5">Next, we compute the regression parameters:</p>
<pre class="commandlinepackt"><strong class="calibre3">#compute regression</strong>
<strong class="calibre3">import statsmodels.formula.api as smf</strong>

<strong class="calibre3"># create a fitted model in one line</strong>
<strong class="calibre3">lm = smf.ols(formula='rating ~ reviews', data=dfr2).fit()</strong>

<strong class="calibre3"># print the coefficients</strong>
<strong class="calibre3">lm.params</strong>  </pre>
<div class="packt_figure"><img class="image-border148" src="Images/67c5be55-8ce5-472e-8d6a-fca1bfa58923.png"/></div>
<p class="calibre5">We computed intercepts for all rating values. I had expected a single value.</p>
<p class="calibre5">Now, we determine the range of the observed data using the following:</p>
<pre class="commandlinepackt"><strong class="calibre3">#min, max observed values</strong>
<strong class="calibre3">X_new = pd.DataFrame({'reviews': [dfr2.reviews.min(), dfr2.reviews.max()]})</strong>
<strong class="calibre3">X_new.head()</strong>  </pre>
<div class="packt_figure"><img class="image-border149" src="Images/14084c18-6acd-4077-9214-72af8b7ff4f4.png"/></div>
<p class="calibre5">So, as we guessed earlier, some businesses have a very large number of reviews.</p>
<pre class="commandlinepackt"><strong class="calibre3">Now, we can make predictions based on the extent data points:</strong>
<strong class="calibre3">#make corresponding predictions</strong>
<strong class="calibre3">preds = lm.predict(X_new)</strong>
<strong class="calibre3">preds</strong>  </pre>
<div class="packt_figure"><img class="image-border150" src="Images/7bb710de-262f-4151-b1d0-e7f757d35cdf.png"/></div>
<p class="calibre5">We are seeing a much bigger range of predicted values than expected. Plot out the observed and predicted data:</p>
<pre class="commandlinepackt"><strong class="calibre3"># first, plot the observed data</strong>
<strong class="calibre3">dfr2.plot(kind='scatter', x='reviews', y='rating')</strong>

<strong class="calibre3"># then, plot the least squares line</strong>
<strong class="calibre3">plt.plot(X_new, preds, c='red', linewidth=2)</strong>
<strong class="calibre3">plt.show()</strong>  </pre>
<p class="calibre5">In the plot displayed as follows, there does not appear to be a relationship between the number of reviews and the review score for a firm. It appears to be a numbers game—if you get people to review your firm, on average they will give you a high score.</p>
<div class="packt_figure"><img class="image-border151" src="Images/a4200469-5647-47cb-9e45-a9a5a1c4c8c0.png"/></div>
<p class="calibre5">There does not appear to be a relationship between the number of reviews and the review score for a firm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre5">In this chapter, we used data and converted a JSON file to a CSV file. We evaluated the Yelp cuisine review dataset determining the top rated and most rated firms. We saw the distribution of ratings. We used Python to perform a similar evaluation of Yelp business ratings, finding very similar distributions of the data.</p>
<p class="calibre5">In the next chapter, we will look at machine learning under Jupyter.</p>
<p class="calibre5"/>
<p class="calibre5"/>


            </article>

            
        </section>
    </div>



  </body></html>