["```py\n$ ghc -O2 --make Main.hs -threaded -rtsopts \n$ ./Main  +RTS -N2\n\n```", "```py\n$ cabal install parallel\n\n```", "```py\n    import Control.Parallel.Strategies (runEval, rpar)\n    ```", "```py\n    main = do\n      print $ runEval $ do\n        a <- rpar task1\n        b <- rpar task2\n        return (a, b)\n    ```", "```py\n    task1 = 8^8^9 :: Integer\n    ```", "```py\n    task2 = 8^8^8 :: Integer\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded –rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n\n    ```", "```py\n$ cabal install parallel\n\n```", "```py\n    import Control.Parallel\n    import Control.Parallel.Strategies\n    Evaluate two tasks in parallel, and wait for both tasks to finish before returning.\n    main = do\n      print $ runEval $ do\n        a <- rpar task1\n        b <- rpar task2\n        rseq a\n        rseq b\n        return (a, b)\n    ```", "```py\n    task1 = 8^8^9 :: Integer\n    ```", "```py\n    task2 = 8^8^8 :: Integer\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded –rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n\n    ```", "```py\n    import Control.Concurrent (forkIO, threadDelay)\n    ```", "```py\n    main = do\n      putStr \"Enter number of seconds to sleep: \"\n      time <- fmap (read :: String -> Int) getLine\n      forkIO $ sleep time\n      main\n    ```", "```py\n    sleep :: Int -> IO ()\n    sleep t = do\n      let micro = t * 1000000\n      threadDelay micro\n      putStrLn $ \"[Just woke up after \" \n                  ++ show t ++ \" seconds]\"\n    ```", "```py\n    $ ghci Main.hs\n\n    Prelude> main\n\n    Prelude> Enter number of seconds to sleep: 3\n\n    Prelude> Enter number of seconds to sleep: 2\n\n    Prelude> Enter number of seconds to sleep: [Just woke up after 2 seconds]\n\n    [Just woke up after 3 seconds]\n\n    ```", "```py\n$ cabal install HTTP\n\n```", "```py\n    import Network.HTTP\n    import Control.Concurrent\n    ```", "```py\n    main = do\n      m <- newEmptyMVar\n      forkIO $ process m\n    ```", "```py\n      putStrLn \"sending first website...\"\n      putMVar m \"http://www.haskell.com\"\n    ```", "```py\n      putStrLn \"sending second website...\"\n      putMVar m \"http://www.gnu.org\"\n    ```", "```py\n      threadDelay $ 10 * 1000000\n    ```", "```py\n    process m = do \n      putStrLn \"waiting...\"\n      v <- takeMVar m\n      resp <- get v\n      putStrLn $ \"response from \" ++ show v ++ \" is \" ++ resp\n      process m\n    ```", "```py\n    get :: String -> IO String\n    get url = do\n       resp <- simpleHTTP (getRequest url)\n       body <- getResponseBody resp\n       return $ take 10 body\n    ```", "```py\n    $ runhaskell Main.hs\n\n    sending first website...\n    sending second website...\n    waiting...\n    waiting...\n    response from \"http://www.haskell.com\" is \n\n    <!doctype html>\n    <html class=\"no-js\" lang=\"en\">\n    <head id=\"ctl00_Head1\"><meta http-equiv=\"X-UA-C\n\n    response from \"http://www.gnu.org\" is \n\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n     \"http://www.w3.org/TR/xhtml1/DTD/xhtml1\n    waiting...\n\n    ```", "```py\n    import Control.Concurrent\n    import qualified Data.Map as M\n    ```", "```py\n    main = download (M.empty :: M.Map Int [ThreadId])\n    ```", "```py\n    download m = do\n      input <- (getLine >>= return . words)\n      respond m input >>= download\n    ```", "```py\n    respond m [\"d\", nstr] = do\n      putStrLn \"Starting download...\"\n      let n = read nstr :: Int\n      threadId <- forkIO $ massiveDownload n\n      return $ M.insertWith (++) n [threadId] m\n    ```", "```py\n    respond m [\"k\", nstr] = do\n      let n = read nstr :: Int\n      case (M.lookup n m) of\n        Just threads -> do \n          putStrLn \"Killing download(s)...\"\n          mapM_ killThread threads\n          download $ M.delete n m\n        Nothing -> do\n          putStrLn \"No such download\"\n          download m\n    ```", "```py\n    respond m _ = do\n      putStrLn \n          \"Type `d #` to start a download or `k #` to kill it.\"\n      return m\n    ```", "```py\n    massiveDownload n = do\n      threadDelay $ 10 * 1000000\n      putStrLn $ \"[Download \" ++ (show n) ++\" complete!]\"\n    ```", "```py\n    $ runhaskell Main.hs\n    d 1\n    Starting download...\n    d 2\n    Starting download...\n    d 3\n    Starting download...\n    k 1\n    Killing download(s)...\n    [Download 2 complete!]\n    [Download 3 complete!]\n\n    ```", "```py\n$ cabal install monad-par\n\n```", "```py\n    import Control.Monad.Par\n    ```", "```py\n    main = print $ length $ show $ runPar mypar\n    ```", "```py\n    mypar = do \n      v1 <- new :: Par (IVar Integer)\n      v2 <- new :: Par (IVar Integer)\n      fork $ put v1 task1\n      fork $ put v2 task2\n      v1' <- get v1\n      v2' <- get v2\n      return (v1' + v2')  \n    ```", "```py\n    task1 = 8^8^8\n    ```", "```py\n    task2 = 8^8^7\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded –rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n\n    15151337\n\n    ```", "```py\nimport Control.Monad.Par\n\nmain = print $ length $ show $ task1 + task2\n\ntask1 = 8^8^8\ntask2 = 8^8^8\n```", "```py\n    import Control.Parallel.Strategies\n    ```", "```py\n    main = do\n      let results = \n                (parMap rdeepseq (^10) [10^10..10^10+10000]) :: [Int]\n      print results\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded -rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n\n    [0,3644720378636855297,1420199564594381824,-9091195533231350103,-3969065814844243968,5699158338132413177,5185631055696798720,-1664423011715345679,-5301432476323807232,-6822228826283293807,-3978116359327587328,-2988467747382449959,669511447655481344,2530383018990005705,-7998143102955305984,  ...\n\n    ```", "```py\nmain = do\n  print $ map (^10) [10^10..10^10+10000]\n```", "```py\n    import Control.Parallel.Strategies\n    ```", "```py\n    main = do\n      let (a, b) = withStrategy (parTuple2 rseq rseq) (task1, task2)\n      print $ seq (a+b) \"done 1\"\n      let (a, bs) = withStrategy (parTuple2 rseq rdeepseq) (task1, tasks)\n      print $ seq (a + sum bs) \"done 2\"\n    ```", "```py\n    task1 = 8^8^8 :: Integer\n    task2 = 8^8^8 :: Integer\n    tasks = [10^10..10^10+10000] :: [Integer]\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded -rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n\n    ```", "```py\n$ cabal install parallel\n\n```", "```py\n$ wget norvig.com/big.txt\n\n$ split –d big.txt words\n\n$ ls words*\nwords00\nwords01\nwords02\nwords03\n…\n\n```", "```py\n    import Data.List (sort, group, sortBy, groupBy, isPrefixOf)\n    import Control.Parallel\n    import Control.Parallel.Strategies\n    import Data.Char (isAlpha, isSpace, toLower)\n    import Data.Map (Map, insertWith, empty, toList)\n    import System.Directory\n    import qualified Data.Map as M\n    ```", "```py\n    mapReduce :: Strategy b -> (a -> b) -> \n    Strategy b -> ([b] -> b) -> [a] -> b\n    mapReduce mStrategy m rStrategy r input = \n      mOutput `pseq` rOutput\n      where mOutput = parMap mStrategy m input\n            rOutput = r mOutput `using` rStrategy\n    ```", "```py\n    mapper :: String -> [(String,Int)] \n    mapper str = freqCount $ getWords str\n    ```", "```py\n          freqCount :: [String] -> [(String, Int)]\n          freqCount xs = \n            map (\\x -> (head x, length x)) . group . sort $ xs\n    ```", "```py\n    getWords :: String -> [String]\n    getWords str = words $ filter \n                         (\\x -> isAlpha x || isSpace x) lower\n      where lower = map toLower str\n    ```", "```py\n    reducer :: [[(String,Int)]] -> [(String,Int)]\n    reducer ls = toList $ \n                 foldl (\\m (k, v) -> insertWith (+) k v m) \n                       (empty :: Map String Int) \n                       (concat ls)\n    ```", "```py\n    main = do       \n            files <- getCurrentDirectory >>= getDirectoryContents\n            let myFiles = filter (\"words `isPrefixOf`) files\n               rawFileData <- mapM readFile myFiles\n               let freqMap = mapReduce (rpar `dot` rdeepseq) \n                                    mapper rseq reducer fawFileData\n            putStrLn $ \"Found \" ++ (show.length) freqMap ++ \" words!\"\n            queryInput freqMap\n    ```", "```py\n    queryInput freqMap = do\n      putStrLn \"Enter a sentence: \"\n      sentence <- readLine\n      let freqs = map (`lookup` freqMap) (words sentence)\n      print $ zip (words sentence) freqs\n      queryInput freqMap\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded -rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n    Found 35537 words!\n    Enter a sentence:\n    no one who is young is ever going to be old\n    [ (\"no\",Just 2328)\n    , (\"one\",Just 3215)\n    , (\"who\",Just 2994)\n    , (\"is\",Just 9731)\n    , (\"young\",Just 624)\n    , (\"is\",Just 9731)\n    , (\"ever\",Just 254)\n    , (\"going\",Just 369)\n    , (\"to\",Just 28614)\n    , (\"be\",Just 6148)\n    , (\"old\",Just 1138) ]\n\n    ```", "```py\n$ sudo apt-get install libdevil-dev\n\n```", "```py\n$ cabal install repa-devil\n\n```", "```py\n    import System.Environment (getArgs)\n    import Data.Word (Word8)\n    import qualified Data.Array.Repa as R\n    import Data.Array.Repa hiding ((++))\n    import Data.Array.Repa.IO.DevIL (runIL, readImage, \n      writeImage, IL, Image(RGB))\n    import Data.Array.Repa.Repr.ForeignPtr (F)\n    ```", "```py\n    main = do\n      let image1 = \"image1.png\"\n      let image2 = \"image2.png\"\n      runIL $ do\n        (RGB a) <- readImage image1\n        (RGB b) <- readImage image2\n        imageOut <- (computeP $ intersect a b) \n                                     :: IL (Array F DIM3 Word8)\n        writeImage (\"output.png\") (RGB imageOut)\n    ```", "```py\n    intersect :: Array F DIM3 Word8 -> \n                 Array F DIM3 Word8 -> \n                 Array D DIM3 Word8\n    intersect a b = R.zipWith (\\w1 w2 -> merge w1 w2) a b\n      where merge w1 w2 = if w1 == w2 then 0 else 255\n    ```", "```py\n    $ ghc -O2 --make Main.hs -threaded -rtsopts\n\n    ```", "```py\n    $ ./Main +RTS -N2\n\n    ```", "```py\n    import System.CPUTime (getCPUTime)\n    import Control.Monad (replicateM_)\n    import Control.Parallel.Strategies (NFData, rdeepseq)\n    import Control.Exception (evaluate)\n    ```", "```py\n    time :: (Num t, NFData t) => t -> IO ()\n    time y = do\n      let trials = 10^6\n      start <- getCPUTime\n      replicateM_ trials $ do\n          x <- evaluate $ 1 + y\n          rdeepseq x `seq` return ()\n      end   <- getCPUTime\n      let diff = (fromIntegral (end - start)) / (10^12)\n      putStrLn $ \"avg seconds: \" ++  \n        (show (diff / fromIntegral trials))\n      return ()\n    ```", "```py\n    main = do \n        putStrLn \"Starting pure...\"\n        time (3+7 :: Int)\n        putStrLn \"...Finished pure\"\n    ```", "```py\n    Starting pure…\n    Avg seconds: 3.2895e-7\n    …Finished pure\n    ```", "```py\n$ wget norvig.com/big.txt\n\n```", "```py\n$ cabal install criterion\n\n```", "```py\n    import Criterion.Main\n    ```", "```py\n    splitUp filename = readFile filename >>= return . words\n    ```", "```py\n    main = defaultMain \n      [ bgroup \"splitUp\" \n        [ bench \"big\" $ nfIO $ splitUp \"big.txt\" \n        , bench \"small\" $ nfIO $ splitUp \"small.txt\" ] ]\n    ```", "```py\n    $ ghc -O --make Main.hs\n\n    $ ./Main\n\n    warming up\n    estimating clock resolution...\n    mean is 1.082787 us (640001 iterations)\n    found 42320 outliers among 639999 samples (6.6%)\n     1860 (0.3%) low severe\n     40460 (6.3%) high severe\n    estimating cost of a clock call...\n    mean is 33.40185 ns (10 iterations)\n    found 2 outliers among 10 samples (20.0%)\n     1 (10.0%) high mild\n     1 (10.0%) high severe\n\n    benchmarking splitUp/big\n    collecting 100 samples, 1 iterations each, in estimated 65.46450 s\n    mean: 656.1964 ms, lb 655.5417 ms, ub 657.1513 ms, ci 0.950\n    std dev: 4.018375 ms, lb 3.073741 ms, ub 5.746751 ms, ci 0.950\n\n    benchmarking splitUp/small\n    mean: 15.33773 us, lb 15.16429 us, ub 15.56298 us, ci 0.950\n    std dev: 1.010893 us, lb 823.5281 ns, ub 1.277931 us, ci 0.950\n    found 8 outliers among 100 samples (8.0%)\n     5 (5.0%) high mild\n     3 (3.0%) high severe\n    variance introduced by outliers: 61.572%\n    variance is severely inflated by outliers\n\n    ```", "```py\n$ ./Main -h\n\n```", "```py\n    $ time runhaskell Main.hs\n    real 0m0.663s\n    user 0m0.612s\n    sys 0m0.057s\n\n    ```", "```py\n    > Measure-Command { start-process runhaskell Main.hs –Wait }\n\n    ```", "```py\n    Days              : 0\n    Hours             : 0\n    Minutes           : 0\n    Seconds           : 1\n    Milliseconds      : 10\n    Ticks             : 10106611\n    TotalDays         : 1.16974664351852E-05\n    TotalHours        : 0.000280739194444444\n    TotalMinutes      : 0.0168443516666667\n    TotalSeconds      : 1.0106611\n    TotalMilliseconds : 1010.6611\n\n    ```"]