<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Everything is Connected - GraphX</h1>
                
            
            
                
<p>"Technology made large populations possible; large populations now make technology indispensable."</p>
<p class="cdpalignright">- Joseph Wood Krutch</p>
<p class="mce-root">In this chapter, we'll learn how many real-world problems can be modeled (and resolved) using graphs. We see that Apache Spark comes with its own graph library, and what you learned about RDDs can be used here too (this time as vertex and edge RDDs).<br class="title-page-name"/>
In a nutshell, the following topics will be covered in this chapter:</p>
<ul class="calibre9">
<li class="mce-root1">A brief introduction to graph theory</li>
<li class="mce-root1">GraphX</li>
<li class="mce-root1">VertexRDD and EdgeRDD</li>
<li class="mce-root1">Graph operators</li>
<li class="mce-root1">Pregel API</li>
<li class="mce-root1">PageRank</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A brief introduction to graph theory</h1>
                
            
            
                
<p class="mce-root">To better understand graphs, let's look at Facebook and how you typically use Facebook. Every day you use your smart phone to post messages on your friend's wall or update your status. Your friends are all posting messages and photos and videos of their own.</p>
<p class="mce-root">You have friends, your friends have friends, who have friends, and so on. Facebook has settings that let you make new friends or remove friends from your friend list. Facebook also has permissions, which allow granular control on who sees what and who can communicate with who.</p>
<p class="mce-root">Now, when you consider that there are a billion Facebook users, the friends and friend's friends list for all users gets quite large and complicated. It is hard to even comprehend and manage all the different relationships or friendships.</p>
<p class="mce-root">So, if someone wants to find out if you and another person <em class="calibre8">X</em> are related at all, they can simply start by looking at all your friends and all your friends' friends, and so on, and try to get to the person <em class="calibre8">X</em>. If person <em class="calibre8">X</em> is a friend of a friend, then you and person <em class="calibre8">X</em> are indirectly connected.</p>
<p>Search for a celebrity or two in your Facebook account and see if someone is a friend of your friend. Maybe you can try to add them as a friend.</p>
<p class="mce-root">We need to build the storage and retrieval of such data about people and their friends so as to allow us to answer questions such as:</p>
<ul class="calibre9">
<li class="mce-root1">Is X a friend of Y?</li>
<li class="mce-root1">Are X and Y connected directly or within two steps?</li>
<li class="mce-root1">How many friends does X have?</li>
</ul>
<p class="mce-root">We can start by trying out a simple data structure such as an array such that every person has an array of friends. So now, it's easy to just take the length of the array to answer 3. We can also just scan the array and quickly answer 1. Now, question 2 will need little more work, take the array of friends of <em class="calibre8">X</em> and for each such friend scan the array of friends.</p>
<p class="mce-root">We have sort of solved the problem by having a specialized data structure as shown in the following example where we create a case class <kbd class="calibre11">Person</kbd> and then add friends to build a relationship like this <kbd class="calibre11">john</kbd> | <kbd class="calibre11">ken</kbd> | <kbd class="calibre11">mary</kbd> | <kbd class="calibre11">dan</kbd>:</p>
<p class="mce-root">Â </p>
<pre class="calibre19">
<strong class="calibre1">case class Person(name: String) {</strong><br class="title-page-name"/><strong class="calibre1">  val friends = scala.collection.mutable.ArrayBuffer[Person]()<br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">  def numberOfFriends() = friends.length<br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">  def isFriend(other: Person) = friends.find(_.name == other.name)<br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">  def isConnectedWithin2Steps(other: Person) = {</strong><br class="title-page-name"/><strong class="calibre1">    for {f &lt;- friends} yield {f.name == other.name ||<br class="title-page-name"/>                              f.isFriend(other).isDefined}</strong><br class="title-page-name"/><strong class="calibre1">    }.find(_ == true).isDefined</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val john = Person("John")</strong><br class="title-page-name"/>john: Person = Person(John)<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val ken = Person("Ken")</strong><br class="title-page-name"/>ken: Person = Person(Ken)<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val mary = Person("Mary")</strong><br class="title-page-name"/>mary: Person = Person(Mary)<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val dan = Person("Dan")</strong><br class="title-page-name"/>dan: Person = Person(Dan)<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.numberOfFriends</strong><br class="title-page-name"/>res33: Int = 0<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.friends += ken</strong><br class="title-page-name"/>res34: john.friends.type = ArrayBuffer(Person(Ken))     //john -&gt; ken<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.numberOfFriends</strong><br class="title-page-name"/>res35: Int = 1<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; ken.friends += mary</strong><br class="title-page-name"/>res36: ken.friends.type = ArrayBuffer(Person(Mary))    //john -&gt; ken -&gt; mary<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; ken.numberOfFriends</strong><br class="title-page-name"/>res37: Int = 1<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; mary.friends += dan</strong><br class="title-page-name"/>res38: mary.friends.type = ArrayBuffer(Person(Dan))   //john -&gt; ken -&gt; mary -&gt; dan<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; mary.numberOfFriends</strong><br class="title-page-name"/>res39: Int = 1<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.isFriend(ken)</strong><br class="title-page-name"/>res40: Option[Person] = Some(Person(Ken))         //Yes, ken is a friend of john<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.isFriend(mary)</strong><br class="title-page-name"/>res41: Option[Person] = None        //No, mary is a friend of ken not john<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.isFriend(dan)</strong><br class="title-page-name"/>res42: Option[Person] = None      //No, dan is a friend of mary not john<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.isConnectedWithin2Steps(ken)</strong><br class="title-page-name"/>res43: Boolean = true     //Yes, ken is a friend of john<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.isConnectedWithin2Steps(mary)</strong><br class="title-page-name"/>res44: Boolean = true     //Yes, mary is a friend of ken who is a friend of john<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; john.isConnectedWithin2Steps(dan)</strong><br class="title-page-name"/>res45: Boolean = false    //No, dan is a friend of mary who is a friend of ken who is a friend of john<br class="title-page-name"/><br class="title-page-name"/>
</pre>
<p class="mce-root">If we build out the <kbd class="calibre11">Person()</kbd> instances for all Facebook users and add the friends to the arrays as the preceding code shows, then eventually, we will be able to perform lots of the queries on who is a friend and what is the relationship between any two persons.</p>
<p class="mce-root">The following diagram shows the data structures' <kbd class="calibre11">Person()</kbd> instances and how they are related to each other logically:</p>
<div><img class="image-border121" src="img/00008.jpeg"/></div>
<p class="mce-root">If you want to use the preceding graph and just find out <strong class="calibre1">John</strong>'s friends, <strong class="calibre1">John</strong>'s friend's friends and so on so that we can quickly find out direct friends, indirect friends (friends level 2), and level 3 (friends' friends' friends), you will see something like the following diagram:</p>
<div><img class="image-border122" src="img/00014.jpeg"/></div>
<p class="mce-root">We can easily extend the <kbd class="calibre11">Person()</kbd> class and provide more and more functionality to answer different questions. That is not the point here, what we want to look at is the preceding diagram showing <kbd class="calibre11">Person</kbd> and friends of the <kbd class="calibre11">Person</kbd> and how drawing all the friends of each <kbd class="calibre11">Person</kbd> yields in a mesh of relationships between persons.</p>
<p class="mce-root">We now introduce the graph theory, which stems from the field of Mathematics. Graph theory defines a graph as a structure made up of vertices, nodes, or points, which are connected by edges, arcs, and lines. If you consider a set of <kbd class="calibre11">Vertices</kbd> as <kbd class="calibre11">V</kbd> and a set of <kbd class="calibre11">Edges</kbd> as <kbd class="calibre11">E</kbd>, then a <kbd class="calibre11">Graph G</kbd> can be defined as an ordered pair of <kbd class="calibre11">V</kbd> and <kbd class="calibre11">E</kbd>.</p>
<pre class="calibre19">
<strong class="calibre1">Graph G = (V, E)</strong><br class="title-page-name"/><strong class="calibre1">V</strong> - set of Vertices<br class="title-page-name"/><strong class="calibre1">E</strong> - set of Edges
</pre>
<p class="mce-root">In our example of the Facebook friends drawing, we can simply consider each of the persons as a vertex in the set of vertices and then each link between any two persons can be considered as an edge in the set of edges.</p>
<p class="mce-root">By this logic, we can list the <strong class="calibre1">Vertices</strong> and <strong class="calibre1">Edges</strong> as shown in the following diagram:</p>
<div><img src="img/00016.jpeg" class="calibre39"/></div>
<p class="mce-root">This depiction as a mathematical graph yields to various methodologies of traversing and querying the Graph using mathematical techniques. When the techniques are applied to computer science as a way to develop programmatical methods to perform the math necessary, the formal approach is, of course, to develop algorithms to implement the mathematical rules at a scalable efficient level.</p>
<p class="mce-root">We have already attempted to implement a simple graph-like program using the case class <kbd class="calibre11">Person</kbd>, but this is just the simplest use case, which should make it obvious that there are a lot of sophisticated extensions possible, such as the following questions to be answered:</p>
<ul class="calibre9">
<li class="mce-root1">What's the best way from X to Y? An example of such a question can be your car GPS telling you the best way to go to the grocery store.</li>
<li class="mce-root1">Recognize the critical edges, which can cause partitions of the graph? An example of such a question is to determine the critical links connecting the internet services/water pipes/power lines of various cities in the state. A critical edge breaks connectivity and produces two subgraphs of well-connected cities, but there will not be any communication between the two subgraphs.</li>
</ul>
<p class="mce-root">Answering the preceding questions yields to several algorithms such as minimum spanning tree, shortest path , page rank, <strong class="calibre1">ALS</strong> (<strong class="calibre1">alternating least squares</strong>), and max-cut min-flow algorithms, and so on, which are applicable to a broad set of use cases.</p>
<p class="mce-root">The other examples are LinkedIn profiles and connections, Twitter followers, Google page rank, airline scheduling, GPS in your car, and so on, where you can clearly see a graph of vertices and edges. Using graph algorithms, the graph seen earlier in the Facebook, LinkedIn, Google examples can be analyzed using various algorithms to yield different business use cases.</p>
<p class="mce-root">Shown below are illustration of some real-life use cases of graphs which show the use of graphs and graph algorithms in some real-life use cases such as:</p>
<ul class="calibre9">
<li class="mce-root1">help determine flight routes between airports</li>
<li class="mce-root1">plan how to layout water pipelines to all the households in the locality</li>
<li class="mce-root1">make your car GPS to plan the route to drive to the grocery</li>
<li class="mce-root1">design how the internet traffic is routed from city to city, state to state and country to country</li>
</ul>
<div><br class="title-page-name"/>
<img class="image-border123" src="img/00018.jpeg"/></div>
<p class="mce-root">Let's now start digging deeper into how we can use Spark GraphX.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">GraphX</h1>
                
            
            
                
<p class="mce-root">As shown in the preceding section, we can model many real-life use cases as Graphs with a set of vertices and a set of edges linking the vertices. We also wrote simple code trying to implement some basic graph operations and queries such as, <em class="calibre8">Is X a friend of Y</em> ? However, as we explored further, the algorithms only get more complicated along with use cases and also the size of graphs is much much larger than can be handled on one machine.</p>
<p>It is not possible to fit one billion Facebook users along with all their friendship relations into one machine or even a few machines.</p>
<p class="mce-root">What we need to do is to look beyond the one machine and few machines thrown together and rather start considering highly scalable architectures to implement the complex graph algorithms, which can handle the volume of data and complex interconnections of the data elements. We have already seen an introduction to Spark, how Spark solves some challenges of distributed computing and big data analytics. We also saw real-time stream processing and Spark SQL along with DataFrames and RDDs. Can we also solve the challenges of graph algorithms? The answer to this is GraphX, which comes with Apache Spark and just like other libraries, sits on top of Spark Core.</p>
<p class="mce-root">GraphX extends the spark RDD by providing a graph abstraction on top of the RDD concept. Graphs in GraphX are created using the concept of vertices or nodes to represent the objects and edges or links to describe the relation between objects and GraphX provides the means to realize many use cases, which suit the graph processing paradigm. In this section, we will learn about GraphX, how to create vertices, edges, and graphs comprising vertices and edges. We will also write code to learn by example some techniques surrounding graph algorithms and processing.</p>
<p class="mce-root">To get started , you will need to import some packages as listed here:</p>
<pre class="calibre19">
<strong class="calibre1">import org.apache.spark._</strong><br class="title-page-name"/><strong class="calibre1">import org.apache.spark.graphx._</strong><br class="title-page-name"/><strong class="calibre1">import org.apache.spark.rdd.RDD</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">import org.apache.spark.graphx.GraphLoader</strong><br class="title-page-name"/><strong class="calibre1">import org.apache.spark.graphx.GraphOps</strong>
</pre>
<p class="mce-root">The fundamental data structure of GraphX is a graph, which abstractly represents a graph with arbitrary objects associated with vertices and edges. The graph provides basic operations to access and manipulate the data associated with vertices and edges as well as the underlying structure. Like Spark RDDs, the graph is a functional data structure in which mutating operations return new graphs. This immutable nature of the <kbd class="calibre11">Graph</kbd> object makes it possible to do large-scale parallel computations without the risk of running into synchronization problems.</p>
<p>Concurrent updates or modification of objects is the primary reason for complex multithreading programming done in many programs.</p>
<p class="mce-root">The graph defines the basic data structure and there is a helper class <kbd class="calibre11">GraphOps</kbd>, which contains additional convenience operations and graph algorithms.</p>
<p class="mce-root">A graph is defined as follows as a class template with two attributes specifying the data type of the two pieces, which make up the graph, namely, the vertices and the edges:</p>
<pre class="calibre19">
<strong class="calibre1">class Graph[VD: ClassTag, ED: ClassTag] </strong>
</pre>
<p class="mce-root">A graph consists of vertices and edges as we already discussed. The set of vertices is in a special data structure known as <kbd class="calibre11">VertexRDD</kbd>. Similarly, the set of edges is in a special data structure known as <kbd class="calibre11">EdgeRDD</kbd>. Together the vertices and edges form the graph and all the subsequent operations can be done using the two data structures.</p>
<p class="mce-root">So, the declaration of the class <kbd class="calibre11">Graph</kbd> looks like this:</p>
<pre class="calibre19">
<strong class="calibre1">class Graph[VD, ED] {</strong><br class="title-page-name"/>  //A RDD containing the vertices and their associated attributes.<br class="title-page-name"/>  <strong class="calibre1">val vertices: VertexRDD[VD]</strong><br class="title-page-name"/><br class="title-page-name"/>  //A RDD containing the edges and their associated attributes. <br class="title-page-name"/>    The entries in the RDD contain just the source id and target id<br class="title-page-name"/>    along with the edge data.<br class="title-page-name"/>  <strong class="calibre1">val edges: EdgeRDD[ED]</strong><br class="title-page-name"/><br class="title-page-name"/>  //A RDD containing the edge triplets, which are edges along with the<br class="title-page-name"/>    vertex data associated with the adjacent vertices.<br class="title-page-name"/>  <strong class="calibre1">val triplets: RDD[EdgeTriplet[VD, ED]]</strong><br class="title-page-name"/><strong class="calibre1">}</strong>
</pre>
<p class="mce-root">Now, let's look at the two main components of the <kbd class="calibre11">Graph</kbd> class, the <kbd class="calibre11">VertexRDD</kbd>, and the <kbd class="calibre11">EdgeRDD</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">VertexRDD and EdgeRDD</h1>
                
            
            
                
<p class="mce-root">A <kbd class="calibre11">VertexRDD</kbd> contains the set of vertices or nodes in a special data structure and an <kbd class="calibre11">EdgeRDD</kbd> contains the set of edges or links between the nodes/vertices again in a special data structure. Both the <kbd class="calibre11">VertexRDD</kbd> and the <kbd class="calibre11">EdgeRDD</kbd> are based on RDDs and the <kbd class="calibre11">VertexRDD</kbd> deals with every single node in the graph while the <kbd class="calibre11">EdgeRDD</kbd> contains all links between all nodes. In this section, we will look at how to create <kbd class="calibre11">VertexRDD</kbd> and <kbd class="calibre11">EdgeRDD</kbd> and then use these objects in building a graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">VertexRDD</h1>
                
            
            
                
<p class="mce-root">As seen earlier, the <kbd class="calibre11">VertexRDD</kbd> is an RDD containing the vertices and their associated attributes. Each element in the RDD represents a vertex or node in the graph. In order to maintain the uniqueness of the vertex, we need to have a way of assigning a unique ID to each of the vertexes. For this purpose, GraphX defines a very important identifier known as <kbd class="calibre11">VertexId</kbd>.</p>
<div><kbd class="calibre22">VertexId</kbd> is defined as a 64-bit vertex identifier that uniquely identifies a vertex within a graph. It does not need to follow any ordering or any constraints other than uniqueness.</div>
<p class="mce-root">The declaration of <kbd class="calibre11">VertexId</kbd> is as follows as simply an alias for a 64-bit <kbd class="calibre11">Long</kbd> number:</p>
<pre class="calibre19">
<strong class="calibre1">type VertexId = Long</strong>
</pre>
<p class="mce-root">The <kbd class="calibre11">VertexRDD</kbd> extends an RDD of a pair of VertexID and vertex attributes represented by <kbd class="calibre11">RDD[(VertexId, VD)]</kbd>. It also ensures that there is only one entry for each vertex and by preindexing the entries for fast, efficient joins. Two VertexRDDs with the same index can be joined efficiently.</p>
<pre class="calibre19">
<strong class="calibre1">class VertexRDD[VD]() extends RDD[(VertexId, VD)]</strong>
</pre>
<p class="mce-root"><kbd class="calibre11">VertexRDD</kbd> also implements many functions, which provide important functionality related to graph operations. Each function typically accepts inputs of vertices represented by <kbd class="calibre11">VertexRDD</kbd>.</p>
<p class="mce-root">Let's load vertices into a <kbd class="calibre11">VertexRDD</kbd> of users. For this, we shall first declare a case class <kbd class="calibre11">User</kbd> as shown here:</p>
<pre class="calibre19">
<strong class="calibre1">case class User(name: String, occupation: String)</strong>
</pre>
<p class="mce-root">Now, using the file <kbd class="calibre11">users.txt</kbd>, create the <kbd class="calibre11">VertexRDD</kbd>:</p>
<table class="calibre40">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">VertexID</strong></td>
<td class="calibre7"><strong class="calibre1">Name</strong></td>
<td class="calibre7"><strong class="calibre1">Occupation</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7">1</td>
<td class="calibre7">John</td>
<td class="calibre7">Accountant</td>
</tr>
<tr class="calibre6">
<td class="calibre7">2</td>
<td class="calibre7">Mark</td>
<td class="calibre7">Doctor</td>
</tr>
<tr class="calibre6">
<td class="calibre7">3</td>
<td class="calibre7">Sam</td>
<td class="calibre7">Lawyer</td>
</tr>
<tr class="calibre6">
<td class="calibre7">4</td>
<td class="calibre7">Liz</td>
<td class="calibre7">Doctor</td>
</tr>
<tr class="calibre6">
<td class="calibre7">5</td>
<td class="calibre7">Eric</td>
<td class="calibre7">Accountant</td>
</tr>
<tr class="calibre6">
<td class="calibre7">6</td>
<td class="calibre7">Beth</td>
<td class="calibre7">Accountant</td>
</tr>
<tr class="calibre6">
<td class="calibre7">7</td>
<td class="calibre7">Larry</td>
<td class="calibre7">Engineer</td>
</tr>
<tr class="calibre6">
<td class="calibre7">8</td>
<td class="calibre7">Marry</td>
<td class="calibre7">Cashier</td>
</tr>
<tr class="calibre6">
<td class="calibre7">9</td>
<td class="calibre7">Dan</td>
<td class="calibre7">Doctor</td>
</tr>
<tr class="calibre6">
<td class="calibre7">10</td>
<td class="calibre7">Ken</td>
<td class="calibre7">Librarian</td>
</tr>
</tbody>
</table>
<p class="mce-root"><br class="title-page-name"/>
Each line of the file <kbd class="calibre11">users.txt</kbd> contains <strong class="calibre1">VertexId</strong> , the <strong class="calibre1">Name</strong>, and the <strong class="calibre1">Occupation</strong>, so we can use the <kbd class="calibre11">String</kbd> split function here:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val users = sc.textFile("users.txt").map{ line =&gt;</strong><br class="title-page-name"/><strong class="calibre1">  val fields = line.split(",")</strong><br class="title-page-name"/><strong class="calibre1">  (fields(0).toLong, User(fields(1), fields(2)))</strong><br class="title-page-name"/><strong class="calibre1">}</strong><br class="title-page-name"/>users: org.apache.spark.rdd.RDD[(Long, User)] = MapPartitionsRDD[2645] at map at &lt;console&gt;:127<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; users.take(10)</strong><br class="title-page-name"/>res103: Array[(Long, User)] = Array((1,User(John,Accountant)), (2,User(Mark,Doctor)), (3,User(Sam,Lawyer)), (4,User(Liz,Doctor)), (5,User(Eric,Accountant)), (6,User(Beth,Accountant)), (7,User(Larry,Engineer)), (8,User(Mary,Cashier)), (9,User(Dan,Doctor)), (10,User(Ken,Librarian)))
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">EdgeRDD</h1>
                
            
            
                
<p class="mce-root">The <kbd class="calibre11">EdgeRDD</kbd> represents the set of Edges between the vertices and is a member of the Graph class as seen earlier. <kbd class="calibre11">EdgeRDD</kbd>, just like <kbd class="calibre11">VertexRDD</kbd>, extends from RDD and takes both Edge attributes and Vertex attributes.</p>
<p class="mce-root"><kbd class="calibre11">EdgeRDD[ED, VD]</kbd> extends <kbd class="calibre11">RDD[Edge[ED]]</kbd> by storing the edges in columnar format on each partition for performance. It may additionally store the vertex attributes associated with each edge to provide the triplet view:</p>
<pre class="calibre19">
<strong class="calibre1">class EdgeRDD[ED]() extends RDD[Edge[ED]]</strong>
</pre>
<p class="mce-root">EdgeRDD also implements many functions, which provide important functionality related to graph operations. Each function typically accepts inputs of edges represented by EdgeRDD. Each Edge consists of a source vertexId, destination vertexId and edge attributes such as a <kbd class="calibre11">String</kbd>, <kbd class="calibre11">Integer</kbd>, or any case class. In the following example, we use a <kbd class="calibre11">String</kbd> friend as the attribute. Later in this chapter, we use the distance in miles (<kbd class="calibre11">Integer</kbd>) as the attribute.</p>
<p class="mce-root">We can create EdgeRDD by reading a file of pairs of vertexIds:</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Source Vertex ID</strong></td>
<td class="calibre7"><strong class="calibre1">Target/Destination Vertex ID</strong></td>
<td class="calibre7"><strong class="calibre1">Distance in Miles</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7">1</td>
<td class="calibre7">3</td>
<td class="calibre7">5</td>
</tr>
<tr class="calibre6">
<td class="calibre7">3</td>
<td class="calibre7">1</td>
<td class="calibre7">5</td>
</tr>
<tr class="calibre6">
<td class="calibre7">1</td>
<td class="calibre7">2</td>
<td class="calibre7">1</td>
</tr>
<tr class="calibre6">
<td class="calibre7">2</td>
<td class="calibre7">1</td>
<td class="calibre7">1</td>
</tr>
<tr class="calibre6">
<td class="calibre7">4</td>
<td class="calibre7">10</td>
<td class="calibre7">5</td>
</tr>
<tr class="calibre6">
<td class="calibre7">10</td>
<td class="calibre7">4</td>
<td class="calibre7">5</td>
</tr>
<tr class="calibre6">
<td class="calibre7">1</td>
<td class="calibre7">10</td>
<td class="calibre7">5</td>
</tr>
<tr class="calibre6">
<td class="calibre7">10</td>
<td class="calibre7">1</td>
<td class="calibre7">5</td>
</tr>
<tr class="calibre6">
<td class="calibre7">2</td>
<td class="calibre7">7</td>
<td class="calibre7">6</td>
</tr>
<tr class="calibre6">
<td class="calibre7">7</td>
<td class="calibre7">2</td>
<td class="calibre7">6</td>
</tr>
<tr class="calibre6">
<td class="calibre7">7</td>
<td class="calibre7">4</td>
<td class="calibre7">3</td>
</tr>
<tr class="calibre6">
<td class="calibre7">4</td>
<td class="calibre7">7</td>
<td class="calibre7">3</td>
</tr>
<tr class="calibre6">
<td class="calibre7">2</td>
<td class="calibre7">3</td>
<td class="calibre7">2</td>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root">Each line of the <kbd class="calibre11">friends.txt</kbd> file contains the source <kbd class="calibre11">vertexId</kbd> and destination <kbd class="calibre11">vertexId</kbd>, so we can use the <kbd class="calibre11">String</kbd> split function here:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val friends = sc.textFile("friends.txt").map{ line =&gt;</strong><br class="title-page-name"/><strong class="calibre1">  val fields = line.split(",")</strong><br class="title-page-name"/><strong class="calibre1">  Edge(fields(0).toLong, fields(1).toLong, "friend")</strong><br class="title-page-name"/><strong class="calibre1">}</strong><br class="title-page-name"/>friends: org.apache.spark.rdd.RDD[org.apache.spark.graphx.Edge[String]] = MapPartitionsRDD[2648] at map at &lt;console&gt;:125<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; friends.take(10)</strong><br class="title-page-name"/>res109: Array[org.apache.spark.graphx.Edge[String]] = Array(Edge(1,3,friend), Edge(3,1,friend), Edge(1,2,friend), Edge(2,1,friend), Edge(4,10,friend), Edge(10,4,friend), Edge(1,10,friend), Edge(10,1,friend), Edge(2,7,friend), Edge(7,2,friend))
</pre>
<p class="mce-root">We now have vertices and edges, so it is time to put everything together and explore how we can build a <kbd class="calibre11">Graph</kbd> from the lists of vertices and edges:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val graph = Graph(users, friends)</strong><br class="title-page-name"/>graph: org.apache.spark.graphx.Graph[User,String] = org.apache.spark.graphx.impl.GraphImpl@327b69c8<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.vertices</strong><br class="title-page-name"/>res113: org.apache.spark.graphx.VertexRDD[User] = VertexRDDImpl[2658] at RDD at VertexRDD.scala:57<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.edges</strong><br class="title-page-name"/>res114: org.apache.spark.graphx.EdgeRDD[String] = EdgeRDDImpl[2660] at RDD at EdgeRDD.scala:41
</pre>
<p class="mce-root">Using the <kbd class="calibre11">Graph</kbd> object, we can look at the vertices and edges using the <kbd class="calibre11">collect()</kbd> function, which will show all vertices and edges. Each vertex is of the form (<kbd class="calibre11">VertexId</kbd>, <kbd class="calibre11">User</kbd>) and each edge is of the form (<kbd class="calibre11">srcVertexId</kbd>, <kbd class="calibre11">dstVertexId</kbd>, <kbd class="calibre11">edgeAttribute</kbd>).</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.vertices.collect</strong><br class="title-page-name"/>res111: Array[(org.apache.spark.graphx.VertexId, User)] = Array((4,User(Liz,Doctor)), (6,User(Beth,Accountant)), (8,User(Mary,Cashier)), (10,User(Ken,Librarian)), (2,User(Mark,Doctor)), (1,User(John,Accountant)), (3,User(Sam,Lawyer)), (7,User(Larry,Engineer)), (9,User(Dan,Doctor)), (5,User(Eric,Accountant)))<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.edges.collect</strong><br class="title-page-name"/>res112: Array[org.apache.spark.graphx.Edge[String]] = Array(Edge(1,2,friend), Edge(1,3,friend), Edge(1,10,friend), Edge(2,1,friend), Edge(2,3,friend), Edge(2,7,friend), Edge(3,1,friend), Edge(3,2,friend), Edge(3,10,friend), Edge(4,7,friend), Edge(4,10,friend), Edge(7,2,friend), Edge(7,4,friend), Edge(10,1,friend), Edge(10,4,friend), Edge(3,5,friend), Edge(5,3,friend), Edge(5,9,friend), Edge(6,8,friend), Edge(6,10,friend), Edge(8,6,friend), Edge(8,9,friend), Edge(8,10,friend), Edge(9,5,friend), Edge(9,8,friend), Edge(10,6,friend), Edge(10,8,friend))
</pre>
<p class="mce-root">Now that we have a graph created, we will look at various operations in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Graph operators</h1>
                
            
            
                
<p class="mce-root">Let's start with the operations we can directly perform using <kbd class="calibre11">Graph</kbd> object, such as filtering the vertices and edges of the graph to filter out based on some attribute of the object. We will also see an example of <kbd class="calibre11">mapValues()</kbd>, which can transform the graph to yield a custom RDD.</p>
<p class="mce-root">First, let's examine the vertices and the edges using the <kbd class="calibre11">Graph</kbd> object we created in the previous section and then look at some graph operators.</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.vertices.collect</strong><br class="title-page-name"/>res111: Array[(org.apache.spark.graphx.VertexId, User)] = Array((4,User(Liz,Doctor)), (6,User(Beth,Accountant)), (8,User(Mary,Cashier)), (10,User(Ken,Librarian)), (2,User(Mark,Doctor)), (1,User(John,Accountant)), (3,User(Sam,Lawyer)), (7,User(Larry,Engineer)), (9,User(Dan,Doctor)), (5,User(Eric,Accountant)))<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.edges.collect</strong><br class="title-page-name"/>res112: Array[org.apache.spark.graphx.Edge[String]] = Array(Edge(1,2,friend), Edge(1,3,friend), Edge(1,10,friend), Edge(2,1,friend), Edge(2,3,friend), Edge(2,7,friend), Edge(3,1,friend), Edge(3,2,friend), Edge(3,10,friend), Edge(4,7,friend), Edge(4,10,friend), Edge(7,2,friend), Edge(7,4,friend), Edge(10,1,friend), Edge(10,4,friend), Edge(3,5,friend), Edge(5,3,friend), Edge(5,9,friend), Edge(6,8,friend), Edge(6,10,friend), Edge(8,6,friend), Edge(8,9,friend), Edge(8,10,friend), Edge(9,5,friend), Edge(9,8,friend), Edge(10,6,friend), Edge(10,8,friend))
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Filter</h1>
                
            
            
                
<p class="mce-root">A function call to <kbd class="calibre11">filter()</kbd> restricts the vertex set to the set of vertices satisfying the given predicate. This operation preserves the index for efficient joins with the original RDD, and it sets bits in the bitmask rather than allocating new memory:</p>
<pre class="calibre19">
<strong class="calibre1">def filter(pred: Tuple2[VertexId, VD] =&gt; Boolean): VertexRDD[VD] </strong>
</pre>
<p class="mce-root">Using <kbd class="calibre11">filter</kbd>, we can filter out everything but the vertex for user <kbd class="calibre11">Mark</kbd>, which can be done either using the vertexId or the <kbd class="calibre11">User.name</kbd> attribute. We can also filter for the <kbd class="calibre11">User.occupation</kbd> attribute.</p>
<p class="mce-root">The following is the code to accomplish the same:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.vertices.filter(x =&gt; x._1 == 2).take(10)</strong><br class="title-page-name"/>res118: Array[(org.apache.spark.graphx.VertexId, User)] = Array((2,User(Mark,Doctor)))<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.vertices.filter(x =&gt; x._2.name == "Mark").take(10)</strong><br class="title-page-name"/>res119: Array[(org.apache.spark.graphx.VertexId, User)] = Array((2,User(Mark,Doctor)))<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.vertices.filter(x =&gt; x._2.occupation == "Doctor").take(10)</strong><br class="title-page-name"/>res120: Array[(org.apache.spark.graphx.VertexId, User)] = Array((4,User(Liz,Doctor)), (2,User(Mark,Doctor)), (9,User(Dan,Doctor)))
</pre>
<p class="mce-root">We can also perform <kbd class="calibre11">filter</kbd> on the edges too, using either the source vertexId or the destination vertexId. So we can filter out the edges to show only the edges, which originate from <kbd class="calibre11">John</kbd> (vertexId = 1):</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.edges.filter(x =&gt; x.srcId == 1)</strong><br class="title-page-name"/>res123: org.apache.spark.rdd.RDD[org.apache.spark.graphx.Edge[String]] = MapPartitionsRDD[2672] at filter at &lt;console&gt;:134<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.edges.filter(x =&gt; x.srcId == 1).take(10)</strong><br class="title-page-name"/>res124: Array[org.apache.spark.graphx.Edge[String]] = Array(Edge(1,2,friend), Edge(1,3,friend), Edge(1,10,friend))
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">MapValues</h1>
                
            
            
                
<p class="mce-root"><kbd class="calibre11">mapValues()</kbd> maps each vertex attribute, preserving the index so as not to change the vertexId. Changing the vertexId would have changed the index so much that subsequent operations would fail and the vertices will not be reachable anymore. Hence, it is important to not change the vertexIds.</p>
<p class="mce-root">The declaration of this function is shown here:</p>
<pre class="calibre19">
<strong class="calibre1">def mapValues[VD2: ClassTag](f: VD =&gt; VD2): VertexRDD[VD2]</strong><br class="title-page-name"/>//A variant of the mapValues() function accepts a vertexId in addition  <br class="title-page-name"/>  to the vertices.<br class="title-page-name"/><strong class="calibre1">def mapValues[VD2: ClassTag](f: (VertexId, VD) =&gt; VD2): VertexRDD[VD2]</strong>
</pre>
<p class="mce-root"><kbd class="calibre11">mapValues()</kbd> can also operate on the edges and maps the values in an edge partitioning preserving the structure but changing the values:</p>
<pre class="calibre19">
<strong class="calibre1">def mapValues[ED2: ClassTag](f: Edge[ED] =&gt; ED2): EdgeRDD[ED2]</strong>
</pre>
<p class="mce-root">The following is the example code invoking <kbd class="calibre11">mapValues()</kbd> in the vertices and edges. MapValues on vertices transforms the vertices to list of pairs of (<kbd class="calibre11">vertexId</kbd> , <kbd class="calibre11">User.name</kbd>). MapValues on edges transforms the edges to triplets of (<kbd class="calibre11">srcId</kbd>, <kbd class="calibre11">dstId</kbd>, <kbd class="calibre11">string</kbd>):</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.vertices.mapValues{(id, u) =&gt; u.name}.take(10)</strong><br class="title-page-name"/>res142: Array[(org.apache.spark.graphx.VertexId, String)] = Array((4,Liz), (6,Beth), (8,Mary), (10,Ken), (2,Mark), (1,John), (3,Sam), (7,Larry), (9,Dan), (5,Eric))<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; graph.edges.mapValues(x =&gt; s"${x.srcId} -&gt; ${x.dstId}").take(10)</strong><br class="title-page-name"/>7), Edge(3,1,3 -&gt; 1), Edge(3,2,3 -&gt; 2), Edge(3,10,3 -&gt; 10), Edge(4,7,4 -&gt; 7))
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">aggregateMessages</h1>
                
            
            
                
<p class="mce-root">The core aggregation operation in GraphX is <kbd class="calibre11">aggregateMessages</kbd>, which applies a user-defined <kbd class="calibre11">sendMsg</kbd> function to each edge triplet in the graph and then uses the <kbd class="calibre11">mergeMsg</kbd> function to aggregate these messages at their destination vertex. <kbd class="calibre11">aggregateMessages</kbd> is used in many graph algorithms, where we have to exchange information between vertices.</p>
<p class="mce-root">The following is the signature for this API:</p>
<pre class="calibre19">
<strong class="calibre1">def aggregateMessages[Msg: ClassTag](</strong><br class="title-page-name"/><strong class="calibre1"> sendMsg: EdgeContext[VD, ED, Msg] =&gt; Unit,</strong><br class="title-page-name"/><strong class="calibre1"> mergeMsg: (Msg, Msg) =&gt; Msg,</strong><br class="title-page-name"/><strong class="calibre1"> tripletFields: TripletFields = TripletFields.All)</strong><br class="title-page-name"/><strong class="calibre1"> : VertexRDD[Msg]</strong>
</pre>
<p class="mce-root">The key functions are the <kbd class="calibre11">sendMsg</kbd> and <kbd class="calibre11">mergeMsg</kbd>, which determine what gets sent either to source vertex or destination vertex of an edge. Then, <kbd class="calibre11">mergeMsg</kbd> processes the messages received from all the Edges and performs a computation or aggregation.</p>
<p class="mce-root">The following is a simple example of calling <kbd class="calibre11">aggregateMessages</kbd> on the <kbd class="calibre11">Graph</kbd> graph, where we send a message to all destination vertices. The merge strategy at each vertex is to just add all the messages being received:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.aggregateMessages[Int](_.sendToDst(1), _ + _).collect</strong><br class="title-page-name"/>res207: Array[(org.apache.spark.graphx.VertexId, Int)] = Array((4,2), (6,2), (8,3), (10,4), (2,3), (1,3), (3,3), (7,2), (9,2), (5,2))
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">TriangleCounting</h1>
                
            
            
                
<p class="mce-root">A triangle is created if two neighbors of a vertex are connected by an edge. In other words, a user will create a triangle with the two friends who are friends with each other.</p>
<p class="mce-root">Graph has a function <kbd class="calibre11">triangleCount()</kbd>, which computes the triangles in the graph.</p>
<p class="mce-root">The following is the code used to count the triangles in the graph by first invoking the <kbd class="calibre11">triangleCount</kbd> function and then by joining the triangles with the vertices (users) to generate the output of each user and the triangle the user belongs to:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val triangleCounts = graph.triangleCount.vertices</strong><br class="title-page-name"/>triangleCounts: org.apache.spark.graphx.VertexRDD[Int] = VertexRDDImpl[3365] at RDD at VertexRDD.scala:57<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; triangleCounts.take(10)</strong><br class="title-page-name"/>res171: Array[(org.apache.spark.graphx.VertexId, Int)] = Array((4,0), (6,1), (8,1), (10,1), (2,1), (1,1), (3,1), (7,0), (9,0), (5,0))<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val triangleCountsPerUser = users.join(triangleCounts).map { case(id, (User(x,y), k)) =&gt; ((x,y), k) }</strong><br class="title-page-name"/>triangleCountsPerUser: org.apache.spark.rdd.RDD[((String, String), Int)] = MapPartitionsRDD[3371] at map at &lt;console&gt;:153<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; triangleCountsPerUser.collect.mkString("\n")</strong><br class="title-page-name"/>res170: String =<br class="title-page-name"/>((Liz,Doctor),0)<br class="title-page-name"/>((Beth,Accountant),1)  <em class="calibre8">//1 count means this User is part of 1 triangle</em><br class="title-page-name"/>((Mary,Cashier),1)  <em class="calibre8">//1 count means this User is part of 1 triangle</em><br class="title-page-name"/>((Ken,Librarian),1)  <em class="calibre8">//1 count means this User is part of 1 triangle</em><br class="title-page-name"/>((Mark,Doctor),1)  <em class="calibre8"> //1 count means this User is part of 1 triangle</em><br class="title-page-name"/>((John,Accountant),1)  <em class="calibre8">//1 count means this User is part of 1 triangle</em><br class="title-page-name"/>((Sam,Lawyer),1)   <em class="calibre8">//1 count means this User is part of 1 triangle</em><br class="title-page-name"/>((Larry,Engineer),0)<br class="title-page-name"/>((Dan,Doctor),0)<br class="title-page-name"/>((Eric,Accountant),0)
</pre>
<p class="mce-root">The diagram of the two triangles we just computed in the preceding code shows the two triangles, (<strong class="calibre1">John</strong>, <strong class="calibre1">Mark</strong>, <strong class="calibre1">Sam</strong>) and (<strong class="calibre1">Ken</strong>, <strong class="calibre1">Mary</strong>, <strong class="calibre1">Beth</strong>):</p>
<div><img class="image-border124" src="img/00023.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pregel API</h1>
                
            
            
                
<p class="mce-root">Graphs are inherently recursive data structures as properties of vertices depend on properties of their neighbors, which in turn depend on properties of their own neighbors. As a consequence, many important graph algorithms iteratively recompute the properties of each vertex until a fixed-point condition is reached. A range of graph-parallel abstractions have been proposed to express these iterative algorithms. GraphX exposes a variant of the Pregel API.</p>
<p class="mce-root">At a high level, the Pregel operator in GraphX is a bulk-synchronous parallel messaging abstraction constrained to the topology of the graph. The Pregel operator executes in a series of steps in which vertices receive the sum of their inbound messages from the previous super step, compute a new value for the vertex property, and then send messages to neighboring vertices in the next super step. Using Pregel, messages are computed in parallel as a function of the edge triplet and the message computation has access to both the source and destination vertex attributes. Vertices that do not receive a message are skipped within a super step. The Pregel operators terminate iteration and return the final graph when there are no messages remaining.</p>
<p class="mce-root">Some algorithms which come built-in using Pregel API are as follows:</p>
<ul class="calibre9">
<li class="mce-root1">ConnectedComponents</li>
<li class="mce-root1">ShortestPaths</li>
<li class="mce-root1">Traveling salesman</li>
<li class="mce-root1">PageRank (covered in the next section)</li>
</ul>
<p class="mce-root">The Pregel API signature is shown in the following code, which shows the various arguments needed. The exact usage will be shown in the subsequent sections, so you can refer to this signature for clarification:</p>
<pre class="calibre19">
<strong class="calibre1">def pregel[A]</strong><br class="title-page-name"/><strong class="calibre1"> (initialMsg: A,   </strong>// the initial message to all vertices<br class="title-page-name"/><strong class="calibre1"> maxIter: Int = Int.MaxValue,  </strong>// number of iterations<br class="title-page-name"/><strong class="calibre1"> activeDir: EdgeDirection = EdgeDirection.Out) <br class="title-page-name"/></strong> // incoming or outgoing edges<br class="title-page-name"/><strong class="calibre1"> (vprog: (VertexId, VD, A) =&gt; VD,</strong><br class="title-page-name"/><strong class="calibre1"> sendMsg: EdgeTriplet[VD, ED] =&gt; Iterator[(VertexId, A)], <br class="title-page-name"/></strong> //send message function<br class="title-page-name"/><strong class="calibre1"> mergeMsg: (A, A) =&gt; A) </strong>//merge strategy<br class="title-page-name"/><strong class="calibre1"> : Graph[VD, ED]</strong> 
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">ConnectedComponents</h1>
                
            
            
                
<p class="mce-root">Connected components are essentially subgraphs within a graph, where the vertices are connected to each other in some way. This means that every vertex in the same component has an edge to/from some other vertex in the component. Whenever no other edge exists to connect a vertex to a component, a new component is created with that specific vertex. This continues until all vertices are in some component.</p>
<p class="mce-root">The graph object provides a <kbd class="calibre11">connectComponents()</kbd> function to compute the connected components. This uses the Pregel API underneath to calculate the component a vertex belongs to. The following is the code to calculate connected components in the graph. Obviously, in this example, we had only one connected component, so it shows one as the component number for all users:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; graph.connectedComponents.vertices.collect<br class="title-page-name"/></strong>res198: Array[(org.apache.spark.graphx.VertexId, org.apache.spark.graphx.VertexId)] = Array((4,1), (6,1), (8,1), (10,1), (2,1), (1,1), (3,1), (7,1), (9,1), (5,1))<br class="title-page-name"/><strong class="calibre1"><br class="title-page-name"/>scala&gt; graph.connectedComponents.vertices.join(users).take(10)</strong><br class="title-page-name"/>res197: Array[(org.apache.spark.graphx.VertexId, (org.apache.spark.graphx.VertexId, User))] = Array((4,(1,User(Liz,Doctor))), (6,(1,User(Beth,Accountant))), (8,(1,User(Mary,Cashier))), (10,(1,User(Ken,Librarian))), (2,(1,User(Mark,Doctor))), (1,(1,User(John,Accountant))), (3,(1,User(Sam,Lawyer))), (7,(1,User(Larry,Engineer))), (9,(1,User(Dan,Doctor))), (5,(1,User(Eric,Accountant))))
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Traveling salesman problem</h1>
                
            
            
                
<p class="mce-root">Traveling salesman problem tried to find the shortest path through an undirected graph traversing every vertex, for example, user, John, wants to drive to every other user minimizing the total distance driven. As the number of vertices and edges increase, the number of permutations also increases polynomially to cover all the possible paths from vertex to vertex. The time complexity increases polynomially to a point that the problem can take a very long time to solve. Rather than solve it completely and accurately, an approach known as a <strong class="calibre1">greedy</strong> algorithm is used to solve the problem as optimally as possible.</p>
<p class="mce-root">To solve the traveling salesman problem, the greedy approach is to quickly choose the shortest edge, knowing that this could be a nonoptimal selection if we traverse further depth-wise.</p>
<p class="mce-root">A diagram of the greedy algorithm on the graph of users and friends is as follows, where we see the traversal picking the shortest weighted edge at each vertex. Also note that the vertices <strong class="calibre1">Larry</strong> (<strong class="calibre1">7</strong>) and <strong class="calibre1">Liz</strong> (<strong class="calibre1">4</strong>) are never visited:</p>
<div><img class="image-border125" src="img/00025.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">ShortestPaths</h1>
                
            
            
                
<p class="mce-root">Shortest paths algorithm finds the path between two vertices by starting at the source Vertex and then traversing the edges connecting the vertices to other vertices until it reaches the target vertex. The shortest paths algorithm works by exchanging messages between various vertices. Also this shortest paths algorithm is not directly a part of the <kbd class="calibre11">Graph</kbd> or <kbd class="calibre11">GraphOps</kbd> objects, rather must be invoked using <kbd class="calibre11">lib.ShortestPaths()</kbd>:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; lib.ShortestPaths.run(graph,Array(1)).vertices.join(users).take(10)</strong><br class="title-page-name"/><br class="title-page-name"/>res204: Array[(org.apache.spark.graphx.VertexId, (org.apache.spark.graphx.lib.ShortestPaths.SPMap, User))] = Array((4,(Map(1 -&gt; 2),User(Liz,Doctor))), (6,(Map(1 -&gt; 2),User(Beth,Accountant))), (8,(Map(1 -&gt; 2),User(Mary,Cashier))), (10,(Map(1 -&gt; 1),User(Ken,Librarian))), (2,(Map(1 -&gt; 1),User(Mark,Doctor))), (1,(Map(1 -&gt; 0),User(John,Accountant))), (3,(Map(1 -&gt; 1),User(Sam,Lawyer))), (7,(Map(1 -&gt; 2),User(Larry,Engineer))), (9,(Map(1 -&gt; 3),User(Dan,Doctor))), (5,(Map(1 -&gt; 2),User(Eric,Accountant))))
</pre>
<p class="mce-root"><kbd class="calibre11">ShortestPaths</kbd> picks the shortest paths in terms of number of hops between the two vertices. The following diagram shows three ways <strong class="calibre1">John</strong> can reach <strong class="calibre1">Larry</strong> and two of the paths are of length 2 and one of length 3. From the results of the preceding code, it clearly shows that the path chosen from <strong class="calibre1">Larry</strong> to John is of length 2.</p>
<p class="mce-root">The same is shown in the output in above code block as a vector containing the length of the path and the nodes <kbd class="calibre11">(7,(Map(1 -&gt; 2),User(Larry,Engineer)))</kbd>:</p>
<div><img class="image-border126" src="img/00031.jpeg"/></div>
<p class="mce-root">We can also compute the shortest path using weighted edges, which means every edge connecting users is not the same. For example, if we can consider the edge value/weight/attribute as the distance between where each user lives, we get a weighted graph. In this case, the shortest path is calculated by the distance between two users in miles:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val srcId = 1 </strong>//vertex ID 1 is the user John<br class="title-page-name"/>srcId: Int = 1<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val initGraph = graph.mapVertices((id, x) =&gt; if(id == srcId) 0.0 else Double.PositiveInfinity)</strong><br class="title-page-name"/>initGraph: org.apache.spark.graphx.Graph[Double,Long] = org.apache.spark.graphx.impl.GraphImpl@2b9b8608<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val weightedShortestPath = initGraph.pregel(Double.PositiveInfinity, 5)(</strong><br class="title-page-name"/><strong class="calibre1"> | (id, dist, newDist) =&gt; math.min(dist, newDist),</strong><br class="title-page-name"/><strong class="calibre1"> | triplet =&gt; {</strong><br class="title-page-name"/><strong class="calibre1"> | if (triplet.srcAttr + triplet.attr &lt; triplet.dstAttr) {</strong><br class="title-page-name"/><strong class="calibre1"> | Iterator((triplet.dstId, triplet.srcAttr + triplet.attr))</strong><br class="title-page-name"/><strong class="calibre1"> | }</strong><br class="title-page-name"/><strong class="calibre1"> | else {</strong><br class="title-page-name"/><strong class="calibre1"> | Iterator.empty</strong><br class="title-page-name"/><strong class="calibre1"> | }</strong><br class="title-page-name"/><strong class="calibre1"> | },</strong><br class="title-page-name"/><strong class="calibre1"> | (a, b) =&gt; math.min(a, b)</strong><br class="title-page-name"/><strong class="calibre1"> | )</strong><br class="title-page-name"/>weightedShortestPath: org.apache.spark.graphx.Graph[Double,Long] = org.apache.spark.graphx.impl.GraphImpl@1f87fdd3<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; weightedShortestPath.vertices.take(10).mkString("\n")</strong><br class="title-page-name"/>res247: String =<br class="title-page-name"/>(4,10.0)<br class="title-page-name"/>(6,6.0)<br class="title-page-name"/>(8,6.0)<br class="title-page-name"/>(10,5.0)<br class="title-page-name"/>(2,1.0)<br class="title-page-name"/>(1,0.0)<br class="title-page-name"/>(3,3.0)<br class="title-page-name"/>(7,7.0)<br class="title-page-name"/>(9,5.0)<br class="title-page-name"/>(5,4.0)
</pre>
<p class="mce-root">The following is a diagram that uses Pregel API to compute the <strong class="calibre1">Single Source Shortest Path</strong> from <strong class="calibre1">John</strong> to <strong class="calibre1">Larry</strong> starting from initialization and iteration by iteration until we reach the best paths.</p>
<p class="mce-root">Initialization of the graph is done by setting the value of vertex representing <strong class="calibre1">John</strong> to zero and all other vertices to positive infinity:</p>
<div><img class="image-border127" src="img/00010.jpeg"/></div>
<p class="mce-root">Once the initialization is complete, we will use Pregel for four iterations of recomputing the vertex values. In each iteration, we go through all the vertices and, at each vertex, check whether there is a better path from a source vertex to a destination vertex. If there is such an edge/path, then the vertex value is updated.</p>
<p class="mce-root">Let's define two functions <em class="calibre8">distance(v)</em> and <em class="calibre8">distance(s, t)</em>, where <em class="calibre8">distance(v)</em> gives the value of a vertex and <em class="calibre8">distance(s,t)</em> gives the value of the edge connecting <em class="calibre8">s</em> to <em class="calibre8">t</em>.</p>
<p class="mce-root">In Iteration 1, every user except John is set to infinity and John is at 0, since he is the source vertex. Now, we use Pregel to loop through the vertices and check whether there is anything better than infinity. Using Ken as an example, we will check if <em class="calibre8">distance("John") + distance("John", "Ken") &lt; distance("Ken")</em>.</p>
<p class="mce-root">This is equivalent to checking whether <em class="calibre8">0 + 5 &lt; Infinity</em>, which is <kbd class="calibre11">true</kbd>; so we update Ken's distance to <em class="calibre8">5</em>.</p>
<p class="mce-root">Similarly, we check for Mary, <em class="calibre8">distance("Ken") + distance("Ken", "Mary") &lt; distance("Mary")</em>, which turns out to be <kbd class="calibre11">false</kbd>, since at that time Ken is still at infinity. Hence, in iteration 1, we could only update the users who are connected to John.</p>
<p class="mce-root">In the next iteration, Mary, Liz, Eric and so on, are all updated since now we have updated values for Ken, Mark, and Sam from iteration 1. This continues for a number of iterations specified in the Pregel API call.</p>
<p class="mce-root">Shown below are the illustrations of the various iterations when computing single source shortest path on the graph:</p>
<div><img class="image-border128" src="img/00038.jpeg"/></div>
<p class="mce-root">The shortest paths from <strong class="calibre1">John</strong> to <strong class="calibre1">Larry</strong> after four iterations shows that the shortest path is five miles. The path from <strong class="calibre1">John</strong> to <strong class="calibre1">Larry</strong> can be seen if you follow the path <strong class="calibre1">John</strong> | <strong class="calibre1">Mark</strong> | <strong class="calibre1">Sam</strong> | <strong class="calibre1">Larry</strong>:</p>
<div><img class="image-border129" src="img/00275.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">PageRank</h1>
                
            
            
                
<p class="mce-root"><strong class="calibre1">PageRank</strong> is one of the most important algorithms in the graph processing space. Originating at Google, the algorithm named after Larry page, the founder of Google, has evolved into many types of use cases based on the concept of ranking vertices or nodes based on relationships or edges.</p>
<p>Google PageRank works by counting the number and quality of links to a page to determine a rough estimate of how important the website is. The underlying assumption is that more important websites are likely to receive more links from other websites. For more information, you can read the description at <a href="https://en.wikipedia.org/wiki/PageRank" class="calibre21">https://en.wikipedia.org/wiki/PageRank</a></p>
<p class="mce-root">Using Google PageRank as an example, you can improve the relative importance of a web page on your company website or maybe your blog by promoting the web page among other popular websites and technical blogs. Using this approach, your blog website may appear in Google search results about some article higher than other similar web pages, if there are a lot of third-party websites, which show your blog website and the content.</p>
<div><strong class="calibre27">Search Engine Optimization</strong> (<strong class="calibre27">SEO</strong>) is one of the biggest industries in the marketing world, where pretty much every website out there is investing into this technology. SEO involves various techniques and strategies essentially to improve how far up your website appears in any search engine results when anyone searches for some relevant words. This is based on Google PageRank-like concept.</div>
<p class="mce-root">If you consider web pages as nodes/vertices and the hyperlinks between the web pages as edges, we essentially created a graph. Now, if you can count the rank of a web page as the number of hyperlinks/edges pointed into such as your <kbd class="calibre11">myblog.com</kbd> site having links on <kbd class="calibre11">cnn.com</kbd> or <kbd class="calibre11">msnbc.com</kbd> so that a user can click on the link and come to your <kbd class="calibre11">myblog.com</kbd> page. This can be a factor representing the importance of the <kbd class="calibre11">myblog.com</kbd> vertex. If we apply this simple logic recursively, we eventually end up with a rank assigned to each vertex calculated using the number of incoming edges and PageRank based on the ranks of the source vertices. A page that is linked to by many pages with high PageRank receives a high rank itself. Let's look at how to solve the PageRank problem at a big data scale using Spark GraphX. As we have seen, PageRank measures the importance of each vertex in a graph, assuming an edge from <strong class="calibre1">a</strong> to <strong class="calibre1">b</strong> represents the value of <strong class="calibre1">b</strong> boosted by <strong class="calibre1">a</strong>. For example, if a Twitter user is followed by many others, the user will be ranked highly.</p>
<p class="mce-root">GraphX comes with static and dynamic implementations of PageRank as methods on the <kbd class="calibre11">pageRank</kbd> object. Static PageRank runs for a fixed number of iterations, while dynamic PageRank runs until the ranks converge. <kbd class="calibre11">GraphOps</kbd> allows calling these algorithms directly as methods on the graph:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val prVertices = graph.pageRank(0.0001).vertices</strong><br class="title-page-name"/>prVertices: org.apache.spark.graphx.VertexRDD[Double] = VertexRDDImpl[8245] at RDD at VertexRDD.scala:57<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; prVertices.join(users).sortBy(_._2._1, false).take(10)</strong><br class="title-page-name"/>res190: Array[(org.apache.spark.graphx.VertexId, (Double, User))] = Array((10,(1.4600029149839906,User(Ken,Librarian))), (8,(1.1424200609462447,User(Mary,Cashier))), (3,(1.1279748817993318,User(Sam,Lawyer))), (2,(1.1253662371576425,User(Mark,Doctor))), (1,(1.0986118723393328,User(John,Accountant))), (9,(0.8215535923013982,User(Dan,Doctor))), (5,(0.8186673059832846,User(Eric,Accountant))), (7,(0.8107902215195832,User(Larry,Engineer))), (4,(0.8047583729877394,User(Liz,Doctor))), (6,(0.783902117150218,User(Beth,Accountant))))
</pre>
<p class="mce-root">The diagram of the PageRank algorithm on the graph is as follows:</p>
<div><img class="image-border130" src="img/00309.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we have introduced graph theory using Facebook as an example; Apache Spark's graph processing library GraphX, <kbd class="calibre11">VertexRDD</kbd>, and EdgeRDDs; graph operators, <kbd class="calibre11">aggregateMessages</kbd>, <kbd class="calibre11">TriangleCounting</kbd>, and the Pregel API; and use cases such as the PageRank algorithm. We have also seen the traveling salesman problem and connected components and so on. We have seen how the GraphX API can be used to develop graph processing algorithms at scale.</p>
<p class="mce-root">In <a href="part0343.html#A73GU1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 11</a>, <em class="calibre8">Learning Machine Learning - Spark MLlib and ML</em>, we will explore the exciting world of Apache Spark's Machine Learning library.</p>


            

            
        
    </body></html>