["```py\n> plot(cos,-2*pi,2*pi) \n```", "```py\n> set.seed(333) \n> data<-rnorm(5000) \n> hist(data) \n```", "```py\nx<-seq(-3,3,length=100) \ny<-dnorm(x,mean=0,sd=1) \ntitle<-\"Area under standard normal dist & x less than -2.33\" \nyLabel<-\"standard normal distribution\" \nxLabel<-\"x value\" \nplot(x,y,type=\"l\",lwd=3,col=\"black\",main=title,xlab=xLabel,ylab=yLabel) \nx<-seq(-3,-2.33,length=100) \ny<-dnorm(x,mean=0,sd=1) \npolygon(c(-4,x,-2.33),c(0,y,0),col=\"red\") \n```", "```py\n> install.packages(\"rattle\") \n```", "```py\n> library(rattle) \n> rattle() \n```", "```py\n> install.packages(\"qgraph\") \n```", "```py\nlibrary(qgraph) \nstocks<-c(\"IBM\",\"MSFT\",\"WMT\") \nx<-rep(stocks, each = 3) \ny<-rep(stocks, 3) \ncorrelation<-c(0,10,3,10,0,3,3,3,0) \ndata <- as.matrix(data.frame(from =x, to =y, width =correlation)) \nqgraph(data, mode = \"direct\", edge.color = rainbow(9)) \n```", "```py\n> data \n from   to     width \n [1,] \"IBM\"  \"IBM\"  \" 0\"  \n [2,] \"IBM\"  \"MSFT\" \"10\"  \n [3,] \"IBM\"  \"WMT\"  \" 3\"  \n [4,] \"MSFT\" \"IBM\"  \"10\"  \n [5,] \"MSFT\" \"MSFT\" \" 0\"  \n [6,] \"MSFT\" \"WMT\"  \" 3\"  \n [7,] \"WMT\"  \"IBM\"  \" 3\"  \n [8,] \"WMT\"  \"MSFT\" \" 3\"  \n [9,] \"WMT\"  \"WMT\"  \" 0\" \n```", "```py\nlibrary(qgraph) \ndata(big5) \ndata(big5groups) \ntitle(\"Correlations among 5 factors\",line = 2.5) \nqgraph(cor(big5),minimum = 0.25,cut = 0.4,vsize = 1.5, \n    groups = big5groups,legend = TRUE, borders = FALSE,theme = 'gray') \n```", "```py\nimport matplotlib.pyplot as plt  \nplt.plot([2,3,8,12]) \nplt.show() \n```", "```py\nimport scipy as sp \nimport matplotlib.pyplot as plt  \nx=sp.linspace(-2*sp.pi,2*sp.pi,200,endpoint=True) \ny=sp.cos(x) \nplt.plot(x,y) \nplt.xlabel(\"x-value\") \nplt.ylabel(\"Cosine function\") \nplt.title(\"Cosine curve from -2pi to 2pi\") \nplt.show() \n```", "```py\nimport matplotlib.pyplot as plt \nfig = plt.figure(facecolor='white') \ndd = plt.axes(frameon=False) \ndd.set_frame_on(False) \ndd.get_xaxis().tick_bottom() \ndd.axes.get_yaxis().set_visible(False) \nx=range(0,11,2) \nx1=range(len(x),0,-1) \ny = [0]*len(x); \nplt.annotate(\"$100 received today\",xy=(0,0),xytext=(2,0.15),arrowprops=dict(facecolor='black',shrink=2)) \nplt.annotate(\"$100 received in 2 years\",xy=(2,0),xytext=(3.5,0.10),arrowprops=dict(facecolor='black',shrink=2)) \ns = [50*2.5**n for n in x1];\nplt.title(\"Time value of money \") \nplt.xlabel(\"Time (number of years)\") \nplt.scatter(x,y,s=s); \nplt.show() \n```", "```py\nusing PyPlot \nn=50 \nsrand(333) \nx = 100*rand(n) \ny = 100*rand(n) \nareas = 800*rand(n) \nfig = figure(\"pyplot_scatterplot\",figsize=(10,10)) \nax = axes() \nscatter(x,y,s=areas,alpha=0.5) \ntitle(\"using PyPlot: Scatter Plot\") \nxlabel(\"X\") \nylabel(\"Y\") \ngrid(\"on\") \n```", "```py\nusing QuantEcon: meshgrid \nusing PyPlot:surf \nusing Plots \nn = 50 \nx = linspace(-3, 3, n) \ny = x \nz = Array{Float64}(n, n) \nf(x, y) = cos(x^2 + y^2) / (1 + x^2 + y^2) \nfor i in 1:n \n    for j in 1:n \n        z[j, i] = f(x[i], y[j]) \n    end \nend \nxgrid, ygrid = meshgrid(x, y) \nsurf(xgrid, ygrid, z',alpha=0.7) \n```", "```py\nx<-seq(-3,3,by=0.05) \ny<-2+2.5*x \nplot(x,y,type=\"b\") \n```", "```py\nimport numpy as np \nimport matplotlib.pyplot as plt  \nn=np.linspace(0,10,10) \npv=100 \nR=0.1 \nfv=pv*(1+R)**n \nplt.plot(n,fv) \nplt.show() \n```", "```py\nusing PyPlot \nx = linspace(0,2*pi,1000) \ny = sin.(x) \nplot(x, y, color=\"green\", linewidth=2.0) \n```", "```py\nresults <- c(10,8,7,4,6) \nnames<-c(\"1st\",\"2nd\",\"3rd\",\"4th\",\"5th\") \npct<-round(results/sum(results)*100) \npct2<-rev(sort(pct)) \nname<-\"Pie Chart of results\" \ncolors<-seq(0.4, 1.0, length = length(results)) \npie(results, labels = names, col = gray(colors),main=name) \n```", "```py\nimport numpy as np \nimport matplotlib.pyplot as plt \ndata = np.random.RandomState(10)  \nn=5000 \nn2=1000 \nx=data.normal(size=n) \ny=data.normal(loc=5, scale=2,size=n2) \na=(x,y) \nb = np.hstack(a) \nplt.hist(b, bins='auto')  \nplt.title(\"Histogram with 'auto bins'\") \nplt.show() \n```", "```py\nx=seq(-4,4,by=0.05) \nn<-length(x) \ny=2+3*x + rnorm(n) \nk<-coef(lm(y~x)) \nintercept<-k[1] \nslope<-k[2] \ny2<-intercept+slope*x \n#\nplot(x,y,type=\"p\",col=\"red\") \nlines(x,y2,col=\"green\") \n```", "```py\nusing PyPlot \nx = linspace(0, 10, 100) \ny = sin.(x) \nname=L\"$y = sin(x)$\"  \nfig, ax = subplots() \nax[:plot](x, y, \"b-\", linewidth=2, label=name,alpha=0.6) \nax[:legend](loc=\"upper center\") \n```", "```py\nset.seed(12345)  \nmu=4 \nstd=2 \nnRandom=2000 \nx <- rnorm(mean =mu, sd =std, n =nRandom) \nname<- \"Normal Probability Density Function\" \ncurve(dnorm, from = -3, to = 3, n = 1000, main = name) \nformula<-expression(f(x) ==paste(frac(1, sqrt(2 * pi * sigma^2)),\" \",e^{frac(-(x - mu)^2, 2 * sigma^2)})) \ntext(2, 0.3, formula, cex = 1.3) \n```", "```py\nimport matplotlib\nimport numpy as np\nimport matplotlib.mathtext as mathtext\nimport matplotlib.pyplot as plt\nmatplotlib.rc('image', origin='upper')\nparser = mathtext.MathTextParser(\"Bitmap\")\n#parser = mathtext.MathTextParser(\"Black\")\n#\nx1=r'$d_2=\\frac{ln(S_0/K)+(r-\\sigma^2/2)T}{\\sigma\\sqrt{T}}=d_1-\\sigma\\sqrt{T}$'\nx2=r'$d_1=\\frac{ln(S_0/K)+(r+\\sigma^2/2)T}{\\sigma\\sqrt{T}}$'\nx3=r' $c=S_0N(d_1)- Ke^{-rT}N(d_2)$'\nrgba1, depth1 = parser.to_rgba(x1, color='blue',fontsize=12, dpi=200)\nrgba2, depth2 = parser.to_rgba(x2, color='blue', fontsize=12, dpi=200)\nrgba3, depth3 = parser.to_rgba(x3, color='red',fontsize=14, dpi=200)\nfig = plt.figure()\nfig.figimage(rgba1.astype(float)/255., 100, 100)\nfig.figimage(rgba2.astype(float)/255., 100, 200)\nfig.figimage(rgba3.astype(float)/255., 100, 300)\nplt.show()\n```", "```py\n> library(ggplot2) \n> help(package=ggplot2) \n```", "```py\nimport matplotlib as mat \nx=dir(mat) \nprint(x) \n```", "```py\nlibrary(animation) \nani.options(interval = 0.05, nmax = 30) \na<- c(3,3,2,0.5) \nb<-c(2,0.5,0) \nname<-\"Brownian Motion\" \npar(mar=a,mgp=b,tcl=-0.3,cex.axis=0.8,cex.lab=0.8,cex.main=1) \nbrownian.motion(pch=21,cex=5,col=\"red\",bg=\"yellow\",main=name) \n```", "```py\nlibrary(animation) \npar(mar = c(4, 4, 1, 2)) \nmyFunction<-function(x) x^2 - 4 \ntitle<-\"Bisection method\" \nbisection.method(FUN=myFunction,main =title) \n```", "```py\nlibrary(animation) \nmyProb<-c(0.5,0.5) \nani.options(interval=0.2,nmax = ifelse(interactive(), 100, 2)) \nflip.coin(bg = \"grey\",col=c(\"black\",\"grey\")) \n```", "```py\npdf(\"c:/temp/myGraph.pdf\") \nplot(cos,-2*pi,2*pi) \ndev.off() \n```", "```py\nlibrary(animation) \na<- c(3, 3, 1, 0.5) \nb<- c(2, 0.5, 0) \npart1<-\"Random walk on the 2D plane: for each point\" \npart2<-\"(x, y), x = x + rnorm(1) and y = y + rnorm(1).\" \ndes<-c(part1,part2) \ntitleName<-\"Demonstration of Brownian Motion\" \n# \nsaveHTML({ par(mar =a, mgp =b, tcl = -0.3,cex.axis = 0.8, cex.lab = 0.8, cex.main = 1) \n  ani.options(interval = 0.05, nmax = ifelse(interactive(),150, 10)) \n  brownian.motion(pch = 21, cex = 5, col = \"red\", bg = \"yellow\") \n  },description =des,title = titleName) \n```", "```py\nlibrary(animation) \na<- c(4, 4, 1, 2) \npart1<-\"The bisection method is a root-finding algorithm\" \npart2<-\"which works by repeatedly dividing an interval in half and then\" \npart3<-\"selecting the subinterval in which a root exists.\" \ndes<-c(part1,part2,part3) \ntitleName<-\"The Bisection Method for Root-finding on an Interval\" \n# \nsaveHTML({ par(mar = a) \n    bisection.method(main = \"\") \n    },img.name = \"bisection.method\",htmlfile = \"bisection.method.html\",  \n    ani.height = 400, ani.width = 600, interval = 1,  \n    title = titleName, description =des) \n```", "```py\nbsCall_<-function(s,x,T,r,sigma){ \n   d1 = (log(s/x)+(r+sigma*sigma/2.)*T)/(sigma*sqrt(T)) \n   d2 = d1-sigma*sqrt(T) \n   call<-s*pnorm(d1)-x*exp(-r*T)*pnorm(d2) \n   return(call) \n} \n\n```", "```py\nlibrary(animation) \nmyProb<-c(0.45,0.1, 0.45) \nani.options(interval=0.2,nmax = ifelse(interactive(), 100, 2)) \nflip.coin(bg = \"yellow\") \n```"]