<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Data Hashing</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hashing a primitive data type</li><li class="listitem" style="list-style-type: disc">Hashing a custom data type</li><li class="listitem" style="list-style-type: disc">Running popular cryptographic hash functions</li><li class="listitem" style="list-style-type: disc">Running a cryptographic checksum on a file</li><li class="listitem" style="list-style-type: disc">Performing fast comparisons between data types</li><li class="listitem" style="list-style-type: disc">Using a high-performance hash table</li><li class="listitem" style="list-style-type: disc">Using Google's CityHash hash functions for strings</li><li class="listitem" style="list-style-type: disc">Computing Geohash for location coordinates</li><li class="listitem" style="list-style-type: disc">Using a bloom filter to remove unique items</li><li class="listitem" style="list-style-type: disc">Running MurmurHash, a simple but speedy hashing algorithm</li><li class="listitem" style="list-style-type: disc">Measuring image similarity with perceptual hashes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Introduction</h1></div></div></div><div><img src="img/ch04.jpg" alt="Introduction"/></div><p>A <strong>hash</strong> is <a id="id235" class="indexterm"/>a lossy way of representing an object into a small and typically fixed-length value. Hashing data embellishes us with speedy lookups and lightweight handling of massive datasets.</p><p>The output of a hashing function is referred to as a <a id="id236" class="indexterm"/>
<strong>digest</strong>. One of the principal properties of a good hashing function is that it must be deterministic, which means a given input must always produce the same corresponding output. Sometimes, two different inputs may end up producing the same output, and we call that a <a id="id237" class="indexterm"/>
<strong>collision</strong>. Given a hash alone, we cannot invert the process to rediscover the object within an adequate time. To minimize the chances of a collision, another property of a hash function called <a id="id238" class="indexterm"/>
<strong>uniformity</strong> is used. In other words, the probability of each output occurring should be nearly the same.</p><p>We will start by first producing a simple digest from an input. Then in the next recipe, we will run the hashing algorithm on our custom-made data type.</p><p>Another important application of hashing is in cryptography. We will cover some of the most popular cryptographic hashing algorithms such as SHA-512. We will also apply these hashes on files for computing checksums to ensure file integrity.</p><p>Lastly, we will cover many nontraditional hashing approaches including CityHash, GeoHashing, bloom filters, MurmurHash, and pHash.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Hashing a primitive data type</h1></div></div></div><p>This <a id="id239" class="indexterm"/>recipe <a id="id240" class="indexterm"/>demonstrates how to use a simple hash function on various primitive data types.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec135"/>Getting ready</h2></div></div></div><p>Install the <a id="id241" class="indexterm"/>
<code class="literal">Data.Hashable</code> package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install hashable</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec136"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the hashing function with the following line:<div><pre class="programlisting">import Data.Hashable</pre></div></li><li class="listitem">Test the <code class="literal">hash</code> function on a string as follows; this function is actually a wrapper around the <code class="literal">hashWithSalt</code> function with a default salt value:<div><pre class="programlisting">main = do
  print $ hash "foo" </pre></div></li><li class="listitem">Test out the <code class="literal">hashWithSalt</code> functions using different initial salt values as follows:<div><pre class="programlisting">  print $ hashWithSalt 1 "foo"
  print $ hashWithSalt 2 "foo"</pre></div></li><li class="listitem">We can also hash tuples and lists as follows:<div><pre class="programlisting">  print $ hash [ (1 :: Int, "hello", True)
               , (0 :: Int, "goodbye", False) ]</pre></div></li><li class="listitem">Notice in the following output how the first three hashes produce different results even though their input is the same:<div><pre class="programlisting">$ runhaskell Main.hs

7207853227093559468
367897294438771247
687941543139326482
6768682186886785615</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec137"/>How it works…</h2></div></div></div><p>Hashing <a id="id242" class="indexterm"/>with a <a id="id243" class="indexterm"/>salt means applying the hash function only after slightly modifying it. It's as if we "salted up" the input before processing it through the hash function. Even the slightest change in salt values produces dramatically different hashed digests.</p><p>We need this concept of a salt for better password security. Hash functions always produce the same output for the same input, and this is both good and bad. There are databases of rainbow tables for every commonly used password in existence for all major hashing algorithms. If a website with a login system service (such as Packt Publishing) stores the password using cryptographic hashes, but without being salted, then it's no better than plain text if the password itself is considered weak. If a service such as Packt Publishing uses salt in its cryptographic hashing (and it should), then it's an added layer of security and rainbow tables are rendered useless.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec138"/>There's more…</h2></div></div></div><p>The previous code produced a hash of a string, but the algorithm is not limited to just strings. The following <a id="id244" class="indexterm"/>data types also implement <code class="literal">hashable</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Bool</li><li class="listitem" style="list-style-type: disc">Char</li><li class="listitem" style="list-style-type: disc">Int</li><li class="listitem" style="list-style-type: disc">Int8</li><li class="listitem" style="list-style-type: disc">Int16</li><li class="listitem" style="list-style-type: disc">Int32</li><li class="listitem" style="list-style-type: disc">Int64</li><li class="listitem" style="list-style-type: disc">Word</li><li class="listitem" style="list-style-type: disc">Word8</li><li class="listitem" style="list-style-type: disc">Word16</li><li class="listitem" style="list-style-type: disc">Word32</li><li class="listitem" style="list-style-type: disc">Word64</li><li class="listitem" style="list-style-type: disc">ByteString</li><li class="listitem" style="list-style-type: disc">List of hashable items</li><li class="listitem" style="list-style-type: disc">Tuple of hashable items</li><li class="listitem" style="list-style-type: disc">Maybe of a hashable item</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec139"/>See also</h2></div></div></div><p>For using a hash function on a custom-made data type, refer to the <em>Hashing a custom data type</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Hashing a custom data type</h1></div></div></div><p>Even a <a id="id245" class="indexterm"/>custom-defined data type can be hashed easily. Dealing with <a id="id246" class="indexterm"/>hashed digests is often useful when the data itself is too space consuming to manage directly. By referencing a data by its digest, we can easily skip the cost of carrying around whole data types. This is especially useful in data analysis.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec140"/>Getting ready</h2></div></div></div><p>Install the <a id="id247" class="indexterm"/>
<code class="literal">Data.Hashable</code> package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install hashable</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec141"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Use the GHC language extension <code class="literal">DeriveGeneric</code> to autodefine the hash functions for our custom data types as follows:<div><pre class="programlisting">{-# LANGUAGE DeriveGeneric #-}</pre></div></li><li class="listitem">Import the relevant packages using the following lines of code:<div><pre class="programlisting">import GHC.Generics (Generic)
import Data.Hashable</pre></div></li><li class="listitem">Create a custom data type and let <code class="literal">GHC</code> autodefine its hashable instance as follows:<div><pre class="programlisting">data Point = Point Int Int
           deriving (Eq, Generic)

instance Hashable Point</pre></div></li><li class="listitem">In <code class="literal">main</code>, create three points. Let two of them be the same, and let the third point be different, as shown in the following code snippet:<div><pre class="programlisting">main = do
    let p1 = Point 1 1
    let p2 = Point 1 1
    let p3 = Point 3 5</pre></div></li><li class="listitem">Print the hash values of identical points as follows:<div><pre class="programlisting">if p1 == p2
  then putStrLn "p1 = p2"
  else putStrLn "p1 /= p2"
  if hash p1 == hash p2
  then putStrLn "hash p1 = hash p2"
  else putStrLn "hash p1 /= hash p2"</pre></div></li><li class="listitem">Print the hash values of different points as follows:<div><pre class="programlisting">  if p1 == p3
    then putStrLn "p1 = p3"
    else putStrLn "p1 /= p3"
  if hash p1 == hash p3
    then putStrLn "hash p1 = hash p3"
    else putStrLn "hash p1 /= hash p3"</pre></div></li><li class="listitem">The output will be as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>p1 = p2</strong>
<strong>hash p1 = hash p2</strong>
<strong>p1 /= p3</strong>
<strong>hash p1 /= hash p3</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec142"/>There's more…</h2></div></div></div><p>We can define a <a id="id248" class="indexterm"/>custom hashing function on our own data types by providing an instance for Hashable. The Hashable instance only requires the implementation of <code class="literal">hashWithSalt :: Int -&gt; a -&gt; Int</code>. To help implement <code class="literal">hashWithSalt</code>, we also have two useful functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hashing a pointer with salt is performed as shown in the following code snippet:<div><pre class="programlisting">hashPtrWithSalt :: Ptr a   --  pointer to the data to hash
                -&gt; Int     --  length, in bytes
                -&gt; Int     --  salt
                -&gt; IO Int  --  hash value</pre></div></li><li class="listitem" style="list-style-type: disc">Hashing a byte array with salt is performed as shown in the following code snippet:<div><pre class="programlisting">hashByteArrayWithSalt
    :: ByteArray#  --  data to hash
    -&gt; Int         --  offset, in bytes
    -&gt; Int         --  length, in bytes
    -&gt; Int         --  salt
    -&gt; Int         --  hash value</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec143"/>See also</h2></div></div></div><p>To hash a built-in primitive, refer to the <em>Hashing a primitive data type</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Running popular cryptographic hash functions</h1></div></div></div><p>A <a id="id249" class="indexterm"/>cryptographic hash function has specific properties that make it different from other hash functions. First of all, producing a possible input message from a given hash digest output should be intractable, meaning that it must take an exponentially long time to solve in practice.</p><p>For example, if a hash produces the digest <code class="literal">66fc01ae071363ceaa4178848c2f6224</code>, then in principle, discovering the content used to generate a digest should be difficult.</p><p>In practice, some<a id="id250" class="indexterm"/> hash functions are easier to crack than others. For example, MD5 and SHA-1 are considered trivial to crack and should not be used, but are demonstrated later for completeness. More information about how MD5 and SHA-1 are insecure can be found at <a class="ulink" href="http://www.win.tue.nl/hashclash/rogue-ca">http://www.win.tue.nl/hashclash/rogue-ca</a> and <a class="ulink" href="https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html">https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html</a> respectively.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec144"/>Getting ready</h2></div></div></div><p>Install the <code class="literal">Crypto.Hash</code> package<a id="id251" class="indexterm"/> from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install cryptohash</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec145"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the cryptographic hash function library as follows:<div><pre class="programlisting">import Data.ByteString.Char8 (ByteString, pack)
import Crypto.Hash</pre></div></li><li class="listitem">Define each hash functions <a id="id252" class="indexterm"/>by explicitly associating the data types as follows:<div><pre class="programlisting">skein512_512 :: ByteString -&gt; Digest Skein512_512
skein512_512 bs = hash bs

skein512_384 :: ByteString -&gt; Digest Skein512_384
skein512_384 bs = hash bs

skein512_256 :: ByteString -&gt; Digest Skein512_256
skein512_256 bs = hash bs

skein512_224 :: ByteString -&gt; Digest Skein512_224
skein512_224 bs = hash bs

skein256_256 :: ByteString -&gt; Digest Skein256_256
skein256_256 bs = hash bs

skein256_224 :: ByteString -&gt; Digest Skein256_224
skein256_224 bs = hash bs

sha3_512 :: ByteString -&gt; Digest SHA3_512
sha3_512 bs = hash bs

sha3_384 :: ByteString -&gt; Digest SHA3_384
sha3_384 bs = hash bs

sha3_256 :: ByteString -&gt; Digest SHA3_256
sha3_256 bs = hash bs

sha3_224 :: ByteString -&gt; Digest SHA3_224
sha3_224 bs = hash bs

tiger :: ByteString -&gt; Digest Tiger
tiger bs = hash bs

whirlpool :: ByteString -&gt; Digest Whirlpool
whirlpool bs = hash bs

ripemd160 :: ByteString -&gt; Digest RIPEMD160
ripemd160 bs = hash bs

sha512 :: ByteString -&gt; Digest SHA512
sha512 bs = hash bs

sha384 :: ByteString -&gt; Digest SHA384
sha384 bs = hash bs

sha256 :: ByteString -&gt; Digest SHA256
sha256 bs = hash bs

sha224 :: ByteString -&gt; Digest SHA224
sha224 bs = hash bs

sha1 :: ByteString -&gt; Digest SHA1
sha1 bs = hash bs
 
md5 :: ByteString -&gt; Digest MD5
md5 bs = hash bs

md4 :: ByteString -&gt; Digest MD4
md4 bs = hash bs

md2 :: ByteString -&gt; Digest MD2
md2 bs = hash bs</pre></div></li><li class="listitem">Test out each <a id="id253" class="indexterm"/>cryptographic hash function on the same input, as shown in the following code snippet:<div><pre class="programlisting">main = do
  let input = pack "haskell data analysis"
  putStrLn $ "Skein512_512: " ++ (show.skein512_512) input
  putStrLn $ "Skein512_384: " ++ (show.skein512_384) input
  putStrLn $ "Skein512_256: " ++ (show.skein512_256) input
  putStrLn $ "Skein512_224: " ++ (show.skein512_224) input
  putStrLn $ "Skein256_256: " ++ (show.skein256_256) input
  putStrLn $ "Skein256_224: " ++ (show.skein256_224) input
  putStrLn $ "SHA3_512: " ++ (show.sha3_512) input
  putStrLn $ "SHA3_384: " ++ (show.sha3_384) input
  putStrLn $ "SHA3_256: " ++ (show.sha3_256) input
  putStrLn $ "SHA3_224: " ++ (show.sha3_224) input
  putStrLn $ "Tiger: " ++ (show.tiger) input
  putStrLn $ "Whirlpool: " ++ (show.whirlpool) input
  putStrLn $ "RIPEMD160: " ++ (show.ripemd160) input
  putStrLn $ "SHA512: " ++ (show.sha512) input
  putStrLn $ "SHA384: " ++ (show.sha384) input
  putStrLn $ "SHA256: " ++ (show.sha256) input
  putStrLn $ "SHA224: " ++ (show.sha224) input
  putStrLn $ "SHA1: " ++ (show.sha1) input
  putStrLn $ "MD5: " ++ (show.md5) input
  putStrLn $ "MD4: " ++ (show.md4) input
  putStrLn $ "MD2: " ++ (show.md2) input</pre></div></li><li class="listitem">The final <a id="id254" class="indexterm"/>output can be seen in the following screenshot:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>
</pre></div><div><img src="img/6331OS_04_05.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec146"/>See also</h2></div></div></div><p>To run one of these cryptographic hash functions on a file to perform an integrity check, refer to the <em>Running a cryptographic checksum on a file</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec53"/>Running a cryptographic checksum on a file</h1></div></div></div><p>One of the most effective <a id="id255" class="indexterm"/>methods to determine whether a file on a computer is different from another file elsewhere is by comparing their cryptographic hashes. If the two hashes are equal, it's only highly probable that the files are equal, but not strictly necessary due to the possibility of collisions.</p><p>After downloading<a id="id256" class="indexterm"/> a file online, such as Arch Linux from <a class="ulink" href="https://www.archlinux.org/download">https://www.archlinux.org/download</a>, it is a good idea to ensure the cryptographic hashes match up. For example, have a look at the following screenshot:</p><div><img src="img/6331OS_04_07.jpg" alt="Running a cryptographic checksum on a file"/></div><p>The preceding screenshot shows the corresponding hashes for the Arch Linux download as of late May, 2014.</p><p>Notice how both MD5 and SHA1 hashes are provided. This recipe will show how to compute these hashes in Haskell to ensure data integrity.</p><p>We will<a id="id257" class="indexterm"/> compute the SHA256, SHA512, and MD5 hashes of its own source file.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec147"/>Getting ready</h2></div></div></div><p>Install the <a id="id258" class="indexterm"/>
<code class="literal">Crypto.Hash</code> package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install cryptohash</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec148"/>How to do it…</h2></div></div></div><p>Create a file named <code class="literal">Main.hs</code> and insert the following code:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant packages as follows:<div><pre class="programlisting">import Crypto.Hash
import qualified Data.ByteString as BS</pre></div></li><li class="listitem">Define the <code class="literal">MD5</code> hash function as follows:<div><pre class="programlisting">md5 :: BS.ByteString -&gt; Digest MD5
md5 bs = hash bs</pre></div></li><li class="listitem">Define the <code class="literal">SHA256</code> hash function as follows:<div><pre class="programlisting">sha256 :: BS.ByteString -&gt; Digest SHA256
sha256 bs = hash bs</pre></div></li><li class="listitem">Define the <code class="literal">SHA512</code> hash function as follows:<div><pre class="programlisting">sha512 :: BS.ByteString -&gt; Digest SHA512
sha512 bs = hash bs</pre></div></li><li class="listitem">Open a file of the <code class="literal">ByteString</code> type using the <code class="literal">readFile</code> function provided by the <code class="literal">Data.ByteString</code> package as follows:<div><pre class="programlisting">main = do
  byteStr &lt;- BS.readFile "Main.hs"</pre></div></li><li class="listitem">Test out the various hashes on the file as follows:<div><pre class="programlisting">    putStrLn $ "MD5: " ++ (show.md5) byteStr
    putStrLn $ "SHA256: " ++ (show.sha256) byteStr
    putStrLn $ "SHA512: " ++ (show.sha512) byteStr</pre></div></li><li class="listitem">The following output is generated:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>MD5: 242334e552ae8ede926de9c164356d18</strong>

<strong>SHA256:</strong>
<strong>50364c25e0e9a835df726a056bd5370657f37d20aabc82e0b1719a343ab505d8</strong>

<strong>SHA512: 1ad6a9f8922b744c7e5a2d06bf603c267ca6becbf52b2b22f8e5a8e2d82fb52d87ef4a13c9a405b06986d5d19b170d0fd05328b8ae29f9d92ec0bca80f7b60e7</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec149"/>See also</h2></div></div></div><p>To apply the cryptographic hash functions on data types instead, refer to the <em>Running popular cryptographic hash functions</em> recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec54"/>Performing fast comparisons between data types</h1></div></div></div><p>The<a id="id259" class="indexterm"/> <code class="literal">StableName</code> package<a id="id260" class="indexterm"/> allows us to establish constant time comparisons of arbitrary data types. The Hackage documentation elegantly describes this (<a class="ulink" href="http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html">http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html</a>):</p><div><blockquote class="blockquote"><p><em>"Stable names solve the following problem: suppose you want to build a hash table with Haskell objects as keys, but you want to use pointer equality for comparison; maybe because the keys are large and hashing would be slow, or perhaps because the keys are infinite in size. We can't build a hash table using the address of the object as the key, because objects get moved around by the garbage collector, meaning a re-hash would be necessary after every garbage collection."</em></p></blockquote></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec150"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the built-in <code class="literal">StableName</code> package as follows:<div><pre class="programlisting">import System.Mem.StableName</pre></div></li><li class="listitem">Create a custom data type as follows:<div><pre class="programlisting">data Point = Point [Int]</pre></div></li><li class="listitem">In <code class="literal">main</code>, define two points as follows:<div><pre class="programlisting">  main = do
    let p1 = Point [1..]
    let p2 = Point [2,4]</pre></div></li><li class="listitem">Get the <a id="id261" class="indexterm"/>stable name of each point and display it using the following set of commands:<div><pre class="programlisting">sn1 &lt;- makeStableName p1
sn2 &lt;- makeStableName p2
print $ hashStableName sn1
print $ hashStableName sn2</pre></div></li><li class="listitem">Notice in the following result how we can easily obtain the stable name of arbitrary data types:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>22</strong>
<strong>23</strong>
</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec55"/>Using a high-performance hash table</h1></div></div></div><p>Haskell already <a id="id262" class="indexterm"/>comes with a <a id="id263" class="indexterm"/>
<code class="literal">Data.Map</code> module based on size-balanced binary trees. There exist better-optimized hash table libraries such as <code class="literal">Data.HashMap</code><a id="id264" class="indexterm"/> from the unordered-containers package.</p><p>For example, both <code class="literal">Data.Map</code> and <code class="literal">Data.HashMap</code> have insertion and lookup time complexities of O(log n); however, the latter uses a large base, so in practice these operations are constant time. More documentation on <code class="literal">Data.HashMap</code> can be found at <a class="ulink" href="http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html">http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html</a>.</p><p>In this recipe, we will use the unordered-contains library from Hackage to create a mapping of word size to a set of words of that size.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec151"/>Getting ready</h2></div></div></div><p>Download a large corpus of text and name the file <code class="literal">big.txt</code> as follows:</p><div><pre class="programlisting">
<strong>$ wget norvig.com/big.txt</strong>
</pre></div><p>Install the<a id="id265" class="indexterm"/> <code class="literal">Data.HashMap</code> package using Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install unordered-containers</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec152"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">HashMap</code> package as follows:<div><pre class="programlisting">import Data.HashMap.Lazy
import Data.Set (Set)
import qualified Data.Set as Set</pre></div></li><li class="listitem">Create a <a id="id266" class="indexterm"/>helper function to define an empty hash map using the following line of code:<div><pre class="programlisting">emptyMap = empty :: HashMap Int (Set String)</pre></div></li><li class="listitem">Define a function to insert a word to the hash map using the following code snippet:<div><pre class="programlisting">insertWord m w = insertWith append key val m
  where append new old = Set.union new old 
    key = length w
    val = Set.singleton w</pre></div></li><li class="listitem">Find all words of a specific length from a map as follows:<div><pre class="programlisting">wordsOfLength len m = Set.size(lookupDefault Set.empty len m )</pre></div></li><li class="listitem">Construct the hashmap from a corpus of text using the following line of code:<div><pre class="programlisting">constructMap text = foldl (\m w -&gt; insertWord m w) emptyMap (words text)</pre></div></li><li class="listitem">Read the large corpus of text, construct the hash map, and print the number of words of each length, as shown in the following code snippet:<div><pre class="programlisting">main = do
  text &lt;- readFile "big.txt"
  let m = constructMap text
  print [wordsOfLength s m | s &lt;- [1..30]]</pre></div></li><li class="listitem">The output is as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>[59,385,1821,4173,7308,9806,11104,11503,10174,7948,5823,4024,2586,1597,987,625,416,269,219,139,115,78,51,50,27,14,17,15,11,7]</strong>
</pre></div></li></ol></div><p>If we plot the data, we can discover an interesting trend as shown in the following figure:</p><div><img src="img/6331OS_04_01.jpg" alt="How to do it…"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec153"/>How it works…</h2></div></div></div><p>Technical specifics about the library are explained in the following blog post by the author:</p><p>
<a class="ulink" href="http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html">http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html</a>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec56"/>Using Google's CityHash hash functions for strings</h1></div></div></div><p>Google's CityHash hash functions<a id="id267" class="indexterm"/> are optimized for<a id="id268" class="indexterm"/> hashing strings, but are not meant to be cryptographically secure. CityHash is ideal for implementing a hash table dealing with strings. We will use it in this recipe to produce both 64-bit and 128-bit digests.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec154"/>Getting ready</h2></div></div></div><p>Install the<a id="id269" class="indexterm"/> <code class="literal">cityhash</code> package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install cityhash</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec155"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the relevant packages as follows:<div><pre class="programlisting">import Data.Digest.CityHash
import Data.ByteString.Char8 (pack)
import Data.Word (Word64)
import Data.LargeWord (Word128)</pre></div></li><li class="listitem">Test the <a id="id270" class="indexterm"/>various hashing function on an input string using the following code snippet:<div><pre class="programlisting">main = do
 (pack str) (1 :: Word128)  let str = "cityhash"
  print $ cityHash64 (pack str)
  print $ cityHash64WithSeed (pack str) (1 :: Word64)
  print $ cityHash64WithSeed (pack str) (2 :: Word64)
  print $ cityHash128 (pack str)
  print $ cityHash128WithSeed
  print $ cityHash128WithSeed (pack str) (2 :: Word128)</pre></div></li><li class="listitem">Display the output as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>11900721293443925155</strong>
<strong>10843914211836357278</strong>
<strong>12209340445019361150</strong>
<strong>116468032688941434670559074973810442908</strong>
<strong>218656848647432546431274347445469875003</strong>
<strong>45074952647722073214392556957268553766</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec156"/>How it works…</h2></div></div></div><p>Google describes its package on its blog announcement at <a class="ulink" href="http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html">http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html</a> as follows:</p><div><blockquote class="blockquote"><p><em>"The key advantage of our approach is that most steps contain at least two independent mathematical operations. Modern CPUs tend to perform best with this type of code."</em></p></blockquote></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec157"/>See also</h2></div></div></div><p>To see a more generic hashing function, refer to the <em>Hashing a primitive data type</em> and <em>Hashing a custom data type</em> recipes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec57"/>Computing a Geohash for location coordinates</h1></div></div></div><p>A Geohash is<a id="id271" class="indexterm"/> a practical encoding of latitude-longitude coordinates. It does not behave like a typical hash <a id="id272" class="indexterm"/>function since minor changes in location only produce minor changes in the output digest. Geohash allows efficient proximity search and arbitrary precision determined by the specified length of the digest.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec158"/>Getting ready</h2></div></div></div><p>Install the <a id="id273" class="indexterm"/>Geohashing library as follows:</p><div><pre class="programlisting">
<strong>$ cabal install geohash</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec159"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">Geohash</code> library as follows:<div><pre class="programlisting">import Data.Geohash</pre></div></li><li class="listitem">Create a geohash of a latitude-longitude coordinate pair as follows:<div><pre class="programlisting">  main = do
    let geohash1 = encode 10 (37.775, -122.419)
    putStrLn $ "geohash1 is " ++ (show geohash1)</pre></div></li><li class="listitem">Display the geohash using the following code snippet:<div><pre class="programlisting">case geohash1 of
  Just g -&gt; putStrLn $ "decoding geohash1: " ++ (show.decode) g
  Nothing -&gt; putStrLn "error encoding"</pre></div></li><li class="listitem">Create a geohash of another similar latitude-longitude coordinate pair as follows:<div><pre class="programlisting">let geohash2 = encode 10 (37.175, -125.419)
putStrLn $ "geohash2 is " ++ (show geohash2)</pre></div></li><li class="listitem">Display the geohash using the following code snippet:<div><pre class="programlisting">case geohash2 of
Just g -&gt; putStrLn $ "decoding geohash2: " ++ (show.decode) g
Nothing -&gt; putStrLn "error encoding"</pre></div></li><li class="listitem">The output is as follows. Notice how the geohash appears to share the same prefix due to their closeness.<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>geohash1 is Just "9q8yyk9pqd"</strong>

<strong>decoding geohash1: Just (37.775000631809235,-122.4189966917038)</strong>

<strong>geohash2 is Just "9nwg6p88j6"</strong>

<strong>decoding geohash2: Just (37.175001204013824,-125.4190045595169)</strong>
</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Using a bloom filter to remove unique items</h1></div></div></div><p>A bloom filter<a id="id274" class="indexterm"/> is an abstract data type that tests whether an item exists in a set. Unlike a typical hash map data structure, a bloom filter only takes up a constant amount of space. The advantage comes in handy when dealing with billions of data, such as representations of DNA strands as strings: "GATA", "CTGCTA", and so on.</p><p>In this recipe, we will use a <a id="id275" class="indexterm"/>bloom filter to try to remove unique DNA strands from a list. This is often desired because a typical DNA sample may contain thousands of strands that only appear once. The major disadvantage of a bloom filter is that false positive results for membership are possible. The bloom filter may accidentally claim that an element exists. Though false negatives are not possible: a bloom filter will never claim that an element does not exist when it actually does.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec160"/>Getting ready</h2></div></div></div><p>Import the <a id="id276" class="indexterm"/>bloom filter package from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install bloomfilter</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec161"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the bloom filter package as follows:<div><pre class="programlisting">import Data.BloomFilter (fromListB, elemB, emptyB, insertB)
import Data.BloomFilter.Hash (cheapHashes)
import Data.Map (Map, empty, insertWith)
import qualified Data.Map as Map</pre></div></li><li class="listitem">Create a function to remove the unique elements from a list. First check to see if each item exists in the bloom filter; if so, add it to a hash map. If not, add it to the bloom filter, as presented in the following code snippet:<div><pre class="programlisting">removeUniques strands = foldl bloomMapCheck 
                        (emptyBloom, emptyMap) strands

  where emptyBloom = emptyB (cheapHashes 3) 1024
        emptyMap = empty :: Map String Int
        bloomMapCheck (b, m) x
        | elemB x b = (b, insertWith (+) x 1 m)
        | otherwise = (insertB x b, m)</pre></div></li><li class="listitem">Run the algorithm<a id="id277" class="indexterm"/> on a couple of DNA strand examples as follows:<div><pre class="programlisting">main = do
let strands = ["GAT", "GATC", "CGT", "GAT"
                        , "GAT", "CGT", "GAT", "CGT"]
print $ snd $ removeUniques strands</pre></div></li><li class="listitem">We see the following strands that likely occur at least twice:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>fromList [("CGT",2),("GAT",3)]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec162"/>How it works…</h2></div></div></div><p>A bloom filter <a id="id278" class="indexterm"/>is composed of a couple of hashing functions and a list of numbers initialized at zero. When inserting an element to this data structure, hashes are computed from each of the hashing functions and the corresponding item in the list is updated. Membership tests on a bloom filter are conducted by computing each of the hash functions in the input and testing whether all corresponding list elements are above some threshold value.</p><div><img src="img/6331OS_04_06.jpg" alt="How it works…"/></div><p>For example, in the preceding figure, three hash functions are applied to every input. When a hash is calculated for <strong>x</strong>, <strong>y</strong>, and <strong>z</strong>, the corresponding element in the list representing the bloom filter is incremented. We can <a id="id279" class="indexterm"/>determine whether <strong>w</strong> exists in this bloom filter by computing the three hashes and checking if corresponding indices are all at a desired value. In this case, <strong>w</strong> does not exist in the bloom filter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec59"/>Running MurmurHash, a simple but speedy hashing algorithm</h1></div></div></div><p>Sometimes, the priority of a hashing function should be in maximizing its computation speed. The MurmurHash algorithm<a id="id280" class="indexterm"/> exists for this reason. When dealing with massive <a id="id281" class="indexterm"/>
<strong>data sets</strong>, speed is essential.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>There are negative qualities of a fast hashing algorithm. If hashing algorithm A is 10 times faster than hashing algorithm B, then it's also 10 times faster to stumble upon the content used to create a digest with A than with B using a random content search. A hashing algorithm should be fast, but not so fast as to impact the security of the algorithm.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec163"/>Getting ready</h2></div></div></div><p>Install the <a id="id282" class="indexterm"/>Murmur hashing algorithm from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install murmur-hash</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec164"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the Murmur hashing algorithm as follows:<div><pre class="programlisting">import Data.Digest.Murmur32</pre></div></li><li class="listitem">Define a custom data type and implement an instance to use Murmur as follows:<div><pre class="programlisting">data Point = Point Int Int
  instance (Hashable32 Point) where 
  hash32Add (Point x y) h = x `hash32Add` (y `hash32Add` h)</pre></div></li><li class="listitem">Run the hashing algorithm on various inputs, using the following code snippet:<div><pre class="programlisting">main = do
  let p1 = Point 0 0
  let p2 = Point 2 3
  putStrLn $ "hash of string: " 
                           ++ (show.hash32) "SO FAST WOW."
  putStrLn $ "hash of a data-type: " ++ (show.hash32) p1
  putStrLn $ "hash of another data-type: " ++ (show.hash32) p2</pre></div></li><li class="listitem">The following<a id="id283" class="indexterm"/> hashes are produced:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>hash of string: Hash32 0xa18fa3d2</strong>

<strong>hash of a data-type: Hash32 0x30408e22</strong>

<strong>hash of another data-type: Hash32 0xfda11257</strong>
</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec60"/>Measuring image similarity with perceptual hashes</h1></div></div></div><p>A perceptual hash<a id="id284" class="indexterm"/> produces a small digest from an image file where <a id="id285" class="indexterm"/>slight changes in the images only<a id="id286" class="indexterm"/> produce a slight change in the hash. This can be useful to quickly compare thousands of images.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec165"/>Getting ready</h2></div></div></div><p>Install the <a id="id287" class="indexterm"/>
<code class="literal">pHash</code> library from <a class="ulink" href="http://www.phash.org">www.phash.org</a>. On a Debian-based system, we can install it by using <code class="literal">apt-get</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install libphash0-dev</strong>
</pre></div><p>Install the <code class="literal">phash</code> library from Cabal as follows:</p><div><pre class="programlisting">
<strong>$ cabal install phash</strong>
</pre></div><p>Find three nearly identical images. We will use the following image:</p><div><img src="img/6331OS_04_02.jpg" alt="Getting ready"/></div><p>This is the second<a id="id288" class="indexterm"/> image <a id="id289" class="indexterm"/>that we will be using</p><div><img src="img/6331OS_04_03.jpg" alt="Getting ready"/></div><p>And the<a id="id290" class="indexterm"/> following<a id="id291" class="indexterm"/> image is the third:</p><div><img src="img/6331OS_04_04.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec166"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">phash</code> library as follows:<div><pre class="programlisting">import Data.PHash
import Data.Maybe (fromJust, isJust)</pre></div></li><li class="listitem">Hash <a id="id292" class="indexterm"/>an image as follows:<div><pre class="programlisting">main = do
  phash1 &lt;- imageHash "image1.jpg"
  putStrLn $ "image1: " ++ show phash1</pre></div></li><li class="listitem">Hash a <a id="id293" class="indexterm"/>similar image as follows:<div><pre class="programlisting">  phash2 &lt;- imageHash "image2.jpg"
    putStrLn $ "image2: " ++ show phash2</pre></div></li><li class="listitem">Hash a slightly different image as follows:<div><pre class="programlisting">  phash3 &lt;- imageHash "image3.jpg"
  putStrLn $ "image3: " ++ show phash3</pre></div></li><li class="listitem">Compute<a id="id294" class="indexterm"/> the similarity of the first two images using the following code snippet:<div><pre class="programlisting">  if isJust phash1 &amp;&amp; isJust phash2
    then do putStr "hamming distance between image1 and image2: "
    print $ hammingDistance (fromJust phash1) (fromJust phash2)
  else print "Error, could not read images"</pre></div></li><li class="listitem">Compute <a id="id295" class="indexterm"/>the similarity of the first to the third image as follows:<div><pre class="programlisting">  if isJust phash1 &amp;&amp; isJust phash3
    then do putStr "hamming distance between image1 and image3: "
    print $ hammingDistance 
    (fromJust phash1) (fromJust phash3)
  else print "Error, could not read images"</pre></div></li><li class="listitem">The output hashes are as follows:<div><pre class="programlisting">
<strong>$ runhaskell Main.hs</strong>

<strong>image1: Just (PHash 14057618708811251228)</strong>

<strong>image2: Just (PHash 14488838648009883164)</strong>

<strong>image3: Just (PHash 9589915937059962524)</strong>

<strong>hamming distance between image1 and image2: 4</strong>

<strong>hamming distance between image1 and image3: 10</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec167"/>How it works…</h2></div></div></div><p>It's much easier to visualize how similar these hashes are in hexadecimal (or binary), since Hamming distance operates in bits.</p><p>The hexadecimal representation of the three images are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Image 1</strong>: c316b1bc36947e1c</li><li class="listitem" style="list-style-type: disc"><strong>Image 2</strong>: c912b1fc36947e1c</li><li class="listitem" style="list-style-type: disc"><strong>Image 3</strong>: 851639bc3650fe9c</li></ul></div><p>By comparing these values, we can see that images 1 and 2 differ by only four, whereas images 1 and 3 differ by a whopping 10 characters.</p></div></div></body></html>