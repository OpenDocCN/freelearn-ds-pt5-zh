<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Object-Oriented Scala</h1>
                
            
            
                
<div><em class="calibre8">"The object-oriented model makes it easy to build up programs by accretion. What this often means, in practice, is that it provides a structured way to write spaghetti code."</em></div>
<p class="cdpalignright">- Paul Graham</p>
<p class="mce-root">In the previous chapter, we looked at how to get programming started with Scala. Well, if you're writing the procedural program that we followed in the previous chapter, you can enforce the code reusability by creating procedures or functions. However, if you continue working, consequently, your program gets longer, bigger, and more complex. At a certain point, you will not even have any other more simple way to organize the entire code before production.</p>
<p class="mce-root">On the contrary, the <strong class="calibre1">object-oriented programming</strong> (<strong class="calibre1">OOP</strong>) paradigm provides a whole new layer of abstraction. You can then modularize your code through defining OOP entities such as classes with related properties and methods. You can even define the relationship between those entities by utilizing inheritance or an interface. You can also group similar classes holding similar functionality together, as a helper class maybe; therefore, making your project suddenly feels more spacious and extensible. In short, the greatest strengths of OOP languages are discoverability, modularity, and extensibility.</p>
<p class="mce-root">Considering the preceding features of OOP languages, in this chapter, we will discuss the basic object-oriented features in Scala. In a nutshell, the following topics will be covered in this chapter:</p>
<ul class="calibre9">
<li class="mce-root1">Variables in Scala</li>
<li class="mce-root1">Methods, classes, and objects in Scala</li>
<li class="mce-root1">Packages and package objects</li>
<li class="mce-root1">Traits and trait linearization</li>
<li class="mce-root1">Java Interoperability</li>
</ul>
<p class="mce-root">Then, we will discuss pattern matching, which is a feature that comes from functional programming concepts. Moreover, we will discuss some built-in concepts in Scala, such as implicit and generics. Finally, we will discuss some widely used build tools that are needed for building our Scala applications into jars.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variables in Scala</h1>
                
            
            
                
<p class="mce-root">Before entering into the depth of OOP features, first, we need to know details about the different types of variables and data types in Scala. To declare a variable in Scala, you need to use <kbd class="calibre11">var</kbd> or <kbd class="calibre11">val</kbd> keywords. The formal syntax of declaring a variable in Scala is as follows:</p>
<pre class="calibre19">
val or var VariableName : DataType = Initial_Value
</pre>
<p class="mce-root">For example, let's see how can we declare two variables whose data types are explicitly specified as follows:</p>
<pre class="calibre19">
var myVar : Int = 50<br class="title-page-name"/>val myVal : String = "Hello World! I've started learning Scala."
</pre>
<p class="mce-root">You can even just declare a variable without specifying the <kbd class="calibre11">DataType</kbd>. For example, let's see how to declare a variable using <kbd class="calibre11">val</kbd> or <kbd class="calibre11">var</kbd>, as follows:</p>
<pre class="calibre19">
var myVar = 50<br class="title-page-name"/>val myVal = "Hello World! I've started learning Scala."
</pre>
<p class="mce-root">There are two types of variables in Scala: mutable and immutable that can be defined as follows:</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Mutable:</strong> The ones whose values you can change later</li>
<li class="mce-root1"><strong class="calibre1">Immutable:</strong> The ones whose values you cannot change once they have been set</li>
</ul>
<p class="mce-root">In general, for declaring a mutable variable, a <kbd class="calibre11">var</kbd> keyword is used. On the other hand, for specifying an immutable variable, a <kbd class="calibre11">val</kbd> keyword is used. To show an example of using the mutable and immutable variables, let's consider the following code segment:</p>
<pre class="calibre19">
package com.chapter3.OOP <br class="title-page-name"/>object VariablesDemo {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    var myVar : Int = 50 <br class="title-page-name"/>    valmyVal : String = "Hello World! I've started learning Scala."  <br class="title-page-name"/>    myVar = 90  <br class="title-page-name"/>    myVal = "Hello world!"   <br class="title-page-name"/>    println(myVar) <br class="title-page-name"/>    println(myVal) <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="mce-root">The preceding code works fine until <kbd class="calibre11">myVar = 90</kbd>, since <strong class="calibre1"><kbd class="calibre11">myVar</kbd></strong> is a mutable variable. However, if you try to change the value of the immutable variable (that is, <kbd class="calibre11">myVal</kbd>), as shown earlier, your IDE will show a compilation error saying reassignment to <kbd class="calibre11">val</kbd>, as follows:</p>
<div><img class="image-border11" src="img/00202.jpeg"/></div>
<div><strong class="calibre1">Figure 1:</strong> Reassignment of immutable variables is not allowed in Scala variable scope</div>
<p class="mce-root">Don't worry looking at the preceding code with the object and method! We will discuss classes, methods, and objects later in this chapter, then things will become more clear.</p>
<p class="mce-root">In Scala variables, we can have three different scopes, depending on the place where you have declared them:</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Fields:</strong> These are variables that belong to an instance of a class of your Scala code. The fields are, therefore, accessible from inside every method in the object. However, depending on the access modifiers, fields can be accessible to instances of the other classes.</li>
</ul>
<p>As discussed earlier, object fields can be mutable or they can be immutable (based on the declaration types using either <kbd class="calibre22">var</kbd> or <kbd class="calibre22">val</kbd>). But, they can't be both at the same time.</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Method arguments:</strong> These are variables, and when the method is called, these can be used to pass the value inside a method. Method parameters are accessible only from inside the method. However, the objects being passed in may be accessible from the outside.</li>
</ul>
<p>It is to be noted that method parameters/arguments are always immutable, no matter what is/are the keyword(s) specified.</p>
<ul class="calibre9">
<li class="mce-root1"><strong class="calibre1">Local variables:</strong> These variables are declared inside a method and are accessible from the inside the method itself. However, the calling code can access the returned value.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reference versus value immutability</h1>
                
            
            
                
<p class="mce-root">According to the section earlier, <kbd class="calibre11">val</kbd> is used to declare immutable variables, so can we change the values of these variables? Will it be similar to the final keyword in Java? To help us understand more about this, we will use the following code snippet:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; var testVar = 10</strong><br class="title-page-name"/><strong class="calibre1">testVar: Int = 10</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; testVar = testVar + 10</strong><br class="title-page-name"/><strong class="calibre1">testVar: Int = 20</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val testVal = 6</strong><br class="title-page-name"/><strong class="calibre1">testVal: Int = 6</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; testVal = testVal + 10</strong><br class="title-page-name"/><strong class="calibre1">&lt;console&gt;:12: error: reassignment to val</strong><br class="title-page-name"/><strong class="calibre1">       testVal = testVal + 10</strong><br class="title-page-name"/><strong class="calibre1">               ^</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">If you run the preceding code, an error at compilation time will be noticed, which will tell you that you are trying to reassign to a <kbd class="calibre11">val</kbd> variable. In general, mutable variables bring a performance advantage. The reason is that this is closer to how the computer behaves and because introducing immutable values forces the computer to create a whole new instance of an object whenever a change (no matter how small) to a particular instance is required</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Data types in Scala</h1>
                
            
            
                
<p class="mce-root">As mentioned, Scala is a JVM language, so it shares lots in common with Java. One of these commonalities is the data types; Scala shares the same data types with Java. In short, Scala has all the same data types as Java, with the same memory footprint and precision. As mentioned in <a href="part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 1</a>, <em class="calibre8">Introduction to Scala</em>, objects are almost everywhere in Scala. and all data types are objects and you can call methods in them as follows:</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Sr.No</strong></p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Data Type and Description</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">1</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Byte</strong>: 8 bit signed value. Ranges from -128 to 127</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">2</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Short</strong>: 16 bit signed value. Ranges -32768 to 32767</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">3</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Int</strong>: 32 bit signed value. Ranges -2147483648 to 2147483647</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">4</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Long</strong>: 64 bit signed value. -9223372036854775808 to 9223372036854775807</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">5</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Float</strong>: 32 bit IEEE 754 single-precision float</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">6</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Double</strong>: 64 bit IEEE 754 double-precision float</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">7</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Char</strong>: 16 bit unsigned Unicode character. Range from U+0000 to U+FFFF</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">8</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">String</strong>: A sequence of Chars</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">9</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Boolean</strong>: Either the literal <kbd class="calibre11">true</kbd> or the literal <kbd class="calibre11">false</kbd></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">10</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Unit</strong>: Corresponds to no value</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">11</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Null</strong>: Null or empty reference</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">12</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Nothing</strong>: The subtype of every other type; includes no values</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">13</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">Any</strong>: The supertype of any type; any object is of type <em class="calibre8">Any</em></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="mce-root">14</p>
</td>
<td class="calibre7">
<p class="mce-root"><strong class="calibre1">AnyRef</strong>: The supertype of any reference type</p>
</td>
</tr>
</tbody>
</table>
<div><strong class="calibre1">Table 1:</strong> Scala data types, description, and range</div>
<p class="mce-root">All the data types listed in the preceding table are objects. However, note that there are no primitive types, as in Java. This means that you can call methods on an <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">Long</kbd>, and so on.</p>
<pre class="calibre19">
val myVal = 20<br class="title-page-name"/>//use println method to print it to the console; you will also notice that if will be inferred as Int<br class="title-page-name"/>println(myVal + 10)<br class="title-page-name"/>val myVal = 40<br class="title-page-name"/>println(myVal * "test")
</pre>
<p class="mce-root">Now, you can start playing around with these variables. Let's get some ideas on how to initialize a variable and work on the type annotations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variable initialization</h1>
                
            
            
                
<p class="mce-root">In Scala, it's a good practice to initialize the variables once declared. However, it is to be noted that uninitialized variables aren't necessarily nulls (consider types like <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">Long</kbd>, <kbd class="calibre11">Double</kbd>, <kbd class="calibre11">Char</kbd>, and so on), and initialized variables aren't necessarily non-null (for example, <kbd class="calibre11">val s: String = null</kbd>). The actual reasons are that:</p>
<ul class="calibre9">
<li class="mce-root1">In Scala, types are inferred from the assigned value. This means that a value must be assigned for the compiler to infer the type (how should the compiler consider this code: <kbd class="calibre11">val a</kbd>? Since a value isn't given, the compiler can't infer the type; since it can't infer the type, it wouldn't know how to initialize it).</li>
<li class="mce-root1">In Scala, most of the time, you'll use <kbd class="calibre11">val</kbd>. Since these are immutable, you wouldn't be able to declare them and then initialize them afterward.</li>
</ul>
<p class="mce-root">Although, Scala language requires you to initialize your instance variable before using it, Scala does not provide a default value for your variable. Instead, you have to set up its value manually using the wildcard underscore, which acts like a default value, as follows:</p>
<pre class="calibre19">
var name:String = _
</pre>
<p class="mce-root">Instead of using the names, such as <kbd class="calibre11">val1</kbd>, <kbd class="calibre11">val2</kbd> and so on, you can define your own names:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val result = 6 * 5 + 8</strong><br class="title-page-name"/><strong class="calibre1">result: Int = 38</strong>
</pre>
<p class="mce-root">You can use these names in subsequent expressions, as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; 0.5 * result</strong><br class="title-page-name"/><strong class="calibre1">res0: Double = 19.0</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Type annotations</h1>
                
            
            
                
<p class="mce-root">If you use a <kbd class="calibre11">val</kbd> or <kbd class="calibre11">var</kbd> keyword to declare a variable, its data type will be inferred automatically according to the value that you assigned to this variable. You also have the luxury of explicitly stating the data type of the variable at declaration time.</p>
<pre class="calibre19">
val myVal : Integer = 10
</pre>
<p class="mce-root">Now, let's look at some other aspects that will be needed while working with variables and data types in Scala. We will see how to work with type ascription and <kbd class="calibre11">lazy</kbd> variables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Type ascription</h1>
                
            
            
                
<p class="mce-root">Type ascription is used to tell the compiler what types you expect out of an expression, from all possible valid types. Consequently, a type is valid if it respects existing constraints, such as variance and type declarations, and it is either one of the types the expression it applies to "is a," or there's a conversion that applies in scope. So, technically, <kbd class="calibre11">java.lang.String</kbd> extends <kbd class="calibre11">java.lang.Object</kbd>, therefore any <kbd class="calibre11">String</kbd> is also an <kbd class="calibre11">Object</kbd>. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val s = "Ahmed Shadman" </strong><br class="title-page-name"/><strong class="calibre1">s: String = Ahmed Shadman</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; val p = s:Object </strong><br class="title-page-name"/><strong class="calibre1">p: Object = Ahmed Shadman </strong><br class="title-page-name"/> <br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lazy val</h1>
                
            
            
                
<p class="mce-root">The main characteristic of a <kbd class="calibre11">lazy val</kbd> is that the bound expression is not evaluated immediately, but once on the first access. Here's where the main difference between <kbd class="calibre11">val</kbd> and <kbd class="calibre11">lazy val</kbd> lies. When the initial access happens, the expression is evaluated and the result is bound to the identifier, the <kbd class="calibre11">lazy val</kbd>. On subsequent access, no further evaluation occurs, instead, the stored result is returned immediately. Let's see an interesting example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; lazy val num = 1 / 0</strong><br class="title-page-name"/><strong class="calibre1">num: Int = &lt;lazy&gt;</strong>
</pre>
<p class="mce-root">If you look at the preceding code in Scala REPL, you will notice that the code runs very well without throwing any errors, even though you divided an integer with 0! Let's see a better example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; val x = {println("x"); 20}</strong><br class="title-page-name"/><strong class="calibre1">x</strong><br class="title-page-name"/><strong class="calibre1">x: Int = 20</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; x</strong><br class="title-page-name"/><strong class="calibre1">res1: Int = 20</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">This works and, later on, you can access the value of variable <kbd class="calibre11">x</kbd> when required. These are just a few examples of using lazy <kbd class="calibre11">val</kbd> concepts. Interested readers should access this page for more details: <a href="https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/" class="calibre10">https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Methods, classes, and objects in Scala</h1>
                
            
            
                
<p class="mce-root">In the previous section, we saw how to work with Scala variables, different data types and their mutability and immutability, along with their usages scopes. However, in this section, to get the real flavor of the OOP concept, we are going to deal with methods, objects, and classes. These three features of Scala will help us understand the object-oriented nature of Scala and its features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Methods in Scala</h1>
                
            
            
                
<p class="mce-root">In this part, we are going to talk about methods in Scala. As you dive into Scala, you'll find that there are lots of ways to define methods in Scala. We will demonstrate them in some of these ways:</p>
<pre class="calibre19">
def min(x1:Int, x2:Int) : Int = {<br class="title-page-name"/>  if (x1 &lt; x2) x1 else x2<br class="title-page-name"/>}
</pre>
<p class="mce-root">The preceding declaration of the method takes two variables and returns the smallest among them. In Scala, all the methods must start with the def keyword, which is then followed by a name for this method. Optionally, you can decide not to pass any parameters to the method or even decide not to return anything. You're probably wondering how the smallest value is returned, but we will get to this later. Also, in Scala, you can define methods without curly braces:</p>
<pre class="calibre19">
def min(x1:Int, x2:Int):Int= if (x1 &lt; x2) x1 else x2
</pre>
<p class="mce-root">If your method has a small body, you can declare your method like this. Otherwise, it's preferred to use the curly braces in order to avoid confusion. As mentioned earlier, you can pass no parameters to the method if needed:</p>
<pre class="calibre19">
def getPiValue(): Double = 3.14159
</pre>
<p class="mce-root">A method with or without parentheses signals the absence or presence of a side effect. Moreover, it has a deep connection with the uniform access principle. Thus, you can also avoid the braces as follows:</p>
<pre class="calibre19">
def getValueOfPi : Double = 3.14159
</pre>
<p class="mce-root">There are also some methods which return the value by explicitly mentioning the return types. For example:</p>
<pre class="calibre19">
def sayHello(person :String) = "Hello " + person + "!"
</pre>
<p class="mce-root">It should be mentioned that the preceding code works due to the Scala compiler, which is able to infer the return type, just as with values and variables.</p>
<p class="mce-root">This will return <kbd class="calibre11">Hello</kbd> concatenated with the passed person name. For example:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def sayHello(person :String) = "Hello " + person + "!"</strong><br class="title-page-name"/><strong class="calibre1">sayHello: (person: String)String</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; sayHello("Asif")</strong><br class="title-page-name"/><strong class="calibre1">res2: String = Hello Asif!</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The return in Scala</h1>
                
            
            
                
<p class="mce-root">Before learning how a Scala method returns a value, let's recap the structure of a method in Scala:</p>
<pre class="calibre19">
def functionName ([list of parameters]) : [return type] = {<br class="title-page-name"/>  function body<br class="title-page-name"/>  value_to_return<br class="title-page-name"/>}
</pre>
<p class="mce-root">For the preceding syntax, the return type could be any valid Scala data type and a list of parameters will be a list of variables separated by a comma and a list of parameters and return type is optional. Now, let's define a method that adds two positive integers and returns the result, which is also an integer value:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def addInt( x:Int, y:Int ) : Int = {</strong><br class="title-page-name"/><strong class="calibre1">     |       var sum:Int = 0</strong><br class="title-page-name"/><strong class="calibre1">     |       sum = x + y</strong><br class="title-page-name"/><strong class="calibre1">     |       sum</strong><br class="title-page-name"/><strong class="calibre1">     |    }</strong><br class="title-page-name"/><strong class="calibre1">addInt: (x: Int, y: Int)Int</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; addInt(20, 34)</strong><br class="title-page-name"/><strong class="calibre1">res3: Int = 54</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">If you now call the preceding method from the <kbd class="calibre11">main()</kbd> method with the real values, such as <kbd class="calibre11">addInt(10, 30)</kbd>, the method will return an integer value sum, which is equal to <kbd class="calibre11">40</kbd>. As using the keyword <kbd class="calibre11">return</kbd> is optional, the Scala compiler is designed such that the last assignment will be returned with the absence of the <kbd class="calibre11">return</kbd> keyword. As in this situation, the greater value will be returned:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def max(x1 : Int , x2: Int)  = {</strong><br class="title-page-name"/><strong class="calibre1">     |     if (x1&gt;x2) x1 else x2</strong><br class="title-page-name"/><strong class="calibre1">     | }</strong><br class="title-page-name"/><strong class="calibre1">max: (x1: Int, x2: Int)Int</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; max(12, 27)</strong><br class="title-page-name"/><strong class="calibre1">res4: Int = 27</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">Well done! We have seen how to use variables and how to declare a method in Scala REPL. Now, its time to see how to encapsulate them inside Scala methods and classes. The next section discusses Scala objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Classes in Scala</h1>
                
            
            
                
<p class="mce-root">Classes are considered as a blueprint and then you instantiate this class in order to create something that will actually be represented in memory. They can contain methods, values, variables, types, objects, traits, and classes which are collectively called <strong class="calibre1">members</strong>. Let's demonstrate this with the following example:</p>
<pre class="calibre19">
class Animal {<br class="title-page-name"/>  var animalName = null<br class="title-page-name"/>  var animalAge = -1<br class="title-page-name"/>  def setAnimalName (animalName:String)  {<br class="title-page-name"/>    this.animalName = animalName<br class="title-page-name"/>  }<br class="title-page-name"/>  def setAnaimalAge (animalAge:Int) {<br class="title-page-name"/>    this.animalAge = animalAge<br class="title-page-name"/>  }<br class="title-page-name"/>  def getAnimalName () : String = {<br class="title-page-name"/>    animalName<br class="title-page-name"/>  }<br class="title-page-name"/>  def getAnimalAge () : Int = {<br class="title-page-name"/>    animalAge<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">We have two variables <kbd class="calibre11">animalName</kbd> and <kbd class="calibre11">animalAge</kbd> with their setters and getters. Now, how do we use them to solve our purpose? Here come the usages of Scala objects. Now, we will discuss Scala objects, then we will trace back to our next discussion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Objects in Scala</h1>
                
            
            
                
<p class="mce-root">An <strong class="calibre1">object</strong> in Scala has a slightly different meaning than the traditional OOP one, and this difference should be explained. In particular, in OOP, an object is an instance of a class, while in Scala, anything that is declared as an object cannot be instantiated! The <kbd class="calibre11">object</kbd> is a keyword in Scala. The basic syntax for declaring an object in Scala is as follows:</p>
<pre class="calibre19">
object &lt;identifier&gt; [extends &lt;identifier&gt;] [{ fields, methods, and classes }]
</pre>
<p class="mce-root">To understand the preceding syntax, let's revisit the hello world program:</p>
<pre class="calibre19">
object HelloWorld {<br class="title-page-name"/>  def main(args : Array[String]){<br class="title-page-name"/>    println("Hello world!")<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">This hello world example is pretty similar to the Java ones. The only big difference is that the main method is not inside a class, but instead it's inside an object. In Scala, the keyword object can mean two different things:</p>
<ul class="calibre9">
<li class="mce-root1">As in OOP, an object can represent an instance of a class</li>
<li class="mce-root1">A keyword for depicting a very different type of instance object called <strong class="calibre1">Singleton</strong></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Singleton and companion objects</h1>
                
            
            
                
<p class="mce-root">In this subsection, we will see a comparative analysis between the singleton object in Scala and Java. The idea beneath the singleton pattern is to have an implementation that makes sure that only a single instance of a class can exist. Here's an example of the Singleton pattern in Java:</p>
<pre class="calibre19">
public class DBConnection {<br class="title-page-name"/>  private static DBConnection dbInstance;<br class="title-page-name"/>  private DBConnection() {<br class="title-page-name"/>  }<br class="title-page-name"/>  public static DBConnection getInstance() {<br class="title-page-name"/>    if (dbInstance == null) {<br class="title-page-name"/>      dbInstance = new DBConnection();<br class="title-page-name"/>    }<br class="title-page-name"/>    return dbInstance;<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">The Scala object does a similar thing, and it's well taken care of by the compiler. Since there will be only one instance, there is no way for object creation here:</p>
<div><img class="image-border12" src="img/00215.jpeg"/></div>
<div><strong class="calibre1">Figure 3:</strong> Object creation in Scala</div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Companion objects</h1>
                
            
            
                
<p class="mce-root">When a <kbd class="calibre11">singleton object</kbd> is named the same as a class, it is called a <kbd class="calibre11">companion object</kbd>. A companion object must be defined inside the same source file as the class. Let's demonstrate this with the example here:</p>
<pre class="calibre19">
class Animal {<br class="title-page-name"/>  var animalName:String  = "notset"<br class="title-page-name"/>  def setAnimalName(name: String) {<br class="title-page-name"/>    animalName = name<br class="title-page-name"/>  }<br class="title-page-name"/>  def getAnimalName: String = {<br class="title-page-name"/>    animalName<br class="title-page-name"/>  }<br class="title-page-name"/>  def isAnimalNameSet: Boolean = {<br class="title-page-name"/>    if (getAnimalName == "notset") false else true<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">The following is the way that you will call methods through the companion object (preferably with the same name - that is, <kbd class="calibre11">Animal</kbd>):</p>
<pre class="calibre19">
object Animal{<br class="title-page-name"/>  def main(args: Array[String]): Unit= {<br class="title-page-name"/>    val obj: Animal = new Animal<br class="title-page-name"/>    var flag:Boolean  = false        <br class="title-page-name"/>    obj.setAnimalName("dog")<br class="title-page-name"/>    flag = obj.isAnimalNameSet<br class="title-page-name"/>    println(flag)  // prints true <br class="title-page-name"/>             <br class="title-page-name"/>    obj.setAnimalName("notset")<br class="title-page-name"/>    flag = obj.isAnimalNameSet<br class="title-page-name"/>    println(flag)   // prints false     <br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">A Java equivalent would be very similar, as follows:</p>
<pre class="calibre19">
public class Animal {<br class="title-page-name"/>  public String animalName = "null";<br class="title-page-name"/>  public void setAnimalName(String animalName) {<br class="title-page-name"/>    this.animalName = animalName;<br class="title-page-name"/>  }<br class="title-page-name"/>  public String getAnimalName() {<br class="title-page-name"/>    return animalName;<br class="title-page-name"/>  }<br class="title-page-name"/>  public boolean isAnimalNameSet() {<br class="title-page-name"/>    if (getAnimalName() == "notset") {<br class="title-page-name"/>      return false;<br class="title-page-name"/>    } else {<br class="title-page-name"/>      return true;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    Animal obj = new Animal();<br class="title-page-name"/>    boolean flag = false;         <br class="title-page-name"/>    obj.setAnimalName("dog");<br class="title-page-name"/>    flag = obj.isAnimalNameSet();<br class="title-page-name"/>    System.out.println(flag);        <br class="title-page-name"/>        <br class="title-page-name"/>    obj.setAnimalName("notset");<br class="title-page-name"/>    flag = obj.isAnimalNameSet();<br class="title-page-name"/>    System.out.println(flag);<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Well done! So far, we have seen how to work with Scala objects and classes. However, working with the method for implementing and solving your data analytics problem is even more important. Thus, we will now see how to work with Scala methods in brief.</p>
<pre class="calibre19">
object RunAnimalExample {<br class="title-page-name"/>  val animalObj = new Animal<br class="title-page-name"/>  println(animalObj.getAnimalName) //prints the initial name<br class="title-page-name"/>  println(animalObj.getAnimalAge) //prints the initial age<br class="title-page-name"/>  // Now try setting the values of animal name and age as follows:   <br class="title-page-name"/>  animalObj.setAnimalName("dog") //setting animal name<br class="title-page-name"/>  animalObj.setAnaimalAge(10) //seting animal age<br class="title-page-name"/>  println(animalObj.getAnimalName) //prints the new name of the animal <br class="title-page-name"/>  println(animalObj.getAnimalAge) //Prints the new age of the animal<br class="title-page-name"/>}
</pre>
<p class="mce-root">The output is as follows:</p>
<pre class="calibre19">
<strong class="calibre1">notset </strong><br class="title-page-name"/><strong class="calibre1">-1 </strong><br class="title-page-name"/><strong class="calibre1">dog </strong><br class="title-page-name"/><strong class="calibre1">10</strong>
</pre>
<p class="mce-root">Now, let's have a brief overview on the accessibility and the visibility of the Scala classes in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Comparing and contrasting: val and final</h1>
                
            
            
                
<p class="mce-root">Just like Java, the final keyword also exists in Scala, which works somehow similar to the val keyword. In order to differentiate between the <kbd class="calibre11">val</kbd> and <kbd class="calibre11">final</kbd> keywords in Scala, let's declare a simple animal class, as follows:</p>
<pre class="calibre19">
class Animal {<br class="title-page-name"/>  val age = 2  <br class="title-page-name"/>}
</pre>
<p class="mce-root">As mentioned in <a href="part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 1</a>, <em class="calibre8">Introduction to Scala</em>, while listing Scala features, Scala can override variables which don't exist in Java:</p>
<pre class="calibre19">
class Cat extends Animal{<br class="title-page-name"/>  override val age = 3<br class="title-page-name"/>  def printAge ={<br class="title-page-name"/>    println(age)<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, before going deeper, a quick discussion on the keyword <kbd class="calibre11">extends</kbd> is a mandate. Refer to the following information box for details.</p>
<p>Using Scala, classes can be extensible. A subclass mechanism using the extends keyword makes it possible to <em class="calibre25">specialize</em> a class by inheriting all members of a given <em class="calibre25">superclass</em> and defining additional class members. Let's look at an example, as follows:<br class="calibre23"/>
<kbd class="calibre22">class Coordinate(xc: Int, yc: Int) {</kbd><br class="calibre23"/>
<kbd class="calibre22">val x: Int = xc</kbd><br class="calibre23"/>
<kbd class="calibre22">val y: Int = yc</kbd><br class="calibre23"/>
<kbd class="calibre22">def move(dx: Int, dy: Int): Coordinate = new Coordinate(x + dx, y + dy)</kbd><br class="calibre23"/>
<kbd class="calibre22">}</kbd><br class="calibre23"/>
<kbd class="calibre22">class ColorCoordinate(u: Int, v: Int, c: String) extends Coordinate(u, v) {</kbd><br class="calibre23"/>
<kbd class="calibre22">val color: String = c</kbd><br class="calibre23"/>
<kbd class="calibre22">def compareWith(pt: ColorCoordinate): Boolean = (pt.x == x) &amp;&amp; (pt.y == y) &amp;&amp; (pt.color == color)</kbd><br class="calibre23"/>
<kbd class="calibre22">override def move(dx: Int, dy: Int): ColorCoordinate = new ColorCoordinate(x + dy, y + dy, color)</kbd><br class="calibre23"/>
<kbd class="calibre22">}</kbd></p>
<p class="mce-root">However, if we declared the age variable as final in the <kbd class="calibre11">Animal</kbd> class, then the <kbd class="calibre11">Cat</kbd> class will not be able to override it, and it will give the following error. For this <kbd class="calibre11">Animal</kbd> example, you should have learned when to use the <kbd class="calibre11">final</kbd> keyword. Let's see an example of this:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; class Animal {</strong><br class="title-page-name"/><strong class="calibre1">     |     final val age = 3</strong><br class="title-page-name"/><strong class="calibre1">     | }</strong><br class="title-page-name"/><strong class="calibre1">defined class Animal</strong><br class="title-page-name"/><strong class="calibre1">scala&gt; class Cat extends Animal {</strong><br class="title-page-name"/><strong class="calibre1">     |     override val age = 5</strong><br class="title-page-name"/><strong class="calibre1">     | }</strong><br class="title-page-name"/><strong class="calibre1">&lt;console&gt;:13: error: overriding value age in class Animal of type Int(3);</strong><br class="title-page-name"/><strong class="calibre1"> value age cannot override final member</strong><br class="title-page-name"/><strong class="calibre1">           override val age = 5</strong><br class="title-page-name"/><strong class="calibre1">                        ^</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">Well done! To achieve the best encapsulation - also called information hiding - you should always declare methods with the least visibility that works. In the next subsection, we will learn how the access and visibility of classes, companion objects, packages, subclasses, and projects work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Access and visibility</h1>
                
            
            
                
<p class="mce-root">In this subsection, we will try to understand the access and visibility of Scala variables and different data types in the OOP paradigm. Let's have a look at access modifiers in Scala. A similar one for Scala:</p>
<table class="calibre24">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7"><strong class="calibre1">Modifier</strong></td>
<td class="calibre7"><strong class="calibre1">Class</strong></td>
<td class="calibre7"><strong class="calibre1">Companion Object</strong></td>
<td class="calibre7"><strong class="calibre1">Package</strong></td>
<td class="calibre7"><strong class="calibre1">Subclass</strong></td>
<td class="calibre7"><strong class="calibre1">Project</strong></td>
</tr>
<tr class="calibre6">
<td class="calibre7">Default/No modifier</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Protected</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
<td class="calibre7">No</td>
<td class="calibre7">No</td>
</tr>
<tr class="calibre6">
<td class="calibre7">Private</td>
<td class="calibre7">Yes</td>
<td class="calibre7">Yes</td>
<td class="calibre7">No</td>
<td class="calibre7">No</td>
<td class="calibre7">No</td>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root"><strong class="calibre1">Public members</strong>: Unlike a private and protected member, it is not required to specify the public keyword for public members. There is no explicit modifier for public members. Such members can be accessed from anywhere. For example:</p>
<pre class="calibre19">
class OuterClass { //Outer class<br class="title-page-name"/>  class InnerClass {<br class="title-page-name"/>    def printName() { println("My name is Asif Karim!") }<br class="title-page-name"/>      <br class="title-page-name"/>    class InnerMost { //Inner class<br class="title-page-name"/>      printName() // OK<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  (new InnerClass).printName() // OK because now printName() is public<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>
</pre>
<p class="mce-root"><strong class="calibre1">Private members</strong>: A private member is visible only inside the class or object that contains the member definition. Let's see an example, as follows:</p>
<pre class="calibre19">
package MyPackage {<br class="title-page-name"/>  class SuperClass {<br class="title-page-name"/>    private def printName() { println("Hello world, my name is Asif Karim!") }<br class="title-page-name"/>  }   <br class="title-page-name"/>  class SubClass extends SuperClass {<br class="title-page-name"/>    printName() //ERROR<br class="title-page-name"/>  }   <br class="title-page-name"/>  class SubsubClass {<br class="title-page-name"/>    (new SuperClass).printName() // Error: printName is not accessible<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root"><strong class="calibre1">Protected members</strong>: A protected member is only accessible from subclasses of the class in which the member is defined. Let's see an example, as follows:</p>
<pre class="calibre19">
package MyPackage {<br class="title-page-name"/>  class SuperClass {<br class="title-page-name"/>    protected def printName() { println("Hello world, my name is Asif<br class="title-page-name"/>                                         Karim!") }<br class="title-page-name"/>  }   <br class="title-page-name"/>  class SubClass extends SuperClass {<br class="title-page-name"/>    printName()  //OK<br class="title-page-name"/>  }   <br class="title-page-name"/>  class SubsubClass {<br class="title-page-name"/>    (new SuperClass).printName() // ERROR: printName is not accessible<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Access modifiers in Scala can be augmented with qualifiers. A modifier of the form <kbd class="calibre11">private[X]</kbd> or <kbd class="calibre11">protected[X]</kbd> means that access is private or protected up to <kbd class="calibre11">X</kbd>, where <kbd class="calibre11">X</kbd> designates an enclosing package, class, or singleton object. Let's see an example:</p>
<pre class="calibre19">
package Country {<br class="title-page-name"/>  package Professional {<br class="title-page-name"/>    class Executive {<br class="title-page-name"/>      private[Professional] var jobTitle = "Big Data Engineer"<br class="title-page-name"/>      private[Country] var friend = "Saroar Zahan" <br class="title-page-name"/>      protected[this] var secret = "Age"<br class="title-page-name"/><br class="title-page-name"/>      def getInfo(another : Executive) {<br class="title-page-name"/>        println(another.jobTitle)<br class="title-page-name"/>        println(another.friend)<br class="title-page-name"/>        println(another.secret) //ERROR<br class="title-page-name"/>        println(this.secret) // OK<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Here's a short note on the preceding code segment:</p>
<ul class="calibre9">
<li class="mce-root1">Variable <kbd class="calibre11">jboTitle</kbd> will be accessible to any class within the enclosing package <kbd class="calibre11">Professional</kbd></li>
<li class="mce-root1">Variable <kbd class="calibre11">friend</kbd> will be accessible to any class within the enclosing package <kbd class="calibre11">Country</kbd></li>
<li class="mce-root1">Variable <kbd class="calibre11">secret</kbd> will be accessible only to the implicit object within instance methods (this) only</li>
</ul>
<p class="mce-root">If you look at the preceding examples, we used the keyword <kbd class="calibre11">package</kbd>. However, we have not discussed this so far. But don't worry; there will be a dedicated section later in this chapter. The constructor is a strong feature for any objected-oriented programming language. Scala is not an exception. Now, let's have a short overview of the constructor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Constructors</h1>
                
            
            
                
<p class="mce-root">The concept and the usage of constructors in Scala are a little different than what they are in C# or Java. There are two types of constructors in Scala - primary and auxiliary constructors. The primary constructor is the class's body, and it's parameter list appears right after the class name.</p>
<p class="mce-root">For example, the following code segment describes the way to use the primary constructor in Scala:</p>
<pre class="calibre19">
class Animal (animalName:String, animalAge:Int) {<br class="title-page-name"/>  def getAnimalName () : String = {<br class="title-page-name"/>    animalName<br class="title-page-name"/>  }<br class="title-page-name"/>  def getAnimalAge () : Int = {<br class="title-page-name"/>    animalAge<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, to use the preceding constructor, this implementation is similar to the previous one, except there are no setters and getters. Instead, we can get the animal name and age, as here:</p>
<pre class="calibre19">
object RunAnimalExample extends App{<br class="title-page-name"/>  val animalObj = new animal("Cat",-1)<br class="title-page-name"/>  println(animalObj.getAnimalName)<br class="title-page-name"/>  println(animalObj.getAnimalAge)<br class="title-page-name"/>}
</pre>
<p class="mce-root">Parameters are given in the class definition time to represent constructors. If we declare a constructor, then we cannot create a class without providing the default values of the parameters that are specified in the constructor. Moreover, Scala allows the instantiation of an object without providing the necessary parameters to its constructor: this happens when all constructor arguments have a default value defined.</p>
<p class="mce-root">Although there is a constraint for using the auxiliary constructors, we are free to add as many additional auxiliary constructors as we want. An auxiliary constructor must, on the first line of its body, call either another auxiliary constructor that has been declared before it, or the primary constructor. To obey this rule, each auxiliary constructor will, either directly or indirectly, end up invoking the primary constructor.</p>
<p class="mce-root">For example, the following code segment demonstrates the use of the auxiliary constructor in Scala:</p>
<pre class="calibre19">
class Hello(primaryMessage: String, secondaryMessage: String) {<br class="title-page-name"/>  def this(primaryMessage: String) = this(primaryMessage, "")<br class="title-page-name"/>  // auxilary constructor<br class="title-page-name"/>  def sayHello() = println(primaryMessage + secondaryMessage)<br class="title-page-name"/>}<br class="title-page-name"/>object Constructors {<br class="title-page-name"/>  def main(args: Array[String]): Unit = {<br class="title-page-name"/>    val hello = new Hello("Hello world!", " I'm in a trouble,<br class="title-page-name"/>                          please help me out.")<br class="title-page-name"/>    hello.sayHello()<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">In the earlier setting, we included a secondary (that is, 2<sup class="calibre26">nd</sup>) message in the primary constructor. The primary constructor will instantiate a new <kbd class="calibre11">Hello</kbd> object. Method <kbd class="calibre11">sayHello()</kbd> will print the concatenated message.</p>
<div><strong class="calibre27">Auxiliary constructors</strong>: In Scala, defining one or more auxiliary constructors for a Scala class gives the consumers of the class different ways to create object instances. Define the auxiliary constructors as methods in the class with the name this. You can define multiple auxiliary constructors, but they must have different signatures (parameter lists). Also, each constructor must call one of the previously defined constructors.</div>
<p class="mce-root">Now let's peep into another important but relatively new concept in Scala, called <strong class="calibre1">traits</strong>. We will discuss this in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Traits in Scala</h1>
                
            
            
                
<p class="mce-root">One of the new features in Scala is a trait, which is very similar to the notion of an interface in Java, except that it can also contain concrete methods. Although, Java 8 already has support for this. On the other hand, traits are one of the new concepts in Scala. But the feature already exists in OOP. So, they look like abstract classes, except that they don't have constructors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A trait syntax</h1>
                
            
            
                
<p class="mce-root">You need to use the <kbd class="calibre11">trait</kbd> keyword in order to declare a trait and it should be followed by the trait name and body:</p>
<pre class="calibre19">
trait Animal {<br class="title-page-name"/>  val age : Int<br class="title-page-name"/>  val gender : String<br class="title-page-name"/>  val origin : String<br class="title-page-name"/> }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Extending traits</h1>
                
            
            
                
<p class="mce-root">In order to extend traits or classes, you need to use the <kbd class="calibre11">extend</kbd> keyword. Traits cannot be instantiated because it may contain unimplemented methods. So, it's necessary to implement the abstract members in the trait:</p>
<pre class="calibre19">
trait Cat extends Animal{ }
</pre>
<p class="mce-root">A value class is not allowed to extend traits. To permit value classes to extend traits, universal traits are introduced, which extends for <kbd class="calibre11">Any</kbd>. For example, suppose that we have the following trait defined:</p>
<pre class="calibre19">
trait EqualityChecking {<br class="title-page-name"/>  def isEqual(x: Any): Boolean<br class="title-page-name"/>  def isNotEqual(x: Any): Boolean = !isEqual(x)<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, to extend the preceding trait in Scala using the universal trait, we follow the following code segment:</p>
<pre class="calibre19">
trait EqualityPrinter extends Any {<br class="title-page-name"/>  def print(): Unit = println(this)<br class="title-page-name"/>}
</pre>
<p class="mce-root">So, what is the difference between an abstract class and the traits in Scala? As you have seen, an abstract class can have constructor parameters, type parameters, and multiple parameters. However, a trait in Scala can have only type parameters.</p>
<p>A trait is fully interoperable if, and only if, it does not contain any implementation code. Furthermore, Scala traits are fully interoperable with Java interfaces in Scala 2.12. Because Java 8 allows method implementations in its interfaces, too.</p>
<p class="mce-root">There might be other cases for traits as well, for example, an abstract class can extend a trait or, if needed, any normal class (including the case classes) can extend an existing trait. For example, an abstract class can also extend traits:</p>
<pre class="calibre19">
abstract class Cat extends Animal { }
</pre>
<p class="mce-root">Lastly, a normal Scala class also can extend a Scala trait. Since classes are concrete, (that is, instances can be created), the abstract members of the trait should be implemented. In the next section, we will discuss the Java interoperability of Scala codes. Now let's peep into another important concept in every OOP, called <strong class="calibre1">abstract classes</strong>. We will discuss this in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Abstract classes</h1>
                
            
            
                
<p class="mce-root">An abstract class in Scala can have constructor parameters as well as type parameters. An abstract class in Scala is fully interoperable with Java. In other words, it is possible to call them from Java code without any intermediate wrappers.</p>
<p class="mce-root">So, what is the difference between an abstract class and the traits in Scala? As you have seen, an abstract class can have constructor parameters, type parameters, and multiple parameters. However, a trait in Scala can have only type parameters. The following is a simple example of an abstract class:</p>
<pre class="calibre19">
abstract class Animal(animalName:String = "notset") {<br class="title-page-name"/>  //Method with definition/return type<br class="title-page-name"/>  def getAnimalAge<br class="title-page-name"/>  //Method with no definition with String return type<br class="title-page-name"/>  def getAnimalGender : String<br class="title-page-name"/>  //Explicit way of saying that no implementation is present<br class="title-page-name"/>  def getAnimalOrigin () : String {} <br class="title-page-name"/>  //Method with its functionality implemented<br class="title-page-name"/>  //Need not be implemented by subclasses, can be overridden if required<br class="title-page-name"/>  def getAnimalName : String = {<br class="title-page-name"/>    animalName<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">In order to extend this class by another one, we need to implement the unimplemented methods earlier <kbd class="calibre11">getAnimalAge</kbd>, <kbd class="calibre11">getAnimalGender</kbd>, and <kbd class="calibre11">getAnimalOrigin</kbd>. For <kbd class="calibre11">getAnimalName</kbd>, we can override it or not, since its implementation is already there.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Abstract classes and the override keyword</h1>
                
            
            
                
<p class="mce-root">If you want to override a concrete method from the superclass, the override modifier is necessary. However, if you are implementing an abstract method, it is not strictly necessary to add the override modifier. Scala uses the <kbd class="calibre11">override</kbd> keyword to override a method from a parent class. For example, suppose you have the following abstract class and a method <kbd class="calibre11">printContents()</kbd> to print your message on the console:</p>
<pre class="calibre19">
abstract class MyWriter {<br class="title-page-name"/>  var message: String = "null"<br class="title-page-name"/>  def setMessage(message: String):Unit<br class="title-page-name"/>  def printMessage():Unit<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, add a concrete implementation of the preceding abstract class to print the contents on the console as follows:</p>
<pre class="calibre19">
class ConsolePrinter extends MyWriter {<br class="title-page-name"/>  def setMessage(contents: String):Unit= {<br class="title-page-name"/>    this.message = contents<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  def printMessage():Unit= {<br class="title-page-name"/>    println(message)<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Secondly, if you want to create a trait to modify the behavior of the preceding concrete class, as follows:</p>
<pre class="calibre19">
trait lowerCase extends MyWriter {<br class="title-page-name"/>  abstract override def setMessage(contents: String) = printMessage()<br class="title-page-name"/>}
</pre>
<p class="mce-root">If you look at the preceding code segment carefully, you will find two modifiers (that is, abstract and override). Now, with the preceding setting, you can do the following to use the preceding class:</p>
<pre class="calibre19">
val printer:ConsolePrinter = new ConsolePrinter()<br class="title-page-name"/>printer.setMessage("Hello! world!")<br class="title-page-name"/>printer.printMessage()
</pre>
<p class="mce-root">In summary, we can add an <kbd class="calibre11">override</kbd> keyword in front of the method to work as expected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Case classes in Scala</h1>
                
            
            
                
<p class="mce-root">A <strong class="calibre1">case</strong> class is an instantiable class that includes several automatically generated methods. It also includes an automatically generated companion object with its own automatically generated methods. The basic syntax of a case class in Scala is as follows:</p>
<pre class="calibre19">
case class &lt;identifier&gt; ([var] &lt;identifier&gt;: &lt;type&gt;[, ... ])[extends &lt;identifier&gt;(&lt;input parameters&gt;)] [{ fields and methods }]
</pre>
<p class="mce-root">A case class can be pattern matched, and comes with the following methods already implemented the method <kbd class="calibre11">hashCode</kbd> (location/scope is a class), <kbd class="calibre11">apply</kbd> (location/scope is an object), <kbd class="calibre11">copy</kbd> (location/scope is a class), <kbd class="calibre11">equals</kbd> (location/scope is a class), <kbd class="calibre11">toString</kbd> (location/scope is a class), and <kbd class="calibre11">unapply</kbd> (location/scope is an object).</p>
<p class="mce-root">Like a plain class, a case class automatically define, getter methods for the constructor arguments. To get a practical insight about the preceding features or a case class, let's see the following code segment:</p>
<pre class="calibre19">
package com.chapter3.OOP <br class="title-page-name"/>object CaseClass {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    case class Character(name: String, isHacker: Boolean) // defining a<br class="title-page-name"/>                               class if a person is a computer hacker     <br class="title-page-name"/>    //Nail is a hacker<br class="title-page-name"/>    val nail = Character("Nail", true)     <br class="title-page-name"/>    //Now let's return a copy of the instance with any requested changes<br class="title-page-name"/>    val joyce = nail.copy(name = "Joyce")<br class="title-page-name"/>    // Let's check if both Nail and Joyce are Hackers<br class="title-page-name"/>    println(nail == joyce)    <br class="title-page-name"/>    // Let's check if both Nail and Joyce equal<br class="title-page-name"/>    println(nail.equals(joyce))        <br class="title-page-name"/>    // Let's check if both Nail and Nail equal<br class="title-page-name"/>    println(nail.equals(nail))    <br class="title-page-name"/>    // Let's the hasing code for nail<br class="title-page-name"/>    println(nail.hashCode())    <br class="title-page-name"/>    // Let's the hasing code for nail<br class="title-page-name"/>    println(nail)<br class="title-page-name"/>    joyce match {<br class="title-page-name"/>      case Character(x, true) =&gt; s"$x is a hacker"<br class="title-page-name"/>      case Character(x, false) =&gt; s"$x is not a hacker"<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">The preceding code produces the following output:</p>
<pre class="calibre19">
<strong class="calibre1">false </strong><br class="title-page-name"/><strong class="calibre1">false </strong><br class="title-page-name"/><strong class="calibre1">true </strong><br class="title-page-name"/><strong class="calibre1">-112671915 </strong><br class="title-page-name"/><strong class="calibre1">Character(Nail,true) </strong><br class="title-page-name"/><strong class="calibre1">Joyce is a hacker</strong>
</pre>
<p class="mce-root">For the REPL and the output of the regular expression matching, if you execute the preceding code (except the <kbd class="calibre11">Object</kbd> and <kbd class="calibre11">main</kbd> method), you should be able to see the more interactive output as follows:</p>
<div><img class="image-border13" src="img/00373.jpeg"/></div>
<div><strong class="calibre1">Figure 2:</strong> Scala REPL for case class</div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Packages and package objects</h1>
                
            
            
                
<p class="mce-root">Just like Java, a package is a special container or object which contains/defines a set of objects, classes, and even packages. Every Scala file has the following automatically imported:</p>
<ul class="calibre9">
<li class="mce-root1"><kbd class="calibre11">java.lang._</kbd></li>
<li class="mce-root1"><kbd class="calibre11">scala._</kbd></li>
<li class="mce-root1"><kbd class="calibre11">scala.Predef._</kbd></li>
</ul>
<p class="mce-root">The following is an example for basic imports:</p>
<pre class="calibre19">
// import only one member of a package<br class="title-page-name"/>import java.io.File<br class="title-page-name"/>// Import all members in a specific package<br class="title-page-name"/>import java.io._<br class="title-page-name"/>// Import many members in a single import statement<br class="title-page-name"/>import java.io.{File, IOException, FileNotFoundException}<br class="title-page-name"/>// Import many members in a multiple import statement<br class="title-page-name"/>import java.io.File<br class="title-page-name"/>import java.io.FileNotFoundException<br class="title-page-name"/>import java.io.IOException
</pre>
<p class="mce-root">You can even rename a member while importing, and that's to avoid a collision between packages that have the same member name. This method is also called class <kbd class="calibre11">alias</kbd>:</p>
<pre class="calibre19">
import java.util.{List =&gt; UtilList}<br class="title-page-name"/>import java.awt.{List =&gt; AwtList}<br class="title-page-name"/>// In the code, you can use the alias that you have created<br class="title-page-name"/>val list = new UtilList
</pre>
<p class="mce-root">As mentioned in <a href="part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 1</a>, <em class="calibre8">Introduction to Scala</em>, you can also import all the members of a package, but some members are also called <strong class="calibre1">member hiding</strong>:</p>
<pre class="calibre19">
import java.io.{File =&gt; _, _}
</pre>
<p class="mce-root">If you tried this in the REPL, it just tells the compiler the full, canonical name of the defined class or object:</p>
<pre class="calibre19">
package fo.ba<br class="title-page-name"/>class Fo {<br class="title-page-name"/>  override def toString = "I'm fo.ba.Fo"<br class="title-page-name"/>}
</pre>
<p class="mce-root">You can even use the style of defining packages in curly braces. You can have a single package and nested package means package within a package. For example, the following code segment defines a single package named <kbd class="calibre11">singlePackage</kbd> consisting of a single class named <kbd class="calibre11">Test</kbd>. The <kbd class="calibre11">Test</kbd> class, on the other hand, consists of a single method named <kbd class="calibre11">toString()</kbd>.</p>
<pre class="calibre19">
package singlePack {<br class="title-page-name"/>  class Test { override def toString = "I am SinglePack.Test" }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, you can make the packaging nested. In other words, you can have more than one package in a nested way. For example, for the below case, we have two packages, namely <kbd class="calibre11">NestParentPack</kbd> and the <kbd class="calibre11">NestChildPack</kbd>, each containing their own classes.</p>
<pre class="calibre19">
package nestParentPack {<br class="title-page-name"/>  class Test { override def toString = "I am NestParentPack.Test" }<br class="title-page-name"/><br class="title-page-name"/>  package nestChildPack {<br class="title-page-name"/>    class TestChild { override def toString = "I am nestParentPack.nestChildPack.TestChild" }<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">Let's create a new object (let's name it <kbd class="calibre11">MainProgram</kbd>), in which we'll invoke the methods and classes we just defined:</p>
<pre class="calibre19">
object MainProgram {<br class="title-page-name"/>  def main(args: Array[String]): Unit = {<br class="title-page-name"/>    println(new nestParentPack.Test())<br class="title-page-name"/>    println(new nestParentPack.nestChildPack.TestChild())<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You will find more examples on the internet that describe sophisticated use cases of packages and package objects. In the next section, we will discuss the Java interoperability of Scala codes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Java interoperability</h1>
                
            
            
                
<p class="mce-root">Java is one of the most popular languages, and many programmers learn Java programming as their first entrance to the programming world. The popularity of Java has increased since its initial release back in 1995. Java has gained in popularity for many reasons. One of them is the design of its platform, such that any Java code will be compiled to bytecode, which in turn runs on the JVM. With this magnificent feature, Java language to be being written once and run anywhere. So, Java is a cross-platform language.</p>
<p class="mce-root">Also, Java has lots of support from its community and lots of packages that will help you get your idea up and running with the help of these packages. Then comes Scala, which has lots of features that Java lacks, such as type inference and optional semicolon, immutable collections built right into Scala core, and lots more features (addressed in <a href="part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 1</a>, <em class="calibre8">Introduction to Scala</em>). Scala also runs on the JVM, just like Java.</p>
<div><strong class="calibre27">Semicolon in Scala:</strong> Semicolons are exactly optional, and they are required when more lines of code should be written on a single line. That's probably the reason why the compiler doesn't complain if a semicolon is put at the end of a line: it is considered a piece of code followed by an empty piece of code that, coincidentally, lives on the same line.</div>
<p class="mce-root">As you can see that both Scala and Java run on the JVM, it makes sense to use them simultaneously in the same program without complaints from the compiler. Let's demonstrate this with an example. Consider the following Java code:</p>
<pre class="calibre19">
ArrayList&lt;String&gt; animals = new ArrayList&lt;String&gt;();<br class="title-page-name"/>animals.add("cat");<br class="title-page-name"/>animals.add("dog");<br class="title-page-name"/>animals.add("rabbit");<br class="title-page-name"/>for (String animal : animals) {<br class="title-page-name"/>  System.out.println(animal);<br class="title-page-name"/>}
</pre>
<p class="mce-root">In order to write the same code in Scala, you can make use of Java packages. Let's translate the previous example into Scala with the help of using Java collections such as <kbd class="calibre11">ArrayList</kbd>:</p>
<pre class="calibre19">
import java.util.ArrayList<br class="title-page-name"/>val animals = new ArrayList[String]<br class="title-page-name"/>animals.add("cat")<br class="title-page-name"/>animals.add("dog")<br class="title-page-name"/>animals.add("rabbit")<br class="title-page-name"/>for (animal &lt;- animals) {<br class="title-page-name"/>  println(animal)<br class="title-page-name"/>}
</pre>
<p class="mce-root">The previous mix applies for the standard packages of Java, but you want to use libraries that aren't packaged with the standard libraries of Java, or even want to use your own classes. Then, you need to make sure that they lie in the classpath.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pattern matching</h1>
                
            
            
                
<p class="mce-root">One of the widely used features of Scala is pattern matching. Each pattern match has a set of alternatives, each of them starting with the case keyword. Each alternative has a pattern and expression(s), which will be evaluated if the pattern matches and the arrow symbol <kbd class="calibre11">=&gt;</kbd> separates pattern(s) from expression(s). The following is an example which demonstrates how to match against an integer:</p>
<pre class="calibre19">
object PatternMatchingDemo1 {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    println(matchInteger(3))<br class="title-page-name"/>  }   <br class="title-page-name"/>  def matchInteger(x: Int): String = x match {<br class="title-page-name"/>    case 1 =&gt; "one"<br class="title-page-name"/>    case 2 =&gt; "two"<br class="title-page-name"/>    case _ =&gt; "greater than two"<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You can run the preceding program by saving this file in <kbd class="calibre11">PatternMatchingDemo1.scala</kbd> and then using the following commands to run it. Just use the following command:</p>
<pre class="calibre19">
<strong class="calibre1">&gt;scalac Test.scala</strong><br class="title-page-name"/><strong class="calibre1">&gt;scala Test</strong>
</pre>
<p class="mce-root">You will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">Greater than two</strong>
</pre>
<p class="mce-root">The cases statements are used as a function that maps integers to strings. The following is another example which matches against different types:</p>
<pre class="calibre19">
object PatternMatchingDemo2 {<br class="title-page-name"/>  def main(args: Array[String]): Unit = {<br class="title-page-name"/>    println(comparison("two"))<br class="title-page-name"/>    println(comparison("test"))<br class="title-page-name"/>    println(comparison(1))<br class="title-page-name"/>  }<br class="title-page-name"/>  def comparison(x: Any): Any = x match {<br class="title-page-name"/>    case 1 =&gt; "one"<br class="title-page-name"/>    case "five" =&gt; 5<br class="title-page-name"/>    case _ =&gt; "nothing else"<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">You can run this example by doing the same for the example earlier and will get the following output:</p>
<pre class="calibre19">
<strong class="calibre1">nothing else</strong><br class="title-page-name"/><strong class="calibre1">nothing else</strong><br class="title-page-name"/><strong class="calibre1">one</strong>
</pre>
<p>Pattern matching is a mechanism for checking a value against a pattern. A successful match can also deconstruct a value into its constituent parts. It is a more powerful version of the switch statement in Java, and it can likewise be used in place of a series of <kbd class="calibre22">if...else</kbd> statements. You can find more on pattern matching by referring to the official docs of Scala (URL: <a href="http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html" class="calibre21">http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html</a>).</p>
<p class="mce-root">In the next section, we will discuss an important feature in Scala that enables us a value that can be passed automatically, so to speak, or a conversion from one type to another that is made automatically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implicit in Scala</h1>
                
            
            
                
<p class="mce-root">Implicit is another exciting and powerful feature introduced by Scala, and it can refer to two different things:</p>
<ul class="calibre9">
<li class="mce-root1">A value that can be automatically passed</li>
<li class="mce-root1">Automatic conversion from one type to another</li>
<li class="mce-root1">They can be used for extending the capabilities of a class</li>
</ul>
<p class="mce-root">Actual automatic conversion can be accomplished with implicit def, as seen in the following example (supposing you are using the Scala REPL):</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; implicit def stringToInt(s: String) = s.toInt</strong><br class="title-page-name"/><strong class="calibre1">stringToInt: (s: String)Int</strong>
</pre>
<p class="mce-root">Now, having the preceding code in my scope, it's possible for me to do something like this:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; def add(x:Int, y:Int) = x + y</strong><br class="title-page-name"/><strong class="calibre1">add: (x: Int, y: Int)Int</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">scala&gt; add(1, "2")</strong><br class="title-page-name"/><strong class="calibre1">res5: Int = 3</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong>
</pre>
<p class="mce-root">Even if one of the parameters passed to <kbd class="calibre11">add()</kbd> is a <kbd class="calibre11">String</kbd> (and <kbd class="calibre11">add()</kbd> would require you to provide two integers), having the implicit conversion in scope allows the compiler to automatically convert from <kbd class="calibre11">String</kbd> to <kbd class="calibre11">Int</kbd>. Obviously enough, this feature could be quite dangerous, because it makes the code less readable; moreover, once an implicit conversion is defined, it's not easy to tell the compiler when to use it and when to avoid using it.</p>
<p class="mce-root">The first type of implicit is a value that can automatically pass an implicit parameter. These parameters are passed while calling a method like any normal parameter, but Scala's compiler tries to fill them automatically. If Scala's compiler fails to automatically fill these parameters, it will complain. The following is an example to demonstrate the first type of implicit:</p>
<pre class="calibre19">
def add(implicit num: Int) = 2 + num
</pre>
<p class="mce-root">By this, you are asking the compiler to look for an implicit value for <kbd class="calibre11">num</kbd>, if not provided during calling the method. You can define implicit value to the compiler like this:</p>
<pre class="calibre19">
implicit val adder = 2
</pre>
<p class="mce-root">Then, we can simply call the function like this:</p>
<pre class="calibre19">
<strong class="calibre1">add</strong>
</pre>
<p class="mce-root">Here, no parameter is passed, so Scala's compiler will look for implicit value, which is <kbd class="calibre11">2</kbd>, and then return <kbd class="calibre11">4</kbd> as the output of the method calling. However, a lot of other options have evolved a questions such as:</p>
<ul class="calibre9">
<li class="mce-root1">Can a method contain both an explicit and an implicit parameter? The answer is YES. Let's see an example on Scala REPL:</li>
</ul>
<pre class="calibre19">
<strong class="calibre1">      scala&gt; def helloWold(implicit a: Int, b: String) = println(a, b)</strong><br class="title-page-name"/><strong class="calibre1">      helloWold: (implicit a: Int, implicit b: String)Unit</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">      scala&gt; val i = 2</strong><br class="title-page-name"/><strong class="calibre1">      i: Int = 2</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">      scala&gt; helloWorld(i, implicitly)</strong><br class="title-page-name"/><strong class="calibre1">      (2,)</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">      scala&gt;</strong>
</pre>
<ul class="calibre9">
<li class="mce-root1">Can a method contain more than one implicit parameter? The answer is YES. Let's see an example on Scala REPL:</li>
</ul>
<pre class="calibre19">
<strong class="calibre1">     scala&gt; def helloWold(implicit a: Int, b: String) = println(a, b)</strong><br class="title-page-name"/><strong class="calibre1">     helloWold: (implicit a: Int, implicit b: String)Unit</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">     scala&gt; helloWold(i, implicitly)</strong><br class="title-page-name"/><strong class="calibre1">     (1,)</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">     scala&gt;</strong>
</pre>
<ul class="calibre9">
<li class="mce-root1">Can an implicit parameter be explicitly provided? The answer is YES. Let's see an example on Scala REPL:</li>
</ul>
<pre class="calibre19">
<strong class="calibre1">     scala&gt; def helloWold(implicit a: Int, b: String) = println(a, b)</strong><br class="title-page-name"/><strong class="calibre1">     helloWold: (implicit a: Int, implicit b: String)Unit</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">     scala&gt; helloWold(20, "Hello world!")</strong><br class="title-page-name"/><strong class="calibre1">     (20,Hello world!)</strong><br class="title-page-name"/><strong class="calibre1">     scala&gt;</strong>
</pre>
<p class="mce-root">What happens if more implicits are contained in the same scope and how are implicits resolved? Is there any order to how implicits are resolved? To get to know the answer to these two questions, refer to this URL at <a href="http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala" class="calibre10">http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala</a>.</p>
<p class="mce-root">In the next section, we will discuss generics in Scala with some examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generic in Scala</h1>
                
            
            
                
<p class="mce-root">Generic classes are classes which take a type as a parameter. They are particularly useful for collection classes. Generic classes can be used in everyday data structure implementation, such as stack, queue, linked list, and so on. We will see some examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining a generic class</h1>
                
            
            
                
<p class="mce-root">Generic classes take a type as a parameter within square brackets <kbd class="calibre11">[]</kbd>. One convention is to use the letter <kbd class="calibre11">A</kbd> as a type parameter identifier, though any parameter name may be used. Let's see a minimal example on Scala REPL, as follows:</p>
<pre class="calibre19">
<strong class="calibre1">scala&gt; class Stack[A] {</strong><br class="title-page-name"/><strong class="calibre1">     |       private var elements: List[A] = Nil</strong><br class="title-page-name"/><strong class="calibre1">     |       def push(x: A) { elements = x :: elements }</strong><br class="title-page-name"/><strong class="calibre1">     |       def peek: A = elements.head</strong><br class="title-page-name"/><strong class="calibre1">     |       def pop(): A = {</strong><br class="title-page-name"/><strong class="calibre1">     |         val currentTop = peek</strong><br class="title-page-name"/><strong class="calibre1">     |         elements = elements.tail</strong><br class="title-page-name"/><strong class="calibre1">     |         currentTop</strong><br class="title-page-name"/><strong class="calibre1">     |       }</strong><br class="title-page-name"/><strong class="calibre1">     |     }</strong><br class="title-page-name"/><strong class="calibre1">defined class Stack</strong><br class="title-page-name"/><strong class="calibre1">scala&gt;</strong><br class="title-page-name"/><br class="title-page-name"/>
</pre>
<p class="mce-root">The preceding implementation of a <kbd class="calibre11">Stack</kbd> class takes any type A as a parameter. This means the underlying list, <kbd class="calibre11">var elements: List[A] = Nil</kbd> can only store elements of type <kbd class="calibre11">A</kbd>. The procedure def push only accepts objects of type <kbd class="calibre11">A</kbd> (note: <kbd class="calibre11">elements = x :: elements</kbd> reassigns elements to a new list created by prepending <kbd class="calibre11">x</kbd> to the current elements). Let's see an example of how to use the preceding class to implement a stack:</p>
<pre class="calibre19">
object ScalaGenericsForStack {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    val stack = new Stack[Int]<br class="title-page-name"/>    stack.push(1)<br class="title-page-name"/>    stack.push(2)<br class="title-page-name"/>    stack.push(3)<br class="title-page-name"/>    stack.push(4)<br class="title-page-name"/>    println(stack.pop) // prints 4<br class="title-page-name"/>    println(stack.pop) // prints 3<br class="title-page-name"/>    println(stack.pop) // prints 2<br class="title-page-name"/>    println(stack.pop) // prints 1<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">The output is as follows:</p>
<pre class="calibre19">
<strong class="calibre1">4</strong><br class="title-page-name"/><strong class="calibre1">3</strong><br class="title-page-name"/><strong class="calibre1">2</strong><br class="title-page-name"/><strong class="calibre1">1</strong>
</pre>
<p class="mce-root">The second use case could be implementing a linked list too. For instance, if Scala didn't have a linked-list class and you wanted to write your own, you could write the basic functionality like this:</p>
<pre class="calibre19">
class UsingGenericsForLinkedList[X] { // Create a user specific linked list to print heterogenous values<br class="title-page-name"/>  private class Node[X](elem: X) {<br class="title-page-name"/>    var next: Node[X] = _<br class="title-page-name"/>    override def toString = elem.toString<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private var head: Node[X] = _<br class="title-page-name"/><br class="title-page-name"/>  def add(elem: X) { //Add element in the linekd list<br class="title-page-name"/>    val value = new Node(elem)<br class="title-page-name"/>    value.next = head<br class="title-page-name"/>    head = value<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private def printNodes(value: Node[X]) { // prining value of the nodes<br class="title-page-name"/>    if (value != null) {<br class="title-page-name"/>      println(value)<br class="title-page-name"/>      printNodes(value.next)<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  def printAll() { printNodes(head) } //print all the node values at a time<br class="title-page-name"/>}
</pre>
<p class="mce-root">Now, let's see how could we use the preceding linked list implementation:</p>
<pre class="calibre19">
object UsingGenericsForLinkedList {<br class="title-page-name"/>  def main(args: Array[String]) {<br class="title-page-name"/>    // To create a list of integers with this class, first create an instance of it, with type Int:<br class="title-page-name"/>    val ints = new UsingGenericsForLinkedList[Int]()<br class="title-page-name"/>    // Then populate it with Int values:<br class="title-page-name"/>    ints.add(1)<br class="title-page-name"/>    ints.add(2)<br class="title-page-name"/>    ints.add(3)<br class="title-page-name"/>    ints.printAll()<br class="title-page-name"/><br class="title-page-name"/>    // Because the class uses a generic type, you can also create a LinkedList of String:<br class="title-page-name"/>    val strings = new UsingGenericsForLinkedList[String]()<br class="title-page-name"/>    strings.add("Salman Khan")<br class="title-page-name"/>    strings.add("Xamir Khan")<br class="title-page-name"/>    strings.add("Shah Rukh Khan")<br class="title-page-name"/>    strings.printAll()<br class="title-page-name"/><br class="title-page-name"/>    // Or any other type such as Double to use:<br class="title-page-name"/>    val doubles = new UsingGenericsForLinkedList[Double]()<br class="title-page-name"/>    doubles.add(10.50)<br class="title-page-name"/>    doubles.add(25.75)<br class="title-page-name"/>    doubles.add(12.90)<br class="title-page-name"/>    doubles.printAll()<br class="title-page-name"/>  }<br class="title-page-name"/>}
</pre>
<p class="mce-root">The output is as follows:</p>
<pre class="calibre19">
<strong class="calibre1">3</strong><br class="title-page-name"/><strong class="calibre1">2</strong><br class="title-page-name"/><strong class="calibre1">1</strong><br class="title-page-name"/><strong class="calibre1">Shah Rukh Khan</strong><br class="title-page-name"/><strong class="calibre1">Aamir Khan</strong><br class="title-page-name"/><strong class="calibre1">Salman Khan</strong><br class="title-page-name"/><strong class="calibre1">12.9</strong><br class="title-page-name"/><strong class="calibre1">25.75</strong><br class="title-page-name"/><strong class="calibre1">10.5</strong>
</pre>
<p class="mce-root">In summary, at the basic level, creating a generic class in Scala is just like creating a generic class in Java, with the exception of the brackets. Well! So far we have gotten to know some essential features to get started with an object-oriented programming language, Scala.</p>
<p class="mce-root">Although, we have not covered some other aspects, however, we still think that you can continue working. In <a href="part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c" class="calibre10">Chapter 1</a>, <em class="calibre8">Introduction to Scala</em>, we discussed what the available editors for Scala are. In the next section, we will see how to set up your build environment. More specifically, three build systems, like Maven, SBT, and Gradle will be covered.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">SBT and other build systems</h1>
                
            
            
                
<p class="mce-root">It's necessary to use a build tool for any enterprise software project. There are lots of build tools that you can choose from, such as Maven, Gradle, Ant, and SBT. A good choice of build tool is the one which will let you focus on coding rather than compilation complexities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Build with SBT</h1>
                
            
            
                
<p class="mce-root">Here, we are going to give a brief introduction to SBT. Before going any further, you need to install SBT using the installation method that fits your system from their official installations methods (URL: <a href="http://www.scala-sbt.org/release/docs/Setup.html" class="calibre10">http://www.scala-sbt.org/release/docs/Setup.html</a>).</p>
<p class="mce-root">So, let's begin with SBT to demonstrate the use of SBT in a terminal. For this build tool tutorial, we assume that your source code files are in a directory. You need to do the following:</p>
<ol class="calibre14">
<li value="1" class="mce-root1">Open the terminal and change path to that directory by using <kbd class="calibre11">cd</kbd>,</li>
<li value="2" class="mce-root1">Create a build file called <kbd class="calibre11">build.sbt</kbd>.</li>
<li value="3" class="mce-root1">Then, populate that build file with the following lines:</li>
</ol>
<pre class="calibre19">
           name := "projectname-sbt"<br class="title-page-name"/>           organization :="org.example"<br class="title-page-name"/>           scalaVersion :="2.11.8"<br class="title-page-name"/>           version := "0.0.1-SNAPSHOT"
</pre>
<p class="mce-root">Let's see the meaning of these lines:</p>
<ul class="calibre9">
<li class="mce-root1">The <kbd class="calibre11">name</kbd> defines a name for your project. This name will be used in the generated jar files.</li>
<li class="mce-root1">The <kbd class="calibre11">organization</kbd> is a namespace that's used to prevent collisions between projects that have similar names.</li>
<li class="mce-root1"><kbd class="calibre11">scalaVersion</kbd> sets the version of Scala that you want to build against.</li>
<li class="mce-root1"><kbd class="calibre11">Version</kbd> specifies the current build version of your project and you can use <kbd class="calibre11">-SNAPSHOT</kbd> for versions that have not been released yet.</li>
</ul>
<p class="mce-root">After creating this build file, you need to <kbd class="calibre11">run</kbd> the <kbd class="calibre11">sbt</kbd> command in your terminal and then a prompt starting with <kbd class="calibre11">&gt;</kbd> will be opened for you. In this prompt, you can type <kbd class="calibre11">compile</kbd> in order to compile your Scala or Java source files in your code. Also, you can enter the command in the SBT prompt in order to run the program if it's runnable. Or you can use the package command in SBT prompt in order to generate a <kbd class="calibre11">.jar</kbd> file, which will exist in a subdirectory called <kbd class="calibre11">target</kbd>. To read more about SBT and more sophisticated examples, you can refer to the official site of SBT.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Maven with Eclipse</h1>
                
            
            
                
<p class="mce-root">Using Eclipse as Scala IDE with Maven as a build tool is very easy and straightforward. In this section, we will demonstrate with screenshots how to use Scala with Eclipse and Maven. To be able to use Maven in Eclipse, you need to install its plugin, which will be different across different versions of Eclipse. After installing the Maven plugin, you will find that it doesn't support Scala directly. What we need to do in order to get this Maven plugin to support Scala projects is to install a connector called <strong class="calibre1">m2eclipse-scala</strong>.</p>
<p class="mce-root">If you paste this URL (<a href="http://alchim31.free.fr/m2e-scala/update-site" class="calibre10">http://alchim31.free.fr/m2e-scala/update-site</a> ) while trying to add new software to Eclipse, you will find that Eclipse understands the URL and suggests some plugins for you to add:</p>
<div><img class="image-border14" src="img/00184.jpeg"/></div>
<div><strong class="calibre1">Figure 4:</strong> Installing Maven plugins on Eclipse to enable Maven build</div>
<p class="mce-root">After installing Maven and the connector for Scala support, we are going to create a new Scala Maven project. To create a new Scala Maven project, you need to navigate to New | Project | Other and then choose Maven Project. After this, select the option that has net.alchim31.maven as Group Id:</p>
<div><img class="image-border15" src="img/00186.jpeg"/></div>
<div><strong class="calibre1">Figure 5:</strong> Creating a Scala Maven project on Eclipse</div>
<p class="mce-root">After this selection, you need to follow the wizard and enter the required values, such as Group Id, and so on. Then, hit Finish and, with this, you have created your first Scala project with Maven support in the workspace. In the project structure, you will find something called <kbd class="calibre11">pom.xml</kbd> where you can add all your dependencies and other things.</p>
<p>For more information about how to add dependencies to your project, you can refer to this link at <a href="http://docs.scala-lang.org/tutorials/scala-with-maven.html" class="calibre21">http://docs.scala-lang.org/tutorials/scala-with-maven.html</a>.</p>
<p class="mce-root">As a continuation of this section, we will show you how to build your Spark application written in Scala in the upcoming chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Gradle with Eclipse</h1>
                
            
            
                
<p class="mce-root">Gradle Inc. provides the Gradle tools and plugins for the Eclipse IDE. This tool allows you to create and import Gradle enabled projects into the Eclipse IDE. In addition, it allows you to run Gradle tasks and monitor the execution of the tasks.</p>
<p>The Eclipse project itself is called <strong class="calibre27">Buildship</strong>. The source code of this project is available on GitHub at <a href="https://github.com/eclipse/Buildship" class="calibre21">https://github.com/eclipse/Buildship</a>.</p>
<p class="mce-root">There are two options for installing Gradle plugins on Eclipse. These are as follows:</p>
<ul class="calibre9">
<li class="mce-root1">Via the Eclipse Marketplace</li>
<li class="mce-root1">Via the Eclipse Update Manager</li>
</ul>
<p class="mce-root">First, let's see how to install Buildship plugins for Grade build on Eclipse using Marketplace: Eclipse | Help | Eclipse Marketplace:</p>
<div><img class="image-border16" src="img/00190.jpeg"/></div>
<div><strong class="calibre1">Figure 6:</strong> Installing Buildship plugins for Grade build on Eclipse using Marketplace</div>
<p class="mce-root">The second option for installing the Gradle plugins on Eclipse is from the Help | Install New Software... menu path to install the Gradle tooling as shown in the following figure:</p>
<div><img class="image-border17" src="img/00192.jpeg"/></div>
<div><strong class="calibre1">Figure 7:</strong> Installing Buildship plugins for Grade build on Eclipse using install new software</div>
<p>For example, the following URL can be used for Eclipse 4.6 (Neon) release: <a href="http://download.eclipse.org/releases/neon" class="calibre21">http://download.eclipse.org/releases/neon</a>.</p>
<p class="mce-root">Once you have installed the Gradle plugins by following any one of the methods described earlier, Eclipse Gradle helps you to set up Scala based Gradle projects: File | New | Project | Select a wizard | Gradle | Gradle Project.</p>
<div><strong class="calibre1"><img class="image-border18" src="img/00196.jpeg"/></strong></div>
<div><strong class="calibre1">Figure 8:</strong> Creating a Gradle project on Eclipse</div>
<p class="mce-root">Now, if you press Next&gt;, you will get the following wizard to specify the name of the project for your purpose:</p>
<div><strong class="calibre1"><img class="image-border19" src="img/00198.jpeg"/></strong></div>
<div><strong class="calibre1">Figure 9:</strong> Creating a Gradle project on Eclipse specifying the project name</div>
<p class="mce-root">Finally, press the Finish button to create the project. Pressing the Finish button essentially triggers the Gradle <kbd class="calibre11">init --type java-library</kbd> command and imports the project. However, if you would like to get a preview of the configuration before the it is created, press Next &gt; to get the following wizard:</p>
<div><img class="image-border20" src="img/00050.jpeg"/></div>
<div><strong class="calibre1">Figure 10:</strong> Preview of the configuration before it is created</div>
<p class="mce-root">Finally, you will see the following project structure on Eclipse. However, we will see how to build Spark applications using Maven, SBT, and Gradle in a later chapter. The reason is that, before starting your project, it is more important to learn Scala and Spark together.</p>
<div><img class="image-border21" src="img/00058.jpeg"/></div>
<div><strong class="calibre1">Figure 11:</strong> The project structure on Eclipse using Gradle</div>
<p class="mce-root">In this section, we have seen three build systems, including SBT, Maven, and Gradle. However, throughout the chapters, I will try to mainly use Maven because of its simplicity and better code compatibility. However, in later chapters, we will use SBT to create JARS from your Spark application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="mce-root">Structuring code in a sane way, with classes and traits, enhances the reusability of your code with generics, and creates a project with standard and widespread tools. Improve on the basics to know how Scala implements the OO paradigm to allow the building of modular software systems. In this chapter, we discussed the basic object-oriented features in Scala, such as classes and objects, packages and package objects, traits, and trait linearization, Java interoperability, pattern matching, implicit, and generics. Finally, we discussed SBT and other build systems that will be needed to build our Spark application on Eclipse or any other IDEs.</p>
<p class="mce-root">In the next chapter, we will discuss what functional programming is and how Scala supports it. We will get to know why it matters and what the advantages of using functional concepts are. Continuing, you will learn pure functions, higher-order functions, Scala collections basics (map, flatMap, filter), for - comprehensions, monadic processing, and for extending higher-order functions outside of collections using the standard library of Scala.</p>


            

            
        
    </body></html>