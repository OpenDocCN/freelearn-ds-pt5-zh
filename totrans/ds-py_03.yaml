- en: Chapter 3. Accelerate your Data Analysis with Python Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Every vision is a joke until the first man accomplishes it; once realized,
    it becomes commonplace."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – *Robert H Goddard*
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will do a technical deep dive into the PixieApp framework.
    You will be able to use the following information both as a *Getting Started*
    tutorial and as reference documentation for the PixieApp programming model.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a high-level description of the anatomy of a PixieApp before
    diving in to its foundational concepts, such as routes and requests. To help follow
    along, we will incrementally build a *GitHub Tracking* sample application that
    applies the capabilities and best practices as they are being introduced, starting
    from building the data analytics to integrating them into the PixieApp.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to apply the lessons learned
    to your own use case, including writing your own PixieApp.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a PixieApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The PixieApp programming model doesn''t require any prior experience
    with JavaScript, however, it is expected that the reader is familiar with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python ([https://www.python.org](https://www.python.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 ([https://www.w3schools.com/html](https://www.w3schools.com/html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS3 ([https://www.w3schools.com/css](https://www.w3schools.com/css))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term **PixieApp** stands for **Pixie Application,** and is meant to emphasize
    its tight integration with the PixieDust capabilities, especially the `display()`
    API. Its main goal is to make it easy for developers to build a user interface
    that can invoke the data analytics implemented in the Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: A PixieApp follows the **single-page application** (**SPA**) design pattern
    ([https://en.wikipedia.org/wiki/Single-page_application](https://en.wikipedia.org/wiki/Single-page_application)),
    where the user is presented with a welcome screen that is dynamically updated
    to respond to a user interaction. An update can be a partial refresh, such as
    updating a graph after the user clicks on a control or a full refresh, such as
    a new screen in a multistep process. In each case, the update is controlled on
    the server side by a route that is triggered using a specific mechanism that we'll
    discuss later. When triggered, the route executes code to handle the request and
    then emits an HTML fragment, which is applied to the right target DOM element
    ([https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp))
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram shows how the client side and server side interact
    with each other when running a PixieApp:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Anatomy of a PixieApp](img/B09699_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence diagram showing the information flow of a PixieApp
  prefs: []
  type: TYPE_NORMAL
- en: When the PixieApp is started (by calling the `run` method), the default route
    is invoked, and the corresponding HTML fragment is returned. As the user interacts
    with the application, more requests are executed, triggering the associated routes
    which refresh the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: From an implementation perspective, a PixieApp is simply a regular Python class that
    has been decorated with the `@PixieApp` decorator. Under the cover, the ` PixieApp`
    decorator instruments the class to add methods and fields required to run the
    app, such as the `run` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information on Python decorators can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get things started, the following code shows a simple *Hello World* PixieApp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode1.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows the structure of a PixieApp, how to define the routes,
    and how to instantiate and run the app. Because PixieApps are regular Python classes,
    they can inherit from other classes, including other PixieApps, which is convenient
    for larger projects to make the code modular and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routes are used to dynamically update all or part of the client screen. They
    can be easily defined by using the `@route` decorator on any class method, based
    on the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A route method is required to return a string that represents the HTML fragment
    for the update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: CSS and JavaScript are allowed to be used in the fragment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `@route` decorator can have one or more keyword arguments, which are required
    to be of the String type. These keyword arguments can be thought of as request
    parameters, which are used internally by the PixieApp framework to dispatch the
    request to the route that is the best match according to the following rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routes with most arguments are always evaluated first.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All arguments must match for a route to be selected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the route is not found, then the default route is selected as a fallback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes can be configured using a wildcard, that is, `*`, in which case, any
    value for the state argument will be a match.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is an example:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: A PixieApp is required to have one, and only one, default route, which is a route
    with no argument, that is, `@route()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very important to configure the routes in a way that doesn't cause conflict,
    especially if your application has hierarchical states. For example, a route associated
    with `state1="load"` could be responsible for loading data and then a second route
    associated with `(state1="load", state2="graph")` could be responsible for plotting
    the data. In this case, a request with both `state1` and `state2` specified will match
    the second route because route evaluation happens from most specific to least
    specific, stopping at the first matching route.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify, the following diagram shows how requests are matched with routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Routes](img/B09699_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Matching requests to routes
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected contract for a method defined as a route is to return an HTML
    fragment, which can contain Jinja2 templating constructs. Jinja2 is a powerful
    Python template engine that provides a rich set of features to dynamically generate
    text, including access to Python variables, methods, and control structures, such
    as `if...else`, `the for` loop, and so on. Covering all its features would be
    beyond the scope of this book, but let''s discuss a few important constructs that
    are used frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: If you want to know more about Jinja2, you can read the full documentation
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jinja.pocoo.org/docs/templates](http://jinja.pocoo.org/docs/templates)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables**: You can use the double-curly braces to access variables that
    are in scope, for example, `"<div>This is my variable {{my_var}}</div>"`. During
    rendering, the `my_var` variable will be replaced with its actual value. You can
    also use the `.` (dot) notation to access complex object, for example, `"<div>This
    is a nested value {{my_var.sub_value}}</div>"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**for loop**: You can use the `{%for ...%}...{%endfor%}` notation to dynamically
    generate text by iterating over a sequence of items (list, tuple, dictionary,
    and so on), as in the example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**if statement**: You can use the `{%if ...%}...{%elif ...%}...{%else%}…{%endif%}`
    notation to conditionally output text, as in the example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also important to know how variables and methods come into the scope
    of the JinJa2 template string returned by the route. PixieApp automatically provides
    access to three types of variables and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class variables and methods**: These are accessible using the `this` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The reason we''re not using the more Pythonic `self` keyword is that it
    is unfortunately already taken by Jinja2 itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Method arguments**: This is useful when the route arguments use the `*` value
    and you want to have access to that value at runtime. In this case, you can add
    arguments to the method itself using the same name as the one defined in the route
    arguments and the PixieApp framework will automatically pass the correct value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The order of the arguments actually doesn''t matter. You also do
    not have to use every argument defined in the route, which is convenient if you
    are only interested in using a subset of the arguments.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The variable will also be in the scope of the Jinja2 template string, as shown
    in the example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode2.py)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Local variables to the method**: PixieApp will automatically put all the local variables
    defined in the method in scope of the Jinja2 template string, provided that you
    add the `@templateArgs` decorator to the method, as shown in the example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode3.py)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generating requests to routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned before, PixieApp follows the SPA design pattern. After the first
    screen is loaded, all subsequent interactions with the server are done using dynamic requests
    as opposed to URL links as is the case for multipage web applications. There are
    three ways to generate a kernel request to a route:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `pd_options` custom attribute to define a list of states to be passed
    to the server, as in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you already have a JSON object that contains the `pd_options` value—as in the
    case of invoking `display()`—you would have to transform it into the format expected
    by the `pd_options` HTML attribute, which can be time-consuming. In this case,
    it is more convenient to specify `pd_options` as a child element, which allows
    the options to be passed directly as a JSON object (and avoid the extra work of
    transforming the data), as in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Programmatically by calling the `invoke_route` method, as in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: Remember to use `this`, as opposed to `self`, if you are calling
    this method from a Jinja2 template string, as `self` is already used by Jinja2
    itself.'
  prefs: []
  type: TYPE_NORMAL
- en: When the state values passed in `pd_options` need to be dynamically computed
    based on user selections, you need to use the `$val(arg)` special directive, which
    acts as a macro that will be resolved at the time the kernel request is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$val(arg)` directive takes one argument that can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ID of an HTML element on the page, such as an input or a combobox, as in
    the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A JavaScript function that must return the desired value, as in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: Dynamic value using the `$val` directive are supported by most of the
    PixieDust custom attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub project tracking sample application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's apply what we learned so far to implementing the sample application. To try
    things out, we want to use the GitHub Rest APIs ([https://developer.github.com/v3](https://developer.github.com/v3))
    to search for projects and load the results into a pandas DataFrame for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial code shows the welcome screen with a simple input box to enter
    the GitHub query and a button to submit the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode4.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things to note from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The Bootstrap CSS framework ([https://getbootstrap.com/docs/3.3](https://getbootstrap.com/docs/3.3))
    and the jQuery JS framework ([https://jquery.com](https://jquery.com)) are provided
    by the Jupyter Notebook. We can readily use them in our code without the need
    to install them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font Awesome icons ([https://fontawesome.com](https://fontawesome.com)) are
    also available by default in the Notebook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PixieApp code could be executed in multiple cells of the Notebook. Since
    we're relying on DOM element IDs, it is important to make sure that two elements
    do not have the same ID which would cause undesirable side effects. To that end,
    it is recommended to always include the unique identifier `{{prefix}}`, provided
    by the PixieDust framework, for example, `"query{{prefix}}"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The results are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A GitHub project tracking sample application](img/B09699_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Welcome screen of our GitHub Tracking application
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a new route that takes the user value and returns
    the results. This route will be invoked by the **Submit Query** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple, the following code doesn''t use a Python library to
    interface with GitHub, such as PyGithub ([http://pygithub.readthedocs.io/en/latest](http://pygithub.readthedocs.io/en/latest)),
    instead, we''ll directly call the REST APIs as documented in the GitHub website:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: When you see the following notation `[[GitHubTracking]]`, this means
    that the code is meant to be added to the `GitHubTracking` PixieApp class and,
    to avoid repeating the surrounding code over and over again, it has been omitted.
    When in doubt, you can always refer to the complete Notebook specified at the
    end of the section.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode5.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we created a route called `do_search` that takes one
    argument called `query`, which we use to build an API URL to GitHub. Using the
    `requests` Python module ([http://docs.python-requests.org](http://docs.python-requests.org))
    to issue a GET request to this URL, we get a JSON payload that we turn into a
    pandas DataFrame. According to the GitHub documentation, the Search API paginates
    with the next page being stored in the link''s headers. The code uses a `while`
    loop to go over each link and load the next page into a new DataFrame. We then
    concatenate all the DataFrames into one called `pdf`. All we have left to do is
    build the HTML fragment that will display the results. The fragment uses the Jinja2
    notation `{{...}}` to access the `pdf` variable defined as a local variable, which
    only works because we used the `@templateArgs` decorator in the `do_search` method.
    Notice that we also use a Jinja2 filter called `length` to display the number
    of repositories found: `{{pdf|length}}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on filters, visit the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jinja.pocoo.org/docs/templates/#filters](http://jinja.pocoo.org/docs/templates/#filters)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to invoke the `do_search` route when the user clicks on the **Submit Query**
    button. For that, we add the `pd_options` attribute to the `<button>` element,
    as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use the `$val()` directive in the `pd_options` attribute to dynamically retrieve
    the value of the input box with ID equals to `"query{{prefix}}"` and store it
    in the query argument.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the search results in a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding code loads all the data at once, which is not recommended since
    we could have a huge number of hits. Similarly, displaying it all in one go would
    make the UI sluggish and non-practical. Thankfully, we can easily build a paginated
    table without too much effort, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a route called `do_retrieve_page` that takes a URL as an argument and
    returns the HTML fragment for the table body
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintain the first, previous, next, and last URLs as fields in the PixieApp
    class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pagination widget (we'll use Bootstrap since it's available) with `First`,
    `Prev`, `Next`, and `Last` button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a table placeholder with the columns headers to be displayed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll now update the code for `do_search,` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The following code is referencing the `do_retrieve_page` method which
    we will define a little later. Please do not attempt to run this code as is until
    you also add the `do_retrieve_page` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode6.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code sample shows a very important property of PixieApps, which
    is that you can maintain state throughout the life cycle of the application by
    simply storing the data into class variables. In this case, we use `self.first_url`,
    `self.prev_url`, `self.next_url`, and `self.last_url`. These variables use the
    `pd_options` property for each button in the pagination widget and update each
    time the `do_retrieve_page` route is invoked. The fragment returned by `do_search`
    now returns a table with a placeholder for the body, identified by `body{{prefix}},`
    which becomes the `pd_target` for each button. We also use the `invoke_route`
    method to make sure that we get the first page when the table is first displayed.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen before that the HTML fragment returned by a route is used to replace
    the entire page, but in the preceding code, we use the `pd_target="body{{prefix}}"`
    attribute to signify that the HTML fragment will be injected in the body element
    of the table that has the `body{{prefix}}` ID. If needed, you can also define
    multiple targets for a user action, by creating one or more `<target>` elements
    as children of the clickable source element. Each `<target>` element can itself
    use all the PixieApp custom attributes to configure kernel requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our GitHub sample application, the `do_retrieve_page` method now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode7.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The `page` argument is a string that contains the name of the `url` class variable
    we want to display. We use the standard `getattr` Python function ([https://docs.python.org/2/library/functions.html#getattr](https://docs.python.org/2/library/functions.html#getattr))
    to get the `url` value from the page. We then issue a GET request on the GitHub
    API `url` to retrieve the payload as JSON format which we pass to the Jinja2 template
    to generate the set of rows that will be injected in the table. For that, we use
    the `{%for…%}` loop control structure available in Jinja2 ([http://jinja.pocoo.org/docs/templates/#for](http://jinja.pocoo.org/docs/templates/#for))
    to generate a sequence of `<tr>` and `<td>` HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the search results for the query: `pixiedust`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the search results in a table](img/B09699_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the list of GitHub repo resulting from a query
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Part 1, we showed how to create the `GitHubTracking` PixieApp, invoke the
    GitHub query REST API, and display the results in a table using pagination. You
    can find the complete Notebook with the source code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%201.ipynb`'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore more PixieApp features that will allow
    us to improve the application by letting the user drill down into a particular
    repository and visualize various statistics about the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to add a button to each row of the search results table that
    triggers a new route for visualizing the selected repository statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is part of the `do_search` function and adds a new column
    in the table header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the table, we update the `do_retrieve_page` method to add a new
    cell that contains a `<button>` element, with `pd_options` arguments that match
    the new route: `analyse_repo_owner` and `analyse_repo_name`. The values of these
    arguments are extracted from the `row` element used for iterating over the payload
    received from the GitHub request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this simple code change in place, restart the PixieApp by running the cell
    again and we can now see the button for each repo, even though we haven't yet
    implemented the corresponding route, which we'll implement next. As a reminder,
    when no matching route is found, the default route is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the table with the added buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the search results in a table](img/B09699_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding action buttons for each row
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the route associated with the Repo Visualization
    page. The design for this page is rather simple: from a combobox, the user chooses
    the type of data they want to visualize on the page. The GitHub REST API provides
    access to many types of data but, for this sample application, we will use the
    commit activity data, which is part of the Statistics category (see [https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data](https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data)
    for a detailed description of this API).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an exercise, feel free to improve this sample application by adding visualizations
    for other types of APIs, such as the Traffic API ([https://developer.github.com/v3/repos/traffic](https://developer.github.com/v3/repos/traffic)).
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that, even though most of the GitHub APIs work without
    authentication, the server may throttle the responses if you don't provide credentials.
    To authenticate the requests, you will need to use your GitHub password or generate
    a personal access token by selecting the **Developer settings** menu on your GitHub
    **Settings** page, then click on **Personal access tokens** menu, followed by
    the **Generate new token button**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate Notebook cell, we will create two variables for the GitHub user
    ID and token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These variables will be used later on to authenticate the requests. Note that,
    even though these variables are created in their own cell, they are visible to
    the entire Notebook, including the PixieApp code.
  prefs: []
  type: TYPE_NORMAL
- en: To provide good code modularity and reuse, we'll implement the Repo Visualization
    page in a new class and have our main PixieApp class inherit from it and automatically
    reuse its routes. This is a pattern to keep in mind when you start having large
    projects and want to break it down into multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main route for the Repo Visualization page returns an HTML fragment that
    has a drop-down menu and a `<div>` placeholder for the visualizations. The drop-down
    menu is created using Bootstrap `dropdown` class ([https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp](https://www.w3schools.com/bootstrap/bootstrap_dropdowns.asp)).
    To make the code easier to maintain, the menu items are generated using a Jinja2
    `{%for..` `%}` loop over an array of tuples ([https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences))
    called `analyses` that contains a description and a function for loading the data
    into a pandas DataFrame. Again here, we create this array in its own cell, which
    will be referenced in the PixieApp class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: The `load_commit_activity` function will be discussed later on in
    this section.'
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this sample application, the array only contains one element
    related to the commit activity, but any element you may add in the future will
    automatically be picked up by the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `do_analyse_repo` route has two arguments: `analyse_repo_owner` and `analyse_repo_name,`
    which should be sufficient to access the GitHub APIs. We also need to save these
    arguments as class variables because they will be needed in the route that generates
    the visualizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode8.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two things to note in the preceding code are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jinja2 template references the `analyses` array using the `this` keyword,
    even though the `analyses` variable is not defined as a class variable. This works
    because of another important PixieApp feature: any variable defined in the Notebook itself
    can be referenced as if they were class variables of the PixieApp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I store `analyse_repo_owner` and `analyse_repo_name` as class variables with
    a different name, for example, `_analyse_repo_owner` and `_analyse_repo_name`.
    This is important because using the same name would have a side effect on the
    route matching algorithm, which also looks at class variables to find arguments.
    Using the same name would then cause this route to always be found, which is not
    the desired effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action button link is defined by the `<a>` tag and uses `pd_options` to
    access a route that has one argument called `analyse_type`, as well as `pd_target`
    pointing at the `"analyse_vis{{prefix}}"` placeholder, `<div>,` defined below
    in the same HTML fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the PixieDust display() API using pd_entity attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the `pd_options` attribute to create a kernel request, the PixieApp
    framework uses the current PixieApp class as the target. However, you can change
    this target by specifying a `pd_entity` attribute. You could, for example, point
    at another PixieApp or, more interestingly, point at a data structure supported
    by the `display()` API, such as a pandas or Spark DataFrame. In this case, and
    provided that you include the correct options as expected by the `display()` API,
    the generated output will be the chart itself (an image in the case of Matplotlib,
    Iframe in the case of Mapbox, or an SVG in the case of Bokeh). One simple way
    to get the correct options is to invoke the `display()` API in its own cell, configure
    the chart as desired using the menus and then copy the cell metadata JSON fragment
    available by clicking on the **Edit Metadata** button. (You may first have to
    enable the button by using the menu **View** | **Cell Toolbar** | **Edit Metadata**).
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify `pd_entity` without any value. In this case, the PixieApp
    framework will use the entity passed as the first argument to the `run` method
    used to launch the PixieApp application. For example, `my_pixieapp.run(cars)`
    with `cars` being a pandas or Spark DataFrame created by the `pixiedust.sampleData()`
    method. The value of `pd_entity` can also be a function call that returns the
    entity. This is useful when you want to dynamically compute the entity before
    rendering it. As with other variables, the scope of `pd_entity` can be either
    the PixieApp class or any variable declared in the Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a function in its own cell that takes a prefix as
    an argument and returns a pandas DataFrame. We then use it as a `pd_entity` value in my
    PixieApp, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode9.py)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we used Python list comprehensions ([https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions))
    to quickly generate mock data based on the `key` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python list comprehensions are one of my favorite features of the Python language
    as they let you create, transform, and extract data with an expressive and concise
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can then create a PixieApp that uses the `compute_pdf` function as a `pd_entity`
    to render the data as a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode10.py)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, for simplicity, I hardcoded the key to `'prefix'` and
    I'll leave it as an exercise to use an input control and the `$val()` directive
    to make it user definable.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to notice is the use of the `pd_render_onload` attribute
    in the div that displays the chart. This attribute tells PixieApp to execute the
    kernel request defined by the element immediately after it is loaded into the
    browser DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results for the preceding PixieApp are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic DataFrame creation within a PixieApp
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our *GitHub Tracking* application, let''s now apply the `pd_entity`
    value to the DataFrame loaded from the GitHub Statistics API. We create a method
    called `load_commit_activity,` responsible for loading the data into a pandas
    DataFrame and returning it along with the `pd_options` needed to display the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode11.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code sends a GET request to GitHub, authenticated with the `github_user`
    and `github_token` variables set up at the beginning of the Notebook. The response
    is a JSON payload that we''ll use to create a pandas DataFrame. Before we can
    create the DataFrame, we need to transform the JSON payload in to the right format.
    Right now, the payload looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to drop the `days` key as it''s not needed for displaying the chart
    and, for proper chart display, we need to convert the value of the `week` key,
    which is a Unix timestamp, into a Python `datetime` object. This transformation
    is done using a Python list comprehension with a simple line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the current implementation, the `load_commit_activity` function is defined
    in its own cell, but we could also have defined it as a member method of the PixieApp.
    As a best practice, using its own cell is very convenient because we can unit
    test the function and iterate rapidly on it without incurring the overhead of
    running the full app every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the `pd_options` value, we can simply run the function with a sample
    repo information and then call the `display()` API in a separate cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using display() in a separate cell to get the visualization configuration
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the preceding chart, you need to select **Line Chart** and then, in
    the **Options** dialog, drag and drop the `week` column to the **Keys** box and
    the `total` column to the **Values** box. You also need to select Bokeh as the
    renderer. Once done, notice that PixieDust will automatically detect that the
    *x* axis is a datetime and will adjust the rendering accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **Edit Metadata** button, we can now copy the chart options JSON
    fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Capturing the display() JSON configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'And return it in the `load_commit_activity` payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to implement the `do_analyse_type` route in the `RepoAnalysis`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode12.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The route has one argument called `analyse_type,` which we use as a key to find
    the load function in the `analyses` array (notice that I again use a list comprehension
    to do the search quickly). We then call this function passing the repo owner and
    name to get the `vis_info` JSON payload and store the pandas DataFrame into a
    class variable called `pdf`. The returned HTML fragment will then use `pdf` as
    the `pd_entity` value and `vis_info["chart_options"]` as `pd_optio` `ns`. Here
    I use the `tojson` Jinja2 filter ([http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters))
    to ensure that it is properly escaped in the generated HTML. I am also allowed
    to use the `vis_info` variable even though it's been declared on the stack because
    I used the `@templateArgs` decorator for the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do before testing our improved application is to make sure
    the main `GitHubTracking` PixieApp class inherits from the `RepoAnalysis` PixieApp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode13.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of the Repo Analysis page is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking the PixieDust display() API using pd_entity attribute](img/B09699_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GitHub repo commit activity visualization
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to experiment further, you can find the complete Notebook for the
    *GitHub Tracking application* Part 2 here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%202.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking arbitrary Python code with pd_script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we look at the `pd_script` custom attribute which lets you
    run arbitrary Python code whenever a kernel request is triggered. There are a
    few rules that govern how the Python code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code has access to the PixieApp class using the `self` keyword, as well
    as any variables, functions, and classes defined in the Notebook, as in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a `pd_target` is specified, then any statement using the `print` function
    will be output in the `target` element. This is not the case if no `pd_target`
    is present. In other words, you cannot use `pd_script` to do a full-page refresh
    (you would have to use the `pd_options` attribute instead), as in the example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode14.py)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the code contains more than one line, it is recommended to use the `pd_script`
    child element, which lets you write the Python code using multiple lines. When
    using this form, make sure that the code respects the Python language rules for
    indentation, as in the example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode15.py)'
  prefs: []
  type: TYPE_NORMAL
- en: One common use case for `pd_script` is to update some state on the server before triggering
    a kernel request. Let's apply this technique to our *GitHub Tracking* application
    by adding a checkbox to switch the visualization between a line chart and a statistical
    summary of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fragment HTML returned by `do_analyse_repo`, we add the checkbox element
    used to switch between the chart and the statistics summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `checkbox` element, we include a `pd_script` attribute that modifies
    a variable state on the server based on the state of the `checkbox` element. We
    use the `$val()` directive to retrieve the value of the `show_stats_{{prefix}}`
    element and compare it with the `true string`. When the user clicks on the checkbox,
    the state is immediately changed on the server and, the next time the user clicks
    on the menu, the stats are showing instead of the charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to change the `do_analyse_type` route to dynamically configure
    `pd_entity` and `chart_options`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode16.py)'
  prefs: []
  type: TYPE_NORMAL
- en: '`chart_options` is now a local variable that contains options for displaying
    as a table if `show_stats` is `true` and regular line chart options if not.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pd_entity` is now set to the `get_pdf()` method, which is responsible for returning the
    appropriate DataFrame based on the `show_stats` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode17.py)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the pandas `describe()` method ([https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.describe.html))
    that returns a DataFrame containing summary statistics, such as count, mean, standard
    deviation, and so on. We also make sure that the first column of this DataFrame
    contains the name of the statistic.
  prefs: []
  type: TYPE_NORMAL
- en: The last change we need to make is to initialize the `show_stats` variable because,
    if we don't, then the first time we check it, we'll get an `AttributeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the internal mechanics of using the `@PixieApp` decorator, you can''t
    use the `__init__` method to initialize variables; instead, the PixieApp programming
    model requires you to use a method called `setup,` which is guaranteed to be called
    when the application starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**: If you have a class inheriting from other PixieApps, then the PixieApp
    framework will automatically call all `setup` functions from base classes using
    their order of appearance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the summary statistics being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking arbitrary Python code with pd_script](img/B09699_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary statistics for a GitHub repo
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the complete Notebook for the *GitHub Tracking* application Part
    3 here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%203.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: Making the application more responsive with pd_refresh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to improve the user experience by making the **Show Statistics** button directly
    show the statistics table instead of having the user to click on the menu again.
    Similar to the menu that loads the **Commit Activity**, we could add a `pd_options`
    attribute to the checkbox with the `pd_target` attribute pointing at the `analyse_vis{{prefix}}`
    element. Instead of duplicating `pd_options` in each of the controls that triggers
    a new display, we could add it once to `analyse_vis{{prefix}}` and have it update
    itself with the `pd_refresh` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the differences between the two designs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the application more responsive with pd_refresh](img/B09699_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sequence diagram with and without pd_refresh
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, step 1 is to update some state on the server side. In the case
    of the route being invoked by the **Control** shown in step 2, the request specification
    is stored in the control itself, triggering step 3, which is to generate the HTML
    fragment and inject it in the target element. With `pd_refresh`, the control doesn't
    know the `pd_options` to invoke the route, instead, it simply uses `pd_refresh`
    to signal the target element, which in turn will invoke the route. In this design,
    we only need to specify the request once (in the target element) and user control
    needs only to update state before triggering a refresh. This makes the implementation
    much easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the differences between the two designs, let's compare
    both implementations in the `RepoAnalysis` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the **Analysis** menu, the changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before, the control triggered the `analyse_type` route, passing the `{{analysis}}`
    selection as part of the kernel request, targeting `analyse_vis{{prefix}}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After, the control now stores the selection state as a class field and asks
    the `analyse_vis{{prefix}}` element to refresh itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the changes for the **Show Statistics** checkbox are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the checkbox simply set the `show_stats` state in the class; the user had
    to click on the menu again to get the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After, the visualization is updated as soon as the checkbox is selected, thanks
    to the `pd_refresh` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the changes for the `analyse_vis{{prefix}}` element are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before, the element didn''t know how to update itself, it relies on other controls
    to direct a request to the appropriate route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After, the element carries the kernel configuration to update itself; any control
    can now change state and call refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the complete Notebook for this section for the *GitHub Tracking*
    application Part 4 here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/GitHub%20Tracking%20Application/GitHub%20Sample%20Application%20-%20Part%204.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PixieApp programming model provides a mechanism for packaging the HTML and
    logic of a complex UI construct into a widget that can be easily called from other
    PixieApps. The steps to create a widget are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PixieApp class that will contain the widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a route with a special `widget` attribute, as in the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will be the starting route for the widget.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a consumer PixieApp class that inherits from the widget PixieApp class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the widget from a `<div>` element by using the `pd_widget` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a widget and consumer PixieApp class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%203/sampleCode18.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered the foundational building blocks of the PixieApp
    programming model that lets you create powerful tools and dashboards directly
    in the Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: We've also illustrated PixieApp concepts and techniques by showing how to build
    a *GitHub Tracking* sample application, including detailed code examples. Best
    practices and more advanced PixieApp concepts will be covered in [Chapter 5](ch05.xhtml
    "Chapter 5. Python and PixieDust Best Practices and Advanced Concepts"), *Python
    and PixieDust Best Practices and Advanced Concepts*, including events, streaming,
    and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should hopefully have a good idea of how Jupyter Notebooks, PixieDust,
    and PixieApps can help bridge the gap between data scientists and developers by
    enabling them to collaborate from within a single tool, such as Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll show how to free the PixieApp from the Notebook and publish
    it as a web application using the PixieGateway microservice server.
  prefs: []
  type: TYPE_NORMAL
