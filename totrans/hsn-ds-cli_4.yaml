- en: Bash Functions and Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been working with bash interactively and had to rely on the bash `history` for
    what we've done. Wouldn't it be nice if you had a portable way to share and store
    the commands you want to run? Well, that functionality exists in the form of shell
    scripts composed of shell functions.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to extend the history we covered in [Chapter 1](d26c5d26-6302-4b9d-b6ce-62b1ab13db0d.xhtml),
    *Data Science at the Command Line and Setting It Up*. Terminals originated as
    text-only devices and evolved graphical support for simple drawing primitives,
    such as rendering enclosed cells in tabular data. The pinnacle of Terminal graphics
    was made by DEC with canvas and vector-graphic support in the form of SIXEL and
    REGIS graphics, respectively. As physical Terminals became a thing of the past,
    lightweight Terminal emulators regressed to being text-only. A renaissance in
    graphics support from Terminal emulators has been occurring with the alacritty,
    wsltty, xterm, mlterm, st, iTerm2, and hterm emulators.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend wsltty with SIXEL support for Windows users, xterm or mlterm with
    SIXEL support for Linux users, and iTerm2 on macOS with PNG rendering (SIXEL support
    may be added in the future).
  prefs: []
  type: TYPE_NORMAL
- en: 'With a recommended Terminal emulator, we will show off canvas-style graphical
    rendering in the Terminal, and of course, include text mode support for DUMB Terminals.
    We''ll only mention that ascii-art libraries exists, `aalib` (**ascii art lib**),
    `libcaca`, and braille fonts that attempt to render graphics to the Terminal using
    font characters only. Here, we''ll work with SIXEL for Linux/Windows and PNG for
    macOS, and leave DUMB Terminal output for all advanced alternatives as an adventure
    for the reader. In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to execute a script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments/parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced shell scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure your Terminal for graphics mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data mining graphable data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphing data with gnuplot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My first shell script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first shell script will cover the basics of how to tell the computer to
    run the shell script.
  prefs: []
  type: TYPE_NORMAL
- en: She bangs, she bangs!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re not talking about that popular Ricky Martin song. We''re talking about
    what every bash script needs in order to run. If you''ve worked with other programming
    languages, you may have noticed the first line always starts with a `#!`. This
    tells the system which interpreter to use. For example, if you''ve worked with
    Python before, you''ve probably seen `#!/usr/bin/env python2.7` in a script. With
    bash, it''s no different. Let''s go ahead and create a new file named `hello_world.sh`
    and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: File editors are the new, hip thing to debate about on the Internet. For example,
    search for `vim` versus `emacs` or `nano` versus `pico`. If you don't have a favorite
    editor, we won't force your selection, but you should use a Very Immensely Method
    to find your one true editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and save this file as `hello_world.sh` and then let''s make the script
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this down. The first line is the shebang that we mentioned. Our
    functions are called `greet_everyone` and `greet_yourself`. Inside the curly brackets, `{
    }`, we can run as many commands as we want. Finally, the functions are called
    below it. Also, notice the `${USER}` variable inside the script. You might be
    wondering how bash was smart enough to print out your username without you defining
    it. Every bash environment has a set of preconfigured variables that you can view.
    Go ahead and run the `printenv` command to see what's available.
  prefs: []
  type: TYPE_NORMAL
- en: This is great if we want to greet the entire world and use your username. But,
    what if we want to take this further?
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments, positional parameters, and IFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional arguments, positional parameters, and the **IFS** (**internal field
    separator**) are advanced list-processing mechanics in bash. We'll cover each
    of them in turn to ensure a base knowledge of how the shell interacts with them.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt me baby one more time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed how to invoke our function, but how do we prompt our users for
    input? The computer can''t read your mind—it can only read your keyboard input!
    For bash to read input, you''ll have to use the (you guessed it) `read` command.
    Let''s expand our function''s capabilities. Go ahead and modify your `hello_world.sh` script
    from the previous section with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added the `read name` code, replaced the `${USER}` variable with `${1:-$USER}` in
    the `greet_yourself` function, and added our first argument to our `greet_yourself
    $name` function call. When `$name` is passed into the `greet_yourself` function,
    it''s assigned to the `$1` variable. That `${1:-$USER}` magic variable is saying
    expand `$1`; if empty, replace with `$USER` retaining the same output behavior
    of our original function if no username is provided by just pressing the `enter` key.
    Run it again to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32e846b5-c3ab-410b-b248-70fe7b413b65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s focus on just our function. Paste the following code into your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a fancy means of creating the `greetlib.sh` file. The `<<EOF` here is
    doc redirection that indicates that we want to specify the standard input to `cat`
    and redirect its standard output to `greetlib.sh`. Everything after that first
    line is shell-interpreted content that's to be concatenated to the end of our
    output file until `EOF` is read. Shell-interpreted content means that variables
    are replaced with values from your current shell environment, we've escaped our
    shell variables with `\$` so that they will be rendered into the `greetlib.sh`
    file as `$` and not interpreted into actual values. Finally, we can source our
    function into our current shell environment and invoke it. We'll practice that
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Feed the function input!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our shell function accepts arguments, known as positional parameters, which
    are the equivalent of ARGV from a POSIX C runtime. Function arguments are automatically
    assigned by their numeric position to variables in this form: `$1, $2, $3, ..,
    $9`. The `$0` variable exists, but contains the name that was used to invoke the
    shell. Some inquiring minds might wonder what happens after the ninth argument.
    Well we need to use the full variable dereferencing syntax, for the tenth and
    eleventh variables, `${10}` and `${11}`, respectively. So what does that all look
    like? Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.` operator is used to read and evaluate a shell script in your current
    execution environment, as though you had typed all of `greetlib.sh` into the command
    line and pressed the `enter` key. This calls the `greet_yourself` function with
    the first positional parameter, `"Joey"`, assigned to `$1`. To jump ahead, we
    have types of positional parameters: options (covered at the end of the chapter)
    and arguments. Options come in short and long forms and are identified by a single
    hyphen or double-hyphen, respectively. Short options are single characters and
    long options are full semantic words that describe values to set. If an argument
    needs a literal hyphen at the start of its value, it needs to be distinguished
    from options by proceeding with a double-hyphen. Hypothetically, this is gobbledygook
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These examples showcase how options and arguments can be passed to a function,
    because the options are just positional parameters. In the first greeting call,
    we assign `--capitalize` to the first positional parameter, `$1`, and `--name=”Joey”` to
    the second positional parameter, `$2`. In the second greeting call, we assign `--lowercase` to
    `$1`, `--` to `$2`, and `-RoBoT1` to `$3`. Our function is basic and lacks the
    ability to process the `--capitalize` and `--lowercase` options as function features.
    We pretend the first greeting call should output `"JOEY"`, and the second greeting
    `-robot1`. Some may wonder how a command can distinguish options that begin with
    a hyphen from an argument, such as `-RoBoT1`. The bare double-hyphen `--` indicates
    that all following positional parameters are to be treated as arguments and not
    processed as options. Again, we'll dig into option processing at the end of the
    chapter, but it's easiest to show function invocations all at once.
  prefs: []
  type: TYPE_NORMAL
- en: Down the rabbit hole of IFS and bash arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Positional parameters are created from the arguments to a shell script, function,
    or the `set` command. The assignment of words to positional variables is accomplished
    by splitting the unquoted string along any of the delimiters contained within
    the IFS variable. The IFS variable defaults to the string, which consists of a
    space, tab, and newline characters. Since the IFS is a variable, it''s possible
    to modify this variable, which is useful when iterating over non-space-delimited
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code exemplifies how the PATH variable, which consists minimally
    of `/bin:/usr/bin`, can be split with a colon delimiter so that each path segment
    can be manipulated. We expect the reader can extrapolate how this might be useful
    for iterating over comma-separated lists, or similar simply delimited datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to limitations in modifying positional parameters, bash 4 introduced arrays.
    In the event that your shell scripts become sufficiently complex to require arrays,
    we encourage you to consider upgrading to a full-fledged scripting language, such
    as Perl, Python, or Ruby, that''s better-suited to handling various list iterations
    that bash doesn''t natively support. Delving in, bash arrays are zero-indexed,
    and are accessed with the `${ARRAY[#]}` special syntax, where the `#` sign should
    be replaced by the integer array index or the special values of `@` or `*`, which
    represent the quoted elements or unquoted elements converted into a string. Here''s
    some code as an example of bash arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Advanced shell scripting magic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the dark magic section of the chapter. It will demonstrate advanced
    shell scripting by taking the preceding lessons and features, and converting them
    into what could be considered a small program.
  prefs: []
  type: TYPE_NORMAL
- en: Here be dragons, ye be warned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple piece of introductory code is great to get a feel for the flavor of
    a language, but we're going to introduce some dark magic in the form of some complex
    utility functions that can be helpful in everyday situations. We'll use a `lineinfile` function
    to insert arbitrary text into a file—it's not a full-featured application, just
    enough to help ensure some simple text is injected into a file. The second function, `ncz`,
    leverages bash IP networking (yes, bash4 can support IP networking YMMV with your
    distro) to perform a socket test equivalent to what `netcat -z` does. Additionally,
    it shows how to make a function behave like a command-line program by parsing
    simple argument flags.
  prefs: []
  type: TYPE_NORMAL
- en: Text injection of text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to create a function that can inject text into an existing file.
    Here''s our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The intended usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`lineinfile` starts off with the standard `function() {}` definition template.
    It reads the first positional parameter passed to the function, `$1`, into the `FILE` variable,
    and shifts the positional parameters so that each parameter''s index is decremented
    by one, so `$2` becomes `$1`, `$3` becomes `$2`, and so on. The second parameter
    is assigned to the `LINE` variable and we prefix it with the regular expression
    start of line `^` and end of line `$` delimiters to indicate that the string being
    injected must match an entire line (sorry, there''s no advanced regex support
    in this simple function). The third parameter looks for context so that we can
    inject the line after the context. Again no ability to specify injecting before
    the context, just after the context if it exists. The fourth parameter is the
    operating mode of our `lineinfile` function to either `add` (adding text is the
    default behavior) or to delete (use the `del` mode).'
  prefs: []
  type: TYPE_NORMAL
- en: Bash networks for fun and profit!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need to interact with network services or APIs. Here, we''ll
    introduce some complete code that tests TCP endpoints, which is useful for checking
    whether an API service is listening and available. This code can be pasted into
    your Terminal, or saved to a file and loaded into your shell environment with
    the `.` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, this code has some minor magic. `getopts` is a function that parses positional
    parameters, according to POSIX processing into options, and assigns the next option
    to the variable specified, in this case opt. It supports short and long options,
    and options can have parameters; parameters would be stored in `OPTARG`. This
    example uses a trivial option string of `:hv`. The colon character indicates that
    invalid option flags should be denoted with the question mark character, `?`.
    The `h` option is for our help flag and `v` is used so we can set a `VERBOSE` flag.
    The `while` loop calls the `getopts` function, which modifies the positional parameters.
    When the `getopts` function completes, it's necessary to shift the processed positional
    parameters out so that we can treat non-options as function arguments. `OPTIND` is
    the index of the last option parsed, so subtracting one from that and shifting
    the positional parameters by that amount ensures that we only proper arguments
    remain in our positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The code attempts to support accepting arguments in the form of `host:port`
    or `host port`. The support for single-parameter or two-parameter arguments is
    handled by always using the second argument as the port, and if there's no second
    argument, defaults to splitting the first parameter on the colon character using
    prefix and suffix removal. The `HOST=${1%:*}` assignment attempts to extract a
    host component from a `host:port` argument by expanding the first positional argument,
    stripping all trailing characters (`%` is a reverse-substitution match) to the
    first colon character (the delimiter between `host:port`) so that we're left with
    just the host portion of the variable. If the reverse match fails, which indicates
    no port components, the unmodified expansion of `$1` will be assigned. To get
    the port, we look at the second argument. If it doesn't exist, we default to the
    port extracted from the first positional argument by stripping the `host:` portion
    of `$1`.
  prefs: []
  type: TYPE_NORMAL
- en: The real dark magic involves file descriptors and bash's IP network support.
    We open file descriptor 6 inside a subshell. We attach the input/output of the
    socket created by `/dev/tcp/$HOST/$PORT` to this file descriptor. Anything written
    to the file descriptor will be sent via a TCP socket to `tcp://$HOST:$PORT`, and
    any responses can be read from the same file descriptor. As network connections
    can error, we capture the return code of the socket open to the `RC` (that’s short
    for return code) variable. We then evaluate whether output is desired from a verbose
    option flag and the status of the return code, printing success/failure according
    to the return code. In C programs, a return code of 0 indicates success, so `true0` indicates
    that the function has invoked to request the verbose mode and a successful socket
    connection was made. Finally, the return code is returned from the function so
    that the status of the remote socket can be evaluated via a shell pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a self-explanatory invocation of the preceding explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From dumb Terminal to glam Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use gnuplot to render dumb text graphics and canvas-style plots
    inside our Terminal. To begin, we need some basic configuration for our gnuplot
    startup. Put the following in `~/.gnuplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a wrapper around gnuplot to get some fancy graphical output.
    This wrapper looks at the `GNUTERM` environment variable of your current shell
    and does some calculations on the Terminal''s width and height so that gnuplot
    knows how big a window it has. The wrapper will update our `~/.gnuplot` configuration
    with the graphics capabilities specified for our Terminal. We aren''t going to
    delve into the wrapper, but just use it as another command. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your OS and Terminal, you'll need to specify the correct graphics
    backend for your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows users with wsltty, and Linux users with mlterm or xterm, should set
    the following environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'macOS users with iTerm2 should use this environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's verify that we're able to plot a graphical test pattern. If your dumb
    Terminal doesn't support graphical mode, we include a text mode test afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the graphical test, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in a graphical Terminal output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f360f088-ca0a-4844-b573-c8ca23660da6.png)'
  prefs: []
  type: TYPE_IMG
- en: Some quick callouts to the test output are important for styling your output
    graphs. The line type on the far right of the test graphic is abbreviated as `lt`
    and provides the visual marker for the plotted tics (or points) of the plot, for
    example, *, +, and x. The linewidth, abbreviated to `lw`, is on the bottom left
    and sets the line's thickness for the plotted line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terminal doesn''t support graphics mode, text plotting can be used.
    Invoke the text test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Which should result in a Terminal output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82efbc34-3db3-4731-809c-4972c4515e58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we need an `alias` to invoke our function with the `GNUTERM` environment
    variable that''s set to an acceptable graphics backend. Run the following alias
    with the `GNUTERM` variable set as determined to work with your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Who, what, where, why, how?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s return to our book data and start to pare it down to the interesting
    bits. Let''s look at just a little bit of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That spat out a bunch of data with very long lines. Let''s try again—maybe
    we really only care about the headers, so let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there''s a lot of text, let''s remove the text fields and focus on numeric
    data by removing `product_title`, `review_headline`, and `review_body`, which
    correspond to fields 6,13, and 14\. Since we''re looking at pseudo big data, let''s
    take all the numerical or Boolean flag fields and dump all the text reviews (we
    can leave that for the natural-language processing folks to analyze), try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like that, we''ve reduced our data size from 6.3 GB to 383 MB of pruned
    `test.tsv` data, which is much more manageable. Now, let''s import this into a
    SQL database to make aggregating tabular data as easy as a SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find the products with the most reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output (counts may differ) should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '54,000 reviews seems like something we could plot some interesting data for,
    so let''s focus on the product ID `B00L9B7IKE`. For plotting, we know which product
    ID we''re looking at, so let''s adjust our query to not report the product ID
    and just focus on the dates, star rating, and counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That's some plottable data if I've ever seen some. We can track how many reviews
    we're getting by day or month, and when we graph this, we can look for anomalies,
    such as an exceptional number of five-star reviews on a single day when prior
    days didn't stick out so much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our data still isn''t quite right; for plotting, we want to group the star
    ratings by date in a single row, so we''ll need to perform another translation
    on the data. We also drop the `-` column option so we get condensed output, and
    we can pipe this through `tr` when we''re ready to pass the data to gnuplot. We''ll
    also save this output into `clusterchart.dat` so that our plotting commands are
    short and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s our condensed output for graphing with gnuplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Enter the mind's eye
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check out what this looks like. Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb22fb88-dc2a-4844-89f6-40bb2eb7f1b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s do the exact same operation, but output the `dumb` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a text-based output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7cfea49-063b-4a16-bd4a-d70bc566458c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To break down what we did, check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to set `GNUTERM`, which should default to what we set in `~/.bash_profile`.
    This tells our gnuplot wrapper which output backend to use. For `GNUTERM=dumb`,
    it will be a text backend. The next part is `gnuplot` with the `-e` expression
    argument. The expression is `gnuplot` syntax. We first set our plots to histograms
    instead of line graphs with `set style data histograms`. Next, we specify the
    bar color by setting it to a flood fill with a solid border and use linetype `-1` as
    the default linetype. After we've defined our plot style, we tell gnuplot to plot
    our data with `plot 'clusterchart.dat'`. Each comma-separated parameter to plot
    represents a column to plot for each row of data in `clusterchart.dat`. We specify
    that the first column in our plot should use the second column of data and use
    the first column of data as our x-label, as denoted by `2:xtic(1) ti col`.
  prefs: []
  type: TYPE_NORMAL
- en: The second column in our plot uses the same `clusterchart.dat` as input by indicating
    the same with two concatenated single quotes and specifies the use of the third
    data column for tick data. The third, fourth, and fifth columns use the same notation
    as the second column, which is to indicate the reuse of `clusterchart.dat` and
    to specify the data column to extract the y-tick data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to get a little fancier, we can use rowstacking instead of clustered
    bar graphs so we can visualize our data more compactly. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a stacked bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5dfc76-990e-4092-89cb-6656d7d648f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to see percentages, we can use our `barchart` wrapper in stacked
    mode. It''s nice to see the discrepancy between different data segments. Try invoking
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a907dd3-adbb-4195-adba-75a14599e1b8.png)'
  prefs: []
  type: TYPE_IMG
- en: This is using our bar chart wrapper in stacked mode (`-s`), and specifying our
    `clusterchart.dat` input file, with the gnuplot script as the last parameter.
    For gnuplot, we're telling it to perform a single iterative plot for `i=2` to
    `6`. The `$data` variable is being set by the bar chart wrapper to the content
    of `clusterchart.dat`. The using parameter is multiplying our fraction by `100`
    to create the percentage of the bar chart for each element, `i`, of the total
    from column `7`. `xtic(1)` is setting the `xtic` mark titles to the contents of
    column 1 for each row of data graphed in a column. In this example, we need to
    add the `column(i)` title to get the key title set properly to the column headers,
    instead of using the last referenced `column(7)` header.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the ability to reuse bash code, a collection of scripts can be cobbled
    together to enhance your command-line productivity. And with the ability to visualize
    results, you can peer into datasets and perform data mining tasks more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dig deeper into bash control flow to create richer
    functions.
  prefs: []
  type: TYPE_NORMAL
