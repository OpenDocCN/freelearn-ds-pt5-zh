<html><head></head><body>
        

                            
                    <h1 class="header-title">Interactive Widgets</h1>
                
            
            
                
<p>There is a mechanism for Jupyter to gather input from the user while the script is running. To do this, we put coding in the use of a widget or user interface control in the script. The widgets we will use in this chapter are defined at <a href="http://ipywidgets.readthedocs.io/en/latest/">http://ipywidgets.readthedocs.io/en/latest/</a></p>
<p>For example, there are widgets for the following:</p>
<ul>
<li><strong>Text input</strong>:<strong> </strong>The Notebook user enters a string that will be used later in the script.</li>
<li> <strong>Button clicks</strong>:<strong> </strong>These<strong> </strong>present the user with multiple options by way of buttons. Then, depending on which button is selected (clicked on); your script can change direction according to the user.</li>
<li><strong>Slider</strong>:<strong> </strong>You can provide the user with a slider where the user can select a value within the range you specify, and then your script can use that value accordingly.</li>
<li><strong>Toggle box and checkboxes</strong>:<strong> </strong>These<strong> </strong>let the user select the different options of your script that they are interested in working with.</li>
<li><strong>Progress bar</strong>:<strong> </strong>A<strong> </strong>progress bar can be used to show how far along they are in a multi-step process.</li>
</ul>
<p>In some cases, this can be wide open as the underlying <em>gather input from the user</em> is generally available. Therefore, you could make really interesting widgets that do not fit the standard user, input a control paradigm. For example, there is a widget allowing a user to click on a geographical map to discover data.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li> Installing widgets</li>
<li> Widget basics</li>
<li> Interact widget</li>
<li> Interactive widget</li>
<li> Widgets package</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing widgets</h1>
                
            
            
                
<ul>
<li>The widgets package is an upgrade to the standard Jupyter installation. You can update the widgets package using this command:</li>
</ul>
<pre style="padding-left: 90px"><strong>pip install ipywidgets</strong></pre>
<ul>
<li>Once complete, you must then upgrade your Jupyter installation using this command:</li>
</ul>
<pre style="padding-left: 60px"><strong>jupyter nbextension enable --py widgetsnbextension</strong></pre>
<ul>
<li>And then you must use this command:</li>
</ul>
<pre style="padding-left: 60px"><strong>conda update jupyter_core jupyter_client</strong></pre>
<ul>
<li>We put together a basic example widget Notebook to make sure everything is working:</li>
</ul>
<pre style="padding-left: 60px"> #import our libraries 
from ipywidgets import * 
from IPython.display import display 
 
#create a slider and message box 
slider = widgets.FloatSlider() 
message = widgets.Text(value = 'Hello World') 
 
#add them to the container 
container = widgets.Box(children = (slider, message)) 
container.layout.border = '1px black solid' 
 
display(container) </pre>
<ul>
<li>We end up with the following screenshot, where the container widget is displayed enclosing the slider and the message box:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/eb4e0f64-ff6d-4e04-a27f-8cbe06b8a4b4.png" style="width:59.42em;height:24.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Widget basics</h1>
                
            
            
                
<p>All widgets work the same, generally:</p>
<ul>
<li>You can create or define an instance of a widget.</li>
<li>You can preset the attributes of a widget, such as its initial value, or a label to be displayed.</li>
<li>Widgets can react to different inputs from a user. The inputs are gathered by a handler or Python function that is invoked when a user performs some action on a widget, for example, to call the handler if the user clicks on a button.</li>
<li>The value of a widget can be used later in your script just as any other variable. For example, you can use a widget to determine how many circles to draw.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Interact widget</h1>
                
            
            
                
<p>Interact is the basic widget which is appears to be used to derive all other widgets. It has variable arguments, and depending on the arguments, will portray a different kind of user input control.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interact widget slidebar</h1>
                
            
            
                
<p>We can use interact to produce a slidebar by passing in an extent. For example, we have the following script:</p>
<pre>#imports 
from ipywidgets import interact 
 
# define a function to work with (cubes the number) 
def myfunction(arg): 
    return arg+1 
 
#take values from slidebar and apply to function provided 
interact(myfunction, arg=9); </pre>
<p>Note that the semicolon following the <kbd>interact</kbd> function call is required.</p>
<p>We have a script which does the following:</p>
<ul>
<li> References the package we want to use</li>
<li> Defines a function that is called for every user input of a value</li>
<li> Calls to interact, passing our handler and a range of values</li>
</ul>
<p class="mce-root"/>
<p>When we run this script, we get a scrollbar that is modifiable by the user:</p>
<div><img src="img/cd952981-9135-4f32-9feb-9b1a599b69d2.png"/></div>
<p>The user is able to slide the vertical bar over the range of values. The upper end is 27 and the lower end is -1 (assuming we could pass additional arguments to interact to set the range of values selectable). <kbd>myfunction</kbd> is called every time the value in the interact widget is changed and the result printed. Hence, we see 27 selected and the number 28 displayed (following the processing of <kbd>myfunction</kbd> - 27 + 1).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interact widget checkbox</h1>
                
            
            
                
<p>We can change the type of control generated, based on the arguments passed to interact. If we had the following script:</p>
<pre>from ipywidgets import interact<br/>def myfunction(x):<br/>    return x<br/># the second argument defines which of the interact widgets to use<br/>interact(myfunction, x=False);</pre>
<p>We are doing the same steps as before; however, the value passed is <kbd>False</kbd> (but it could also be <kbd>True</kbd>). The <kbd>interact</kbd> function examines the argument passed, determines it is a Boolean value, and presents the appropriate control for a Boolean: a checkbox.</p>
<p class="mce-root"/>
<p>If we run the preceding script in a Notebook, we get a display like the following:</p>
<div><img src="img/bc2e0301-501b-4ebd-8baf-693a23c29c0d.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Interact widget textbox</h1>
                
            
            
                
<p>We can generate a text input control, again by passing in different arguments to interact. For example, see the following script:</p>
<pre style="padding-left: 60px">from ipywidgets import interact<br/>def myfunction(x):<br/>    return x<br/>#since argument is a text string, interact generates a textbox control for it<br/>interact(myfunction, x= "Hello World");</pre>
<p class="mce-root"/>
<p>This produces a text input control with the initial value of <kbd>Hello World</kbd>:</p>
<div><img src="img/e76f1816-f446-4848-b31b-90448398e899.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Interact dropdown</h1>
                
            
            
                
<p>We can also use the interact function to produce a drop-down listbox for the user to select from. In the following script we produce a dropdown with two choices:</p>
<pre style="padding-left: 60px">from ipywidgets import interact 
def myfunction(x): 
    return x 
interact(myfunction, x=['red','green']); </pre>
<p>This script will do the following:</p>
<ul>
<li> Pull in the interact reference,</li>
<li> Define a function that will be called whenever the user changes the value of the control</li>
<li>Calls the <kbd>interact</kbd> function with a set of values, which interact will interpret to mean create a dropdown for the user.</li>
</ul>
<p class="mce-root"/>
<p>If we run this script in a Notebook, we get the following display:</p>
<div><img src="img/540c3757-470d-424d-bb5f-766841b31846.png"/></div>
<p>The preceding screenshot shows us that the value printed at the bottom will change according to what is selected in the dropdown by the user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interactive widget</h1>
                
            
            
                
<p>There is also an interactive widget. The interactive widget works like the interact widget, but does not display the user input control until called upon directly by the script. This would be useful if you had some calculations that had to be performed for the parameters of the widget display, or even if you wanted to decide whether you needed a control at runtime.</p>
<p>For example, we could have a script (similar to the previous script) as follows:</p>
<pre>from ipywidgets import interactive<br/>from IPython.display import display<br/>def myfunction(x):<br/>return x<br/>w = interactive(myfunction, x= "Hello World ");<br/>display(w)</pre>
<p>We have made a couple of changes to the script:</p>
<ul>
<li> We are referencing the interactive widget</li>
<li> The interactive function returns a widget, rather than immediately displaying a value</li>
<li> We must script the display of the widget ourselves</li>
</ul>
<p>If we run the following script, to the user it looks very similar:</p>
<div><img src="img/e4173c7c-347a-4156-9f31-f53f900dbdd5.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Widgets</h1>
                
            
            
                
<p>There is another package of widgets, called <kbd>widgets</kbd>, that has all of the standard controls you might want to use, with many optional parameters available to customize your display.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The progress bar widget</h1>
                
            
            
                
<p>One of the widgets available in this package displays a progress bar to the user. We could have the following script:</p>
<pre>import ipywidgets as widgets 
widgets.FloatProgress( 
    value=45, 
    min=0, 
    max=100, 
    step=5, 
    description='Percent:', 
) </pre>
<p>The preceding script would display our progress bar as follows:</p>
<div><img src="img/a6615908-832a-474a-98d0-b7766bd0a2d0.png"/></div>
<p>We see a progress bar that looks to be 45%.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The listbox widget</h1>
                
            
            
                
<p>We could also use the <kbd>listbox</kbd> widget, called a <kbd>Dropdown</kbd>, as in the following script:</p>
<pre>import ipywidgets as widgets 
from IPython.display import display 
w = widgets.Dropdown( 
    options={'Pen': 7732, 'Pencil': 102, 'Pad': 33331}, 
    description='Item:', 
) 
display(w) 
w.value </pre>
<p>This script will display a listbox to the user with the values <kbd>Pen</kbd>, <kbd>Pencil</kbd>, and <kbd>Pad</kbd>. When the user selects one of the values, the associated value is returned in the <kbd>w</kbd> variable, which we display as in the following screenshot:</p>
<div><img src="img/b28ed7dc-5743-4f0b-a3f8-7668f78ebc7a.png"/></div>
<p>Therefore, we see the inventory value associated with Pen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The text widget</h1>
                
            
            
                
<p>The <kbd>text</kbd> widget gathers a text string from the user for reuse elsewhere in your script. A text widget has a description (label) and a value (entered by the user or preset in your script).</p>
<p>In this example, we will just gather a text string and display it on the screen as part of the output for the script. We will use the following script:</p>
<pre>from ipywidgets import widgets<br/>from IPython.display import display<br/>#take the text from the box, define variable for handler<br/>text = widgets.Text()<br/>#display it<br/>display(text)<br/>def handle_submit(sender):<br/>    print(text.value)<br/>#when we hit return in the textbox call upon the handler<br/>text.on_submit(handle_submit)</pre>
<p class="mce-root"/>
<p>The Python package that contains the basic widgets is <kbd>ipywidgets</kbd>, so we need to reference that. We define a handler for the text field that will be called when the user hits submit after entering their text value. When we do this, we are using the <kbd>text</kbd> widget.</p>
<p>If we run the preceding script in a Notebook, we get a display as follows:</p>
<div><img src="img/cf36f06c-4c69-4726-809f-6c8ed62076d3.png"/></div>
<p>We should point out some of the highlights of this page:</p>
<ul>
<li> The ordering of the elements of the page is important. The text field referenced by the handler must be defined before the reference.</li>
<li> When invoking a widget, the widget automatically looks for any handlers that might be associated with the script. In this case, we have a <kbd>submit</kbd> handler. There are many other handlers available. <kbd>text.on_submit</kbd> assigns the handler to the widget.</li>
<li> Otherwise, we have a standard Python Notebook.</li>
</ul>
<p class="mce-root"/>
<ul>
<li>If we run the script (Cell | Run All), we get the preceding screenshot (waiting for us to enter a value in the text box):</li>
<li>So, our script has set up a widget for gathering input from the user and later done something with that value. (We are just displaying it here, but we could use the input for further processing.)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The button widget</h1>
                
            
            
                
<p>Similarly, we can use a <kbd>Button</kbd> widget in our script, as can be seen in the following example: </p>
<pre style="padding-left: 60px">from ipywidgets import widgets 
from IPython.display import display 
 
button = widgets.Button(description="Submit"); 
display(button) 
 
def on_button_clicked(widget): 
    print("Clicked Button:" + widget.description); 
     
button.on_click(on_button_clicked); </pre>
<p>This script does the following:</p>
<ul>
<li> References the features we want to use from the <kbd>widgets</kbd> packages.</li>
<li> Creates our button.</li>
<li> Defines a handler for the click event on a button. The handler receives the <kbd>Button</kbd> object that was clicked upon (the widget).</li>
<li> The handler displays information about the button clicked on (you can imagine if we had several buttons in a display, we would want to determine which button was clicked).</li>
<li> Lastly, we assign the defined handler to the <kbd>Button</kbd> object we created.</li>
</ul>
<p>Note the indentation of the coding for the handler; this is the standard Python style that must be followed.</p>
<p>If we run the preceding script in a Notebook, we get a display like the following screenshot:</p>
<div><img src="img/b1b16a32-4ec3-4fc2-87b7-1e51f2254c05.png" style="width:43.25em;height:20.58em;"/></div>
<p>Note the <kbd>Submit</kbd> button at the bottom of the following image. You could change other attributes of the button, such as its position, size, color, and many more. </p>
<p>If we then click on the <kbd>Submit</kbd> button, we get the following display where our message about the button being clicked is displayed:</p>
<div><img src="img/f44534d8-c48b-4002-8116-24ca9797d8bc.png" style="width:42.67em;height:22.92em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Widget properties</h1>
                
            
            
                
<p>All widgets controls have a set of properties for your display that can be adjusted as needed. You can see the list of properties by taking an instance of a control and running the <kbd>control.keys</kbd> command in a Notebook, as can be seen in the following example:</p>
<pre>from ipywidgets import * 
w = IntSlider() 
w.keys </pre>
<p>This script pulls in a blanket reference to all of the controls available in widgets. We then create an <kbd>IntSlider</kbd> instance and display the list of properties that we can adjust. So, we end up with a display like the following screenshot:</p>
<div><img src="img/ea4e5151-a04d-45b9-b646-eea168991996.png"/></div>
<p class="mce-root"/>
<p>As you can see, the list is extensive:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="TableColumnHeadingPACKT"><strong>Property</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>orientation</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Whether left align, right align or justified</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>color</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Color of font</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>height</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Height of control</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>disabled</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Whether control is disabled or not</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>visible</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Is the control displayed?</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>font_style</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Style of font, for example, italic</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>min</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Minimum value (used in range list)</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>background_color</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Background color of control</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>width</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Width of control</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>font_family</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Font family to be used for text in control</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>description</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">The description field is used for documentation purposes</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>max</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Maximum value (of range)</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>padding</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Padding applied (to edges of control)</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>font_weight</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Weight of font used in control, for example, bold</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>font_size</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Size of font used for text in control</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>value</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Selected and entered value for control</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT"><kbd>margin</kbd></p>
</td>
<td>
<p class="TableColumnContentPACKT">Margin to use when displaying control</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjusting widget properties</h1>
                
            
            
                
<p>We could adjust any of these in our scripts using something like this script, where we disable a text box (the text box will display, but the user cannot enter a value into it). We could have the following script:</p>
<pre>from ipywidgets import * 
Text(value='You can not change this text!', disabled=True) </pre>
<p>This is the screenshot of the preceding code:</p>
<div><img src="img/6e4f94a8-7cce-4c5a-bea5-095bd7cd8503.png"/></div>
<p>When a field is disabled, the textbox is grayed out. When the user hovers the cursor over the field, they get a red circle with a slash through it, which means it cannot be changed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjusting properties</h1>
                
            
            
                
<p>All of the properties shown previously are accessible to read and write. We can show this transition with a small script, as follows:</p>
<pre>from ipywidgets import * 
w = IntSlider() 
original = w.value 
w.value = 5 
original, w.value </pre>
<p>The script creates a slider, retrieves its current value, changes the value to <kbd>5</kbd>, and then displays the original and current value of the control.</p>
<p class="mce-root"/>
<p>If we were to run the preceding script in a Notebook, we would see the following expected results:</p>
<div><img src="img/50bcbc29-eb89-4ddd-a672-676f52456d49.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Widget events</h1>
                
            
            
                
<p>All of the controls work by reacting to user actions, either with a mouse or keyboard. The default actions for controls are built into the software, but you can add your own handling of events (user actions).</p>
<p>We have seen this kind of event handling previously (for example, in the section on the slidebar, a function is called whenever the slider value is changed by the user). But, let's explore it in a little more depth.</p>
<p>We could have the following script:</p>
<pre>from ipywidgets import widgets<br/>from IPython.display import display<br/>button = widgets.Button(description="Click Me!")<br/>display(button)<br/>def on_button_clicked(b):<br/>    print("Button clicked.")<br/>button.on_click(on_button_clicked)</pre>
<p>This script does the following:</p>
<ul>
<li> Creates a button.</li>
<li> Displays the button to the user.</li>
<li> Defines a handler click event. It prints a message that you clicked on the screen. You can have any Python statements you want in the handler.</li>
<li>Lastly, we associated the click handler with the button we created. So, now when the user clicks on our button, the handler is called and the <kbd>Button clicked</kbd> message is displayed on screen (as shown in the following screenshot):</li>
</ul>
<p class="mce-root">If we run the preceding script in a Notebook and click on the button a few times, we get the following display:</p>
<div><img src="img/fc1accae-6da3-42a8-8395-b418f96e43a6.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Widget containers</h1>
                
            
            
                
<p>You can also assemble containers of widgets directly, using Python syntax, by passing the child elements in the constructor. For example, we could have the following script:</p>
<pre> #import our libraries 
from ipywidgets import * 
from IPython.display import display 
 
#create a slider and message box 
slider = widgets.FloatSlider() 
message = widgets.Text(value = 'Hello World') 
 
#add them to the container 
container = widgets.Box(children = (slider, message)) 
container.layout.border = '1px black solid' 
 
display(container) </pre>
<p>The preceding script shows that we are creating a container (which is a <kbd>Box</kbd> widget), in which we are specifying the child, contained controls. The call to display the container will iteratively display the child elements as well. So, we end up with a display like the following screenshot:</p>
<div><img src="img/2fcb2b87-1ddb-4f5c-b476-f72145e45f86.png"/></div>
<p>You can see the border around the box and the two controls in the box.</p>
<p>Similarly, we could have added the children to the container after the container was displayed, by using syntax like this:</p>
<pre>from ipywidgets import * <br/>from IPython.display import display <br/>container = widgets.Box() <br/>container.layout.border = '1px black solid' <br/>display(container) <br/>slider = widgets.FloatSlider() <br/>message = widgets.Text(value='Hello World') <br/>container.children=[slider, message] </pre>
<p>When we add the child to the container, the container repaints, which will cause the repainting of any children.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If we run this script in another Notebook, we get a very similar result to the previous example, with a display like the following screenshot:</p>
<div><img src="img/ad5198ea-6314-441e-8586-c83a8d723dc4.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we added widgets to our Jupyter installation and we used the interact and interactive widgets to produce a variety of user input controls. We then looked at the widgets package in depth to investigate some of the user controls available, properties available in the containers, events that are available emitting from the controls, and how to build containers for the controls.</p>
<p>In the next chapter, we will look into sharing Notebooks and converting them into different formats.</p>


            

            
        
    </body></html>