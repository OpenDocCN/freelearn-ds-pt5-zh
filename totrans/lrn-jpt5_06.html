<html><head></head><body>
        

                            
                    <h1 class="header-title">Jupyter JavaScript Coding</h1>
                
            
            
                
<p>JavaScript is a high-level, dynamic, untyped, and interpreted programming language. There are several outgrowth languages that are based on JavaScript. In the case of Jupyter, the underlying JavaScript is really Node.js. Node.js is an event-based framework that uses JavaScript, which can be used to develop large, scalable applications. Note that this is in contrast to the earlier languages covered in this book which are primarily used for data analysis (Python is a general language as well, but has clear aspects that deal with its capabilities of performing data analysis).</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li> Adding JavaScript packages to Jupyter</li>
<li> JavaScript Jupyter Notebook</li>
<li> Basic JavaScript in Jupyter</li>
<li> Node.js <kbd>d3</kbd> package</li>
<li> Node.js <kbd>stats-analysis</kbd> package</li>
<li> Node.js JSON handling</li>
<li> Node.js <kbd>canvas</kbd> package</li>
<li> Node.js <kbd>plotly</kbd> package</li>
<li> Node.js asynchronous threads</li>
<li> Node.js <kbd>decision-tree</kbd> package</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding JavaScript scripting to your installation</h1>
                
            
            
                
<p>In this section, we will install JavaScript scripting on macOS and Windows. There are separate steps for getting JavaScript scripting available on your Jupyter installation for each environment. The macOS installation is very clean. The Windows installation still appears to be in flux, and I would expect the following instructions to change over time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding JavaScript scripts to Jupyter on macOS or Windows</h1>
                
            
            
                
<p>I followed the instructions for loading the JavaScript engine for Anaconda from <a href="https://github.com/n-riesco/ijavascript">https://github.com/n-riesco/iJavaScript</a>. The steps are as follows:</p>
<pre><strong>conda install nodejs</strong> 
<strong>npm install -g iJavaScript</strong> 
<strong>ijsinstall</strong> </pre>
<p>At this point, starting Jupyter will provide the JavaScript (Node.js) engine as a choice, as shown in the following screenshot:</p>
<div><img class="alignnone size-full wp-image-722 image-border" src="img/019ed732-2d3f-49aa-bc4a-5b59eef553ae.png" style="width:17.92em;height:29.67em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript Hello World Jupyter Notebook</h1>
                
            
            
                
<p>Once installed, we can attempt the first JavaScript Notebook by clicking on the New menu and selecting JavaScript. We will name the Notebook <kbd>Hello, World!</kbd> and put the following lines in this script:</p>
<pre>var msg = "Hello, World!" 
console.log(msg) </pre>
<p>This script sets a variable and displays the contents of the variable. After entering the script and running (Cell | Run All), we will end up with a Notebook screen that looks like the following screenshot:</p>
<div><img src="img/c70ff5e9-b013-448c-9ad3-603ba646dd71.png"/></div>
<p>We should point out some of the highlights of this page:</p>
<ul>
<li>We have the now-familiar language logo in the upper-right corner that depicts the type of script in use</li>
<li>There is output from every line of the Notebook</li>
<li>More importantly, we can see the true output of the Notebook (following line one) where the string is echoed</li>
<li>Otherwise, the Notebook looks as familiar as the other types we have seen</li>
</ul>
<p>If we look at the contents of the Notebook on disk, we can see similar results as well:</p>
<pre>{ 
  "cells": [ 
    &lt;&lt;same format as seen earlier for the cells&gt;&gt; 
  ], 
  "metadata": { 
    "kernelspec": { 
      "display_name": "JavaScript (Node.js)", 
      "language": "JavaScript", 
      "name": "JavaScript" 
    }, 
    "language_info": { 
      "file_extension": ".js", 
      "mimetype": "application/JavaScript", 
      "name": "JavaScript", 
      "version": "8.9.3" 
    } 
  }, 
  "nbformat": 4, 
  "nbformat_minor": 2 
} </pre>
<p>So, using the same Notebook and the JSON file format, Jupyter provides a different language for use in the Notebook by changing the <kbd>metadata</kbd> and <kbd>language_info</kbd> values appropriately.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding JavaScript packages to Jupyter</h1>
                
            
            
                
<p>The JavaScript language does not normally install additional packages—it makes reference to other packages via the runtime include directive which is used in your programs. Other packages can be referenced across the network or copied locally into your environment. It is assumed that accessing a library across the network via a CDN is a more efficient and faster mechanism.</p>
<p>However, Node.js adds the required verb to the JavaScript syntax. In this case, your code requires another module to be loaded, which is assumed to be installed in your current environment. To install another module, use <kbd>npm</kbd>, for example, in the following command:</p>
<pre><strong>npm install name-of-module</strong> </pre>
<p>This will install the module that's been referenced (including any embedded packages that are required) on your machine so that a required statement will work correctly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic JavaScript in Jupyter</h1>
                
            
            
                
<p>JavaScript, and even Node.js, are not usually noted for data handling, but for application (website) development. This differentiates JavaScript coding in Jupyter from the languages that we covered earlier. However, the examples in this chapter will highlight using JavaScript for application development with data access and analysis features.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript limitations in Jupyter</h1>
                
            
            
                
<p>JavaScript was originally used to specifically address the need for scripting inside of an HTML page, usually on the client-side (in a browser). As such, it was built to be able to manipulate HTML elements on the page. Several packages have been developed to further this feature, even for creating a web server, especially using extensions such as Node.js.</p>
<p>The use of any of the HTML manipulation and generation features inside of Jupyter runs into a roadblock, since Jupyter expects to control presentation to the user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js d3 package</h1>
                
            
            
                
<p>The <kbd>d3</kbd> package has data access functionality. In this case, we will read from a tab-separated file and compute an average. Note the use of the underscore variable name for <kbd>lodash</kbd>. Variable names starting with an underscore are assumed to be private. However, in this case, it is just a play on the name of the package we are using, which is <kbd>lodash</kbd>, or underscore. <kbd>lodash</kbd> is also a widely used a <kbd>utility</kbd> package.</p>
<p>For this script to execute, I had to do the following:</p>
<ul>
<li>Install <kbd>d3</kbd></li>
<li>Install <kbd>lodash</kbd></li>
<li>Install <kbd>isomorphic-fetch</kbd> (<kbd>npm install --save isomorphic-fetch es6-promise</kbd>)</li>
<li>Import <kbd>isomorphic-fetch</kbd></li>
</ul>
<p>The script we will use is as follows:</p>
<pre>var fs = require("fs");<br/>var d3 = require("d3");<br/>var _ = require("lodash");<br/>var _ = require("isomorphic-fetch");<br/><br/>//read and parse the animals file<br/>console.log("Animal\tWeight");<br/>d3.csv("http://www.dantoomeysoftware.com/data/animals.csv", function(data) {<br/>    console.log(data.name + '\t' + data.avg_weight);<br/>});</pre>
<p>This assumes that we have previously loaded the <kbd>fs</kbd> and <kbd>d3</kbd> packages using <kbd>npm</kbd>, as described in the previous script.</p>
<p>For this example, I created a <kbd>data</kbd> directory on my website, since the URL that we entered is expected to be an absolute URL, and created a CSV file (<kbd>animal.csv</kbd>) in that directory:</p>
<pre>Name,avg_weight 
Lion,400 
Tiger,400 
Human,150 
Elephant,2000 </pre>
<p>If we load this script into a Notebook and run it, we get the following output, as expected:</p>
<div><img src="img/9c6b27f8-6ece-42e0-9d88-ad10870f4f2f.png"/></div>
<p>It's important to note that the <kbd>d3</kbd> function (many of them, actually) operate asynchronously. In our case, we are just printing every row of the file. You can imagine more elaborate functionality.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js stats-analysis package</h1>
                
            
            
                
<p>The <kbd>stats-analysis</kbd> package has many of the common statistics that you may want to perform on your data. You will have to install this package using <kbd>npm</kbd>, as explained previously.</p>
<p>If we had a small set of people's temperatures to work with, we could get some of the statistics on the data readily by using this script:</p>
<pre>const stats = require("stats-analysis"); 
 
var arr = [98, 98.6, 98.4, 98.8, 200, 120, 98.5]; 
 
//standard deviation 
var my_stddev = stats.stdev(arr).toFixed(2); 
 
//mean 
var my_mean = stats.mean(arr).toFixed(2); 
 
//median 
var my_median = stats.median(arr); 
 
//median absolute deviation 
var my_mad = stats.MAD(arr); 
 
// Get the index locations of the outliers in the data set 
var my_outliers = stats.indexOfOutliers(arr); 
 
// Remove the outliers 
var my_without_outliers = stats.filterOutliers(arr); 
 
//display our stats 
console.log("Raw data is ", arr); 
console.log("Standard Deviation is ", my_stddev); 
console.log("Mean is ", my_mean); 
console.log("Median is ", my_median); 
console.log("Median Abs Deviation is " + my_mad); 
console.log("The outliers of the data set are ", my_outliers); 
console.log("The data set without outliers is ", my_without_outliers); </pre>
<p>When this script is entered in a Notebook, we get something similar to what's shown in the following screenshot:</p>
<div><img src="img/a885f097-9c9c-477e-bd46-aa359363eac3.png"/></div>
<p>When run, we get the results that are shown in the following screenshot:</p>
<div><img src="img/f6c0cc74-468c-4ee7-8f83-651dcdfc3e9d.png" style="width:35.42em;height:9.58em;"/></div>
<p>Interestingly, <kbd>98.5</kbd> is considered an outlier. I assume that there is an optional parameter to the command that would change the limits used. Otherwise, the results are as expected.</p>
<p class="mce-root"/>
<p>The outliers are coming from dealing with the raw data as pure mathematical items. So, technically, from the data provided, we have the outliers identified. However, we would likely use a different method to determine outliers, knowing the domain average human temperatures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js JSON handling</h1>
                
            
            
                
<p>In this example, we will load a JSON dataset and perform some standard manipulations on the data. I am referencing the list of FORD Models from <a href="http://www.carqueryapi.com/api/0.3/?callback=?&amp;cmd=getModels&amp;make=ford">http://www.carqueryapi.com/api/0.3/?callback=?&amp;cmd=getModels&amp;make=ford</a>. I can't reference this directly, as it is not a flat file, but an API call. Therefore, I downloaded the data into a local file called <kbd>fords.json</kbd>. Also, the output from the API call wraps the JSON like so: <kbd>?(json);</kbd>. This would have to be removed before parsing.</p>
<p>The scripting we will use is as follows. In the script, <kbd>JSON</kbd> is a built-in package of Node.js, so we can reference this package directly. The <kbd>JSON</kbd> package provides many of the standard tools that you need to handle your JSON files and objects.</p>
<p>Of interest here is the JSON file reader, which constructs a standard JavaScript array of objects. Attributes of each object can be referenced by <kbd>name</kbd>, for example, <kbd>model.model_name</kbd>:</p>
<pre>//load the JSON dataset 
//http://www.carqueryapi.com/api/0.3/?callback=?&amp;cmd=getModels&amp;make=ford 
var fords = require('/Users/dtoomey/fords.json'); 
 
//display how many Ford models are in our data set 
console.log("There are " + fords.Models.length + " Ford models in the data set"); 
 
//loop over the set 
var index = 1 
for(var i=0; i&lt;fords.Models.length; i++) { 
     
    //get this model 
    var model = fords.Models[i]; 
     
    //pull it's name 
    var name = model.model_name; 
     
    //if the model name does not have numerics in it 
    if(! name.match(/[0-9]/i)) { 
        //display the model name 
        console.log("Model " + index + " is a " + name); 
        index++; 
    } 
     
    //only display the first 5 
    if (index&gt;5) break; 
} </pre>
<p>If we pull this script into a new Notebook entry, we get the following screenshot:</p>
<div><img src="img/e71fc713-c218-46bd-a173-cf97ff1e1d10.png"/></div>
<p>When the script is executed, we get the expected results, as follows:</p>
<div><img src="img/c4572efc-acef-4288-a74c-cfa81553d655.png"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js canvas package</h1>
                
            
            
                
<p>The <kbd>canvas</kbd> package is used for generating graphics in Node.js. We can use the example from the <kbd>canvas</kbd> package home page (<a href="https://www.npmjs.com/package/canvas">https://www.npmjs.com/package/canvas</a>).</p>
<p>First, we need to install <kbd>canvas</kbd> and its dependencies. There are directions on the home page for the different operating systems, but it is very familiar to the tools we have seen before (we have seen them for macOS):</p>
<pre><strong>npm install canvas</strong> 
<strong>brew install pkg-config cairo libpng jpeg giflib</strong> </pre>
<p>This example does not work in Windows. The Windows install required Microsoft Visual C++ to be installed. I tried several iterations to no avail.</p>
<p>With the <kbd>canvas</kbd> package installed on your machine, we can use a small Node.js script to create a graphic:</p>
<pre>// create a canvas 200 by 200 pixels 
var Canvas = require('canvas') 
  , Image = Canvas.Image 
  , canvas = new Canvas(200, 200) 
  , ctx = canvas.getContext('2d') 
  , string = "Jupyter!"; 
 
// place our string on the canvas 
ctx.font = '30px Impact'; 
ctx.rotate(.1); 
ctx.fillText(string, 50, 100); 
  
var te = ctx.measureText(string); 
ctx.strokeStyle = 'rgba(0,0,0,0.5)'; 
ctx.beginPath(); 
ctx.lineTo(50, 102); 
ctx.lineTo(50 + te.width, 102); 
ctx.stroke(); 
  
//create an html img tag, with embedded graphics 
console.log('&lt;img src="img/' + canvas.toDataURL() + '" /&gt;'); </pre>
<p>This script is creating <kbd>canvas</kbd>, writing <kbd>string</kbd> as <kbd>Jupyter!</kbd> across <kbd>canvas</kbd>, and then generating an HTML <kbd>img</kbd> tag with the graphic.</p>
<p class="mce-root"/>
<p>After we run the script in a Notebook, we get the <kbd>img</kbd> tag as the output:</p>
<div><img src="img/c1a4a82e-dfa7-449f-9fae-d3712bebd296.png"/></div>
<p>We can take the <kbd>img</kbd> tag and save it to an HTML page so it looks like this:</p>
<pre>&lt;html&gt;<br/> &lt;body&gt;<br/> &lt;img src="img/png;base64,iVBORw0KGgo&lt;the rest of the tag&gt;CC" /&gt;<br/> &lt;/body&gt;<br/> &lt;/head&gt; </pre>
<p>We can then open the HTML file with a browser to display our graphic:</p>
<div><img src="img/2c108493-6bf8-47c7-82dd-73fe882a699e.png" style="width:41.50em;height:20.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js plotly package</h1>
                
            
            
                
<p><kbd>plotly</kbd> is a package that works differently to most. To use this software, you must register with a <kbd>username</kbd> so that you are provided with an <kbd>api_key</kbd> (at <a href="https://plot.ly/">https://plot.ly/</a>). You then place the <kbd>username</kbd> and <kbd>api_key</kbd> in your script. At that point, you can use all of the <kbd>plotly</kbd> package features.</p>
<p>First, like all of the other packages, we need to install it:</p>
<pre><strong>npm install plotly</strong> </pre>
<p>Once installed, we can reference the <kbd>plotly</kbd> package as needed. Using a simple script, we can generate a <kbd>histogram</kbd> with <kbd>plotly</kbd>:</p>
<pre>//set random seed 
var seedrandom = require('seedrandom'); 
var rng = seedrandom('Jupyter'); 
//setup plotly 
var plotly = require('plotly')(username="&lt;username&gt;", api_key="&lt;key&gt;") 
var x = []; 
for (var i = 0; i &lt; 500; i ++) { 
    x[i] = Math.random(); 
} 
require('plotly')(username, api_key); 
var data = [ 
  { 
    x: x, 
    type: "histogram" 
  } 
]; 
var graphOptions = {filename: "basic-histogram", fileopt: "overwrite"}; 
plotly.plot(data, graphOptions, function (err, msg) { 
    console.log(msg); 
}); </pre>
<p>Once loaded and run in Jupyter as a Notebook, we get the following screen:</p>
<div><img src="img/8fc767c6-a753-4589-9e67-8efd6ae214fc.png"/></div>
<p>Instead of creating a local file, or just displaying the graphic on the screen, any graphic that is created is stored on Plotly. The output of the <kbd>plot</kbd> command is a set of return values from your graphic's creation. Most important is the URL where you can access the graphic.</p>
<p class="mce-root"/>
<p>Ideally, what should happen is that I should be able to access my graphic (histogram) using the URL provided, which is <a href="https://plot.ly/~dantoomey/1">https://plot.ly/~dantoomey/1</a>. The returned URL works as expected after inserting a <kbd>~</kbd> character into the URL. However, when I looked around the Plotly website, I did find my graphics in slightly different paths than expected. All of your graphics are in your home page, which in my case is <a href="https://plot.ly/~dantoomey">https://plot.ly/~dantoomey</a>. I can now access all of my graphics. The histogram is shown in the following screenshot:</p>
<div><img src="img/3b5e0edf-a875-46ad-8984-3acad0d269e0.png"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js asynchronous threads</h1>
                
            
            
                
<p>Node.js has built-in mechanisms for creating threads and having them fire asynchronously. Using an example from <a href="http://book.mixu.net/node/ch7.html">http://book.mixu.net/node/ch7.html</a>, we have the following:</p>
<pre>//thread function - invoked for every number in items array 
function async(arg, callback) { 
  console.log('cube \''+arg+'\', and return 2 seconds later'); 
  setTimeout(function() { callback(arg * 3); }, 2000); 
} 
 
//function called once - after all threads complete 
function final() { console.log('Done', results); } 
 
//list of numbers to operate upon 
var items = [ 0, 1, 1, 2, 3, 5, 7, 11 ]; 
 
//results of each step 
var results = []; 
 
//loop the drives the whole process 
items.forEach(function(item) { 
  async(item, function(result){ 
    results.push(result); 
    if(results.length == items.length) { 
      final(); 
    } 
  }) 
}); </pre>
<p>This script creates an asynchronous function that operates on a number. For every number (<kbd>item</kbd>), we call upon the inline function, passing the number to the function which applies the number to the <kbd>results</kbd> list. In this case, it just triples the number and waits for two seconds. The main loop (at the bottom of the script) creates a thread for each number in the list and then waits for them all to complete before calling the <kbd>final()</kbd> routine.</p>
<p>The Notebook page looks like this:</p>
<div><img src="img/34652c45-a6fc-4291-94d6-e7c90016d892.png"/></div>
<p>When we run the script, we get something like the following output:</p>
<div><img src="img/c5aefacc-b73c-4bd5-aecb-45dae4c77472.png" style="width:20.33em;height:10.50em;"/></div>
<p>It is odd to see the delay for the last line of output (from the <kbd>final()</kbd> routine) to display, although we specifically stated to add a delay when we coded the <kbd>async</kbd> function previously.</p>
<p>Also, when I played around with other functions, such as cubing each number, the <kbd>results</kbd> list came back in a very different order. I would not have thought such a basic mathematics function would have any effect on performance.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js decision-tree package</h1>
                
            
            
                
<p>The <kbd>decision-tree</kbd> package is an example of a machine learning package. It is available at <a href="https://www.npmjs.com/package/decision-tree">https://www.npmjs.com/package/decision-tree</a>. The package is installed by using the following command:</p>
<pre><strong>npm install decision-tree</strong> </pre>
<p>We need a dataset to use for training/developing our decision tree. I am using the car MPG dataset from the following web page: <a href="https://alliance.seas.upenn.edu/~cis520/wiki/index.php?n=Lectures.DecisionTrees">https://alliance.seas.upenn.edu/~cis520/wiki/index.php?n=Lectures.DecisionTrees</a>. It did not seem to be available directly, so I copied it into Excel and saved it as a local CSV.</p>
<p>The logic for machine learning is very similar:</p>
<ul>
<li>Load our dataset</li>
<li>Split into a training set and a testing set</li>
<li>Use the training set to develop our model</li>
<li>Test the mode on the test set</li>
</ul>
<p>Typically, you might use two-thirds of your data for training and one-third for testing.</p>
<p>Using the <kbd>decision-tree</kbd> package and the <kbd>car-mpg</kbd> dataset, we would have a script similar to the following:</p>
<pre>//Import the modules 
var DecisionTree = require('decision-tree'); 
var fs = require("fs"); 
var d3 = require("d3"); 
var util = require('util'); 
 
//read in the car/mpg file 
fs.readFile("/Users/dtoomey/car-mpg.csv", "utf8", function(error, data) { 
     
    //parse out the csv into a dataset 
    var dataset = d3.tsvParse(data); 
     
    //display on screen - just for debugging 
    //console.log(JSON.stringify(dataset)); 
 
    var rows = dataset.length; 
    console.log("rows = " + rows); 
    var training_size = rows * 2 / 3; 
    console.log("training_size = " + training_size); 
    var test_size = rows - training_size; 
    console.log("test_size = " + test_size); 
 
    //Prepare training dataset 
    var training_data = dataset.slice(1, training_size); 
 
    //Prepare test dataset 
    var test_data = dataset.slice(training_size, rows); 
 
    //Setup Target Class used for prediction 
    var class_name = "mpg"; 
 
    //Setup Features to be used by decision tree 
    var features = ["cylinders","displacement","horsepower", "weight", "acceleration", "modelyear", "maker"]; 
 
    //Create decision tree and train model 
    var dt = new DecisionTree(training_data, class_name, features); 
    console.log("Decision Tree is " + util.inspect(dt, {showHidden: false, depth: null})); 
 
    //Predict class label for an instance 
    var predicted_class = dt.predict({ 
        cylinders: 8, 
        displacement: 400, 
        horsepower: 200, 
        weight: 4000, 
        acceleration: 12, 
        modelyear: 70, 
        maker: "US" 
    }); 
    console.log("Predicted Class is " + util.inspect(predicted_class, {showHidden: false, depth: null})); 
 
    //Evaluate model on a dataset 
    var accuracy = dt.evaluate(test_data); 
    console.log("Accuracy is " + accuracy); 
 
    //Export underlying model for visualization or inspection 
    var treeModel = dt.toJSON(); 
    console.log("Decision Tree JSON is " + util.inspect(treeModel, {showHidden: false, depth: null})); 
}); </pre>
<p>There is wide use of <kbd>console.log</kbd> to display progressive information about the processing that is occurring. I am using the <kbd>util()</kbd> function further in order to display members of objects in use.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The packages must also be installed using <kbd>npm</kbd>.</p>
<p>If we run this in a Notebook, we end up with the results that are shown at the top of the following output:</p>
<div><img src="img/26107f8f-8baf-4db3-865e-6f1af5d3ab35.png"/></div>
<p>Here, the system is just logging the entries that it finds in the file and presenting decision points on the different variables we have assigned. For example, <kbd>mpg</kbd> is <kbd>Bad</kbd> when <kbd>cylinders</kbd> is <kbd>8</kbd>, <kbd>displacement</kbd> is <kbd>400</kbd>, and so on. </p>
<p>We arrive at a model for determining whether <kbd>mpg</kbd> for a vehicle is acceptable, based on the vehicle's characteristics. In this case, we have a bad predictor, as noted in the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to add JavaScript to our Jupyter Notebook. We saw some of the limitations of using JavaScript in Jupyter. We had a look at examples of several packages that are typical of Node.js coding, including <kbd>d3</kbd> for graphics, <kbd>stats-analysis</kbd> for statistics, built-in JSON handling, <kbd>canvas</kbd> for creating graphics files, and <kbd>plotly</kbd>, which is used for generating graphics with a third-party tool. We also saw how multi-threaded applications can be developed using Node.js under Jupyter. Lastly, we saw machine learning for developing a decision tree.</p>
<p>In the next chapter, we will see how to create interactive widgets that can be used in your Notebook.</p>


            

            
        
    </body></html>