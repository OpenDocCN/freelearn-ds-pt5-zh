- en: Chapter 9. Parallel and Concurrent Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Haskell Runtime System (RTS) options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating a procedure in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling parallel algorithms in sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forking I/O actions for concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with a forked I/O action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing forked threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelizing pure functions using the Par monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping over a list in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing tuple elements in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing MapReduce to count word frequencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating images in parallel using Repa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking runtime performance in Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the criterion package to measure performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking runtime performance in the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Introduction](img/ch09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the greatest accomplishments in the study of data analysis is the intelligent
    approach to parallel and concurrent design. As we collect more and more data,
    we are able to discover more and more patterns. However, this comes at a price
    of time and space. More data may take more time to compute or more space in terms
    of memory. It is a very real problem that this chapter will try to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The first few recipes will cover how to evoke pure procedures in parallel and
    in sequence. The following recipes on forking will deal with concurrency using
    I/O actions. We will then delve deeper by learning how to access a list and tuple
    elements in parallel. Then, we will implement MapReduce in Haskell to solve a
    time-consuming problem efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: We will end the review of parallel and concurrent design by learning how to
    benchmark runtime performance. Sometimes, the easiest way to discover if code
    is successfully running in parallel is by timing it against a nonparallel version
    of the code. If the computation time between the two appears to be the same, then
    it is very likely that something is wrong. Either the code is not running in parallel
    or the cost of evoking parallelism outweighs the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Haskell Runtime System options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Runtime System** (**RTS**) in Haskell configures special options such
    as scheduling, profiling, and managing storage for a compiled Haskell program.
    In order to write multithreaded code, we must specify our own RTS options as outlined
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For further reading, the GHC Commentary on the official Haskell Wiki web page
    has a very detailed explanation of the runtime system available at [https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a terminal, compile a code, and run it using the RTS option. Imagine that
    our file is named `Main.hs`, and issue the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to make use of multiple threads, we must compile our code with the
    `threaded` and `rtsopts` flags enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Now that it is compiled with `rtsopts`, we can run our program with special
    instructions placed between the `+RTS` and `-RTS` flags. If there is a `+RTS`
    flag without a `–RTS` flag, then we assume that the RTS options continue until
    the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: We set the number of threads to use by placing `-Nx` within the RTS argument,
    which stands for "use x threads". So, to use two threads, we should type *-N2*.
    To use all possible threads, we simply type *-N*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to specify the RTS options is during compile time, using the `--with-rtsopts`
    flag. More advanced methods include modifying environment variables or overriding
    runtime system hooks. More information on these can be found on the official Haskell
    user guide available at [https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html](https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html).
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating a procedure in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will conduct two time-consuming tasks in parallel. We will
    use the `rpar` function provided by the `parallel` package from hackage. The `rpar`
    function annotates its argument to be evaluated in parallel. Then, we call `runEval`
    to actually perform the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `parallel` package using cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the parallel package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate two tasks in parallel, and wait for both tasks to finish before returning
    as seen in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A time-consuming task can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another time-consuming task can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it by specifying the number of cores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time-consuming calculations (`task1` and `task2`) in this recipe require
    a huge amount of memory and may exceed the limitations of the machine in use.
    Adjust the tasks to be more manageable, such as 4^8^9 or 4^8^8\. In this recipe,
    specifically, the overhead cost of parallelizing these simple mathematical calculations
    may be greater than the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time-consuming functions are annotated with `rpar`, which suggests that the
    computation should occur in parallel. Once `runEval` is applied, the sparked code
    runs in parallel. Future parts of the code can continue with the execution until
    the output of these parallel-running threads are needed.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we run `task1` and `task2` in parallel. We immediately return
    the result to be used in future parts of the code, and the code only waits for
    the tasks to complete once necessary. The computation is being processed in the
    background until it is needed later.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To explore examples of using a sequence in a parallel design, refer to the *Controlling
    parallel algorithms in sequence* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling parallel algorithms in sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will conduct two time-consuming tasks in parallel. We will
    use the `rpar` function and the `rseq` function provided by the `parallel` package
    from hackage. The `rpar` function annotates its argument to be evaluated in parallel.
    The other function, `rseq`, forces sequential evaluations in what is called the
    **weak head normal form**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `parallel` package using cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the parallel package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform a time-consuming task as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform another time-consuming task as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it by specifying the number of cores as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time-consuming functions are annotated with `rpar` or `rseq`, which describe
    whether a computation should happen in parallel or in a sequence. If a function
    is sparked to be run in parallel, then future parts of the code can be made to
    run until that value is needed. In that case, the code blocks until the parallel
    operation is complete. If a function is required to be in sequence, the code will
    wait until the function has computed a result, and only then will it move on.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we run `task1` and `task2` in parallel. We then run `rseq` on
    the values to demonstrate the concept of sequencing. The first time we call `rseq`,
    we are forcing the code to wait until `task1`, which is represented by the variable
    `a`, is complete. Depending on the parallel design of the algorithm, it may not
    be necessary to sequence it at all. We also force `task2`, which is represented
    by the variable `b`, to wait until the value is calculated just to demonstrate
    how sequencing works.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see an example of only parallel design without sequencing, refer to the *Evaluating
    a procedure in parallel* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Forking I/O actions for concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick and easy way to launch an I/O type function in the background is by
    calling the `forkIO` function provided by the `Control.Concurrent` package. In
    this recipe, we will demonstrate simple input/output concurrently in Haskell.
    We will get the number of seconds to wait from the user input, and in the background,
    it will sleep and print a message once the thread wakes up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the built-in concurrency package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ask the user the number of seconds the program has to sleep for. Then, sleep
    for that many seconds by calling our `sleep` function defined in the following
    code snippet. Finally, recursively call `main` again to demonstrate that the user
    can continue to input while a thread is running in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function that takes in the number of seconds to sleep, and apply `threadDelay
    :: Int -> IO ()` to that value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run the program, we can quickly input multiple numbers before receiving
    an output as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `print` and `putrStrLn` functions are not atomic, so you may also get interleaved
    output.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To send data to a forked action, refer to the *Communicating with a forked I/O
    action* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with a forked I/O action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick and easy way to launch an I/O type function in the background is by
    calling the `forkIO` function provided by the `Control.Concurrent` package. In
    this recipe, we will be communicating with forked I/O actions by sending messages
    using a variable type called `MVar`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `HTTP` package from cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new variable that will be used by the fork process. The `newEmptyMVar`
    function is of the `IO (MVar a)` type, so we will extract the expression out and
    label it `m` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the fork, send it some data by calling `putMVar :: MVar a ->
    a -> IO ()`, as shown in the following lines of code. The variable will hold the
    given value, and the forked process waiting on that data will resume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can reuse the expression and send it more data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make sure `main` does not terminate before the forked process is finished,
    we just force `main` to wait for 10 seconds by calling the `threadDelay` function.
    This is for demonstration purposes only, and a complete solution should terminate
    `main` immediately once the fork is complete, as presented in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the code that will be forked to run in parallel as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to perform an HTTP GET request on a URL as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the program will then be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see a simpler example of using `forkIO`, refer to the *Forking I/O actions
    for concurrency* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Killing forked threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a new thread, we can keep track of its corresponding thread ID
    to kill it later manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will be creating a command-line interface for forking new
    processes to download a huge file. A download will be initiated with the `d` command
    followed by a number. So, running `d 1` will launch a thread to download item
    #1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn how to kill threads while they are still running. Our command
    to kill threads will look like `k 1` in order to kill the downloaded item #1.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new file, which we call `Main.hs`, insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let `main` call the helper `download` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to take the user queries and appropriately respond as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Respond to a download request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Respond to a kill request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Respond to an invalid request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pretend to download a huge file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and evoke a couple of downloads and kill commands as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program keeps track of a mapping from the download number to thread IDs.
    Whenever a new download is initiated, we insert the corresponding thread ID to
    the map. To kill a thread, we call `killThread` on the respective thread ID.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelizing pure functions using the Par monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Par monad from the `Control.Monad.Par` package is used to speed up pure
    functions using parallel threads. Information flow is guided by variables called
    `IVar`. We can `put` values to `IVar` in parallel or `get` values from it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the Par monad on cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the Par monad as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run a computation in parallel, and perform some interesting function such as
    counting the number of digits and printing it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an I/O type action as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform a time-consuming task as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform another time-consuming task as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it by specifying the number of cores as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The natural nonparallelized version of the code certainly looks cleaner. In
    the following example, we see the same principle at work mathematically as the
    previous example but without the use of monads. However, we no longer have the
    power of concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For dealing with computations that use I/O, refer to the *Forking I/O actions
    for concurrency* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping over a list in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be applying the map function in parallel. Given a list
    of values, we will be using multiple threads to apply a function over each value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the parallel strategies as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Map over a list using the `rdeepseq` strategy using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first few characters of the printed output are shown here after compiling
    and running the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code by specifying the number of cores as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `parMap` function has the type `Strategy b -> (a -> b) -> [a] -> [b]`. It
    looks exactly like the type signature of the map function, except that it takes
    in something called Strategy. A **Strategy** decouples the method of parallelism
    from the implementation of code. An example of a Strategy is `rdeepseq`, which
    fully evaluates its argument. For example, Haskell is lazy evaluated, so the code
    `length [5^5^5, 6^6^6]` will not evaluate the value of `5^5^5` or `6^6^6`. We
    can use the `rdeepseq` example to better control what computations should be evaluated
    when run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, a slow and simple version of the code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Try timing the runtime to see the significant differences in using multiple
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many Strategies depending on how the parallelism should be evoked,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r0` is the simplest Strategy that simply does not evaluate the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dot` is used to compose two Strategies together for finer control in more
    complicated expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rseq` will immediately evaluate the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpar` will annotate the expression to be evaluated in parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If dealing with tuples, refer to the *Accessing tuple elements in parallel*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on timing code, refer to the *Benchmarking runtime performance
    in Haskell* recipe or the *Benchmarking runtime performance in the terminal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing tuple elements in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will cover how to access elements of a tuple in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the built-in package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate the expression in a tuple in parallel. We perform this task twice
    with different strategies to demonstrate how strategies are easily swapped to
    change the parallel nature of the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define time-consuming tasks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it by specifying the number of cores as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with tuples of more than two elements, other helper methods exist
    such as `parTuple3`, `parTuple4`, `parTuple5`, `parTuple6`, `parTuple7`, `parTuple8`,
    and `parTuple9`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If dealing with lists, refer to the *Mapping over a list in parallel* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing MapReduce to count word frequencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MapReduce is a framework for efficient parallel algorithms that take advantage
    of divide and conquer. If a task can be split into smaller tasks, and the results
    of each individual task can be combined to form the final answer, then MapReduce
    is likely the best framework for this job.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, we can see that a large list is split up, and the mapper
    functions work in parallel on each split. After all the mapping is complete, the
    second phase of the framework kicks in, reducing the various calculations into
    one final answer.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be counting word frequencies in a large corpus of text.
    Given many files of words, we will apply the MapReduce framework to find the word
    frequencies in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing MapReduce to count word frequencies](img/6331OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `parallel` package using cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create multiple files with words. In this recipe, we download a huge text file
    and split it up using the UNIX `split` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the MapReduce logic. The mapping functions should all occur before the
    reducing logic as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `mapper` function to count the frequency of words as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Count the number of times a word occurs in a string as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the words out of an arbitrary corpus of characters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reduce the list of word frequencies into one final answer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the MapReduce problem and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ask to use input, and then display the frequency of each word entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it by specifying the number of cores as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Manipulating images in parallel using Repa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repa is a powerful library for manipulating high-dimensional arrays in parallel.
    We will use it to read and edit the pixels of an image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install **Developer''s Image Library** (**DevIL**), a cross-platform image
    manipulation toolkit. It can be downloaded from [http://openil.sourceforge.net/download.php](http://openil.sourceforge.net/download.php)
    or through `apt-get` on Debian systems as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Repa package from cabal for the DevIL toolkit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two images named `image1.png` and `image2.png` that have the same dimensions,
    which are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here comes the second image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the images, process them, and produce an output image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the helper function to process the images as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it by specifying the number of cores, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The images are read as three-dimensional Repa arrays of pixels, where each pixel
    is represented by a Word8\. The first two dimensions index the images by width
    and height, and the last dimension selects the color channel (red, green, blue,
    or alpha).
  prefs: []
  type: TYPE_NORMAL
- en: We run the `zipWith` function provided by Repa to combine two images into one
    with our intersect/merge rule. In order to actually run this process efficiently
    in parallel, we must call the `computeP` function.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking runtime performance in Haskell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmarking runtime is the process of timing how long it takes for the code
    to run. We can understand whether our parallel or concurrent code is in fact faster
    than the naive implementation by proper benchmarking. This recipe will demonstrate
    how to time code runtime in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the necessary libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to print out the duration of a pure task. Evaluate the pure
    expression a very large number of times (10^6), and then calculate the average
    CPU time it takes to run one pure task. The `getCPUTime` function returns the
    number of picoseconds since the start of the program''s execution, as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the timing function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The measurements for conducting a pure task are printed out. Actual measurements
    will differ depending on the state of the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Benchmarking runtime performance in the terminal* recipe for producing
    benchmark results outside the Haskell environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using the criterion package to measure performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more reliable performance measures, the `criterion` package comes in handy.
    The package description points out a major flaw in using simple procedures to
    time pure code.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Because GHC optimizes aggressively when compiling with -O, it is potentially
    easy to write innocent-looking benchmark code that will only be evaluated once,
    for which all but the first iteration of the timing loop will be timing the cost
    of doing nothing."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `small.txt` file with a few words. Create a file, `big.txt`, filled
    with text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `criterion` library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the I/O function we wish to time as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Benchmark the desired function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By calling this library''s `defaultMain` function in `main`, we can leverage
    some very powerful benchmarking features. For instance, try running the following
    command to see a plethora of features supported by criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Benchmarking runtime performance in the terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmarking runtime is the process of timing how long it takes the code to
    run. This skill is invaluable since it helps compare performance. By externally
    measuring the runtime as opposed to instrumenting it within the code, we can easily
    proceed without understanding the inner working of the code. If we're on a Unix-like
    system such as Linux or OS X, we can use the `time` command, and on Windows systems,
    we can use `Measure-Command` with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure our machine is either Unix-like (such as Linux or OS X) or Windows.
    Otherwise, we must search online for a way to time execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Unix-like systems, there is a built-in `time` command. When running any
    piece of code from the terminal, we can prefix it with `time` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The argument to this command is run, and the system resource usage is immediately
    summarized. The actual accuracy of the results depends on the machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On Windows, we can use the `Measure-Command` feature in PowerShell. Open PowerShell,
    go to the correct directory, and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see a result with the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To time execution within the Haskell code itself, refer to the *Benchmarking
    runtime performance in Haskell* recipe.
  prefs: []
  type: TYPE_NORMAL
