["```py\n$ cabal install cassava\n\n```", "```py\n    import Data.Csv\n    import qualified Data.ByteString.Lazy as BSL\n    ```", "```py\n    myData :: [(Char, Int)]\n    myData = zip ['A'..'Z'] [1..]\n    ```", "```py\n    main = BSL.writeFile \"letters.csv\" $ encode myData\n    ```", "```py\ndata Person = Person { name :: Text, age :: Int }\n\ninstance ToRecord Person where\n     toRecord (Person name age) = record [\n        toField name, toField age]\n```", "```py\n$ cabal install yocto\n\n```", "```py\n    import Text.JSON.Yocto\n    import qualified Data.Map as M\n    ```", "```py\n    data Point = Point Rational Rational\n    ```", "```py\n    pointObject (Point x y) = \n      Object $ M.fromList [ (\"x\", Number x)\n                          , (\"y\", Number y)]\n    ```", "```py\n    main = do\n      let points = [ Point 1 1\n                   , Point 3 5\n                   , Point (-3) 2]\n      let pointsArray = Array $ map pointObject points\n    ```", "```py\n      writeFile \"points.json\" $ encode pointsArray\n    ```", "```py\n    $ runhaskell Main.hs\n    $ cat points.json\n    [{\"x\":1,\"y\":1}, {\"x\":3,\"y\":5}, {\"x\":-3,\"y\":2}]\n\n    ```", "```py\n$ sudo apt-get install sqlite3\n\n```", "```py\n$ cabal install sqlite-simple\n\n```", "```py\n$ sqlite3 test.db \"CREATE TABLE test (id INTEGER PRIMARY KEY, str text);\"\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n    import Control.Applicative\n    import Database.SQLite.Simple\n    import Database.SQLite.Simple.FromRow\n    ```", "```py\n    data TestField = TestField Int String deriving (Show)\n    instance FromRow TestField where\n      fromRow = TestField <$> field <*> field\n    ```", "```py\n    getDB :: Connection -> IO [TestField]\n\n    getDB conn = query_ conn \"SELECT * from test\"\n    ```", "```py\n    insertToDB :: Connection -> String -> IO ()  \n    insertToDB conn item = \n      execute conn \n      \"INSERT INTO test (str) VALUES (?)\" \n      (Only item)\n    ```", "```py\n    main :: IO ()\n\n    main = withConnection \"test.db\" dbActions\n    ```", "```py\n    dbActions :: Connection -> IO ()\n\n    dbActions conn = do\n      let dataItems = [\"A\", \"B\", \"C\"]\n    ```", "```py\n      mapM_ (insertToDB conn) dataItems\n    ```", "```py\n      r <- getDB conn\n      mapM_ print r \n    ```", "```py\n    $ sqlite3 test.db \"SELECT * FROM test\"\n\n    1|A\n    2|C\n    3|D\n\n    ```", "```py\n$ mkdir ~/db\n\n```", "```py\n$ mongod â€“dbpath ~/db\n\n```", "```py\n$ cabal install mongoDB\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings, ExtendedDefaultRules #-}\n    import Database.MongoDB\n    import Control.Monad.Trans (liftIO)\n    ```", "```py\n    data Person = Person { first :: String \n                         , last :: String }\n    ```", "```py\n    myData :: [Person]\n    myData = [ Person \"Mercury\" \"Merci\"\n             , Person \"Sylvester\" \"Smith\"]\n    ```", "```py\n    main = do\n        pipe <- runIOE $ connect (host \"127.0.0.1\")\n        e <- access pipe master \"test\" (store myData)\n        close pipe\n        print e\n    ```", "```py\n    store vals = insertMany \"people\" mongoList \n      where mongoList = map \n                        (\\(Person f l) -> \n                          [\"first\" =: f, \"last\" =: l]) \n                        vals\n    ```", "```py\n    $ mongod --dbpath ~/db\n\n    ```", "```py\n    $ runhaskell Main.hs\n    $ mongo\n    >  db.people.find()\n    { \"_id\" : ObjectId(\"536d2b13f8712126e6000000\"), \"first\" : \"Mercury\", \"last\" : \"Merci\" }\n    { \"_id\" : ObjectId(\"536d2b13f8712126e6000001\"), \"first\" : \"Sylvester\", \"last\" : \"Smith\" }\n\n    ```", "```py\n$ cabal install blaze-html\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n\n    import Control.Monad (forM_)\n    import Text.Blaze.Html5\n    import qualified Text.Blaze.Html5 as H\n    import Text.Blaze.Html.Renderer.Utf8 (renderHtml)\n    import qualified Data.ByteString.Lazy as BSL\n    ```", "```py\n    dataInList :: Html -> [String] -> Html\n    dataInList label items = docTypeHtml $ do    \n      H.head $ do\n        H.title \"Generating HTML from data\"\n      body $ do\n        p label\n        ul $ mapM_ (li . toHtml) items\n    ```", "```py\n    main = do    \n      let movies = [ \"2001: A Space Odyssey\"\n                   , \"Watchmen\"\n                   , \"GoldenEye\" ]\n      let html = renderHtml $ dataInList \"list of movies\" movies\n      BSL.writeFile \"index.html\" $ html\n    ```", "```py\n    $ runhaskell Main.hs\n\n    ```", "```py\n$ cabal install LaTeX\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n    import Text.LaTeX\n    import Text.LaTeX.Base.Class\n    import Text.LaTeX.Base.Syntax\n    import qualified Data.Map as M\n    ```", "```py\n    main :: IO ()\n    main = execLaTeXT myDoc >>= renderFile \"output.tex\"\n    ```", "```py\n    myDoc :: Monad m => LaTeXT_ m\n\n    myDoc = do\n      thePreamble\n      document theBody\n    ```", "```py\n    thePreamble :: Monad m => LaTeXT_ m\n\n    thePreamble = do\n      documentclass [] article\n      author \"Dr. Databender\"\n      title \"Data Analyst\"\n    ```", "```py\n    myData :: [(Int,Int)]\n\n    myData = [ (1, 50)\n             , (2, 100)\n             , (3, 150)]\n    ```", "```py\n    theBody :: Monad m => LaTeXT_ m\n\n    theBody = do\n    ```", "```py\n      maketitle\n      section \"Fancy Data Table\"\n      bigskip\n      center $ underline $ textbf \"Table of Points\"\n      center $ tabular Nothing [RightColumn, VerticalLine, LeftColumn] $ do\n        textbf \"Time\" & textbf \"Cost\"\n        lnbk\n        hline\n        mapM_ (\\(t, c) -> do texy t & texy c; lnbk) myData \n    ```", "```py\n    $ runhaskell Main.hs\n    $ pdflatex output.tex\n\n    ```", "```py\n$ cabal install template\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n\n    import qualified Data.ByteString.Lazy as S\n    import qualified Data.Text as T\n    import qualified Data.Text.IO as TIO\n    import qualified Data.Text.Lazy.Encoding as E\n    import qualified Data.ByteString as BS\n    import Data.Text.Lazy (toStrict)\n    import Data.Text.Template\n    ```", "```py\n    myData = [ [ (\"name\", \"Databender\"), (\"title\", \"Dr.\") ],\n               [ (\"name\", \"Paragon\"), (\"title\", \"Master\") ],\n               [ (\"name\", \"Marisa\"), (\"title\", \"Madam\") ] ]\n    ```", "```py\n    myTemplate = template \"Hello $title $name!\"\n    ```", "```py\n    context :: [(T.Text, T.Text)] -> Context\n    context assocs x = maybe err id . lookup x $ assocs\n      where err = error $ \"Could not find key: \" ++ T.unpack x\n    ```", "```py\n    main :: IO ()\n    main = do\n      let res = map (\\d -> toStrict ( \n                      render myTemplate (context d) )) myData\n      TIO.writeFile \"messages.txt\" $ T.unlines res\n    ```", "```py\n    $ runhaskell Main.hs\n\n    $ cat messages.txt\n\n    Hello Dr. Databender!\n    Hello Master Paragon!\n    Hello Madam Marisa!\n\n    ```", "```py\n$ cabal install repa-io\n\n```", "```py\n    import Data.Array.Repa.IO.Matrix\n    import Data.Array.Repa\n    ```", "```py\n    x :: Array U DIM2 Int \n    x = fromListUnboxed (Z :. (4::Int) :. (3::Int)) \n      [ 1, 2, 9, 10\n      , 4, 3, 8, 11\n      , 5, 6, 7, 12 ]\n    ```", "```py\n    main = writeMatrixToTextFile \"output.dat\" x\n    ```"]