- en: Chapter 1. Python for Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using dictionary objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a dictionary of dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a list from another list - list comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an iterator and a generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function as a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding functions in another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering the function behavior with decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating anonymous functions with lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the map function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using zip and izip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing arrays from the tabular data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessing the columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting with a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with itertools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python programming language provides a lot of built-in data structures and
    functions that are very handy for data science programming. In this chapter, we
    will look at some that are most frequently used. In the subsequent chapters, you
    will see that these will be used in various sections for different topics. A good
    grasp of these will help you in the long run to quickly bootstrap a program in
    order to handle data and develop algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter is a quick overview of handy data structures and methods,
    you will start discovering your own ways of combining these data structures to
    achieve your requirements as you become a seasoned Python user.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these data structures have an utility, though different circumstances
    may require using two or more data structures in tandem to achieve your requirements.
    You will see this in action in some of the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using dictionary objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, containers are objects that can hold any number of arbitrary objects.
    They provide a way to access the child objects and iterate over them. Dictionary,
    tuple, list, and set are container objects in Python. More container types are
    available with the `collections` module. Let's look at the dictionary object in
    detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at an example Python script to understand how a dictionary operates.
    So, with a text, this script tries to get the word count, that is, how many times
    each word has appeared in the given text.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s proceed to demonstrate how to operate a dictionary in Python. Let''s
    use a simple sentence to demonstrate the use of a dictionary. We will follow it
    up with an actual dictionary creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding code builds a word frequency table; every word and its frequency
    is calculated. The final print statement produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is a key value pair. For each word (key), we have a frequency
    (value). A dictionary data structure is a hash map where values are stored against
    a key. In the preceding example, we used a string as a key; however, any other
    immutable data type can also be used as a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following URL for a detailed discussion about mutable and immutable
    objections in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/reference/datamodel.html](https://docs.python.org/2/reference/datamodel.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, values can be any data type including custom classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 2, we initialized the dictionary. Its empty when initialized. When
    a new key is added to a dictionary, accessing the dictionary through the new key
    will throw `KeyError`. In the preceding example in step 3, we included an if statement
    in the for loop to handle this situation. However, we can also use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With every key access to the dictionary, this statement has to be repeated
    if we are adding elements to a dictionary in a loop, as in a loop, we are not
    aware of new keys. Rewriting step 3 using `setdefault` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 2.5 and above has a class named `defaultdict`; it''s in the `collections`
    module. This takes care of the `setdefault` action. A `defaultdict` class is invoked
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you have noticed, we included `collections.defaultdict` in our code and initialized
    our dictionary. Note that the `int` parameter, `defaultdict`, takes a function
    as an argument. In this case, we passed the `int()` function and thus, when the
    dictionary encounters a key that was not seen before, it initializes the key with
    a value returned by the `int()` function, in this case, zero. We will use `defaultdict`
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A typical dictionary does not remember the order in which the keys were inserted.
    In its collections module, Python provides a container called `OrderedDict` that
    can remember the order in which the keys were inserted. See the following Python
    documentation for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/collections.html#collections.OrderedDict](https://docs.python.org/2/library/collections.html#collections.OrderedDict)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looping through a dictionary is very easy; using the keys() function provided
    in the dictionary, we can loop through the key and using values(), we can loop
    through the values or using items(), we can loop through both the keys and values.
    Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, using `dict.items()`, we can iterate through the keys and values
    present in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python documentation for dictionaries is very exhaustive and is a handy
    companion when working with dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/tutorial/datastructures.html#dictionaries](https://docs.python.org/2/tutorial/datastructures.html#dictionaries)'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are very useful as an intermediate data structure. If your program
    uses JSON as a way to move around information between modules, dictionary is the
    right data type for the job. It is very convenient to load a dictionary from a
    JSON file and similarly dump a dictionary as JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides us with libraries to handle JSON very efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Counter is a dictionary subclass to count the hashable objects. Our example
    of the word count can be easily done using counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows and you can verify this output with the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can go through the following link to understand more about Counters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/collections.html#collections.Counter](https://docs.python.org/2/library/collections.html#collections.Counter)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with Dictionary of Dictionaries* recipe in [Chapter 1](ch01.xhtml
    "Chapter 1. Python for Data Science"), *Using Python for Data Science*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a dictionary of dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, the real power of these data structures lies in how
    creatively you can use them to achieve your tasks. Let's look at an example to
    understand how to use dictionaries in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B04041_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the first column, we have three users and the rest of the columns are movies.
    The cell values are ratings given by a user for a movie. Let's say we want to
    represent this in memory so that some other part of a larger code base can easily
    access this information. We will use a dictionary of dictionaries to achieve this
    objective.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create the `user_movie_rating` dictionary using an anonymous function
    to demonstrate the concept of a dictionary of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will fill it with data to show the effective use of a dictionary of dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `user_movie_rating` is a dictionary of dictionaries. As explained in the
    previous section, `defaultdict` takes a function for argument; in this case, we
    passed a built-in anonymous function, `lambda`, which returns a dictionary. So,
    every time a new key is passed to `user_movie_rating`, a new dictionary will be
    created for this key. We will see more about the `lambda` function in the subsequent
    section.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can access the rating of any user movie combination very quickly.
    Similarly, there are plenty of use cases where a dictionary of dictionaries comes
    in very handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a closing note on the dictionary, I would like to mention that having a
    good grasp of the dictionary data structure will help ease a lot of your data
    science programming tasks. As we will see later, dictionaries are frequently used
    to store features and labels in machine learning. The Python NLTK library uses
    a dictionary extensively to store features in text mining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.nltk.org/book/ch05.html](http://www.nltk.org/book/ch05.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The section titled *Mapping words to Properties using Python Dictionaries* is
    a good read to understand how effectively dictionaries can be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating Anonymous Functions* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python
    for Data Science"), *Using Python for Data Science*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tuple is a type of container object known as sequence types in Python. Tuples
    are immutable and can have a heterogeneous sequence of elements separated by a
    comma and enclosed in parentheses. They support the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`in` and `not in`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparision, concatenation, slicing, and indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min()` and `max()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than having a full program as we did with dictionaries, we will see tuples
    as fragmented codes where we will concentrate on the creation and manipulation
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see some scripts demonstrating the creation and manipulation of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In step 1, we created a tuple. Though strictly speaking, the parentheses are
    not needed, still it''s an option for better readability. As you can see, we created
    a heterogeneous tuple with numeric and string values. Step 2 details how the elements
    of a tuple can be accessed through the index. Indices start from zero. A negative
    number can be used to access the tuple in reverse. The output of the print statement
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Python tuple indices start from 0\. Tuples are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 3, we will look at the most important property of a tuple called immutability.
    It is not possible to change the value of an item in a tuple; step 3 will result
    in an error thrown by the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This may look restrictive; however, the immutable feature has immense value
    from a data science perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While building programs for machine learning, in particular during the feature
    generation from raw data, creating feature tuples ensures that values cannot be
    changed by downstream programs.
  prefs: []
  type: TYPE_NORMAL
- en: As these features reside in a tuple, no downstream program can accidently change
    the feature values.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we want to point out that a tuple can have a mutable object as its
    member, for example, a list. If we have a tuple as shown in step 4, the third
    element of the tuple is a list. Now, let''s try to change an element in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will print the tuple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the value of the first element in the list is changed to `100`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, we concatenated two tuples. Another interesting way to use tuples
    is when different modules are creating different features for a machine learning
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For example, let's say that you have one module that is creating a bag-of-words
    kind of feature and another module that is working on creating numerical features
    for a typical text classification program. These models can output the tuples
    and a final module can concatenate these tuples to get a full feature vector.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its immutable property, unlike a list, a tuple cannot be extended after
    its creation. It does not support an `append` function. Another advantage of this
    immutable property is that a tuple can be used as a key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, when creating keys, we may need to concatenate different string values
    using custom separators to create a unique key. Instead, a tuple with these string
    values can be created to be used as a key.
  prefs: []
  type: TYPE_NORMAL
- en: This improves the program output readability and also avoids bugs from creeping
    in when the keys are combined manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 6, we will detail the slicing operations in a tuple. Typically, there
    are three numbers provided for the slicing and they are separated by a colon.
    The first number decides which index to start the slicing, the second one decides
    the ending index, and the last one is for step. The examples in step 6 will clarify
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we specified only the start index number, `1`. (Remember that
    indices start with zero.) We got a slice of the tuple starting from index, `1`.
    Let''s see another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specified the start index as `1` and end index as `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slicing operations are right-ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though we specified the end index as `3`, the output will be returned till
    index `2`, that is, one before. Hence, we have `2` and `3` as a part of our output
    slice. Finally, let''s provide all three parameters and the start and end indices
    followed by the step size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It displays the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, our step size is `2`. In addition to the start and end indices, we also
    specified the step size. Hence, it jumps two indices every time and produces the
    output as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the negative indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the negative index. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything except the last element is returned in the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Food for thought, the output of the preceding statement is as follows—a curious
    reader should be able to figure out how we got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 7, we will show that we can use the `min()` and `max()` functions on
    a tuple to get the minimum and maximum value out of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 8, we will show the conditional operators in and not in; this can be
    effectively used to find out if an element is part of a tuple or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the preceding section, we accessed the elements of a tuple by
    their indices. For better program readability, say that we want to have a name
    assigned to each of the elements of a tuple and access the elements by their names.
    This is where namedtuple comes to our rescue. The following URL gives a good documentation
    of namedtuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/collections.html#collections.namedtuple](https://docs.python.org/2/library/collections.html#collections.namedtuple)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example to illustrate the use of a namedtuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we accessed the elements of `vec_1` and `vec_2` using object
    notation, `vec_1.x`, `vec_1.y`, and so on. Instead of using their indices, we
    now have a better readable program. `Vec_1.x` is equivalent to `vec_1[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Data Analysis – Explore and Wrangle* recipe in [Chapter 3](ch03.xhtml "Chapter 3. Data
    Analysis – Explore and Wrangle"), *Analyzing Data - Explore & Wrangle* which represents
    the text as a Bag-of-words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sets are very similar to list data structures except that they do not allow
    duplicates. It's an unordered collection of homogeneous elements. Typically, sets
    are used to remove the duplicate elements from a list. However, a set supports
    operations such as intersection, union, difference, and symmetric difference.
    These operations are very handy in a lot of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will write a small program to understand the various utilities
    of set data structures. In our example, we will calculate a similarity score between
    two sentences using Jaccard's coefficient. We will see in detail about Jaccard's
    coefficient and similar other measures in later chapters. Here is a quick introduction
    to this measure. Jaccard's coefficient is a number between zero and one, where
    one indicates a high similarity. It's calculated based on how many elements are
    common between the two sets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see some Python scripts that are used for the set creation and manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In steps 1 and 2, we took two sentences, split them into words, and created
    two sets using the `set()` function. The `set` function can be used to convert
    a list or tuple to a set. Look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `a` is a tuple and `b` is a list. With the `set()` function,
    the duplicates are eliminated and a set object is returned. The `st_1.split()`
    and `st_2.split()` method return a list and we will pass it to a set function
    to get the set objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now calculate the similarity score between two sentences using Jaccard's
    coefficient. We will see in detail about Jaccard's coefficient and similar other
    measures in the similarity measures section in a later chapter. We will leverage
    the `union()` and `intersection()` functions available with the sets to calculate
    the similarity score.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we will perform two operations. First, using the `intersection()`
    function, we will try to find out what words are common between the sets. The
    common words between the two sentences are `'cats'` and `'dogs'`. Followed by
    this, we will find out the count of the common words, which is two. In the next
    step, we will find out the list of unique words between the two sets using the
    `union()` function. The unique words between these two sentences are `'cats'`,
    `'hate'`, `'dogs'`, and `'chase'`. This is sometimes referred to as vocabulary
    in natural language processing. Finally, we will calculate Jaccard's coefficient
    in step 6, which is the ratio of a count of the common words between the two sets
    to a count of the unique words between the two sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this program looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We gave the preceding example to represent the usage of the set functions.
    However, you can use the built-in functions from libraries such as scikit-learn.
    Going forward, we will leverage as much of these functions from libraries as possible,
    instead of hand coding these utility functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Writing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list is a container object and sequence type. They are similar to tuples except
    that they are homogenous and mutable. A list allows append operations. They can
    also be used as either a stack or queue. Unlike tuples, lists are expandable;
    you can add elements to a list using the append function after its creation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to how we saw tuples, we will see lists as fragmented codes where we
    will concentrate on the creation and manipulation activity instead of having a
    full program as we did with dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at some Python scripts demonstrating the list creation and manipulation
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we saw different ways of creating a list. Note that we have only
    homogeneous elements. There can be duplicates unlike a set. Steps 2,3,4,5,6, and
    7 are similar to the tuple steps. We will not elaborate on these steps. They cover
    the indexing, slicing, concatenation, minmax, and in and not in operations similar
    to a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 8 presents the append and extend operations. This is where a list starts
    to differ from a tuple. (Of course, we know that these lists are homogeneous.)
    Let''s look at the output of the first part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can see that 10 is added to the `a` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is of the second part where extend is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We extended the original `a` list by another list, `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 9, we will show how a list can be used as a stack. The `pop()` function
    helps to retrieve the last element appended to the list. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The last element to be appended is the first element to be retrieved **Last
    In, First Out** (**LIFO**) style as in stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 10, we will implement a queue using a list. The `pop()` function with
    zero as a parameter indicates that the index of the element to be retrieved has
    been passed. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The output adheres to the LIFO style of a queue. However, this is not a very
    efficient method. Popping the first element is not optimal because of the way
    a list is implemented. An efficient way to perform this operation is to use the
    deque data structure explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The final step details the sort and reverse operations in a list. A list has
    a built-in function, `sort()`, to sort the elements of a list. By default, it
    sorts in an ascending order. Sorting is explained in detail in a later section
    of this chapter. The `reverse()` function will reverse the elements of a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create a list with elements from 1 to 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will shuffle the elements using the `shuffle()` function from a module random.
    This shuffles the elements so that we can demonstrate the sort operations. The
    shuffled output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `a.sort()` does an in-place sort and when we print a, we will get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a.reverse()` is also an in-place operation that produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The deque stands for double-ended queue. Unlike stack and queues, which can
    be appended and popped in only one direction, the append and pop operations can
    be done at both ends with deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/collections.html#collections.deque](https://docs.python.org/2/library/collections.html#collections.deque)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a list from another list - list comprehension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comprehension is a way to create a sequence from another sequence. For example,
    we can create a list from another list or tuple. Let''s look at a list comprehension.
    Typically, a list comprehension involves the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence, say a list whose elements we are interested in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable representing the elements of the sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output expression that is responsible for producing the output sequence using
    the elements of the input sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional predicate expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's define a simple problem in order to understand all the different elements
    involved in comprehension. With an input list with positive and negative numbers,
    we need an output list that is the square of all the negative elements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following script, we will show a simple example of list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example is written in a way to explain the various components of comprehension.
    Let''s look at step 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our input list is `a` and output list is `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a variable `x` to represent each element in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pow(x,2)` is the output expression, which uses the elements in the input
    to produce the output list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `if` `x < 0` is the predicate expression that controls which elements
    of the input list are used to produce the output list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The comprehension syntax is exactly the same as a dictionary. A simple example
    will illustrate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created a new dictionary, b from the input dictionary,
    a. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we retained the keys of the `a` dictionary, but now the new
    values are a square of the original values in a. A point to note is the use of
    curly bracelets instead of brackets during the comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do comprehension for tuples with a small trick. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the `pow()` function, we used a new process function. I will leave
    it to you as an exercise to decipher what the process function does. Note that
    we followed the same syntax for a comprehension list; however, we used braces
    instead of brackets. The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! We wanted a tuple but ended up with a generator (more on generators in
    the later sections). The right way to do it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the print b statement will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Python comprehension is based on the set builder notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Set-builder_notation](http://en.wikipedia.org/wiki/Set-builder_notation)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Itertools.dropwhile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/itertools.html#itertools.dropwhile](https://docs.python.org/2/library/itertools.html#itertools.dropwhile)'
  prefs: []
  type: TYPE_NORMAL
- en: With a predicate and sequence, dropwhile will return only those items in the
    sequence that satisfies the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a no-brainer that a key input for a data science program is data. Data
    may vary in size—some of them may fit into memory and some may not. The record
    access mechanism can vary from one data format to another. Interestingly, different
    algorithms may demand chunks of varying length to process. For example, let's
    say that you are writing a stochastic gradient descent algorithm and you want
    to pass chunks of 5,000 records in each epoch, it will be very nice to have an
    abstraction that can handle the accessing of the data, understanding the data
    format, looping through the data, and providing the caller with the required data.
    This will result in a clean code. Most of the time, the interesting part lies
    in what we do with the data and not how we access the data. Python provides us
    with an elegant way in the form of iterators to handle all of these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iterator in Python implements an iterator pattern. It allows us to go over
    a sequence one by one without materializing the whole sequence!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple iterator called simple counter and provide it with some
    code on how to effectively use the iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we defined a class by the name of `SimpleCounter`. The `__init__`
    constructor takes two parameters, `start` and `end,` defining the beginning and
    end of our sequence. Note the two methods, `__iter__` and `next`. Any object in
    Python that is meant to be an iterator object should support these two functions.
    The `__iter__` returns the complete class object as an iterator object. The `next`
    method returns the next value in the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in step 2, we can access the successive elements in the iterator using
    the `next()` function. Python also provides us with a convenient function, `iter()`,
    which can be used in a loop to access elements sequentially as shown in step 3\.
    The `iter()` uses the `next()` function internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point to note is that an iterator object can be used only once. After running
    the preceding code, we will try to access the iterator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It will throw the StopIteration exception. Calling `c.next()` after the sequence
    has exhausted will result in a StopIteration exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `iter()` function handles this exception and exits the loop once the data
    has been exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see another example of an iterator. Let''s say that we need to access
    a very large file in our program; however, in our program, we will work through
    it only one line at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In Python, a file object is an iterator; it supports the `iter()` and `next()`
    functions. Hence, instead of loading the whole file in memory, we can work with
    a single line at a time.
  prefs: []
  type: TYPE_NORMAL
- en: An iterator gives you the power to write custom code in order to access your
    data sources in a manner that your application demands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link provides more information about how iterators can be used
    in various ways in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Infinite iterators, `count()`, `cycle()` and `repeat()` in itertools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/itertools.html#itertools.cycle](https://docs.python.org/2/library/itertools.html#itertools.cycle)'
  prefs: []
  type: TYPE_NORMAL
- en: Generating an iterator and a generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw what an iterator is in the previous recipe; now in this one, let's see
    how to generate an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generators provide a clean syntax to loop through a sequence of values eliminating
    the need to have the two functions, __iter__ and next(). We don't have to write
    a class. A point to note is that both generators and iterables produce an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: How it do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a look the following example; it should be easy to follow if you
    understood comprehension from the previous section. In this case, we have a generator
    comprehension. If you recall, we tried doing a tuple comprehension in this way
    and got a generator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how to use the yield statement to create a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `my_gen()` function is a generator; we used the
    yield statement to return the output in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we mentioned that both a generator and iterables produce
    an iterator. Let''s validate this by trying to call the generator using the `iter`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on to iterables in our next recipe, a key point to note with
    a generator is that once we have gone through the sequence, we are done—no more
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a generator object, we can go over the sequence only once.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterables are similar to generators except for a key difference, we can go on
    and on with an iterable, that is, once we have exhausted all the elements in a
    sequence, we can again start accessing it from the beginning unlike a generator.
  prefs: []
  type: TYPE_NORMAL
- en: They are object-based generators that do not hold any state. Any class with
    the `iter` method that yields data can be used as a stateless object generator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try to understand iterables with a simple example. This recipe should
    be easy to follow if you have understood the previous recipes on generators and
    iterators.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple iterable called SimpleIterable and show some scripts
    that manipulate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works..
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we created a simple class that is our iterable. The init constructor
    takes two arguments, start and end, similar to our earlier example. We defined
    a function called iter, which will give us our required sequence. In this given
    range of numbers, the square of these numbers will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two loops. We iterated through our range of numbers, 1 to 10,
    in the first loop. When we will run the second for loop, you will notice that
    it once again iterates through the sequence and doesn't raise any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using Iterators* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python for Data
    Science"), *Using Python for Data Science*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generating an Iterator - Generators* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python
    for Data Science"), *Using Python for Data Science*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function as a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python supports functional programming in addition to imperative paradigms.
    In the previous sections, we have seen some functional programming constructs
    without an explicit explanation. Let's go over them in this section. Functions
    are first-class citizens in Python. They have attributes and they can be referenced
    and assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the paradigm of passing a function as a variable in Python in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a simple function and see how it can be used as a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We defined a simple function in step 1; with an input, the function returns
    the square of the input. We assigned this function to a `square_me` variable.
    Finally, we were able to invoke the function by calling `square_me` with a valid
    parameter. This demonstrates how a function can be treated as a variable in Python.
    This is a very import functional programming construct.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding functions in another function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will explain yet another functional programming construct; defining
    a function in another function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a simple example of writing a function, which will return the sum
    of the squares of the given input list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a simple function to demonstrate a function in another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, you can see that we defined a `square_input()` function in the `sum_square()`
    function. The parent function uses it to perform the sum of squares operation.
    In the next step, we called the function and printed its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output produced was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Passing a function as a parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now demonstrate how to pass a function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we defined a `apply_func` function with two variables. The first
    variable is a function and second one is a sequence. As you can see, we used the
    map function (more on this function in the recipes to follow) to apply the given
    function to all the elements of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we invoked `apply_func` on a list a; first with the `square_input` function
    followed by a `log` function. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the elements of a are all squared. The map applies the square_input
    function to all the elements in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, log is applied on all the elements in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's look at the functions that will return another function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a high school example and try to explain the use of functions returning
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our problem is we are given a cylinder of radius r and we would like to know
    the volume of it for different heights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.mathopenref.com/cylindervolume.html](http://www.mathopenref.com/cylindervolume.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding formula gives the exact cubic units that will fill a cylinder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a simple function to demonstrate the concept of a function returning
    a function. In addition, we will write a small piece of code to show the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we defined a function called `cylinder_vol()`; it takes a single
    parameter, `r`, radius.In this function, we defined another function, `get_vol()`.
    The `get_vol()` function has access to r and pi, takes the height as an argument.
    For the given radius, r, which was the parameter to `cylinder_vol()`, different
    heights were passed as a parameter to `get_vol()`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we defined a radius; in this case, as ten and invoke the `cylinder_vol()`
    functionwith it. It returns the `get_vol()` function, which we stored in a variable
    named `find_volume`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3,we invoked `find_volume` with different heights, 10 and 20\. Note
    that we didn't give the radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output produced is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functools is a module for higher order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/functools.html](https://docs.python.org/2/library/functools.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Altering the function behavior with decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators wrap a function and alter their behavior. They are best understood
    with some working examples. Let's see some decorators in action in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you recall the section where we explained a function as an argument to another
    function, function as a variable, and function returning a function? Most important
    of all, do you remember the cylinder example? If you followed it, decorators should
    be a piece of cake. In this exercise, we will do a pipeline of cleaning activity
    on a given string. With a string with mixed casing and punctuation, we will use
    decorators to write a cleaning routine, which can be extended very easily.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a simple decorator for the text manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start from the last two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared a string variable. We want to clean the string. In our case, we
    want the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: We want the string to be in lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to strip the punctuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to return a list of words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see that we called the `tokenize_whitespace` function with the string,
    s, as a parameter. Let''s look at the `tokenize_whitespace` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that this is very simple function and with a string input, the function
    splits it by a space and returns a list of words. We will alter the behavior of
    this function using decorators. You can see that the decorator that we will use
    for this function is `@pipeline_wrapper`. This is an easier way of calling the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tokenize_whitespace` = `pipeline_wrapper (clean_tokens)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the decorator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `pipeline_wrapper` returns the `wrapper` function. In the
    `wrapper` function, you can see that the final return statement returns `func`;
    this is the original function passed by us to the wrapper.The `wrapper` modifies
    the behavior of our original `tokenize_whitespace` function. The input to `tokenize_whitespace`
    is modified first by the `to_lower()` function, which changes the input string
    to lowercase, followed by the `remove_punc()` function, which removes the punctuation.
    The final output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Exactly what we wanted—the punctuation stripped, strings converted to lowercase,
    and finally, a list of words.
  prefs: []
  type: TYPE_NORMAL
- en: Creating anonymous functions with lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anonymous functions are created using the lambda statement in Python. Functions
    that are not bound to a name are called anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you followed the section on passing functions as a parameter, the example
    in this section is very similar to it. We passed a predefined function in that
    section; here we will pass a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see a simple example with a toy dataset to explain anonymous functions
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we have a function called `do_list` that accepts another function
    as an argument. With a list and function, `do_list` applies the input function
    over the elements of the given list, sums up the transformed values, and returns
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will invoke the do-list function, the first parameter is our input
    list a, and the second parameter is our lambda function. Let''s decode our lambda
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: An anonymous function is declared using the keyword, lambda; it's followed by
    defining a parameter for the function. In this case, x is the name of the parameter
    passed to this anonymous function. The expression succeeding the colon operator
    is the return value. The input parameter is evaluated using the expression and
    returned as the output. In this input, the square of the input is returned as
    the output. In the next print statement, we have a lambda function, which returns
    the cube of the given input.
  prefs: []
  type: TYPE_NORMAL
- en: Using the map function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Map is a built-in Python function. It takes a function and an iterable for
    an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The function is applied on all the elements of the iterable and results are
    returned as a list. As a function is passed to map, lambda is most commonly used
    along with map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a very simple example using the map function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see an example on how to use a map function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is very similar to the code in the previous recipe. A map functions takes
    two parameters. The first one is a function and second one is a sequence. In our
    example code, we used an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This function squares the given input. We also passed a list to map.
  prefs: []
  type: TYPE_NORMAL
- en: Map applies a function that squares all the elements in the given list and returns
    the result as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, any other function can be applied to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Using map, we can replace the code snippet in the previous recipe with a single
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Map expects an N-argument function if we have N-sequences. Let''s see an example
    to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We passed two sequences a and b to our map function. Notice that the function
    passed is the power function. It takes two arguments. Let''s see the result of
    the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the elements of list `a` is raised to the power of value in
    the same position in list b. A point to note is that both the lists should be
    of the same size; if not, Python will fill the smaller list with None. Though
    our examples are operating on a list, any iterable can be passed to a map function.
  prefs: []
  type: TYPE_NORMAL
- en: Working with filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True to its name, filter filters elements from a sequence based on the given
    function. With a sequence of negative and positive numbers, we can use a filter
    function to, say, filter out all the negative numbers. Filter is a built-in Python
    function. It takes a function and an iterable for an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The function that is passed as an argument is returned as a Boolean value based
    on a test.
  prefs: []
  type: TYPE_NORMAL
- en: The function is applied on all the elements of the iterable and all the items
    that are returned as true when the function is applied over them are returned
    as a list. An anonymous function, lambda, is most commonly used along with filter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a simple code to see the filter function in action.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see an example on how to use a filter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The lambda function that we use here is very simple; it returns true if the
    given value is greater than ten, false otherwise. Our print statement gives the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, only elements greater than ten are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Using zip and izip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zip takes two equal length collections and merges them together in pairs. Zip
    is a built-in Python function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's demonstrate zip using a very simple example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s pass two sequences to a zip function and print the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two parameters to our zip function are two lists, both with values ranging
    from `1` to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A range function takes three parameters. The starting value of the list, ending
    value of the list, and a step value. The default step value is one. In our case,
    we passed 1 and 5 as the starting and ending values of the list. Remember that
    Python is right-closed, so the range (`1`, `5`) will return a list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the two sequences to the zip function and the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that both the collections should be of the same size; if not, then
    the output is truncated to the size of the shortest collection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess what the output is?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the * operator does. A `*` operator unpacks a collection in
    their positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The `**` operator unpacks a dictionary as a set of named arguments. In this
    case, we will get an output,6, when we apply the `**` operator to a dictionary.
    Look at the following function, which takes six arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The output of the print statement is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with these two operators, we can write a function without any restrictions
    on the number of variables that it can ingest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Back to the zip utility. One drawback with zip is that it can compute the list
    all at once. This may be an issue when we have two very large lists. The `izip`
    comes to the rescue in these cases. They compute the elements only when requested.
    The `izip` is a part of `itertools`. Please refer to the itertools recipe for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with Itertools* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Python
    for Data Science"), *Using Python for Data Science*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing arrays from the tabular data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The meat of any data science application is to find an appropriate data handling
    routine for a given problem. In the case of machine learning, it's either the
    supervised or unsupervised method to predict or classify the data. Even before
    this step, a good amount of time is spent in the data transformation and making
    the data suitable for these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, data is made available to a data science program in many ways. A data
    science programmer is faced with the challenge of accessing the data and making
    it available to a later part of his code using the Python data structure. Mastering
    ways to access data through Python will be very handy when writing a data science
    program as it will allow you to jump to the meat of the problem very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, data is available as a text file, separated by either a comma or
    tab. A Python built-in file object utility can be used in this case. As we saw
    earlier, a file object implements the `__iter__()` and `next()` methods. This
    allows us to work on very large files, which do not fit into memory, by reading
    only a small chunk of the files at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Python machine learning libraries such as scikit-learn works on the NumPy libraries.
    In this section, we will see ways of efficiently reading external data and converting
    it to numPy arrays for the downstream data processing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy provides us with a function called `genfromtext` to create NumPy arrays
    from tabular data. Once the data is available as NumPy arrays, it's much easier
    for the downstream systems to process this data. Let's look at how we can leverage
    `genfromtext`. The following code was written using the NumPy version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's import the necessary libraries to start with. We will proceed to define
    a sample input. Finally, we will demonstrate how to process tabular data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we simulated a tabulated data using the `StringIO` utility. We have
    three rows and three columns. The rows are new line-delimited and columns are
    comma-delimited.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we used `genfromtxt` from NumPy to ingest the data as a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to genfromtxt is the source of the file and filename; in
    our case, it''s the StringIO object. The input is comma-delimited; the delimiter
    argument allows us to specify the same. After running the preceding code, the
    data value is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we successfully loaded the data from the string in a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Various parameters and default values of the same are shown here for the `genfromtxt`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The only mandatory argument is the name of the source of the data. In our case,
    we used a StringIO object. It can be a string corresponding to the name of a file
    or an object similar to a file with a read method. It can also be a URL of a remote
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to split the given line into columns. Once the file is open
    to be read, genfromtxt splits the non-empty lines into a sequence of strings.
    Empty lines are ignored and so are the commented lines. The comments option helps
    gentext decide which are the comment lines. The strings are split into columns
    based on a delimiter specified by the delimiter option. In our example case, we
    used a `,` delimiter. A `/t` is also a very popular delimiter. By default, the
    delimiter is `None` in gentext, which means that it assumes that the line is split
    into columns through whitespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when lines are changed to a sequence of strings and subsequently
    the columns are extracted, the individual columns are not stripped of the leading
    or trailing whitespaces. In a later part of the code, this needs to be handled,
    especially if some of the variables are used as keys in a dictionary. For example,
    if the leading or trailing whitespaces are not handled consistently, this may
    lead to a bug/error in the code. Setting `autostrip=True` helps avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, we want to skip, say, top n rows or bottom n rows while reading
    a file. This may be due to the presence of headers or footers. The `skip_header
    = n` will skip the first n lines while reading and similarly, `skip_footer = n`
    will skip the last n lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to unwanted rows, we may encounter many cases where we may not need
    to use some columns. The `usecols` argument is used to specify the list of columns
    that we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, we selected only two columns, column
    0 and 1\. The data object looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Custom column names can be provided using the `names` argument. A string argument
    with comma-separated column names looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'By having `names` to true, the first row in the input data is used as a column
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Another simple method from NumPy to create NumPy arrays from the text input
    is `loadtxt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This is less sophisticated than genfromtxt; if you need a simple reader without
    any sophisticated data handling mechanisms such as handling missing values, you
    can opt for loadtxt.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we are not interested in loading the data as a NumPy array but
    want to load it as a list, Python provides us with a default csv library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html)'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting method in the preceding csv library is `csv.Sniffer.sniff()`.
    If we have a very large csv file and we want to understand its structure, we can
    use `sniff()`. This will return a dialect subclass, which has most of the properties
    of the csv file.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing the columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often the data that we get is not in the format we can consume. A lot of data
    processing called data preprocessing steps in machine learning terminology has
    to be applied. One way to work through this hurdle is to ingest all the input
    as strings and carry on with the required data transformation at the later stages.
    Another way is to perform these changes at the source. The `genfromtext` provides
    us with some functionalities in order to perform this data transformation while
    reading from the source.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following lines of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical example of how we get data in real life. The first two columns
    have a string kg and inr attached to the rear and front of the actual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to ingest this data in a NumPy array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first two columns are not read.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's import the necessary libraries to start with. We will proceed to define
    a sample input. Finally, we will demonstrate data preprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we defined two lambda functions, one for column 1 where we need to
    strip the string 'kg' from the right-hand side and another to strip the string
    'inr' from the left-hand side of column 2.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we will go ahead and define a dictionary where the key is the column
    name to which the function has to be applied and the value is the function. This
    dictionary is passed as a parameter with the `converters` name in `genfromtext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Note that Nan has vanished, giving way to an actual value from the input.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Converters can also be used to handle the missing values in an input record
    through a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambda function returns -999 for the missing values. In our input, the
    second column of the second row is empty and this should be replaced by -999\.
    The final output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the SciPy documentations given here for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with sorting a list and then move on to sorting other iterables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to proceed with the sorting. The first way is to use the
    built-in sort function in the list and the other way is to use the sorted function.
    Let's work it out through an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to leverage the sort and sorted functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We declared two lists, a and b, with the same elements. As a convenience way
    to verify the output, we will print list `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the sort function available with the list data type, `a.sort()`, to
    perform an in-place sort. The following print statement shows that the list has
    now been sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the sorted function. This function performs the sorting on
    the list and returns a new sorted list. You can see that we invoked it as `sorted(b)`
    and stored the output in `b_s`. The print statement against `b_s` yields a sorted
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sort` function is only available for a list data type. By default, sorting
    is done in an ascending order; this can be controlled by a reverse parameter to
    the sort function. By default, reverse is set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Sorting with a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we saw all the examples where a list or sequence was sorted by elements.
    Let's now proceed to see if we can sort it using keys. In the previous example,
    elements were the keys. In the real world, there are more complicated records
    where a record contains multiple columns and we would like to sort with one or
    more columns). We will work out our examples through a list of tuples and the
    same applies to the other sequence objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, a single tuple represents a person's record, which includes
    his name, ID, and age. Let's write a sorting in order to sort by the various fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a record-like structure using a list and tuples. We will use
    this data to demonstrate the data sorting with a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, each record has three fields: name, identification, and age.
    We used the lambda function to pass a key by which we need to sort the given records.
    In step 2, we passed the name as the key to sort. Similarly, in steps 2 and 3,
    we passed the ID and age as the keys. We can see the outputs in various steps;
    the outputs are sorted by the particular key that we want them to.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the importance of sorting by a key, Python provides a convenient function
    to access keys instead of writing lambdas. The operator module has the `itemgetter`,
    `attrgetter`, and `methodcaller` functions. The sorting example that we saw can
    be written as follows using `itemgetter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have not used the lambda functions, rather used `itemgetter` to
    specify the key by which we need to sort. More than one field can be given as
    an input to `itemgetter` when we need multiple level sorting; for example, let''s
    say that we need to sort by name and then by age, our code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `attrgetter` and `methodcaller` comes in handy when the elements of our
    iterable are class objects. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the class with three variables: name, age, and
    ID. We also have the `pretty_print` method to print the values of the class object`.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s populate a list with these class objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a list of employee objects. There are three variables in each
    object: name, ID, and age. Let''s print the list to see the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the order of the insertion has been preserved. Now, let''s
    use `attrgetter` to sort the list with the age field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Let's print the sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the records are now sorted by age.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `methodcaller` can be used to sort when we want to use a method in our
    class to decide the sorting. For demonstration purposes, let''s add a random method,
    which divides the age by the ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now sort the list by calling this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now print the list in a sorted order and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Working with itertools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Itertools includes functions to work with iterables; it is inspired by a functional
    programming language such as Haskell. They promise to be memory-efficient and
    very fast.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of functions available in Itertools; we will go through some
    of them as we work it out through examples. A link to the full list of functions
    has been provided.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s proceed to see a set of Python scripts used to demonstrate the usage
    of itertools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Step 1 is pretty straightforward, where two iterables are combined using `chain()`.
    A point to note is that `chain()` is not realized till it''s actually called.
    Check the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling chain(a,b) returns the chain object. However, when we run the following
    command, the actual output is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 describes `compress`. In this example, elements of a are selected based
    on elements in b. You can see that in b, the second value is zero and hence, the
    second value in a is also not selected.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 does simple mathematical combinations. We have an input list, a, and
    want the elements of a in combinations of two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4 explains a counter object, which can serve as an infinite resource of
    a sequence number given a start number. Running the code, we will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we used izip here. (Zip and izip have been covered in previous
    sections.) Our output is a tuple where the first element is provided by counter
    and second element is provided by our input list, a.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 details the islice operation; islice is the same as slice, which we covered
    in the previous section, except that islice is memory-efficient and does not realize
    the complete output unless called upon.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)
    for a complete list of the itertools.
  prefs: []
  type: TYPE_NORMAL
