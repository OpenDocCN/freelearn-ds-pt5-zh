["```py\npip3 install statsmodels\n```", "```py\n# import needful libraries\nimport pandas as pd\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n\n# Read dataset\nsales_data = pd.read_csv('sales.csv')\n\n# Setting figure size\nplt.figure(figsize=(10,6))\n\n# Plot original sales data\nplt.plot(sales_data['Time'], sales_data['Sales'], label=\"Sales-Original\")\n\n# Rotate xlabels\nplt.xticks(rotation=60)\n\n# Add legends\nplt.legend()\n\n#display the plot\nplt.show()\n```", "```py\n# Moving average with window 3\nsales_data['3MA']=sales_data['Sales'].rolling(window=3).mean()\n\n# Moving average with window 5\nsales_data['5MA']=sales_data['Sales'].rolling(window=5).mean()\n\n# Setting figure size\nplt.figure(figsize=(10,6))\n\n# Plot original sales data\nplt.plot(sales_data['Time'], sales_data['Sales'], label=\"Sales-Original\", color=\"blue\")\n\n# Plot 3-Moving Average of sales data\nplt.plot(sales_data['Time'], sales_data['3MA'], label=\"3-Moving Average(3MA)\", color=\"green\")\n\n# Plot 5-Moving Average of sales data\nplt.plot(sales_data['Time'], sales_data['5MA'], label=\"5-Moving Average(5MA)\", color=\"red\")\n\n# Rotate xlabels\nplt.xticks(rotation=60)\n\n# Add legends\nplt.legend()\n\n# Display the plot\nplt.show()\n```", "```py\n# import needful libraries\nimport pandas as pd\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n\n# Read dataset\nsales_data = pd.read_csv('sales.csv', index_col =\"Time\")\n\n# Apply all the windows on given DataFrame\nsales_data['boxcar']=sales_data.Sales.rolling(3, win_type ='boxcar').mean()\nsales_data['triang']=sales_data.Sales.rolling(3, win_type ='triang').mean()\nsales_data['hamming']=sales_data.Sales.rolling(3, win_type ='hamming').mean()\nsales_data['blackman']=sales_data.Sales.rolling(3, win_type ='blackman').mean()\n\n#Plot the rolling mean of all the windows\nsales_data.plot(kind='line',figsize=(10,6))\n```", "```py\n# Import required library\nimport statsmodels.api as sm\nimport pandas as pd\nimport statsmodels.tsa.stattools as ts\nimport numpy as np\n\n# Calculate ADF function \ndef calc_adf(x, y):\n    result = sm.OLS(x, y).fit()\n    return ts.adfuller(result.resid)\n```", "```py\n# Read the Dataset\ndata = sm.datasets.sunspots.load_pandas().data.values\nN = len(data)\n```", "```py\n# Create Sine wave and apply ADF test  \nt = np.linspace(-2 * np.pi, 2 * np.pi, N)\nsine = np.sin(np.sin(t))\nprint(\"Self ADF\", calc_adf(sine, sine))\n```", "```py\nSelf ADF (-5.0383000037165746e-16, 0.95853208606005591, 0, 308,\n{'5%': -2.8709700936076912, '1%': -3.4517611601803702, '10%':\n-2.5717944160060719}, -21533.113655477719)\n```", "```py\n# Apply ADF test on Sine and Sine with noise \nnoise = np.random.normal(0, .01, N)\nprint(\"ADF sine with noise\", calc_adf(sine, sine + noise))\n```", "```py\nADF sine with noise (-7.4535502402193075, 5.5885761455106898e- 11, 3, 305, {'5%': -2.8710633193086648, '1%': -3.4519735736206991, '10%': -2.5718441306100512}, -1855.0243977703672)\n```", "```py\n# Apply ADF test on Sine and Cosine with noise \ncosine = 100 * np.cos(t) + 10\n\nprint(\"ADF sine vs cosine with noise\", calc_adf(sine, cosine + noise))\n```", "```py\nADF sine vs cosine with noise (-17.927224617871534, 2.8918612252729532e-30, 16, 292, {'5%': -2.8714895534256861, '1%': -3.4529449243622383, '10%': -2.5720714378870331}, -11017.837238220782) \n```", "```py\nprint(\"Sine vs sunspots\", calc_adf(sine, data))\n```", "```py\nSine vs sunspots (-6.7242691810701016, 3.4210811915549028e-09, 16, 292,\n{'5%': -2.8714895534256861, '1%': -3.4529449243622383, \n'10%': -2.5720714378870331}, -1102.5867415291168)\n```", "```py\n# import needful libraries\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom statsmodels.tsa.seasonal import seasonal_decompose\n\n# Read the dataset\ndata = pd.read_csv('beer_production.csv')\ndata.columns= ['date','data']\n\n# Change datatype to pandas datetime\ndata['date'] = pd.to_datetime(data['date'])\ndata=data.set_index('date')\n\n# Decompose the data\ndecomposed_data = seasonal_decompose(data, model='multiplicative')\n\n# Plot decomposed data\ndecomposed_data.plot()\n\n# Display the plot\nplt.show()\n```", "```py\n# import needful libraries\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n\n# Read the dataset\ndata = sm.datasets.sunspots.load_pandas().data\n\n# Calculate autocorrelation using numpy\ndy = data.SUNACTIVITY - np.mean(data.SUNACTIVITY)\ndy_square = np.sum(dy ** 2)\n\n# Cross-correlation\nsun_correlated = np.correlate(dy, dy, mode='full')/dy_square\nresult = sun_correlated[int(len(sun_correlated)/2):]\n\n# Diplay the Chart\nplt.plot(result)\n\n# Display grid\nplt.grid(True)\n\n# Add labels\nplt.xlabel(\"Lag\")\n\nplt.ylabel(\"Autocorrelation\")\n# Display the chart\nplt.show()\n```", "```py\nfrom pandas.plotting import autocorrelation_plot\n\n# Plot using pandas function\nautocorrelation_plot(data.SUNACTIVITY)\n```", "```py\n# import needful libraries\nfrom statsmodels.tsa.ar_model import AR\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import mean_squared_error\nimport matplotlib.pyplot as plt\nimport statsmodels.api as sm\nfrom math import sqrt\n\n# Read the dataset\ndata = sm.datasets.sunspots.load_pandas().data\n```", "```py\n# Split data into train and test set\ntrain_ratio=0.8\n\ntrain=data[:int(train_ratio*len(data))]\ntest=data[int(train_ratio*len(data)):]\n```", "```py\n# AutoRegression Model training\nar_model = AR(train.SUNACTIVITY)\nar_model = ar_model.fit()\n\n# print lags and\nprint(\"Number of Lags:\", ar_model.k_ar)\nprint(\"Model Coefficients:\\n\", ar_model.params)\n```", "```py\nNumber of Lags: 15\nModel Coefficients:\nconst            9.382322\nL1.SUNACTIVITY   1.225684\nL2.SUNACTIVITY  -0.512193\nL3.SUNACTIVITY  -0.130695\nL4.SUNACTIVITY   0.193492\nL5.SUNACTIVITY  -0.168907\nL6.SUNACTIVITY   0.054594\nL7.SUNACTIVITY  -0.056725\nL8.SUNACTIVITY   0.109404\nL9.SUNACTIVITY   0.108993\nL10.SUNACTIVITY -0.117063\nL11.SUNACTIVITY  0.200454\nL12.SUNACTIVITY -0.075111\nL13.SUNACTIVITY -0.114437\nL14.SUNACTIVITY  0.177516\nL15.SUNACTIVITY -0.091978\ndtype: float64\n```", "```py\n# make predictions\nstart_point = len(train)\nend_point = start_point + len(test)-1\npred = ar_model.predict(start=start_point, end=end_point, dynamic=False)\n\n# Calculate errors\nmae = mean_absolute_error(test.SUNACTIVITY, pred)\nmse = mean_squared_error(test.SUNACTIVITY, pred)\nrmse = sqrt(mse)\nprint(\"MAE:\",mae)\nprint(\"MSE:\",mse)\nprint(\"RMSE:\",rmse)\n```", "```py\nMAE: 31.17846098350052\nMSE: 1776.9463826165913\nRMSE: 42.15384184883498\n```", "```py\n# Setting figure size\nplt.figure(figsize=(10,6))\n\n# Plot test data\nplt.plot(test.SUNACTIVITY, label='Original-Series')\n\n# Plot predictions\nplt.plot(pred, color='red', label='Predicted Series')\n\n# Add legends\nplt.legend()\n\n# Display the plot\nplt.show()\n```", "```py\n# import needful libraries\nimport statsmodels.api as sm\nfrom statsmodels.tsa.arima_model import ARMA\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.metrics import mean_squared_error\nimport matplotlib.pyplot as plt\nfrom math import sqrt\n\n# Read the dataset\ndata = sm.datasets.sunspots.load_pandas().data\ndata.drop('YEAR',axis=1,inplace=True)\n```", "```py\n# Split data into train and test set\ntrain_ratio=0.8\ntrain=data[:int(train_ratio*len(data))]\ntest=data[int(train_ratio*len(data)):]\n```", "```py\n# AutoRegression Model training\narma_model = ARMA(train, order=(10,1))\narma_model = arma_model.fit()\n```", "```py\n# make predictions\nstart_point = len(train)\nend_point = start_point + len(test)-1\npred = arma_model.predict(start_point,end_point)\n\n# Calculate errors\nmae = mean_absolute_error(test.SUNACTIVITY, pred)\nmse = mean_squared_error(test.SUNACTIVITY, pred)\nrmse = sqrt(mse)\nprint(\"MAE:\",mae)\nprint(\"MSE:\",mse)\nprint(\"EMSE:\",rmse)\n```", "```py\nMAE: 33.95457845540467\nMSE: 2041.3857010355755\nEMSE: 45.18169652675268\n```", "```py\n# Setting figure size\nplt.figure(figsize=(10,6))\n\n# Plot test data\nplt.plot(test, label='Original-Series')\n\n# Plot predictions\nplt.plot(pred, color='red', label='Predicted Series')\n\n# Add legends\nplt.legend()\n\n# Display the plot\nplt.show()\n```", "```py\n# Import required libraries\nimport numpy as np\nimport statsmodels.api as sm\nfrom scipy.optimize import leastsq\nimport matplotlib.pyplot as plt\n\n# Create model function\ndef model(p, t):\n    C, p1, f1, phi1 , p2, f2, phi2, p3, f3, phi3 = p\n    return C + p1 * np.sin(f1 * t + phi1) + p2 * np.sin(f2 * t + phi2) +p3 * np.sin(f3 * t + phi3)\n\n# Create error function\ndef error(p, y, t):\n    return y - model(p, t)\n\n# Create fit function\ndef fit(y, t):\n    p0 = [y.mean(), 0, 2 * np.pi/11, 0, 0, 2 * np.pi/22, 0, 0, 2 * np.pi/100, 0]\n    params = leastsq(error, p0, args=(y, t))[0]\n    return params\n```", "```py\n# Load the dataset\ndata_loader = sm.datasets.sunspots.load_pandas()\nsunspots = data_loader.data[\"SUNACTIVITY\"].values\nyears = data_loader.data[\"YEAR\"].values\n```", "```py\n# Apply and fit the model\ncutoff = int(.9 * len(sunspots))\nparams = fit(sunspots[:cutoff], years[:cutoff])\nprint(\"Params\", params)\n\npred = model(params, years[cutoff:])\nactual = sunspots[cutoff:]\n```", "```py\nprint(\"Root mean square error\", np.sqrt(np.mean((actual - pred) ** 2)))\nprint(\"Mean absolute error\", np.mean(np.abs(actual - pred)))\nprint(\"Mean absolute percentage error\", 100 *\nnp.mean(np.abs(actual - pred)/actual))\nmid = (actual + pred)/2\nprint(\"Symmetric Mean absolute percentage error\", 100 *\n       np.mean(np.abs(actual - pred)/mid))\nprint(\"Coefficient of determination\", 1 - ((actual - pred) \n        **2).sum()/ ((actual - actual.mean()) ** 2).sum())\n```", "```py\nParams [47.1880006  28.89947462   0.56827279 6.51178464  4.55214564\n 0.29372076 -14.30924768 -18.16524123 0.06574835 -4.37789476]\nRoot mean square error 59.56205597915569\nMean absolute error 44.58158470150657\nMean absolute percentage error 65.16458348768887\nSymmetric Mean absolute percentage error 78.4480696873044\nCoefficient of determination -0.3635315489903188\n```", "```py\nyear_range = data_loader.data[\"YEAR\"].values[cutoff:]\n\n# Plot the actual and predicted data points\nplt.plot(year_range, actual, 'o', label=\"Sunspots\")\nplt.plot(year_range, pred, 'x', label=\"Prediction\")\nplt.grid(True)\n\n# Add labels\nplt.xlabel(\"YEAR\")\nplt.ylabel(\"SUNACTIVITY\")\n\n# Add legend\nplt.legend()\n\n# Display the chart\nplt.show()\n```", "```py\n# Import required library\nimport numpy as np\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\nfrom scipy.fftpack import rfft\nfrom scipy.fftpack import fftshift\n\n# Read the dataset\ndata = sm.datasets.sunspots.load_pandas().data\n\n# Create Sine wave\nt = np.linspace(-2 * np.pi, 2 * np.pi, len(data.SUNACTIVITY.values))\nmid = np.ptp(data.SUNACTIVITY.values)/2\nsine = mid + mid * np.sin(np.sin(t))\n```", "```py\n# Compute FFT for Sine wave\nsine_fft = np.abs(fftshift(rfft(sine)))\nprint(\"Index of max sine FFT\", np.argsort(sine_fft)[-5:])\n\n# Compute FFT for sunspots dataset\ntransformed = np.abs(fftshift(rfft(data.SUNACTIVITY.values)))\nprint(\"Indices of max sunspots FFT\", np.argsort(transformed)[-5:])\n```", "```py\n# Create subplots\nfig, axs = plt.subplots(3,figsize=(12,6),sharex=True)\nfig.suptitle('Power Specturm')\naxs[0].plot(data.SUNACTIVITY.values, label=\"Sunspots\")\naxs[0].plot(sine, lw=2, label=\"Sine\")\naxs[0].legend() # Set legends\naxs[1].plot(transformed, label=\"Transformed Sunspots\")\naxs[1].legend() # Set legends\naxs[2].plot(sine_fft, lw=2, label=\"Transformed Sine\")\naxs[2].legend() # Set legends\n\n# Display the chart\nplt.show()\n```", "```py\nplt.plot(transformed ** 2, label=\"Power Spectrum\")\n```", "```py\nplt.plot(np.angle(transformed), label=\"Phase Spectrum\")\n```", "```py\n# Import required library\nimport numpy as np\nimport statsmodels.api as sm\nfrom scipy.fftpack import rfft\nfrom scipy.fftpack import fftshift\nimport matplotlib.pyplot as plt\n\n# Read the dataset\ndata = sm.datasets.sunspots.load_pandas().data\n```", "```py\n# Compute FFT\ntransformed = fftshift(rfft(data.SUNACTIVITY.values))\n\n# Compute Power Spectrum\npower=transformed ** 2\n\n# Compute Phase\nphase=np.angle(transformed)\n```", "```py\n# Create subplots\nfig, axs = plt.subplots(3,figsize=(12,6),sharex=True)\nfig.suptitle('Power Specturm')\naxs[0].plot(data.SUNACTIVITY.values, label=\"Sunspots\")\naxs[0].legend() # Set legends\naxs[1].plot(power, label=\"Power Spectrum\")\naxs[1].legend() # Set legends\naxs[2].plot(phase, label=\"Phase Spectrum\")\naxs[2].legend() # Set legends\n\n# Display the chart\nplt.show()\n```"]