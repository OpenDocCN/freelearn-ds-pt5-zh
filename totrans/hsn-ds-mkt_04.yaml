- en: Key Performance Indicators and Visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run marketing campaigns or any other marketing efforts, you would most
    likely want to know how well each of them performs and understand the weaknesses
    and strengths of each of your marketing efforts. In this chapter, we are going
    to discuss commonly used **key performance indicators** (**KPIs**) that help you
    track the performances of your marketing efforts. More specifically, we will cover
    such KPIs as sales revenue, **cost per acquisition** (**CPA**), digital marketing
    KPIs, and site traffic. We will learn how these KPIs can help you stay on track
    toward your marketing goals.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing some of the commonly used KPIs, we will then learn how we can
    use Python and/or R to compute such KPIs and build visualizations of those KPIs.
    In this chapter, we will use a bank marketing dataset that showcases a real-world
    case of marketing campaigns for finance organizations. For the Python project,
    we will learn how we can use the `pandas` and `matplotlib` libraries to analyze
    data and build visualizations. For the R project, we will introduce the `dplyr`
    and `ggplot2` libraries to analyze and manipulate data and build visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: KPIs to measure performances of different marketing efforts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing and visualizing KPIs using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing and visualizing KPIs using R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KPIs to measure performances of different marketing efforts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every marketing effort costs money to the company. When you run marketing campaigns
    through emails, sending each email costs some money. When you are running marketing
    efforts on social network services or broadcast media, it also requires some capital.
    As every marketing effort is associated with some costs, it is critical to look
    at the performances of marketing campaigns and track the **return on investments**
    (**ROI**) of your marketing campaigns. We will mainly discuss how to track sales
    revenue, CPA, and digital marketing KPIs in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Sales revenue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is clear that the goal of every marketing effort is to generate and grow
    more revenue for the company. No company wants to spend more money on marketing
    than it generates. In order to correctly report the sales revenue, you will need
    to clearly define how you want to attribute sales to each of your marketing efforts.
    Some sales might come from email marketing campaigns, while some others might
    come from advertisements placed on TV or public transportation. Some sales could
    even come naturally, without any attributions to any of your marketing campaigns.
  prefs: []
  type: TYPE_NORMAL
- en: In order to correctly report how much sales revenue each of your marketing efforts
    drives, you will have to clearly define the rules to attribute your sales to each
    of your marketing efforts. For example, if you are an ecommerce company and promoting
    special offers through email and TV marketing campaigns, you might want to put
    a different URL in the emails than the URL in your TV commercials. This way, you
    can identify and differentiate those sales from email marketing campaigns from
    those sales from marketing efforts through TV.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your needs, you might also want to report time-series sales revenue
    data. You can report it in a spreadsheet format, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b625535c-0106-4f31-929a-f002fefc79eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also report time-series sales revenue data in a line chart, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/747bf180-1b19-4247-8601-dbcf45c6d315.png)'
  prefs: []
  type: TYPE_IMG
- en: We will discuss more about the different types of plots and data visualizations
    you can use for reporting KPIs when we work through the Python and R exercises
    toward the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cost per acquisition (CPA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to look at the effectiveness of your marketing efforts is CPA. This
    KPI metric tells you how much it costs you to acquire a customer through your
    marketing efforts. A high CPA means it costs more to acquire a new customer, while
    a low CPA clearly means it costs less to acquire a new customer. Depending on
    the type of business, you can still have a very profitable marketing campaign
    with high CPA. For example, if you are selling a very luxurious and high-end product,
    where the pool of targeted customers is small and it costs more to acquire such
    customers, your CPA might be high, but the value of each customer you acquired
    might be even higher and result in a profitable marketing campaign.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at the following hypothetical case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5badd7a-3ac4-4829-9ea4-eddf96d26b2a.png)'
  prefs: []
  type: TYPE_IMG
- en: If you look at this spreadsheet, **Happy Hour Event** was the most expensive
    marketing event, in terms of both the total cost and CPA. However, it generated
    the most **Sales** and **Sales per Customer**; thus, it was the most valuable
    campaign. On the other hand, **Radio Commercial** was the lowest CPA marketing
    campaign, even though the total cost is the second highest, because it helped
    the business to acquire the most number of customers. However, the total sales
    from these customers did not exceed the total cost of this campaign and introduced
    a net loss to the company.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this is a hypothetical situation, a similar case can happen in real
    life. Marketing efforts, such as **Happy Hour Event** and **Webinar** have better-targeted
    customers than **Radio Commercial**. The quality of customers acquired through
    highly-targeted marketing campaigns is many times better compared to non-targeted
    marketing campaigns.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how we can break down the marketing campaign results to
    analyze the cost-effectiveness in more depth, we will look at some of the commonly
    used KPIs for digital marketing.
  prefs: []
  type: TYPE_NORMAL
- en: Digital marketing KPIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the choices of marketing channels grow into online space, such as on social
    network services, blogs, and search engines, reporting the performances of digital
    marketing efforts has become more and more important. Previously discussed KPIs,
    sales revenue, and cost per acquisition, apply in the digital marketing space
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, based on individual attribution logic, you can analyze how much
    sales are generated through different social network services, such as Facebook,
    LinkedIn, and Instagram. You can also analyze how many customers are acquired
    through such marketing channels and see what individual digital marketing campaigns''
    CPAs and generated values are. Let''s discuss some more digital marketing KPIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Click-through rate** (**CTR**) is another KPI that is commonly looked at
    for digital marketing efforts. CTR is the percentage of people who viewed your
    advertisement and then went on to click the advertisement. The formula looks as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3475a6d1-f101-400a-b723-31b7ac1aed70.png)'
  prefs: []
  type: TYPE_IMG
- en: CTR is an important measure in digital marketing channels, as it measures how
    effective your online marketing is in bringing traffic to your website.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can use **lead ratio** to measure how much of the website traffic
    can be converted into leads. Typically, only a subset of website traffic is a
    good fit to become your customers. These **marketing qualified leads** (**MQL**)
    are the leads that are ready to be marketed to and meet business-specific criteria
    to become customers who are likely to make purchases, based on their characteristics.
    As you start marketing to these qualified leads, you should also look at conversion
    rates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The** conversion rate** is the percentage of leads that are converted into
    active customers. You can define what should be considered as conversions, based
    on your marketing goals. If your goal is to see what percentage of leads became
    paying customers, then you can compute the conversion rate somewhat similar to
    the following formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8f945f3a-851b-460b-9b69-ab2086f7b8b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If your goal is to see what percentage of leads signed up on your website,
    then you can compute the conversion rate as in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/257bbf18-22d1-4498-9855-90865d946ee9.png)'
  prefs: []
  type: TYPE_IMG
- en: We have looked at various KPIs so far and discussed how these KPIs can help
    you track the progress and performances of your marketing efforts. We will now
    look at how to use Python and/or R to compute such KPIs and build visualizations.
    If you plan on using one of the two programming languages, Python and R, used
    in this book, you can skip to the section that you'd like to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Computing and visualizing KPIs using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss how we can use Python to compute and
    visualize the KPIs we have discussed in the previous sections. We will primarily
    focus on analyzing conversion rates using bank marketing data. For those readers
    who would like to use R for this exercise, you can skip to the next section. We
    will be using the `pandas` and `matplotlib` libraries in Python to manipulate
    and analyze data and build various charts to accurately report the progress and
    performances of marketing efforts.
  prefs: []
  type: TYPE_NORMAL
- en: For the exercise in this section, we are going to use the *UCI's Bank Marketing
    Data Set*, which can be found at this link:[ https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing).
    You can follow this link and download the data by clicking the `Data Folder` link
    in the top-left corner. For this exercise, we downloaded the `bank-additional.zip`
    data and we will use the `bank-additional-full.csv` file in that zipped file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open this `bank-additional-full.csv` file, you will notice that a
    semi-colon (`;`) is used as a separator, instead of a comma (`,`). In order to
    load this data, you can use the following code to read in this data into a `pandas`
    `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are importing the `pandas` library with the
    alias, `pd`, and we are using the `read_csv` function to load the data. For separators
    other than commas, you can define a custom separator with the `sep` argument within
    the `read_csv` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the field description in the data download page ([https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)),
    the output variable, `y`, which has information on whether a client has subscribed
    to a term deposit, is encoded as `''yes''` or `''no''`. In order to simplify our
    conversion rate computations, we will encode this variable as `1` for `''yes''`
    and `0` for `''no''`. You can use the following code for this encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code snippet, we are using the `apply` function to
    encode `''yes''` as `1` and `''no''` as `0` for the variable, `y`, and then adding
    this encoded data as a new column, `conversion`. The code and the loaded data
    in our Jupyter Notebook will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b122168c-72eb-431e-91af-644d51aad7e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have successfully read the data into a `pandas` `DataFrame`, we
    will start looking at how to analyze and visualize conversion rates, using various
    methods and plots.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate conversion rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we are going to look at the aggregate conversion rate. We can calculate
    this metric by dividing the total number of clients subscribed to a term deposit
    by the total number of clients in the data. Since we have already encoded the
    output variable as `1` for those who have converted and `0` for those who have
    not, in a column named `conversion`, we can simply sum over this column to get
    the total number of conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can sum over the `conversion` column
    and get the total number of clients in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what our code for conversion rate calculations in the Jupyter
    Notebook look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b8cd4a4-f2ef-42d8-b18c-a3596a1d6930.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from this code output in the Jupyter Notebook, we have `4640`
    converted clients out of a total of `41188` bank clients, which suggests the aggregate
    conversion rate is `11.27%`. In the following section, we are going to analyze
    how these conversion rates vary by different age groups.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion rates by age
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregate conversion rate tells us the overall performance of our marketing
    campaign. However, it does not give us that much insight. When we are reporting
    and tracking the progress of marketing efforts, we typically would want to dive
    deeper into the data and break down the customer base into multiple segments and
    compute KPIs for individual segments. We will first break our data into smaller
    segments by `age` and see how the conversion rates differ by different age groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the `groupby` function to calculate
    conversion rates by each age.
  prefs: []
  type: TYPE_NORMAL
- en: We first group by a variable name, `age`, and sum over the `conversion` column,
    using the `sum` function, to get the total number of conversions by each age.
    Then, we group by `age` again and count the number of records in each `age` group
    by using the `count` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these two computations, we can calculate the conversion rates for each
    `age`, as shown in the code. A part of the calculated conversion rates for each
    `age` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3101f3f1-1c3d-4036-bb46-3c3719a4122a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to look at conversion rates across client ages is by plotting a
    line chart, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd275a9a-750e-40d7-a624-3e0b95d3a0dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to visualize conversion rates across different ages looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As this code shows, we are using the `conversions_by_age` variable that we built
    previously and the `plot` function for a line chart. As you can see from this
    code, you can change the size of a figure by an argument, named `figsize`, and
    the title of the chart with an argument, named `title`. In order to change the
    labels of the *x*-axis and *y*-axis, you can use the `set_xlabel` and `set_ylabel`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is noticeable in the previous line chart is the fact that there
    seems to be lots of noise in old age groups. Conversion rates for those who are
    `70` or older vary a lot and if you look at the data, this is mostly because the
    number of clients in this age group is relatively small, compared to other age
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reduce this unwanted noise, we can group multiple ages together.
    In this exercise, we group bank clients into six different groups, based on their
    age—between `18` and `30`, between `30` and `40`, between `40` and `50`, between
    `50` and `60`, between `60` and `70`, and `70` and older. The following code can
    be used to group the clients into their corresponding groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at this code, we are using the `apply` function on the column,
    `age`, to group clients into six different age groups and add this data to a new
    column, named `age_group`. In order to calculate the conversion rates for these
    newly created age groups, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous case, we are using the `groupby`, `sum`, and `count`
    functions to calculate conversion rates for these six different age groups. The
    resulting data looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c87019e0-eeb8-4d7b-ae77-3e2cf41f8573.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this, the variations by each age group are much smaller
    than before, especially in old age groups. We can visualize this data using a
    bar plot, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6400ebaa-c9a5-430f-9512-3e4c1f509fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to build this bar plot looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the same `plot` function that we
    used before to build a line plot. The only difference is the `kind` argument,
    with which we can define different types of plots we would like to build. Here,
    we are giving a value of `bar` to this `kind` argument to build a bar plot.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full code in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/python/ConversionRate.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/python/ConversionRate.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Conversions versus non-conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One other thing we can look at is the demographic differences between the converted
    clients and non-converted clients. This type of analysis can help us identify
    what differentiates converted groups from non-converted groups in our marketing
    campaigns and help us understand our target clients better and what types of customers
    respond better to our marketing efforts. In this exercise, we will compare the
    distributions of the marital status among the conversions and non-conversions
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first count the number of conversions and non-conversions for each
    marital status. The following code shows how we can compute this using `pandas`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are using the `pivot_table` function in the `pandas`
    library. We are grouping by the columns, `marital` and `conversion`, where `marital`
    will become the index and `conversion` will become the column of the new `DataFrame`.
    With the `aggfunc` argument, we can supply the type of aggregation we want to
    perform. Here, we are using the `len` function to simply count the number of clients
    for each group. The resulting data looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a85b170-769b-4e0b-af04-85822cbe4e16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to represent this data is by using pie charts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b8ac645-7b7f-403a-8b37-8d4132cfe650.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code shows how we can build these pie charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the same `plot` function as before,
    but using `pie` as the kind of plot that we would like to build. You can use the `autopct`
    argument to format the label for each group in the pie charts.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the tabular format of the data output, pie charts make it much easier
    to understand the overall distributions of the data. With pie charts, we can easily
    see that the `married` group takes up the largest proportions in both conversions
    and non-conversions groups, while the `single` group comes as the second. Using
    pie charts, we can easily visualize the similarities and differences between two
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions by age and marital status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have aggregated our data by one criterion. However, there are cases
    where you want to group the data by more than one column. In this section, we
    will discuss how we can analyze and report conversion rates by more than one criterion.
    As an exercise, we will use age groups that we have built in the previous section
    and the marital status as the two columns to group by.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, we are grouping our data by the two columns,
    `age_group` and `marital`, and summing the number of conversions. Then, we divide
    this by the total number of clients in each group. The resulting data looks like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a834d935-1164-4371-abb1-533264c4e68b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this data, we can now see the distribution of conversion
    rates based on two criteria, age group and martial status. For example, the conversion
    rate of clients who are single and between **18** and **30** years old is 13.25%,
    while the conversion rate of clients who are married and between **60** and **70**
    years old is 30.11%. Another way to visualize this data is to use a bar plot that
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7a55ab6-0b06-46af-a335-3b8770e229a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this bar chart, we can easily see the distributions of conversion rates
    for each of the age and marital status groups. The code we used to build this
    bar plot looks is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Similar to previous cases, we are using the `plot` function of the `pandas`
    library and passing `bar` to the `kind` argument of the function. Since the `DataFrame`,
    `age_marital_df`, has four columns for each of the marital statuses and is indexed
    by age groups, the `plot` function builds a bar plot with four bars for each of
    the marital statuses for each of the age groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to stack those four bars for each age group, then you can
    use the following code for a stacked bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, the only difference is the argument, `stacked`,
    that we used in this code. When this argument is set to `True`, it will build
    a stacked bar plot, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2634f436-965d-41af-bfd5-d27600fcc768.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from this stacked bar plot, different marital statuses are stacked
    on top of each other for each of the age groups. This way, we can not only easily
    see the overall trends in conversion rates across different age groups, but also
    the proportions of converted clients with different marital statuses for each
    age group.
  prefs: []
  type: TYPE_NORMAL
- en: The full code and Jupyter Notebook that we used for this Python exercise can
    be found in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/python/ConversionRate.ipynb](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/python/ConversionRate.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Computing and visualizing KPIs using R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss how we can use R to compute and visualize
    the KPIs we have discussed in the previous sections. We will primarily focus on
    analyzing conversion rates using bank marketing data. For those readers, who would
    like to use Python for this exercise, you can find the Python exercise in the
    previous section. We will be using the `dplyr` and `ggplot2` libraries in R to
    manipulate and analyze data and build various charts to accurately report the
    progress and performances of marketing efforts. The `dplyr` library provides various
    functionalities for data manipulation for data science and machine learning tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For the exercise in this section, we are going to use the **UCI**'s **Bank Marketing
    Data Set**, which can be found at this link: [https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing).
    You can follow this link and download the data by clicking the `Data Folder` link
    in the top-left corner. For this exercise, we downloaded the `bank-additional.zip` data
    and we will use the `bank-additional-full.csv` file in that zipped file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open this `bank-additional-full.csv` file, you will notice that a
    semi-colon (`;`) is used as a separator, instead of a comma (`,`). In order to
    load this data, you can use the following code to read in this data into a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the `read.csv` function to load
    the data. For separators other than commas, you can define a custom separator
    with the `sep` argument within the `read.csv` function. If your data file contains
    a row for the header, you can set the argument, `header`, to `TRUE`. On the other
    hand, if your data file does not contain a row for the header and the data starts
    from the first row, you can set it to `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the field description in the data download page ([https://archive.ics.uci.edu/ml/datasets/bank+marketing](https://archive.ics.uci.edu/ml/datasets/bank+marketing)),
    the output variable, `y`, which has information on whether a client has subscribed
    to a term deposit, is encoded as `''yes''` or `''no''`. In order to simplify our
    conversion rate computations, we will encode this variable as `1` for `''yes''`
    and `0` for `''no''`. You can use the following code for this encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code snippet, we are using the `as.integer` function
    to encode `''yes''` as `1` and `''no''` as `0` for the variable, `y`, and then
    adding this encoded data as a new column, `conversion`. Since the `as.integer`
    function will use `1` and `2` for `''no''` and `''yes''` encodings by default,
    we are subtracting the values by `1`. The data now looks like the following in
    our RStudio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9e71c7f-eaba-4b63-8567-0aecc6b1a58b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have successfully read the data into an `R` `DataFrame`, we will
    start looking at how to analyze and visualize conversion rates, using various
    methods and plots.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate conversion rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we are going to look at is the aggregate conversion rate. We can calculate
    this metric by dividing the total number of clients subscribed to a term deposit
    by the total number of clients in the data. Since we have already encoded the
    output variable as 1 for those who have converted and 0 for those who have not
    in a column, named `conversion`, we can simply sum over this column to get the
    total number of conversions. The following code snippet shows how we can sum over
    the `conversion` column and get the total number of clients in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code snippet, we are using the `sum` function in R
    to calculate the total number of conversions and the `nrow` function to count
    the number of rows in our dataset. On a side note, as with `nrow`, you can use
    the `ncol` function to count the number of columns of a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the code looks like on our RStudio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b064e7d-c589-41fa-9129-bac465e2a0d6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from this code output in the RStudio, we have `4640` converted
    clients out of a total of `41188` bank clients, which suggests the aggregate conversion
    rate is `11.27%`. In the following section, we are going to analyze how these
    conversion rates vary by different age groups. We are using the `sprintf` function
    to format a string with integers and floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion rates by age
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregate conversion rate tells us the overall performance of our marketing
    campaign. However, it does not give us that much insight. When we are reporting
    and tracking the progress of marketing efforts, we typically would want to dive
    deeper into the data and break down the customer base into multiple segments and
    compute KPIs for individual segments. We will first break our data into smaller
    segments by age and see how the conversion rates differ by different age groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The pipe operator, `%>%`, in this code, is the way you can apply different functions
    sequentially. In this code snippet, we are passing `conversionDF` to a `group_by`
    function, then passing the results of this `group_by` function to the `summarise`
    function, and lastly to the `mutate` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `group_by` function, we are grouping the `DataFrame` by the column `age`.
    Then, for each age group, we are counting the number of records in each group,
    by using a function, `n()`, and naming it `TotalCount`. Also, we are summing over
    the column, `conversion`, for each age group, by using the `sum` function, and
    naming it `NumConversions`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we are using the `mutate` function, which adds new variables, while
    preserving the original `DataFrame`, to compute conversion rates for each age
    group. As you can see, we are simply dividing `NumConversion` by `TotalCount`
    and multiplying it by `100.0` to get the conversion rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting data is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebdf5a19-e660-43bb-8d27-d35b2e8e86da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to look at conversion rates across client ages is by plotting a
    line chart, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b44831d7-3be8-48fe-b526-910b16b7ee62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to visualize conversion rates across different ages is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the `ggplot` function to initialize
    a `ggplot` object with `conversionsByAge` as the data and the column, `Age`, as
    the *x*-axis and the column, `ConversionRate`, as the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use `geom_line` function to connect the observations and create a line
    chart. You can change the title of a plot, by using `ggtitle` function. Also,
    you can use `xlab` and `ylab` functions to rename the x-axis label and y-axis
    label respectively.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is noticeable in the previous line chart is the fact that there
    seems to be lots of noise in older age groups. Conversion rates for those who
    are 70 or older vary a lot and if you look at the data, this is mostly because
    the number of clients in this age group is relatively small, compared to other
    age groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reduce this unwanted noise, we can group multiple ages together.
    In this exercise, we group bank clients into six different groups, based on their
    age—between `18` and `30`, between `30` and `40`, between `40` and `50`, between
    `50` and `60`, between `60` and `70`, and `70` and older. The following code can
    be used to group the clients into their corresponding groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous case, we are using the `group_by` function to group the `conversionsDF`
    data by the `age` column. The difference here is how we used the `cut` function
    to create the age range for each age group.
  prefs: []
  type: TYPE_NORMAL
- en: The `breaks` argument defines the points at which the `cut` function is going
    to divide the `DataFrame`. The argument, `seq(20, 70, by = 10)`, means we are
    going to create a sequence from `20` to `70` in increments of `10`. Once the data
    is grouped by these age groups, the rest are the same as before. We are using
    the `summarise` and `mutate` functions to compute for the `TotalCount`, `NumConversions`,
    and `ConversionRate` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting `DataFrame` is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4e8d9d-88b5-47ef-ad3e-995d207e832e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from this, the variations by each age group are much smaller
    than before, especially in old age groups. We can visualize this data using a
    bar plot, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2de62aed-8ebd-4451-9130-c038d4fc8794.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to build this bar plot is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are passing the `conversionsByAgeGroup` data
    to the `ggplot` object with the `AgeGroup` column as the *x*-axis and the `ConversionRate`
    column as the *y*-axis. We are using the `geom_bar` function to build a bar plot.
  prefs: []
  type: TYPE_NORMAL
- en: The `width` argument defines the width of each bar in the bar plot. Similar
    to the previous line chart, you can use `ggtitle` to rename the title of the plot
    and the `xlab` and `ylab` functions to rename the labels of the *x*-axis and *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full code in the following repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/R/ConversionRate.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/R/ConversionRate.R).
  prefs: []
  type: TYPE_NORMAL
- en: Conversions versus non-conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One other thing we can look at is the demographic differences between the converted
    clients and non-converted clients. This type of analysis can help us identify
    what differentiates converted groups from non-converted groups in our marketing
    campaigns and helps us understand our target clients better and what types of
    customers respond better to our marketing efforts. In this exercise, we will compare
    the distributions of the marital status among the conversions and non-conversions
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first count the number of conversions and non-conversions for each
    marital status. The following code shows how we can compute this using `R` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, we are using the pipe operator, `%>%`, in the `dplyr`
    package to pass the `DataFrame`, `conversionsDF` to the `group_by` function and
    then to the `summarise` function. In the `group_by` function, we are grouping
    by two columns, `marital` and `conversion`. In the `summarise` function, we are
    simply counting the number of records in each group, by using the `n` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting data is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75f9ff53-7e1f-4509-b02c-e51634534181.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to represent this data is by using pie charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ecad4e9-16f5-49c0-9297-a45a28411cdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code shows how we can build these pie charts in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For building a pie chart in R, we are using the same `geom_bar` function, just
    as if we are building a bar chart. The difference here is `coord_polar("y")`,
    which transforms a bar chart into a pie chart. Then, we are using the `facet_wrap`
    function to create two columns of pie charts by the column, `Conversion`. This
    builds two pie charts, one for the conversions group and another for the non-conversions
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the tabular format of the data output, pie charts make it much easier
    to understand the overall distributions of the data. With pie charts, we can easily
    see that the `married` group takes up the largest proportions in both conversions
    and non-conversions groups, while the `single` group comes second. Using pie charts,
    we can easily visualize the similarities and differences between two groups.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions by age and marital status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have aggregated our data by one criterion. However, there are cases
    where you want to group the data by more than one column. In this section, we
    will discuss how we can analyze and report conversion rates by more than one criterion.
    As an exercise, we will use the age groups that we have built in the previous
    section and the marital status as the two columns to group by.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Similar to when we built custom age groups, we are using the `cut` function
    in `group_by` to create age groups from `20` to `70` in increments of `10`. However,
    we are grouping by the column, `marital`, as well this time.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are using the `summarise` function to compute the number of records
    in each group `Count`, and the number of conversions in each group, `NumConversions`.
    Then, using the `mutate` function, we calculate the total counts in each age group,
    named `TotalCount`, and the conversion rates in each group, named `ConversionRate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting data is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94774145-f1a9-4d75-8967-a246e7766c99.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from this data, we can now see the distribution of conversion
    rates based on two criteria, age group and martial status. For example, the conversion
    rate of clients who are single and between **20** and **30** years old is 11.10%,
    while the conversion rate of clients who are married and between **40** and **50**
    years old is 5.74%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to visualize this data is to use a bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/617745e6-5fcc-44dc-a6b9-5b8cac7eed42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this bar chart, we can easily see the distributions of conversion rates
    for each of the age and marital status groups. The code we used to build this
    bar plot is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a `ggplot` object with the `conversionsByAgeMarital` data.
    We are using `AgeGroup` for the *x*-axis and `ConversionRate` for the *y*-axis,
    while we are using `Marital` column to use different colors for different types
    of marital status. Then, we are building a bar plot by using the `geom_bar` function.
    With this configuration, `ggplot` builds a bar plot of conversion rates against
    age groups with breakdowns by marital status, which we saw in the previous bar
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to stack those four bars for each age group, then you can
    use the following code for a stacked bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, the only difference is the code, `position="stack"`,
    in the `geom_bar` function. If you pass the value, `"dodge"`, to this `position`
    argument of the `geom_bar` function, it will create an unstacked bar plot. Whereas,
    if you pass the value, `"stack"`, to this `position` argument of the `geom_bar`
    function, it will build a stacked bar plot, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c6297ad-bd1e-4726-87f2-44ddd21d5fcf.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from this stacked bar plot, different marital statuses are stacked
    on top of each other for each of the age groups. This way, we can not only easily
    see the overall trends in conversion rates across different age groups, but also
    the proportions of converted clients with different marital statuses for each
    age group.
  prefs: []
  type: TYPE_NORMAL
- en: The full code that we used for this R exercise can be found in the following
    repository: [https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/R/ConversionRate.R](https://github.com/yoonhwang/hands-on-data-science-for-marketing/blob/master/ch.2/R/ConversionRate.R).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to use descriptive analysis for reporting
    and analytics on the progress and performances of marketing efforts. We have discussed
    various KPIs that are often used in marketing to track the progress of marketing
    campaigns. We have learned how important it is to look at how much sales revenue
    each marketing strategy generates. When analyzing the sales revenue metrics, we
    have seen that it is important to approach it from different angles. You might
    want to look at not only the aggregate sales revenue, but also time-series (monthly,
    quarterly, or yearly) sales revenue. You might also want to look at sales attributed
    to each individual marketing campaigns and how much revenue each campaign generated
    for your company. We have also discussed CPAmetrics, with which you can tell the
    cost-effectiveness of your marketing strategies. We have learned various metrics
    to analyze for digital marketing channels as well, such as CTR, lead ratio, and
    conversion rates. As we have seen and experimented in the Python and R exercises,
    we can go multiple levels deeper into these KPI metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how we can apply data science and
    machine learning techniques for explanatory analysis. More specifically, we will
    discuss how we can use regression analysis and models to understand the drivers
    behind marketing engagement. We will also cover how we can interpret the regression
    analysis results in the following chapter.
  prefs: []
  type: TYPE_NORMAL
