- en: Chapter 5. The Dance with Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything from creating simple binary trees to practical applications such
    as Huffman encoding is covered in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a binary tree data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a rose tree (multiway tree) data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing a tree depth-first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing a tree breadth-first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Foldable instance for a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the height of a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a binary search tree data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the order property of a binary search tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a self-balancing tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a min-heap data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding a string using a Huffman tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding a Huffman code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Introduction](img/ch05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Trees are a common data structure used in a variety of data analysis techniques.
    A **tree** is a hierarchical connection of nodes under one all-encompassing mighty
    root node. Every node can have zero or more children, but each child node associates
    with only one parent. Also, the root is the only special case that has no parent
    node. All nodes without children are also referred to as **leaf** nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, we can very gracefully represent a tree since the recursive nature
    of the data structure makes use of the recursive nature of functional programming.
    This section will cover creating our own trees as well as using existing implementations
    from libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement heaps and Huffman trees, which are some of the most notable
    examples of trees in data analysis. In other chapters throughout the book, we
    also run into HTML/XML traversal, hierarchical clustering, and decision trees,
    which all depend heavily on the tree data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a binary tree data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a binary tree, each node has at most two children. We will define a data
    structure to encompass the left and right subtrees of each node.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in the recipe will represent the following tree. The root node is labeled
    **n3** with a value of **3**. It has a left node **n1** of value **1**, and a
    right node **n2** of value **2**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code requires no imports. We can jump in and define the data structure
    recursively. A tree can either be a node with values or null/empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, create the tree shown in the preceding diagram and print it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full tree is printed out as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the nodes in a tree need more than two children, then see the next section,
    *Defining a rose tree (multiway tree) data type*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a rose tree (multiway tree) data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rose tree relaxes the limitation of at most two children per node. It can
    have an arbitrary number of elements. Rose trees are common when parsing HTML
    to represent the **Document Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be representing the following tree in this recipe. The root node has
    three children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not need any imports for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rose tree data type is similar to that of the binary tree, except that
    instead of left and right children, it will store an arbitrary list of children:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct the tree from the preceding diagram and print it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The printed output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using dedicated left and right fields to represent child nodes, a
    rose tree uses a list data structure to represent an arbitrary number of children.
    A rose tree can be used to emulate a binary tree if each node is restricted to
    have at most two children.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To represent a binary tree, it may be simpler to use the previous recipe, *Defining
    a binary tree data type*.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a tree depth-first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate one way to traverse through a tree. The algorithm
    starts at the root node and continues exploring nodes along the entire length
    of a branch before going back to explore more shallow nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will examine each node before recursively examining its child nodes,
    we call this a **pre-order traversal**. Instead, if we examine each node afterwards,
    then we call this approach **post-order traversal**. Anything in-between is an
    **in-order traversal**, but naturally, there is no unique in-order traversal for
    rose trees.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage in using the depth-first approach is the minimal space
    complexity. Video game AIs often use depth-first approaches in determining the
    ideal move to take against an opponent. However, in enormous or infinite trees,
    a depth-first search may never terminate if we keep visiting subsequent child
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will traverse the following tree in a depth-first fashion. Starting at node
    **r**, we first explore node **n1**, followed by **n2**, then go back up to find
    **n3**, and backtrack all the way to finally end at **n4**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use an existing rose tree implementation from `Data.Tree`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function will traverse a tree depth-first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a depth-first implementation of adding all the values in a tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a tree to represent the preceding diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the depth-first functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the following two lines of output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use the built-in rose tree data structure from `Data.Tree`.
    Similar to our implementation in the previous recipe, it has the `Tree` data type
    having the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We recursively run the `depthFirst` algorithm on every child node and append
    it to the node's value, thereby creating a list that represents the tree traversal.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If traversing a tree by the tree level is preferred, then take a look at the
    next section, *Traversing a tree breadth-first*.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a tree breadth-first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a breadth-first search approach to traversing a tree, nodes are visited in
    the order of the depth of the tree. The root is visited, then its children, then
    each of their children, and so on and so forth. This process requires a greater
    space complexity than the depth-first traversal but comes in handy for optimizing
    search algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine trying to find all relevant topics from a Wikipedia article.
    Traversing all the links within the article in a breadth-first fashion will help
    ensure the topics start out with relevance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examine the tree in the following diagram. A breadth-first traversal will start
    at the root node **r**, then continue to the next level, encountering **n1** and
    **n4**, finally followed by **n2** and **n3**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using an existing implementation of a rose tree from `Data.Tree`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the breadth-first traversal of a tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For demonstration, implement a function to add the values of each node in a
    tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a tree based on the preceding diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the breadth-first algorithms in `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The printed output is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use the built-in rose tree data structure from `Data.Tree`.
    Similar to our implementation in one of the previous recipes, it has the `Tree`
    data type with the following constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We perform the breadth-first search by creating a list that begins with the
    values of the node's direct children. Then, the values of the children's children
    are appended, and so on until the tree is fully traversed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If space complexity becomes an issue, then the previous recipe, *Traversing
    a tree depth-first*, might offer a better approach.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Foldable instance for a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of traversing a tree can be generalized by implementing a `Foldable`
    instance. Usually, folds are used on lists; for example, `foldr1 (+) [1..10]`
    traverses a list of numbers to produce a grand sum. Similarly, we can apply `foldr1
    (+) tree` to find the sum of all nodes in a tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be folding through the following tree to obtain a sum of all node values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following built-in packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tree from `Data.Tree` already implements `Foldable`, so we will define
    our own tree data type for demonstration purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `foldMap` function for the `Foldable` instance. This implementation
    will give us a post-order traversal of the tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to fold through a tree to find the sum of all nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct a tree that represents the one in the preceding diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the folding by running the `add` function on a tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result gets printed out as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function that is necessary to define a `Foldable` instance is either `foldMap`
    or `foldr`. In this recipe, we define the `foldMap :: (Foldable t, Data.Monoid.Monoid
    m) => (a -> m) -> t a -> m` function that essentially maps a function `f` over
    every node in a tree, and glues it together using `mappend` from `Data.Monoid`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other ways to traverse through elements of a tree are discussed in the previous
    two sections, *Traversing a tree depth-first* and *Traversing a tree breadth-first*.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the height of a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The height of a tree is the length of the longest downward path from the root
    node. For example, the height of a balanced binary tree should be around log to
    the base 2 of the number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As long as we're consistent, the height of a tree can be defined as either the
    number of nodes or the number of edges in the longest path. In this recipe, we
    will count by using the number of nodes. The longest path of this tree contains
    three nodes and two edges. Therefore, this tree has a height of three units.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `maximum function` from `Data.List` and the built-in tree data structure
    from `Data.Tree`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to calculate the height of a tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct a tree on which we will run our algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the function in `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The height of the tree will be printed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `height` function recursively finds the maximum height among its child trees
    and returns one plus that value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a binary search tree data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary search tree restricts an order property on a binary tree. This order
    property requires that among every node, the nodes in the left subtree must not
    be greater, and that the nodes in the right subtree must not be less than the
    current node.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a binary `BSTree` module to expose our binary search tree data structure.
    Insert the following code in a file called `BSTree.hs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the data structure for a binary tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a convenience function to create a one-node tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a function to insert new values in the binary search tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a function to find a node with a specific value in a binary search
    tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, test out the `BSTree` module by creating a new file that can be called
    `Main.hs` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, construct a binary search tree by calling the `insert` function
    on various values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the tree and test out the `find` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core functions of a binary search tree data structure are `insert` and `find`,
    and are used for inserting and finding elements in a binary search tree respectively.
    Finding a node is accomplished by traversing the tree and taking advantage of
    its order property. If the value is lower than expected, it will check the left
    node; otherwise, if the value is greater, it will check the right node. Eventually,
    this recursive algorithm either finds the desired node or ends up at a leaf node
    and consequently does not find the node.
  prefs: []
  type: TYPE_NORMAL
- en: A binary search tree does not guarantee the tree to be balanced, and therefore,
    a speedy O(log n) lookup is not to be expected. There is always a possibility
    for a binary search tree to end up looking like a list data structure (consider,
    for example, when we insert nodes in the following order [1,2,3,4,5] and examine
    the resulting structure).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a binary tree, the order property can be verified using the following
    recipe titled *Verifying the order property of a binary search tree*. To use a
    balanced binary tree, refer to the recipe, *Using a self-balancing tree*.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the order property of a binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a binary tree, this recipe will cover how to verify if it actually satisfies
    the order property such that all elements in the left subtree are of lesser value,
    and that all values of the right subtree are of greater value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be verifying whether or not the following tree is a binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No imports are necessary for this recipe. Perform the following steps to find
    if the tree is a binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a data structure for a binary tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct a tree based on the preceding diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function to verify whether or not a tree obeys the binary order
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the function in `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clearly, the tree does not obey the order property, and therefore, the output
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `valid` function recursively checks if the left subtree contains elements
    less than the current node and if the right subtree contains elements greater
    than the current node.
  prefs: []
  type: TYPE_NORMAL
- en: Using a self-balancing tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An AVL tree is a balanced binary search tree. The heights of each subtree differ
    by at most one. On each insertion or deletion, the tree shifts around its nodes
    through a series of rotations to become balanced. A balanced tree ensures the
    height is minimized, which guarantees lookups and insertions to be within *O(log
    n)* time. In this recipe, we will use an AVL tree package directly, but self-balancing
    trees also exist within the `Data.Set` and `Data.Map` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using the `AvlTree` package to use `Data.Tree.AVL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant AVL tree packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up an AVL tree from a list of values and read the minimum and maximum values
    from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The minimum and maximum values are printed out as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `asTree :: (e -> e -> COrdering e) -> [e] -> AVL` e-function takes in an
    ordering property and a list of elements to produce an AVL tree out of the corresponding
    elements. The function `fstCC :: Ord a => a -> a -> COrdering a` comes from `Data.Cordering`
    and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A combining comparison for an instance of ''Ord'' which keeps the first argument
    if they are deemed equal. The second argument is discarded in this case.*'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of Haskell''s `Data.Set` and `Data.Map` functions efficiently
    uses balanced binary trees. We can rewrite the recipe by simply using `Data.Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a min-heap data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap is a binary tree with both a shape property and a heap property. The
    shape property enforces the tree to behave in a balanced way by defining each
    node to have two children unless the node is in the very last level. The heap
    property ensures that each node is less than or equal to either of its child nodes
    if it is a min-heap, and vice versa in case of a max-heap.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps are used for constant time lookups for maximum or minimum elements. We
    will use a heap in the next recipe to implement our own Huffman tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the lens library for easy data manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the `MinHeap` module in a file `MinHeap.hs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use a list to represent a binary tree data structure for demonstration
    purposes only. It is best to implement the heap as an actual binary tree (as we
    have done in the previous sections), or we should use an actual array that will
    give us constant time access to its elements. For simplicity, we will define the
    root node to start at index 1\. Given a node at index `i`, the left child will
    always be located at *2*i*, and the right child at *2*i + 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a convenience function to initiate an empty heap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insertion of a node in a heap is done by appending the node to the end of the
    array and percolating it up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deleting a node from a heap is done by swapping the root node with the last
    element, and then percolating down from the root node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to view the minimum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Percolating down from a node means ensuring the heap property holds for the
    current node; otherwise, swap the node with the greater or lesser (depending on
    the max or min heap) child. This process is recursively applied all the way down
    to the leaf nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `left`, `right`, `i''`, `l`, and `r` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Percolating a node up means to recursively swap a node with its parent until
    the heap property of the tree holds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a convenience function to swap items at two indices in a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view the weights of each node in the array representation of a heap, we
    can define the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in a different file that we can name `Main.hs`, we can test out the
    min-heap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the weights in the array representation of the heap is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in this recipe is for understanding the heap data structure, but it
    is by no means efficient. Better implementations of heaps exist on Hackage, including
    the `Data.Heap` library that we will explore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the heap library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to construct a min-heap from a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to construct a max-heap from a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the heaps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The view functions return a tuple in a `Maybe` data structure. The first element
    of the tuple is the value from performing a lookup, and the second element is
    the new heap with that value removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Encoding a string using a Huffman tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Huffman tree** allows efficient encoding of data by calculating a probability
    distribution of characters to optimize the space taken per character. Imagine
    compressing this book into one piece of paper and back without any information
    loss. Huffman trees allow this type of optimal lossless data compression based
    on statistics.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement a Huffman tree from a source of text and produce
    a string representation of its Huffman codes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the string "hello world" contains 11 characters, which, depending
    on the encoding and architecture, may take up as few as 11 bytes of space to represent.
    The code in this recipe will transform the string into just 51 bits, or 6.375
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure to be connected to the Internet since this recipe will download text
    from [http://norgiv.com/big.txt](http://norgiv.com/big.txt) to analyze probability
    distribution of many characters. We will be using the min-heap that was implemented
    in the previous recipe by importing `MinHeap`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following packages. We will be using our previous `MinHeap` module,
    so be sure to include the code from the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to return an association list of characters to its frequency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The data structure of a Huffman tree is simply a binary tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct a Huffman tree with one value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to construct a Huffman tree from a min-heap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a map of Huffman codes from the Huffman tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to encode a string to text using the Huffman codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the entire process by executing the following in `main`. Downloading
    and calculating the frequency might take a couple of minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The string representation of the Huffman tree is then printed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we obtain a source of data to analyze by downloading the text from [http://norvig.com/big.txt](http://norvig.com/big.txt).
    Next, we obtain the frequency map of each character and throw it in a heap. The
    Huffman tree is constructed from this min-heap by combining the two lowest frequency
    nodes until only one node is left in the min-heap. Finally, the Huffman codes
    are used on a sample "hello world" string to see the encoding.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read an encoded Huffman value, see the next section, *Decoding a Huffman
    code*.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a Huffman code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This code relies heavily on the previous recipe, *Encoding a string using a
    Huffman tree*. The same Huffman tree data structure is used next to decode a string
    representation of a Huffman coding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the previous recipe, *Encoding a string using a Huffman tree*. The same
    `HTree` data structure is used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We traverse down the tree until we hit a leaf node. Then, we prepend the character
    found and restart from the root node. This process continues until no input is
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To encode data using a Huffman tree, see the previous recipe, *Encoding a string
    using a Huffman tree*.
  prefs: []
  type: TYPE_NORMAL
