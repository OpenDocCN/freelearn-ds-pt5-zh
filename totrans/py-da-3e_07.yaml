- en: Data Visualization
  prefs: []
  type: TYPE_NORMAL
- en: Data visualization is the initial move in the data analysis system toward easily
    understanding and communicating information. It represents information and data
    in graphical form using visual elements such as charts, graphs, plots, and maps.
    It helps analysts to understand patterns, trends, outliers, distributions, and
    relationships. Data visualization is an efficient way to deal with a large number
    of datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers various libraries for data visualization, such as Matplotlib,
    Seaborn, and Bokeh. In this chapter, we will first focus on Matplotlib, which
    is the basic Python library for visualization. After Matplotlib, we will explore
    Seaborn, which uses Matplotlib and offers high-level and advanced statistical
    plots. In the end, we will work on interactive data visualization using Bokeh.
    We will also explore `pandas` plotting. The following is a list of topics that
    will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualization using Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced visualization using the Seaborn package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive visualization with Bokeh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code and the datasets at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter05).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code blocks are available in the `ch5.ipynb` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter uses only one CSV file (`HR_comma_sep.csv`) for practice purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use the Matplotlib, `pandas`, Seaborn, and Bokeh Python
    libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualization using Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, a picture speaks a thousand words. Humans understand visual things
    better. Visualization helps to present things to any kind of audience and can
    easily explain a complex phenomenon in layman's terms. Python offers a couple
    of visualization libraries, such as Matplotlib, Seaborn, and Bokeh.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib is the most popular Python module for data visualization. It is a
    base library for most of the advanced Python visualization modules, such as Seaborn.
    It offers flexible and easy-to-use built-in functions for creating figures and
    graphs.
  prefs: []
  type: TYPE_NORMAL
- en: In Anaconda, Matplotlib is already installed. If you still find an error, you
    can install it in the following ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install Matplotlib with `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Python 3, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also simply install Matplotlib from your terminal or Command Prompt
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To create a very basic plot in Matplotlib, we need to invoke the `plot()` function
    in the `matplotlib.pyplot` subpackage. This function produces a two-dimensional
    plot for a single list or multiple lists of points with known *x* and *y* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demo code is in the `ch5.ipynb` file in this book''s code bundle,
    which you can find at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter05/Ch5.ipynb](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter05/Ch5.ipynb).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a small demo code for visualizing the line plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/613c4c85-5c82-45fd-973a-38d2af386454.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code block, first, we are importing the Matplotlib and NumPy
    modules. After this, we are creating the data using the `linespace()` function
    of NumPy and plotting this data using the `plot()` function of Matplotlib. Finally,
    we are displaying the figure using the `show()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic components of a plot: the figure and the axes. The figure
    is a container on which everything is drawn. It contains components such as plots,
    subplots, axes, titles, and a legend. In the next section, we will focus on these
    components, which act like accessories for charts.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessories for charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `matplotlib` module, we can add titles and axes labels to a graph. We
    can add a title using `plt.title()` and labels using `plt.xlabel()` and `plt.ylabel()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple graphs mean multiple objects, such as line, bar, and scatter. Points
    of different series can be shown on a single graph. Legends or graph series reflect
    the *y* axis. A legend is a box that appears on either the right or left side
    of a graph and shows what each element of the graph represents. Let''s see an
    example where we see how to use these accessories in our charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a7a1c2c-2d44-4f82-8a8f-e7170c513546.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding graph, two lines are shown on a single graph. We have used
    two extra parameters – `label` and `color` – in the `plot()` function. The `label`
    parameter defines the name of the series and `color` defines the color of the
    line graph. In the upcoming sections, we will focus on different types of plots.
    We will explore a scatter plot in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scatter plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scatter plots draw data points using Cartesian coordinates to show the values
    of numerical values. They also represent the relationship between two numerial
    values. We can create a scatter plot in Matplotlib using the `scatter()` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00c7d96b-b3b3-4957-8fbd-3411ec219f66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding scatter plot, the `scatter()` function takes x-axis and y-axis
    values. In our example, we are plotting two lists: `x` and `y`. We can also use
    optional parameters such as `c` for color, `alpha` for the transparency of the
    markers, ranging between 0 and 1, and `marker` for the shape of the points in
    the scatter plot, such as `*`, `o`, or any other symbol. In the next section,
    we will focus on the line plot.'
  prefs: []
  type: TYPE_NORMAL
- en: Line plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A line plot is a chart that displays a line between two variables. It has a
    sequence of data points joined by a segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4fe2dd4-3d3a-4999-88b1-be9b0fadee7e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding line plot program, the `plot()` function takes x-axis and y-axis
    values. In the next section, we will learn how to plot a pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: Pie plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pie plot is a circular graph that is split up into wedge-shaped pieces. Each
    piece is proportionate to the value it represents. The total value of the pie
    is 100 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d09425f-b30d-4870-a971-4b8d6f54fb61.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code of the pie chart, we specified `values`, `labels`, `colors`,
    `startangle`, `shadow`, `explode`, and `autopct`. In our example, `values` is
    the scores of the student in four subjects and `labels` is the list of subject
    names. We can also specify the color list for the individual subject scores. The
    `startangle` parameter specifies the first value angle, which is 90 degrees; this
    means the first line is vertical.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can also use the `shadow` parameter to specify the shadow of
    the pie slice and the `explode` parameter to pull out a pie slice list of the
    binary value. If we want to pull out a second pie slice, then a tuple of values
    would be (0, 0.1, 0, 0). Let's now jump to the bar plot.
  prefs: []
  type: TYPE_NORMAL
- en: Bar plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A bar plot is a visual tool to compare the values of various groups. It can
    be drawn horizontally or vertically. We can create a bar graph using the `bar()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f04bf569-db9a-4dd8-ba18-9bfbd9a11cb3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding bar chart program, the `bar()` function takes *x*-axis values,
    *y*-axis values, and a color. In our example, we are plotting movie ratings and
    their frequency. Movie ratings are on the *x* axis and the rating frequency is
    on the *y* axis. We can also specify the color of the bars in the bar graph using
    the `color` parameter. Let's see another variant of bar plot in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Histogram plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A histogram shows the distribution of a numeric variable. We create a histogram
    using the `hist()` method. It shows the probability distribution of a continuous
    variable. A histogram only works on a single variable while a bar graph works
    on two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d029d49-dc00-4322-8022-af240ac0c396.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding histogram, the `hist()` function takes `values`, `bins`, and
    `rwidth`. In our example, we are plotting the age of the employee and using a
    bin of 10 years. We are starting our bin from 20 to 60 with a 10 years bin size.
    We are using a relative bar width of 0.6, but you can choose any size for thicker
    and thinner width. Now it's time to jump to the bubble plot, which can handle
    multiple variables in a two-dimensional plot.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A bubble plot is a type of scatter plot. It not only draws data points using
    Cartesian coordinates but also creates bubbles on data points. Bubble shows the
    third dimension of a plot. It shows three numerical values: two values are on
    the *x* and *y* axes and the third one is the size of data points (or bubbles):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d66b28e-5b60-4c42-a234-eaa15a183e36.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding plot, a bubble chart is created using the scatter function.
    Here, the important thing is the `s` (size) parameter of the scatter function.
    We assigned a third variable, `scaled_gdp_per_capita`, to the `size` parameters.
    In the preceding bubble plot, countries are on the *x* axis, the population is
    on the *y* axis, and GDP per capita is shown by the size of the scatter point
    or bubble. We also assigned a random color to the bubbles to make it attractive
    and more understandable. From the bubble size, you can easily see that Qatar has
    the highest GDP per capita and Kuwait has the lowest GDP per capita. In all the
    preceding sections, we have focused on most of the Matplotlib plots and charts.
    Now, we will see how we can plot the charts using the `pandas` module.
  prefs: []
  type: TYPE_NORMAL
- en: pandas plotting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pandas` library offers the `plot()` method as a wrapper around the Matplotlib
    library. The `plot()` method allows us to create plots directly on `pandas` DataFrames.
    The following `plot()` method parameters are used to create the plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kind`: A string parameter for the type of graph, such as line, bar, barh,
    hist, box, KDE, pie, area, or scatter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`figsize`: This defines the size for a figure in a tuple of (width, height).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This defines the title for the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid`: Boolean parameter for the axis grid line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`legend`: This defines the legend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xticks`: This defines the sequence of x-axis ticks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yticks`: This defines the sequence of y-axis ticks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a scatter plot using the `pandas plot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d5e58d4-dcc9-47bc-85b3-80dfffc93a5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding plot, the `plot()` function takes `kind`, `x`, `y`, `color`,
    and `title` values. In our example, we are plotting the scatter plot between age
    and income using the `kind` parameter as `''scatter''`. The `age` and `income`
    columns are assigned to the `x` and `y` parameters. The scatter point color and
    the title of the plot are assigned to the `color` and `title` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe1b8fcd-fd1a-44e1-adc2-2843c962f2d4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding plot, the `plot()` function takes `kind`, `x`, `y`, `color`,
    and `title` values. In our example, we are plotting the bar plot between age and
    income using the `kind` parameter as `'bar'`. The `name` and `age` columns are
    assigned to the `x` and `y` parameters. The scatter point color is assigned to
    the `color` parameter. This is all about `pandas` plotting. Now, from the next
    section onward, we will see how to visualize the data using the Seaborn library.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced visualization using the Seaborn package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization can be helpful to easily understand complex patterns and concepts.
    It represents the insights in pictorial format. In the preceding sections, we
    have learned about Matplotlib for visualization. Now, we will explore the new
    Seaborn library for high-level and advanced statistical plots. Seaborn is an open
    source Python library for high-level interactive and attractive statistical visualization.
    Seaborn uses Matplotlib as a base library and offers more simple, easy-to-understand,
    interactive, and attractive visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Anaconda software suite, you can install the Seaborn library in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Seaborn with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For Python 3, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simply install Seaborn from your terminal or Command Prompt using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are installing it into the Jupyter Notebook, then you need to put the
    `!` sign before the `pip` command. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's jump to the `lm` plot of Seaborn.
  prefs: []
  type: TYPE_NORMAL
- en: lm plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `lm` plot plots the scatter and fits the regression model on it. A scatter
    plot is the best way to understand the relationship between two variables. Its
    output visualization is a joint distribution of two variables. `lmplot()` takes
    two column names – `x` and `y` – as a string and DataFrame variable. Let''s see
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17714774-b536-4968-85f7-4bc049be363a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, `lmplot()` fits the regression line. We can also remove this by
    setting the `fit_reg` parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e389c44-cd99-436e-a622-92f7f25557d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a dataset of HR Analytics and try to plot `lmplot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/017df826-085a-4c23-b317-1c8aac44a89b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, `last_evaluation` is the evaluated performance of
    the employee, `satisfaction_level` is the employee's satisfaction level in the
    company, and `left` means whether the employee left the company or not. `satisfaction_level`
    and `last_evaluation` were drawn on the *x* and *y* axes, respectively. The third
    variable left is passed in the `hue` parameter. The `hue` property is used for
    color shade. We are passing a `left` variable as `hue`. We can clearly see in
    the diagram that employees that have left are scattered into three groups. Let's
    now jump to bar plots.
  prefs: []
  type: TYPE_NORMAL
- en: Bar plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`barplot()` offers the relationship between a categorical and a continuous
    variable. It uses rectangular bars with variable lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22ef555d-5837-48a9-8dd8-88883321b131.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the bar plot is created using the `bar()` function.
    It takes two columns – `x` and `y` – and a DataFrame as input. In the next section,
    we will see how to plot a distribution plot.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This plots a univariate distribution of variables. It is a combination of a
    histogram with the default bin size and a **Kernel Density Estimation** (**KDE**)
    plot. In our example, `distplot()` will take the `satisfaction_level` input column
    and plot the distribution of it. Here, the distribution of `satisfaction_level`
    has two peaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5256c688-8301-464e-bad2-4108271a2d93.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code block, we have created the distribution plot using `distplot()`.
    It's time to jump to the box plot diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Box plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Box plot, aka box-whisker plot, is one of the best plots to understand the
    distribution of each variable with its quartiles. It can be horizontal or vertical.
    It shows quartile distribution in a box, which is known as a whisker. It also
    shows the minimum and maximum and outliers in the data. We can easily create a
    box plot using Seaborn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5923cc3c-5649-4e02-acbe-0009b4d1a50b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we have used two variables for the box plot. Here,
    the box plot indicates that the range of `satisfaction_level` is higher than `last_evaluation`
    (performance). Let's jump to the KDE plot in Seaborn.
  prefs: []
  type: TYPE_NORMAL
- en: KDE plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `kde()` function plots the probability density estimation of a given continuous
    variable. It is a non-parametric kind of estimator. In our example, the `kde()`
    function takes one parameter, `satisfaction_level`, and plots the KDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a99ab7a8-9e47-47ad-96c8-e7dc804e65ec.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code block, we have created a density plot using `kdeplot()`.
    In the next section, we will see another distribution plot, which is a combination
    of a density and box plot, known as a violin plot.
  prefs: []
  type: TYPE_NORMAL
- en: Violin plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Violin plots are a combined form of box plots and KDE, which offer easy-to-understand
    analysis of the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a103c26-d7de-400a-b91b-c2c6840caec0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we have used two variables for the violin plot. Here,
    we can conclude that the range of `satisfaction_level` is higher than `last_evaluation`
    (performance) and both the variables have two peaks in the distribution. After
    working on distribution plots, we will see how we can combine the `groupby` operation
    and box plot into a single plot using a count plot.
  prefs: []
  type: TYPE_NORMAL
- en: Count plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`countplot()` is a special type of bar plot. It shows the frequency of each
    categorical variable. It is also known as a histogram for categorical variables.
    It makes operations very simple compared to Matplotlib. In Matplotlib, to create
    a count plot, first we need to group by the category column and count the frequency
    of each class. After that, this count is consumed by Matplotlib''s bar plot. But
    the Seaborn count plot offers a single line of code to plot the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c32b145-c58f-48e3-920e-430f8f1ab04a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we are counting the `salary` variable. The `count()`
    function takes a single column and DataFrame. So, we can easily conclude from
    the graph that most of the employees have low and medium salaries. We can also
    use `hue` as the second variable. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fa48cc3-20a7-4fb0-abe2-7d43cda6fec5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we can see that `left` is used as the hue or color
    shade. This indicates that most of the employees with the lowest salary left the
    company. Let's see another important plot for visualizing the relationship and
    distribution of two variables.
  prefs: []
  type: TYPE_NORMAL
- en: Joint plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The joint plot is a multi-panel visualization; it shows the bivariate relationship
    and distribution of individual variables in a single graph. We can also plot a
    KDE using the `kind` parameter of `jointplot()`. By setting the `kind` parameter
    as `"kde"`, we can draw the KDE plot. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f41ea0ea-fc2b-4abc-ad61-524a322e8e59.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding plot, we have created the joint plot using `jointplot()` and
    also added the `kde` plot using a `kind` parameter as `"kde"`. Let's jump to heatmaps
    for more diverse visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Heatmaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heatmap offers two-dimensional grid representation. The individual cell of
    the grid contains a value of the matrix. The heatmap function also offers annotation
    on each cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa30eaf5-0f91-4a9d-ad6c-2e5c01d31fb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, the Iris dataset is loaded using `load_dataset()`
    and the correlation is calculated using the `corr()` function. The `corr()` function
    returns the correlation matrix. This correlation matrix is plotted using the `heatmap()`
    function for the grid view of the correlation matrix. It takes two parameters:
    the correlation matrix and `annot`. The `annot` parameter is passed as `True`.
    In the plot, we can see a symmetric matrix, and all the values on the diagonal
    are ones, which indicates a perfect correlation of a variable with itself. We
    can also set a new color map using the `cmap` parameter for different colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bde2842-cf24-496f-b49b-ace8bdc8ab4c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding heatmap, we have changed the color map using the `cmap` parameter
    for different colors. Here, we are using the `YlGnBu` (yellow, green, and blue)
    combination for `cmap`. Now, we will move on to the pair plot for faster exploratory
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Pair plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Seaborn offers quick exploratory data analysis with relationships and individual
    distribution using a pair plot. A pair plot offers a single distribution using
    a histogram and joint distribution using a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f3364c2-28ea-4ca1-8b03-35f622390a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the Iris dataset is loaded using `load_dataset()`
    and that dataset is passed into the `pairplot()` function. In the plot, it creates
    an *n* by *n* matrix or a grid of graphs. The diagonal shows the distribution
    of the columns, and the non-diagonal elements of the grid show the scatter plot
    to understand the relationship among all the variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding few sections, we have seen how to use the Seaborn plots. Now,
    we will jump to another important visualization library, which is Bokeh. In the
    upcoming sections, we will draw interactive and versatile plots using the Bokeh
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive visualization with Bokeh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bokeh is an interactive, high-quality, versatile, focused, and more powerful
    visualization library for large-volume and streaming data. It offers interactive,
    rich charts, plots, layouts, and dashboards for modern web browsers. Its output
    can be mapped to a notebook, HTML, or server.
  prefs: []
  type: TYPE_NORMAL
- en: Both the Matplotlib and Bokeh libraries have different intentions. Matplotlib
    focuses on static, simple, and fast visualization while Bokeh focuses on highly
    interactive, dynamic, web-based, and quality visualization. Matplotlib is generally
    used for publication images while Bokeh is for a web audience. In the remaining
    sections of this chapter, we will learn basic plotting using Bokeh. We can create
    more interactive visuals for data exploration using Bokeh.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to install the Bokeh library is with the Anaconda distribution
    package. To install Bokeh, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also install it using `pip`. To install Bokeh using `pip`, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Plotting a simple graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s plot a first and simple plot using Bokeh. First, we need to import the
    basic `bokeh.plotting` module. The `output_notebook()` function defines that the
    plot will render on the Jupyter Notebook. The `figure` object is used as one of
    the core objects to draw charts and graphs. The `figure` object focuses on the
    plot title, size, label, grids, and style. The `figure` object also deals with
    plot style, title, axes labels, axes, grids, and various methods for adding data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ae25831-21b5-4559-87d4-5597bb34d3f1.png)'
  prefs: []
  type: TYPE_IMG
- en: After setting up the `figure` object, we will create a scatter circle markers
    plot using a circle function. The `circle()` function will take `x` and `y` values.
    It also takes size, color, and alpha parameters. The `show()` function will finally
    plot the output once all the features and data are added to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Glyphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bokeh uses a visual glyph, which refers to the circles, lines, triangles, squares,
    bars, diamonds, and other shape graphs. The glyph is a unique symbol that is used
    to convey information in pictorial form. Let''s create a line plot using the `line()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/186afe2d-4b28-4873-a0ce-a51a4bf80366.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the `line()` function takes the *x*- and *y*-axis
    values. It also takes the `line_width` and `color` values of the line. In the
    next section, we will focus on the layouts for multiple plots.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bokeh offers layouts for organizing plots and widgets. Layouts organize more
    than one plot in a single panel for interactive visualizations. They also allow
    setting the sizing modes for resizing the plots and widgets based on panel size.
    The layout can be of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Row layout**: This organizes all the plots in a row or in a horizontal fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column layout**: This organizes all the plots in a column or in a vertical
    fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested layout**: This is a combination of row and column layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid layout**: This offers you a grid of matrices for arranging the plots
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see a row layout example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/045edd8a-4c85-4a89-a200-aa5ad5a7b8af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this layout plot, we have imported the row and column layouts, loaded the
    Iris data from Bokeh sample data, instantiated the three `figure` objects with
    plot width and height, created the three scatter circle markers on each figure
    object, and created the row layout. This row layout will take the `figure` objects
    as input and is drawn using the `show()` function. We can also create a column
    layout by creating a column layout in place of a row layout, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29f71614-53d2-476e-9730-20d151492716.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding plot, we have created the column layout of three plots. Let's
    jump to the nested layouts for more powerful visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Nested layout using row and column layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A nested layout is the combination of multiple row and column layouts. Let''s
    see the example given here for a better practical understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82bfd6df-4a0e-46fa-867d-f35c9bab4452.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see the row layout has two rows. In the first, `fig1` is assigned
    and the second row has the column layout of `fig2` and `fig3`. So, this layout
    becomes a 2*2 layout, in which the first column has only one component and the
    second column has two components.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple plots and objects can also be created using a grid layout. A grid
    layout arranges the plots and widget objects in a row-column matrix fashion. It
    takes a list of figure objects for each row. We can also use `None` as a placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845b71f3-3c3a-4be5-a056-6433d52f602e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding layout is similar to the nested layout. Here, we have imported
    `gridplot()`. It arranges the components in rows and columns. The grid plot has
    taken a list of row figures. The first items in the list are `fig1` and `fig2`.
    The second items are `None` and `fig3`. Each item is a row in the grid matrix.
    The `None` placeholder is used to leave the cell empty or without components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sizing modes can help us to configure figures with resizing options. Bokeh
    offers the following sizing modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed`: This retains the same original width and height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch_width`: This stretches to the available width based on the type of
    the other component. It doesn''t maintain the aspect ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch_height`: This stretches to the available height based on the type
    of the other component. It doesn''t maintain the aspect ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch_both`: This stretches both the width and height based on the type
    of the other component without maintaining the original aspect ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale_width`: This stretches to the available width based on the type of the
    other component while maintaining the original aspect ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale_height`: This stretches to the available height based on the type of
    the other component while maintaining the original aspect ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale_both`: This stretches both the width and height based on the type of
    the other component while maintaining the original aspect ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After learning about layouts and multiple plots, it's time to learn about interactions
    for interactive visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bokeh offers interactive legends for runtime-actionable graphs. Legends can
    be hidden or muted by clicking on glyph plots. We can activate these modes by
    activating the `click_policy` property and clicking on the legend entry.
  prefs: []
  type: TYPE_NORMAL
- en: Hide click policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hide click policy hides the desirable glyphs by clicking on the legend entry.
    Let''s see an example of a hide click policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92f05d68-5e04-42b0-ad96-d38eab3ffddf.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can set the click policy with the `legend.click_policy` parameter of
    the `figure` object. Also, we need to run a `for` loop of each type of glyph or
    legend element on which you click. In our example, we are running a `for` loop
    for types of species and colors. On the click of any species in the legend, it
    will filter the data and hide that glyph.
  prefs: []
  type: TYPE_NORMAL
- en: Mute click policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mute click policy mutes the glyph by clicking on a legend entry. Here, the
    following code shows the desirable glyph with high intensity and uninteresting
    glyphs using lower intensity instead of hiding the whole glyph. Let''s see an
    example of a mute click policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd36ff08-ab1a-46e0-adf1-31f3d6c9b06d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can set the mute click policy with the `legend.click_policy` parameter
    to mute figure objects. Also, we need to run the `for` loop of each type of glyph
    or legend element on which you click. In our example, we are running a `for` loop
    for types of species and colors. On the click of any species in the legend, it
    will filter the data and hide that glyph. In addition to that, we need to add
    a `muted_color` and `muted_alpha` parameter to the scatter circle marker.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bokeh offers several annotations for supplementary information for visualizations.
    It helps the viewer by adding the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Titles**: This annotation provides a name to the plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Axis labels**: This annotation provides labels to the axis. It helps us to
    understand what the *x* and *y* axes represent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legends**: This annotation represents the third variable via color or shape
    and helps us to link features for easy interpretations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color bars**: Color bars are created using ColorMapper with the color palette.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an annotation example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99f04a92-7d11-4c2f-a442-afa85a769048.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, `CategoricalColorMapper` is imported and objects are
    created by defining factors or unique items in iris species and their respective
    colors. A color dictionary is created by defining the `field` and `transform`
    parameters for the mapper. We need to define the figure title; `x_axis_label`
    and `y_axis_label` were defined inside the `figure` object. The legend is defined
    in the circle scatter marker function with the species column and its location
    is defined using the location attribute of the `figure` object with `top_left`.
  prefs: []
  type: TYPE_NORMAL
- en: Hover tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hover tool shows the related information whenever the mouse pointer is
    placed over a particular area. Let''s see examples to understand the hovering
    plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce8e8bfd-6bbd-42a0-a272-c6c1eb6649ac.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we have imported `HoverTool` from `bokeh.models` and
    created its object by defining the information that will be shown on mouse hover.
    In our example, we have defined information in the list of tuples. Each tuple
    has two arguments. The first is for the string label and the second is for the
    actual value (preceded with `@`). This hover object is passed into the `figure`
    object's `tools` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Widgets offer real-time interaction on the frontend. Widgets have the capability
    to modify and update plots at runtime. They can run either a Bokeh server or a
    standalone HTML application. For using widgets, you need to specify the functionality.
    It can be nested inside the layout. There are two approaches to add the functionality
    of widgets into the program:'
  prefs: []
  type: TYPE_NORMAL
- en: CustomJS callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the Bokeh server and setup event handler, such as `onclick` or `onchange
    event`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tab panes allow us to create multiple plots and layouts in a single window.
    Let''s see an example of a tab panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5c7ec44-0173-496d-8875-107e55997926.png)![](img/9fa9fdce-f755-4953-b135-330127ac4787.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we have created the two panels by passing `figure` objects
    to a child parameter and `title` to a `title` parameter to `Panel`. Both panels
    are combined into a list and passed to the `Tabs` layout object. This `Tabs` object
    is shown by the `show()` function. You can change the tab by just clicking on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Slider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A slider is a graphical track bar that controls the value by moving it on a
    horizontal scale. We can change the values of the graph without affecting its
    formatting. Let''s see an example of a slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/547ca4f5-0d95-4dcb-bfa4-11ac83724d45.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, the Bokeh `slider()` function takes `start`, `end`, `value`,
    `step`, `title`, and CustomJS callback as input. In our example, we are creating
    a line graph and changing its `y` variable by the power of the `x` variable using
    the slide bar. We can create the slider by passing `start`, `end`, `value`, `step`,
    `title`, and a CustomJS callback to the `Slider` object. We need to focus on the
    CustomJS callback. It takes the source DataFrame, gets the value of the slider
    using `cb_obj.value`, and updates its values using the `change.emit()` function.
    We are updating `y_value` in the `for` loop by finding its power using the slider
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed visualizing data using plotting with Matplotlib,
    `pandas`, Seaborn, and Bokeh. We covered various plots, such as line plots, pie
    plots, bar plots, histograms, scatter plots, box plots, bubble charts, heatmaps,
    KDE plots, violin plots, count plots, joint plots, and pair plots. We focused
    on accessories for charts, such as titles, labels, legends, layouts, subplots,
    and annotations. Also, we learned about interactive visualization using Bokeh
    layouts, interactions, hover tools, and widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter, [Chapter 6](0a7bfc74-e20e-4613-949f-715cc06574aa.xhtml), *Retrieving,
    Processing, and Storing Data*, will teach us skills of data reading and writing
    from various sources such as files, objects, and relational and NoSQL databases.
    Although some people don't consider these skills for data analysis, an independent
    or assistant data analyst must know how they can fetch data from various file
    formats and databases for analysis purposes.
  prefs: []
  type: TYPE_NORMAL
