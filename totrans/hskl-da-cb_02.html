<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Integrity and Inspection"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Integrity and Inspection</h1></div></div></div><p>This chapter will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Trimming excess whitespace</li><li class="listitem" style="list-style-type: disc">Ignoring punctuation and specific characters</li><li class="listitem" style="list-style-type: disc">Coping with unexpected or missing input</li><li class="listitem" style="list-style-type: disc">Validating records by matching regular expressions</li><li class="listitem" style="list-style-type: disc">Lexing and parsing an e-mail address</li><li class="listitem" style="list-style-type: disc">Deduplication of nonconflicting data items</li><li class="listitem" style="list-style-type: disc">Deduplication of conflicting data items</li><li class="listitem" style="list-style-type: disc">Implementing a frequency table using Data.List</li><li class="listitem" style="list-style-type: disc">Implementing a frequency table using Data.MultiSet</li><li class="listitem" style="list-style-type: disc">Computing the Manhattan distance</li><li class="listitem" style="list-style-type: disc">Computing the Euclidean distance</li><li class="listitem" style="list-style-type: disc">Comparing scaled data using the Pearson correlation coefficient</li><li class="listitem" style="list-style-type: disc">Comparing sparse data using cosine similarity</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Introduction</h1></div></div></div><div class="mediaobject"><img src="graphics/ch02.jpg" alt="Introduction"/></div><p>The conclusions drawn from data analysis are only as robust as the quality of the data itself. After obtaining raw text, the next natural step is to validate and clean it carefully. Even the slightest bias may risk the integrity of the results. Therefore, we must take great precautionary measures, which involve thorough inspection, to ensure sanity checks are performed on our data before we begin to understand it. This section should be the starting point for cleaning data in Haskell.</p><p>Real-world data often has an impurity that needs to be addressed before it can be processed. For example, extraneous whitespaces or punctuation could clutter data, making it difficult to parse. Duplication and data conflicts are another area of unintended consequences of reading real-world data. Sometimes it's just reassuring to know that data makes sense by conducting sanity checks. Some examples of sanity checks include matching regular expressions as well as detecting outliers by establishing a measure of distance. In this chapter, we will cover each of these topics.</p></div></div>
<div class="section" title="Trimming excess whitespace"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Trimming excess whitespace</h1></div></div></div><p>The text obtained <a id="id109" class="indexterm"/>from sources may unintentionally include beginning or trailing whitespace characters. When parsing such an input, it is often wise to trim the text. For example, when Haskell source code contains trailing whitespace, the <span class="strong"><strong>GHC</strong></span> compiler<a id="id110" class="indexterm"/> ignores it through a process called <span class="strong"><strong>lexing</strong></span><a id="id111" class="indexterm"/>. The lexer produces a sequence of tokens, effectively ignoring meaningless characters such as excess whitespace.</p><p>In this recipe, we will use built-in libraries to make our own <code class="literal">trim</code> function.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">isSpace :: Char -&gt; Bool</code> function from the built-in <code class="literal">Data.Char</code> package:<div class="informalexample"><pre class="programlisting">import Data.Char (isSpace)</pre></div></li><li class="listitem">Write a trim function that removes the beginning and trailing whitespace:<div class="informalexample"><pre class="programlisting">trim :: String -&gt; String
trim = f . f
  where f = reverse . dropWhile isSpace</pre></div></li><li class="listitem">Test it out within <code class="literal">main</code>:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = putStrLn $ trim " wahoowa! "</pre></div></li><li class="listitem">Running the code will result in the following trimmed string:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>wahoowa!</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How it works...</h2></div></div></div><p>Our <code class="literal">trim</code> function<a id="id112" class="indexterm"/> lazily strips the whitespace from the beginning and ending parts of the string. It starts by dropping whitespace letters from the beginning. Then, it reverses the string to apply the same function again. Finally, it reverses the string one last time to bring it back to the original form. Fortunately, the <code class="literal">isSpace</code> function<a id="id113" class="indexterm"/> from <code class="literal">Data.Char</code> handles<a id="id114" class="indexterm"/> any <span class="strong"><strong>Unicode</strong></span> space character as well as the control characters <code class="literal">\t</code>, <code class="literal">\n</code>, <code class="literal">\r</code>, <code class="literal">\f</code>, and <code class="literal">\v</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>There's more…</h2></div></div></div><p>Ready-made <a id="id115" class="indexterm"/>parser combinator libraries such as <code class="literal">parsec</code> or <code class="literal">uu-parsinglib</code> could be used to do this instead, rather than reinventing the wheel. By introducing a <code class="literal">Token</code> type and parsing to this type, we can elegantly ignore the whitespace. Alternatively, we can use the alex lexing library (package name, <code class="literal">alex</code>) for this task. These libraries are overkill for this simple task, but they allow us to perform a more generalized tokenizing of text.</p></div></div>
<div class="section" title="Ignoring punctuation and specific characters"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Ignoring punctuation and specific characters</h1></div></div></div><p>Usually in<a id="id116" class="indexterm"/> natural language processing, some uninformative words or characters, called <a id="id117" class="indexterm"/>
<span class="strong"><strong>stop words</strong></span>, can be filtered out for easier handling. When<a id="id118" class="indexterm"/> computing word frequencies or extracting sentiment data from a corpus, punctuation or special characters might need to be ignored. This recipe demonstrates how to remove these specific characters from the body of a text.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>How to do it...</h2></div></div></div><p>There are no imports necessary. Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement <code class="literal">main</code> and define a string called <code class="literal">quote</code>. The back slashes (<code class="literal">\</code>) represent multiline strings:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let quote = "Deep Blue plays very good chess-so what?\ 
    \Does that tell you something about how we play chess?\
    \No. Does it tell you about how Kasparov envisions,\ 
    \understands a chessboard? (Douglas Hofstadter)"
  putStrLn $ (removePunctuation.replaceSpecialSymbols) quote</pre></div></li><li class="listitem">Replace all punctuation marks with an empty string, and replace all special symbols with a space:<div class="informalexample"><pre class="programlisting">punctuations = [ '!', '"', '#', '$', '%'
               , '(', ')', '.', ',', '?']
  
removePunctuation = filter (`notElem` punctuations)
        
specialSymbols = ['/', '-']

replaceSpecialSymbols = map $ 
  (\c -&gt;if c `elem` specialSymbols then ' ' else c)</pre></div></li><li class="listitem">By <a id="id119" class="indexterm"/>running the code, we will find that all special characters and punctuation are <a id="id120" class="indexterm"/>appropriately removed to facilitate dealing with the text's corpus:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>
<span class="strong"><strong>Deep Blue plays very good chess so what Does that tell you something about how we play chess No Does it tell you about how Kasparov envisions understands a chessboard Douglas Hofstadter</strong></span>
</pre></div></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>There's more...</h2></div></div></div><p>For more powerful control, we can<a id="id121" class="indexterm"/> install <code class="literal">MissingH</code>, which is a very helpful utility we can use to deal with strings:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install MissingH</strong></span>
</pre></div><p>It provides a <code class="literal">replace</code> function that takes three arguments and produces a result as follows: </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Prelude&gt; replace "hello" "goodbye" "hello world!"</strong></span>

<span class="strong"><strong>"goodbye world!"</strong></span>
</pre></div><p>It replaces all occurrences of the first string with the second string in the third argument. We can also compose multiple <code class="literal">replace</code> functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Prelude&gt; ((replace "," "").(replace "!" "")) "hello, world!"</strong></span>

<span class="strong"><strong>"hello world"</strong></span>
</pre></div><p>By folding the composition <code class="literal">(.)</code> function over a list of these <code class="literal">replace</code> functions, we can generalize the <code class="literal">replace</code> function to an arbitrary list of tokens:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Prelude&gt; (foldr (.) id $ map (flip replace "") [",", "!"]) "hello, world!"</strong></span>

<span class="strong"><strong>"hello world"</strong></span>
</pre></div><p>The list of punctuation marks can now be arbitrarily long. We can modify our recipe to use our new and more generalized functions:</p><div class="informalexample"><pre class="programlisting">removePunctuation = foldr (.) id $ map (flip replace "") 
        ["!", "\"", "#", "$", "%", "(", ")", ".", ",", "?"]
        
replaceSpecialSymbols = foldr (.) id $ map (flip replace " ") 
        ["/", "-"]</pre></div></div></div>
<div class="section" title="Coping with unexpected or missing input"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Coping with unexpected or missing input</h1></div></div></div><p>Data sources often contain incomplete and unexpected data. One common approach to parsing<a id="id122" class="indexterm"/> such data in Haskell<a id="id123" class="indexterm"/> is using the <code class="literal">Maybe</code> data type.</p><p>Imagine designing a function to find the nth element in a list of characters. A naïve implementation may have the type <code class="literal">Int -&gt; [Char] -&gt; Char</code>. However, if the function is trying to access an index out of bounds, we should try to indicate that an error has occurred.</p><p>A common<a id="id124" class="indexterm"/> way to deal with these errors is by encapsulating the output <code class="literal">Char</code> into a <code class="literal">Maybe</code> context. Having the type <code class="literal">Int -&gt; [Char] -&gt; Maybe Char</code> allows for some better error handling. The constructors for <code class="literal">Maybe</code> are <code class="literal">Just a</code> or <code class="literal">Nothing</code>, which will become apparent by running GHCi and testing out the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ghci</strong></span>

<span class="strong"><strong>Prelude&gt; :type Just 'c'</strong></span>
<span class="strong"><strong>Just 'c' :: Maybe Char</strong></span>

<span class="strong"><strong>Prelude&gt; :type Nothing</strong></span>
<span class="strong"><strong>Nothing :: Maybe a</strong></span>
</pre></div><p>We will set each field as a <code class="literal">Maybe</code> data type so that whenever a field cannot be parsed, it will simply be represented as <code class="literal">Nothing</code>. This recipe will demonstrate how to read the CSV data with faulty and missing info.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>Getting ready</h2></div></div></div><p>We create an input set of CSV files to read in. The first column will be for laptop brands, the next column will be for their models, and the third column will be for the base cost. We should leave some fields blank to simulate an incomplete input. We name the file <code class="literal">input.csv</code>:</p><div class="mediaobject"><img src="graphics/6331OS_02_01.jpg" alt="Getting ready"/></div><p>Also, we must install the csv library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install csv</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>How to do it...</h2></div></div></div><p>Create a new file, which<a id="id125" class="indexterm"/> we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the CSV library:<div class="informalexample"><pre class="programlisting">import Text.CSV</pre></div></li><li class="listitem">Create a data type corresponding to the CSV fields:<div class="informalexample"><pre class="programlisting">data Laptop = Laptop { brand :: Maybe String
                     , model :: Maybe String
                     , cost :: Maybe Float 
                     } deriving Show</pre></div></li><li class="listitem">Define <a id="id126" class="indexterm"/>and implement <code class="literal">main</code> to read the CSV input and parse relevant info:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let fileName = "input.csv"
  input &lt;- readFile fileName
  let csv = parseCSV fileName input
  let laptops = parseLaptops csv
  print laptops</pre></div></li><li class="listitem">From a list of records, create a list of laptop data types:<div class="informalexample"><pre class="programlisting">parseLaptops (Left err) = []
parseLaptops (Right csv) = 
  foldl (\a record -&gt; if length record == 3
                      then (parseLaptop record):a
                      else a) [] csv

parseLaptop record = Laptop{ brand = getBrand $ record !! 0
                           , model = getModel $ record !! 1
                           , cost = getCost $ record !! 2 }</pre></div></li><li class="listitem">Parse each field, producing <code class="literal">Nothing</code> if there is an unexpected or missing item:<div class="informalexample"><pre class="programlisting">getBrand :: String -&gt; Maybe String
getBrand str = if null str then Nothing else Just str

getModel :: String -&gt; Maybe String
getModel str = if null str then Nothing else Just str

getCost :: String -&gt; Maybe Float
getCost str = case reads str::[(Float,String)] of
  [(cost, "")] -&gt; Just cost
  _ -&gt; Nothing</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>How it works...</h2></div></div></div><p>The <code class="literal">Maybe</code> monad <a id="id127" class="indexterm"/>allows you to have two states: <code class="literal">Just</code> something or <code class="literal">Nothing</code>. It provides a useful abstraction to produce an error state. Each field in these data types exists in a <code class="literal">Maybe</code> context. If a field doesn't exist, then we simply regard it as <code class="literal">Nothing</code> and move on.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>There's more...</h2></div></div></div><p>If a more <a id="id128" class="indexterm"/>descriptive error state is desired, the <code class="literal">Either</code> monad may be more useful. It also has two states, but they are more descriptive: <code class="literal">Left</code> something, or <code class="literal">Right</code> something. The <code class="literal">Left</code> state is often used to describe the error type, whereas the <code class="literal">Right</code> state holds the desired result. We can use the <code class="literal">Left</code> state to describe different types of errors instead of just one behemoth <code class="literal">Nothing</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>See also</h2></div></div></div><p>To review CSV data input, see the <span class="emphasis"><em>Keeping and representing data from a CSV file</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. The Hunt for Data">Chapter 1</a>, <span class="emphasis"><em>The Hunt for Data</em></span>.</p></div></div>
<div class="section" title="Validating records by matching regular expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Validating records by matching regular expressions</h1></div></div></div><p>A<a id="id129" class="indexterm"/> regular expression<a id="id130" class="indexterm"/> is a language for matching patterns in a string. Our Haskell code can process a regular expression to<a id="id131" class="indexterm"/> examine a text and tell us whether or not it matches the rules described by the expression. Regular expression matching can be used to validate or identify a pattern in the text. </p><p>In this recipe, we will read a corpus of English text to find possible candidates of full names in a sea of words. Full names usually consist of two words that start with a capital letter. We use this heuristic to extract all the names from an article.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>Getting ready</h2></div></div></div><p>Create an <code class="literal">input.txt</code> file with some text. In this example, we use a snippet from a New York Times article on dinosaurs (<a class="ulink" href="http://www.nytimes.com/2013/12/17/science/earth/outsider-challenges-papers-on-growth-of-dinosaurs.html">http://www.nytimes.com/2013/12/17/science/earth/outsider-challenges-papers-on-growth-of-dinosaurs.html</a>)</p><p><span class="emphasis"><em>Other co-authors of Dr. Erickson's include Mark Norell, chairman of paleontology at the American Museum of Natural History; Philip Currie, a professor of dinosaur paleobiology at the University of Alberta; and Peter Makovicky, associate curator of paleontology at the Field Museum in Chicago.</em></span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the regular expression library:<div class="informalexample"><pre class="programlisting">import Text.Regex.Posix ((=~))</pre></div></li><li class="listitem">Match a string against a regular expression to detect words that look like names:<div class="informalexample"><pre class="programlisting">looksLikeName :: String -&gt; Bool
looksLikeName str = str =~ "^[A-Z][a-z]{1,30}$" :: Bool</pre></div></li><li class="listitem">Create<a id="id132" class="indexterm"/> functions that remove unnecessary punctuation and special symbols. We will use the same functions defined in the previous recipe entitled <span class="emphasis"><em>Ignoring punctuation and specific characters</em></span>:<div class="informalexample"><pre class="programlisting">punctuations = [ '!', '"', '#', '$', '%'
               , '(', ')', '.', ',', '?']
removePunctuation = filter (`notElem` punctuations)
        
specialSymbols = ['/', '-']
replaceSpecialSymbols = map $ 
                         (\c -&gt; if c `elem`  specialSymbols
                                then ' ' else c)</pre></div></li><li class="listitem">Pair adjacent words together and form a list of possible full names:<div class="informalexample"><pre class="programlisting">createTuples (x:y:xs) = (x ++ " " ++ y) : 
                          createTuples (y:xs)
createTuples _ = [] </pre></div></li><li class="listitem">Retrieve the input and find possible names from a corpus of text:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do

  input &lt;- readFile "input.txt"
  let cleanInput = 
    (removePunctuation.replaceSpecialSymbols) input

  let wordPairs = createTuples $ words cleanInput

  let possibleNames = 
    filter (all looksLikeName . words) wordPairs

  print possibleNames</pre></div></li><li class="listitem">The resulting output after running the code is as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>["Dr Erickson","Mark Norell","American Museum","Natural History","History Philip","Philip Currie","Peter Makovicky","Field Museum"]</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How it works...</h2></div></div></div><p>The <code class="literal">=~</code> function <a id="id133" class="indexterm"/>takes in a string and a<a id="id134" class="indexterm"/> regular expression and returns a target that we parse as <code class="literal">Bool</code>. In this recipe, the <code class="literal">^[A-Z][a-z]{1,30}$</code> regular expression matches the words that start with a capital letter and are between 2 and 31 letters long.</p><p>In order to determine the usefulness of the algorithm presented in this recipe, we will introduce two metrics of relevance: <span class="strong"><strong>precision</strong></span> <a id="id135" class="indexterm"/>and<a id="id136" class="indexterm"/> <span class="strong"><strong>recall</strong></span>. Precision is the percent of retrieved data that is relevant. Recall is the percent of relevant data that is retrieved.</p><p>Out of a total of 45 words in the <code class="literal">input.txt</code> file, four correct names are produced and a total eight candidates are retrieved. It has a precision of 50 percent and a recall of 100 percent. This is not bad at all for a simple regular expression trick.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>See also</h2></div></div></div><p>Instead of running regular expressions on a string, we can pass them through a lexical analyzer. The next recipe entitled <span class="emphasis"><em>Lexing and parsing an e-mail address</em></span> will cover this in detail.</p></div></div>
<div class="section" title="Lexing and parsing an e-mail address"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Lexing and parsing an e-mail address</h1></div></div></div><p>An elegant <a id="id137" class="indexterm"/>way to clean data is by defining a lexer to split up a string into tokens. In <a id="id138" class="indexterm"/>this recipe, we will parse an e-mail address using the <code class="literal">attoparsec</code> library. This will naturally allow us to ignore the surrounding whitespace.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>Getting ready</h2></div></div></div><p>Import the<a id="id139" class="indexterm"/> <code class="literal">attoparsec</code> parser combinator library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install attoparsec</strong></span>
</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How to do it…</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the GHC <code class="literal">OverloadedStrings</code> language extension to more legibly use the <code class="literal">Text</code> data type throughout the code. Also, import the other relevant libraries:<div class="informalexample"><pre class="programlisting">{-# LANGUAGE OverloadedStrings #-}
import Data.Attoparsec.Text
import Data.Char (isSpace, isAlphaNum)</pre></div></li><li class="listitem">Declare a <a id="id140" class="indexterm"/>data type for an e-mail address:<div class="informalexample"><pre class="programlisting">data E-mail = E-mail 
  { user :: String
  , host :: String
  } deriving Show</pre></div></li><li class="listitem">Define<a id="id141" class="indexterm"/> how to parse an e-mail address. This function can be as simple or as complicated as required:<div class="informalexample"><pre class="programlisting">e-mail :: Parser E-mail
e-mail = do
  skipSpace
  user &lt;- many' $ satisfy isAlphaNum
  at &lt;- char '@'
  hostName &lt;- many' $ satisfy isAlphaNum
  period &lt;- char '.'
  domain &lt;- many' (satisfy isAlphaNum)
  return $ E-mail user (hostName ++ "." ++ domain)</pre></div></li><li class="listitem">Parse an e-mail address to test the code:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = print $ parseOnly e-mail "nishant@shukla.io"</pre></div></li><li class="listitem">Run the code to print out the parsed e-mail address:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>Right (E-mail {user = "nishant", host = "shukla.io"})</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>How it works…</h2></div></div></div><p>We create an e-mail parser by matching the string against multiple tests. An e-mail address must contain some alphanumerical username, followed by the 'at' sign (<code class="literal">@</code>), then an alphanumerical hostname, a period, and lastly the top-level domain.</p><p>The various functions used from the <code class="literal">attoparsec</code> library can be found in the <code class="literal">Data.Attoparsec.Text</code> documentation, which is available at <a class="ulink" href="https://hackage.haskell.org/package/attoparsec/docs/Data-Attoparsec-Text.html">https://hackage.haskell.org/package/attoparsec/docs/Data-Attoparsec-Text.html</a>.</p></div></div>
<div class="section" title="Deduplication of nonconflicting data items"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Deduplication of nonconflicting data items</h1></div></div></div><p>Duplication is a<a id="id142" class="indexterm"/> common problem when collecting large<a id="id143" class="indexterm"/> amounts of data. In this recipe, we will combine similar records in a way that ensures no information is lost.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>Getting ready</h2></div></div></div><p>Create an <code class="literal">input.csv</code> file with repeated data:</p><div class="mediaobject"><img src="graphics/6331OS_02_02.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will be using the <code class="literal">CSV</code>, <code class="literal">Map</code>, and <code class="literal">Maybe</code> packages:<div class="informalexample"><pre class="programlisting">import Text.CSV (parseCSV, Record)
import Data.Map (fromListWith)
import Control.Applicative ((&lt;|&gt;))</pre></div></li><li class="listitem">Define the <code class="literal">Item</code> data type corresponding to the CSV input:<div class="informalexample"><pre class="programlisting">data Item = Item   { name :: String
                   , color :: Maybe String
                   , cost :: Maybe Float
                   } deriving Show</pre></div></li><li class="listitem">Get each record from CSV and put them in a map by calling our <code class="literal">doWork</code> function:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let fileName = "input.csv"
  input &lt;- readFile fileName
  let csv = parseCSV fileName input
  either handleError doWork csv</pre></div></li><li class="listitem">If we're unable to parse CSV, print an error message; otherwise, define the <code class="literal">doWork</code> function that creates a map from an association list with a collision strategy defined by <code class="literal">combine</code>:<div class="informalexample"><pre class="programlisting">handleError = print

doWork :: [Record] -&gt; IO ()
doWork csv = print $ 
             fromListWith combine $ 
             map parseToTuple csv</pre></div></li><li class="listitem">Use<a id="id144" class="indexterm"/> the <code class="literal">&lt;|&gt;</code> function from <code class="literal">Control.Applicative</code> to merge the nonconflicting fields:<div class="informalexample"><pre class="programlisting">combine :: Item -&gt; Item -&gt; Item

combine item1 item2 = 
    Item { name = name item1
         , color = color item1 &lt;|&gt; color item2
         , cost = cost item1 &lt;|&gt; cost item2 }</pre></div></li><li class="listitem">Define the helper functions to create an association list from a CSV record:<div class="informalexample"><pre class="programlisting">parseToTuple :: [String] -&gt; (String, Item)
parseToTuple record = (name item, item) 
    where item = parseItem record


parseItem :: Record -&gt; Item
parseItem record = 
    Item { name = record !! 0
      , color = record !! 1
      , cost = case reads(record !! 2)::[(Float,String)] of
        [(c, "")] -&gt; Just c
        _ -&gt; Nothing  }</pre></div></li><li class="listitem">Executing the code shows a map filled with combined results:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>fromList </strong></span>
<span class="strong"><strong>[ ("glasses",</strong></span>
<span class="strong"><strong>    Item {name = "glasses", color = "black", cost = Just 60.0})</strong></span>
<span class="strong"><strong>, ("jacket",</strong></span>
<span class="strong"><strong>    Item {name = "jacket", color = "brown", cost = Just 89.99})</strong></span>
<span class="strong"><strong>, ("shirt",</strong></span>
<span class="strong"><strong>    Item {name = "shirt", color = "red", cost = Just 15.0})</strong></span>
<span class="strong"><strong>]</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>How it works...</h2></div></div></div><p>The <code class="literal">Map</code> data type offers a convenient function <code class="literal">fromListWith :: Ord k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; Map k a</code> to easily combine data in the map. We use it to find out whether a key already exists. If so, we combine the fields in the old and new items and store them under the key.</p><p>The true hero<a id="id145" class="indexterm"/> in this recipe is the <code class="literal">&lt;|&gt;</code> function form <code class="literal">Control.Applicative</code>. The <code class="literal">&lt;|&gt;</code> function takes its arguments and returns the first one that is not <span class="emphasis"><em>empty</em></span>. Since both <code class="literal">String</code> and <code class="literal">Maybe</code> implement <code class="literal">Applicative typeclass</code>, we can reuse the <code class="literal">&lt;|&gt;</code> function for a more manageable code. Here are a couple of examples of it in use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ghci</strong></span>

<span class="strong"><strong>Prelude&gt; import Control.Applicative</strong></span>

<span class="strong"><strong>Prelude Control.Applicative&gt; (Nothing) &lt;|&gt; (Just 1)</strong></span>
<span class="strong"><strong>Just 1</strong></span>

<span class="strong"><strong>Prelude Control.Applicative&gt; (Just 'a') &lt;|&gt; (Just 'b')</strong></span>
<span class="strong"><strong>Just 'a'</strong></span>

<span class="strong"><strong>Prelude Control.Applicative&gt; "" &lt;|&gt; "hello"</strong></span>
<span class="strong"><strong>"hello"</strong></span>

<span class="strong"><strong>Prelude Control.Applicative&gt; "" &lt;|&gt; ""</strong></span>
<span class="strong"><strong>""</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>There's more...</h2></div></div></div><p>If you're dealing with larger numbers, it may be wise to use <code class="literal">Data.Hashmap.Map</code> instead because the running time for <span class="emphasis"><em>n</em></span> items is <span class="emphasis"><em>O(min(n, W))</em></span>, where <span class="emphasis"><em>W</em></span> is the number of bits in an integer (32 or 64).</p><p>For even better performance, <code class="literal">Data.Hashtable.Hashtable</code> provides <span class="emphasis"><em>O(1)</em></span> performance for lookups but adds complexity by being in an I/O monad.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>See also</h2></div></div></div><p>If the corpus contains inconsistent information about duplicated data, see the next recipe on <span class="emphasis"><em>Deduplication of conflicting data items</em></span>.</p></div></div>
<div class="section" title="Deduplication of conflicting data items"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Deduplication of conflicting data items</h1></div></div></div><p>Unfortunately, <a id="id146" class="indexterm"/>information about an item may be inconsistent throughout the corpus. Collision strategies are often domain-dependent, but one common way <a id="id147" class="indexterm"/>to manage this conflict is by simply storing all variations of the data. In this recipe, we will read a CSV file that contains information about musical artists and store all of the information about their songs and genres in a set.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>Getting ready</h2></div></div></div><p>Create a CSV input file with the following musical artists. The first column is for the name of the artist or band. The second column is the song name, and the third is the genre. Notice how some musicians have multiple songs or genres.</p><div class="mediaobject"><img src="graphics/6331OS_02_03.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will be using the <code class="literal">CSV</code>, <code class="literal">Map</code>, and <code class="literal">Set</code> packages:<div class="informalexample"><pre class="programlisting">import Text.CSV (parseCSV, Record)
import Data.Map (fromListWith)
import qualified Data.Set as S</pre></div></li><li class="listitem">Define the <code class="literal">Artist</code> data type corresponding to the CSV input. For fields that may contain conflicting data, store the value in its corresponding list. In this case, song- and genre-related data are stored in a set of strings:<div class="informalexample"><pre class="programlisting">data Artist = Artist { name :: String
                     , song :: S.Set String
                     , genre :: S.Set String
                     } deriving Show</pre></div></li><li class="listitem">Extract data from CSV and insert it in a map:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let fileName = "input.csv"
  input &lt;- readFile fileName
  let csv = parseCSV fileName input
  either handleError doWork csv</pre></div></li><li class="listitem">Print out any error that might occur:<div class="informalexample"><pre class="programlisting">handleError = print</pre></div></li><li class="listitem">If no error occurs, then combine the data from the CSV and print it out:<div class="informalexample"><pre class="programlisting">doWork :: [Record] -&gt; IO ()
doWork csv = print $ 
             fromListWith combine $ 
             map parseToTuple csv</pre></div></li><li class="listitem">Create <a id="id148" class="indexterm"/>a map from an association list with a collision strategy defined by <code class="literal">combine</code>:<div class="informalexample"><pre class="programlisting">combine :: Artist -&gt; Artist -&gt; Artist
combine artist1 artist2 = 
    Artist { name = name artist1
           , song = S.union (song artist1) (song artist2)
           , genre = S.union (genre artist1) (genre artist2) }</pre></div></li><li class="listitem">Make the helper functions create an association list from the CSV records:<div class="informalexample"><pre class="programlisting">parseToTuple :: [String] -&gt; (String, Artist)
parseToTuple record = (name item, item) 
  where item = parseItem record

parseItem :: Record -&gt; Artist
parseItem record = 
  Artist { name = nameStr
         , song = if null songStr 
                  then S.empty 
                  else S.singleton songStr
         , genre = if null genreStr 
                   then S.empty 
                   else S.singleton genreStr
         }
  where nameStr  = record !! 0
        songStr  = record !! 1
        genreStr = record !! 2</pre></div></li><li class="listitem">The output of the program will be a map with the following information that will be collected:<div class="informalexample"><pre class="programlisting">fromList [ 
("Daft Punk", Artist 
  {  name = "Daft Punk", 
    song = fromList ["Get Lucky","Around the World"], 
    genre = fromList ["French house"]}),
("Junior Boys", Artist 
  {  name = "Junior Boys", 
    song = fromList ["Bits &amp; Pieces"], 
    genre = fromList ["Synthpop"]}),
("Justice", Artist 
  {  name = "Justice", 
    song = fromList ["Genesis"], 
    genre = fromList ["Electronic rock","Electro"]}),
("Madeon", Artist 
  {  name = "Madeon", 
    song = fromList ["Icarus"], 
    genre = fromList ["French house"]})]</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>How it works...</h2></div></div></div><p>The <code class="literal">Map</code> data type <a id="id149" class="indexterm"/>offers a convenient function <code class="literal">fromListWith :: Ord k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; Map k a</code> to easily combine data in <code class="literal">Map</code>. We use it to find out whether a key already exists. If so, we combine the fields in the old and new items and store them under the key.</p><p>We use a set to efficiently combine these data fields.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>There's more...</h2></div></div></div><p>If dealing with larger numbers, it may be wise to use <code class="literal">Data.Hashmap.Map</code> instead because the running time for <span class="emphasis"><em>n</em></span> items is <span class="emphasis"><em>O(min(n, W))</em></span>, where <span class="emphasis"><em>W</em></span> is the number of bits in an integer (32 or 64).</p><p>For even better performance, <code class="literal">Data.Hashtable.Hashtable</code> provides <span class="emphasis"><em>O(1)</em></span> performance for lookups but adds complexity by being in an I/O monad.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>See also</h2></div></div></div><p>If the corpus contains nonconflicting information about duplicated data, see the previous section on <span class="emphasis"><em>Deduplication of nonconflicting data items</em></span>.</p></div></div>
<div class="section" title="Implementing a frequency table using Data.List"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Implementing a frequency table using Data.List</h1></div></div></div><p>A frequency map<a id="id150" class="indexterm"/> <a id="id151" class="indexterm"/>of values is often useful to detect outliers. We can use it to identify frequencies that seem out of the ordinary. In this recipe, we will be counting the number of different colors in a list.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>How to do it...</h2></div></div></div><p>Create a new file, which<a id="id152" class="indexterm"/> we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will use the <code class="literal">group</code> and <code class="literal">sort</code> functions from <code class="literal">Data.List</code>:<div class="informalexample"><pre class="programlisting">import Data.List (group, sort)</pre></div></li><li class="listitem">Define a simple data type for colors:<div class="informalexample"><pre class="programlisting">data Color = Red | Green | Blue deriving (Show, Ord, Eq)</pre></div></li><li class="listitem">Create a list of these colors:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let items = [Red, Green, Green, Blue, Red, Green, Green]</pre></div></li><li class="listitem">Implement the frequency map and print it out:<div class="informalexample"><pre class="programlisting">  let freq = 
     map (\x -&gt; (head x, length x)) . group . sort $ items
  print freq</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>How it works...</h2></div></div></div><p>Grouping identical items after sorting the list is the central idea.</p><p>See the following step-by-step evaluation in ghci:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Prelude&gt; sort items</strong></span>

<span class="strong"><strong>[Red,Red,Green,Green,Green,Green,Blue]</strong></span>
<span class="strong"><strong>Prelude&gt; group it</strong></span>

<span class="strong"><strong>[[Red,Red],[Green,Green,Green,Green],[Blue]]</strong></span>

<span class="strong"><strong>Prelude&gt; map (\x -&gt; (head x, length x)) it</strong></span>

<span class="strong"><strong>[(Red,2),(Green,4),(Blue,1)]</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>As we may expect, sorting the list is the most expensive step.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>See also</h2></div></div></div><p>A cleaner version of the code is possible by using <code class="literal">Data.MultiSet</code> described in the next recipe, <span class="emphasis"><em>Implementing a frequency table using Data.MultiSet</em></span>.</p></div></div>
<div class="section" title="Implementing a frequency table using Data.MultiSet"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Implementing a frequency table using Data.MultiSet</h1></div></div></div><p>A frequency map<a id="id153" class="indexterm"/> of values is often useful to <a id="id154" class="indexterm"/>detect outliers. We will use an existing library that does much of the work for us.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>Getting ready</h2></div></div></div><p>We will be using the <code class="literal">multiset</code> package from Hackage:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install multiset</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will use the <code class="literal">fromList</code> and <code class="literal">toOccurList</code> functions from <code class="literal">Data.MultiSet</code>:<div class="informalexample"><pre class="programlisting">import Data.MultiSet (fromList, toOccurList)</pre></div></li><li class="listitem">Define a simple data type for colors:<div class="informalexample"><pre class="programlisting">data Color = Red | Green | Blue deriving (Show, Ord, Eq)</pre></div></li><li class="listitem">Create a list of these colors:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let items = [Red, Green, Green, Blue, Red, Green, Green]</pre></div></li><li class="listitem">Implement the frequency map and print it out:<div class="informalexample"><pre class="programlisting">  let freq = toOccurList . fromList $ items
  print freq</pre></div></li><li class="listitem">Run the code to display the frequency list:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>[ (Red, 2), (Green, 4), (Blue, 1) ]</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec80"/>How it works...</h2></div></div></div><p>The <code class="literal">toOccurList :: MultiSet a -&gt; [(a, Int)]</code> function creates a frequency map from a list. <a id="id155" class="indexterm"/>We construct <code class="literal">MuliSet</code> using the provided <code class="literal">fromList</code> function.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec81"/>See also</h2></div></div></div><p>If importing a new library is not desired, see the previous recipe on <span class="emphasis"><em>Implementing a frequency map using Data.List</em></span>.</p></div></div>
<div class="section" title="Computing the Manhattan distance"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Computing the Manhattan distance</h1></div></div></div><p>Defining a <a id="id156" class="indexterm"/>distance between two items allows us to easily interpret clusters and patterns. The Manhattan distance is one of the easiest to implement and is used primarily due to its simplicity.</p><div class="mediaobject"><img src="graphics/6331OS_02_04.jpg" alt="Computing the Manhattan distance"/></div><p>The Manhattan distance (or Taxicab distance) between two items is the sum of the absolute differences of their coordinates. So if we are given two points (1, 1) and (5, 4), then the Manhattan distance will be <span class="emphasis"><em>|1-5| + |1-4| = 4 + 3 = 7</em></span>.</p><p>We can use this distance metric to detect whether an item is unusually <span class="emphasis"><em>far away</em></span> from everything else. In this recipe, we will detect outliers using the Manhattan distance. The calculations merely involve addition and subtraction, and therefore, it performs exceptionally well for a very large amount of data.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec82"/>Getting ready</h2></div></div></div><p>Create a list of comma-separated points. We will compute the smallest distance between these points and a test point:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat input.csv</strong></span>

<span class="strong"><strong>0,0</strong></span>
<span class="strong"><strong>10,0</strong></span>
<span class="strong"><strong>0,10</strong></span>
<span class="strong"><strong>10,10</strong></span>
<span class="strong"><strong>5,5</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec83"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the CSV and List packages:<div class="informalexample"><pre class="programlisting">import Text.CSV (parseCSV)</pre></div></li><li class="listitem">Read in the following points:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let fileName = "input.csv"
  input &lt;- readFile fileName
  let csv = parseCSV fileName input</pre></div></li><li class="listitem">Represent<a id="id157" class="indexterm"/> the data as a list of floating point numbers:<div class="informalexample"><pre class="programlisting">  let points = either (\e -&gt; []) (map toPoint . myFilter) csv</pre></div></li><li class="listitem">Define a couple of points to test the function:<div class="informalexample"><pre class="programlisting">  let test1 = [2,1]
  let test2 = [-10,-10]</pre></div></li><li class="listitem">Compute the Manhattan distance on each of the points and find the smallest result:<div class="informalexample"><pre class="programlisting">  if (not.null) points then do
    print $ minimum $ map (manhattanDist test1) points
    print $ minimum $ map (manhattanDist test2) points
  else putStrLn "Error: no points to compare"</pre></div></li><li class="listitem">Create a helper function to convert a list of strings to a list of floating point numbers:<div class="informalexample"><pre class="programlisting">toPoint record = map (read :: String -&gt; Float) record</pre></div></li><li class="listitem">Compute the Manhattan distance between two points:<div class="informalexample"><pre class="programlisting">manhattanDist p1 p2 = 
  sum $ zipWith (\x y -&gt; abs (x - y)) p1 p2</pre></div></li><li class="listitem">Filter out records that are of incorrect size:<div class="informalexample"><pre class="programlisting">myFilter = filter (\x -&gt; length x == 2)</pre></div></li><li class="listitem">The output will be the shortest distance between the test points and the list of points:<div class="informalexample"><pre class="programlisting">$ runhaskell Main.hs 

3.0
20.0</pre></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec84"/>See also</h2></div></div></div><p>If the distance matches more closely to the traditional geometric space, then read the next recipe on <span class="emphasis"><em>Computing the Euclidean distance</em></span>.</p></div></div>
<div class="section" title="Computing the Euclidean distance"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Computing the Euclidean distance</h1></div></div></div><p>Defining <a id="id158" class="indexterm"/>a distance between two items allows us to easily interpret clusters and patterns. The Euclidean distance is one of the most geometrically natural forms of distance to implement. It uses the Pythagorean formula to compute how far away two items are, which is similar to measuring the distance with a physical ruler.</p><div class="mediaobject"><img src="graphics/6331OS_02_05.jpg" alt="Computing the Euclidean distance"/></div><p>We can use this distance metric to detect whether an item is unusually <span class="emphasis"><em>far away</em></span> from everything else. In this recipe, we will detect outliers using the Euclidean distance. It is slightly more computationally expensive than measuring the Manhattan distance since it involves multiplication and square roots; however, depending on the dataset, it may provide more accurate results.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec85"/>Getting ready</h2></div></div></div><p>Create a list of comma-separated points. We will compute the smallest distance between these points and a test point.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat input.csv</strong></span>

<span class="strong"><strong>0,0</strong></span>
<span class="strong"><strong>10,0</strong></span>
<span class="strong"><strong>0,10</strong></span>
<span class="strong"><strong>10,10</strong></span>
<span class="strong"><strong>5,5</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec86"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the CSV and List packages:<div class="informalexample"><pre class="programlisting">import Text.CSV (parseCSV)</pre></div></li><li class="listitem">Read in the following points:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let fileName = "input.csv"
  input &lt;- readFile fileName
  let csv = parseCSV fileName input</pre></div></li><li class="listitem">Represent <a id="id159" class="indexterm"/>the data as a list of floating point numbers:<div class="informalexample"><pre class="programlisting">  let points = either (\e -&gt; []) (map toPoint . myFilter) csv </pre></div></li><li class="listitem">Define a couple of points to test out the function:<div class="informalexample"><pre class="programlisting">  let test1 = [2,1]
  let test2 = [-10,-10]</pre></div></li><li class="listitem">Compute the Euclidean distance on each of the points and find the smallest result:<div class="informalexample"><pre class="programlisting">  if (not.null) points then do
    print $ minimum $ map (euclidianDist test1) points
    print $ minimum $ map (euclidianDist test2) points
  else putStrLn "Error: no points to compare"</pre></div></li><li class="listitem">Create a helper function to convert a list of strings to a list of floating point numbers:<div class="informalexample"><pre class="programlisting">toPoint record = map (read String -&gt; Float) record</pre></div></li><li class="listitem">Compute the Euclidean distance between two points:<div class="informalexample"><pre class="programlisting">euclidianDist p1 p2 = sqrt $ sum $ 
                      zipWith (\x y -&gt; (x - y)^2) p1 p2</pre></div></li><li class="listitem">Filter out records that are of incorrect size:<div class="informalexample"><pre class="programlisting">myFilter = filter (\x -&gt; length x == 2)</pre></div></li><li class="listitem">The output will be the shortest distance between the test points and the list of points:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>2.236068</strong></span>
<span class="strong"><strong>14.142136</strong></span>
</pre></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec87"/>See also</h2></div></div></div><p>If a more computationally efficient distance calculation is required, then take a look at the previous recipe, <span class="emphasis"><em>Computing the Manhattan distance</em></span>.</p></div></div>
<div class="section" title="Comparing scaled data using the Pearson correlation coefficient"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Comparing scaled data using the Pearson correlation coefficient</h1></div></div></div><p>Another <a id="id160" class="indexterm"/>way to measure how closely two items relate to each other is by examining their individual trends. For example, two items that both show an upward trend are more closely related. Likewise, two items <a id="id161" class="indexterm"/>that both show a downward trend are also closely related. To simplify the algorithm, we will only consider linear trends. This calculation of correlation is called the Pearson correlation coefficient. The closer the coefficient is to zero, the less correlated the two data sets will be.</p><p>The Pearson correlation coefficient <a id="id162" class="indexterm"/>for a sample is calculated using the following formula:</p><p> </p><div class="mediaobject"><img src="graphics/6331OS_02_06.jpg" alt="Comparing scaled data using the Pearson correlation coefficient"/></div><p>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec88"/>How to do it...</h2></div></div></div><p>Create a new file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement <code class="literal">main</code> to compute the correlation coefficient between two lists of numbers:<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let d1 = [3,3,3,4,4,4,5,5,5]
  let d2 = [1,1,2,2,3,4,4,5,5]
  let r = pearson d1 d2
  print r</pre></div></li><li class="listitem">Define the<a id="id163" class="indexterm"/> function to compute the Pearson coefficient:<div class="informalexample"><pre class="programlisting"> pearson xs ys = (n * sumXY - sumX * sumY) / 
                 sqrt ( (n * sumX2 - sumX*sumX) * 
                        (n * sumY2 - sumY*sumY) )

  where n = fromIntegral (length xs)
        sumX = sum xs
        sumY = sum ys
        sumX2 = sum $ zipWith (*) xs xs
         sumY2 = sum $ zipWith (*) ys ys
        sumXY = sum $ zipWith (*) xs ys</pre></div></li><li class="listitem">Run the code to print the coefficient.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>0.9128709291752768</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec89"/>How it works...</h2></div></div></div><p>The Pearson correlation coefficient <a id="id164" class="indexterm"/>measures<a id="id165" class="indexterm"/> the degree of linear relationship between two variables. The magnitude of this coefficient describes how strongly the variables are related. If positive, the two variables change together. If negative, as one variable increases, the other decreases.</p></div></div>
<div class="section" title="Comparing sparse data using cosine similarity"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Comparing sparse data using cosine similarity</h1></div></div></div><p>When a<a id="id166" class="indexterm"/> data set has multiple empty fields, comparing the distance using the Manhattan or Euclidean metrics might result in skewed <a id="id167" class="indexterm"/>results. Cosine similarity measures how closely two vectors are oriented with each other. For example, the vectors (82, 86) and (86, 82) essentially point in the same direction. In fact, their cosine similarity is equivalent to the cosine similarity between (41, 43) and (43, 41). A cosine similarity of 1 corresponds to vectors that point in the exact same direction, and 0 corresponds to vectors that are completely orthogonal to each other.</p><div class="mediaobject"><img src="graphics/6331OS_02_07.jpg" alt="Comparing sparse data using cosine similarity"/></div><p>As long as the angles between the two vectors are equal, their cosine similarity is equivalent. Applying a distance metric such as the Manhattan distance or Euclidean distance in this case produces a significant difference between the two sets of data.</p><p>The cosine similarity between the two vectors is the dot product of the two vectors divided by the product of their magnitudes.</p><div class="mediaobject"><img src="graphics/6331OS_02_08.jpg" alt="Comparing sparse data using cosine similarity"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec90"/>How to do it...</h2></div></div></div><p>Create a new<a id="id168" class="indexterm"/> file, which we will call <code class="literal">Main.hs</code>, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement <code class="literal">main</code> to compute the cosine similarity between two lists of numbers.<div class="informalexample"><pre class="programlisting">main :: IO ()
main = do
  let d1 = [3.5, 2, 0, 4.5, 5, 1.5, 2.5, 2]
  let d2 = [  3, 0, 0,   5, 4, 2.5,   3, 0]</pre></div></li><li class="listitem">Compute the cosine similarity.<div class="informalexample"><pre class="programlisting">  let similarity = dot d1 d2 / (eLen d1 * eLen d2)
  print similarity</pre></div></li><li class="listitem">Define the dot product and Euclidean length helper functions.<div class="informalexample"><pre class="programlisting">dot a b = sum $ zipWith (*) a b  
eLen a = sqrt $ dot a a</pre></div></li><li class="listitem">Run <a id="id169" class="indexterm"/>the code to print the cosine similarity.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>0.924679432210068</strong></span>
</pre></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec91"/>See also</h2></div></div></div><p>If the data set is not sparse, consider using the Manhattan or Euclidean distance metrics instead, as detailed in the recipes <span class="emphasis"><em>Computing the Manhattan distance</em></span> and <span class="emphasis"><em>Computing the Euclidean distance</em></span>.</p></div></div></body></html>