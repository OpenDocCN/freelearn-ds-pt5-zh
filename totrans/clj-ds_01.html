<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 1. Statistics"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch01" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 1. Statistics</h1></div></div></div><div class="calibre2"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre17"><td class="calibre18"> </td><td class="calibre18"><p class="calibre19"><span class="strong1"><em class="calibre13">"The people who cast the votes decide nothing. The people who count the votes decide everything."</em></span></p></td><td class="calibre18"> </td></tr><tr class="calibre17"><td class="calibre18"> </td><td colspan="2" class="calibre20">--<span class="strong1"><span class="strong1"><em class="calibre13">Joseph Stalin</em></span></span></td></tr></table></div><p class="calibre11">Over the course of the following ten chapters of <span class="strong1"><em class="calibre13">Clojure for Data Science</em></span>, we'll attempt to discover a broadly linear path through the field of data science. In fact, we'll find as we go that the path is not quite so linear, and the attentive reader ought to notice many recurring themes along the way.</p><p class="calibre11">Descriptive statistics <a id="id0" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>concern themselves with summarizing sequences of numbers and they'll appear, to some extent, in every chapter in this book. In this chapter, we'll build foundations for what's to come by implementing functions to calculate the mean, median, variance, and standard deviation of numerical sequences in Clojure. While doing so, we'll attempt to take the fear out of interpreting mathematical formulae.</p><p class="calibre11">As soon as we have more than one number to analyze it becomes meaningful to ask how those numbers are distributed. You've probably already heard expressions such as "long tail" and the "80/20 rule". They concern the spread of numbers throughout a range. We demonstrate the value of distributions in this chapter and introduce the most useful of them all: the normal distribution.</p><p class="calibre11">The study of distributions is aided immensely by visualization, and for this we'll use the Clojure library Incanter. We'll show how Incanter can be used to load, transform, and visualize real data. We'll compare the results of two national elections—the 2010 United Kingdom general election and the 2011 Russian presidential election—and see how even basic analysis can provide evidence of potentially fraudulent activity.</p><div class="calibre2" title="Downloading the sample code"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec08" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Downloading the sample code</h1></div></div></div><p class="calibre11">All of the book's <a id="id1" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>sample code is available on Packt Publishing's <a id="id2" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>website at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> or from GitHub at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://github.com/clojuredatascience">http://github.com/clojuredatascience</a>. Each chapter's sample code is available in its own repository.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">The sample code for <a id="id3" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <span class="strong1"><em class="calibre13">Statistics</em></span> can be downloaded from <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/clojuredatascience/ch1-statistics">https://github.com/clojuredatascience/ch1-statistics</a>.</p></div></div><p class="calibre11">Executable examples are provided regularly throughout all chapters, either to demonstrate the effect of code that has been just been explained, or to demonstrate statistical principles that have been introduced. All example function names begin with <code class="literal">ex-</code> and are numbered sequentially throughout each chapter. So, the first runnable example of <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <span class="strong1"><em class="calibre13">Statistics</em></span> is named <code class="literal">ex-1-1</code>, the second is named <code class="literal">ex-1-2</code>, and so on.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Running the examples"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec09" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Running the examples</h1></div></div></div><p class="calibre11">Each example is a <a id="id4" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function in the <code class="literal">cljds.ch1.examples</code> namespace that can be run in two ways—either from the <span class="strong1"><strong class="calibre12">REPL</strong></span> or on the command line with <span class="strong1"><strong class="calibre12">Leiningen</strong></span>. If you'd like to run the examples in the REPL, you can execute:</p><div class="calibre2"><pre class="programlisting">
<span class="strong1"><strong class="calibre12">lein repl</strong></span>
</pre></div><p class="calibre11">on the command line. By default, the REPL will open in the <code class="literal">examples</code> namespace. Alternatively, to run a specific numbered example, you can execute:</p><div class="calibre2"><pre class="programlisting">
<span class="strong1"><strong class="calibre12">lein run –-example 1.1</strong></span>
</pre></div><p class="calibre11">or pass the single-letter equivalent:</p><div class="calibre2"><pre class="programlisting">
<span class="strong1"><strong class="calibre12">lein run –e 1.1</strong></span>
</pre></div><p class="calibre11">We only assume basic command-line familiarity throughout this book. The ability to run Leiningen and shell scripts is all that's required.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="tip02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre22">If you become <a id="id5" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>stuck at any point, refer to the book's wiki at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://wiki.clojuredatascience.com">http://wiki.clojuredatascience.com</a>. The wiki will provide troubleshooting tips for known issues, including advice for running examples on a variety of platforms.</p></div></div><p class="calibre11">In fact, shell scripts are only used for fetching data from remote locations automatically. The book's wiki will <a id="id6" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>also provide alternative instructions for those not wishing or unable to execute the shell scripts.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Downloading the data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec10" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Downloading the data</h1></div></div></div><p class="calibre11">The dataset for this <a id="id7" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>chapter has been made available by the Complex Systems Research Group at the Medical University of Vienna. The analysis we'll be performing closely mirrors their research to determine the signals of systematic election fraud in the national elections of countries around the world.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note03" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">For more information about the research, and for links to download other datasets, visit the book's <a id="id8" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>wiki or the research group's website at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.complex-systems.meduniwien.ac.at/elections/election.html">http://www.complex-systems.meduniwien.ac.at/elections/election.html</a>.</p></div></div><p class="calibre11">Throughout this book we'll be making use of numerous datasets. Where possible, we've included the data with the example code. Where this hasn't been possible—either because of the size of the data or due to licensing constraints—we've included a script to download the data instead.</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <span class="strong1"><em class="calibre13">Statistics</em></span> is just such a chapter. If you've cloned the chapter's code and intend to follow the examples, download the data now by executing the following on the command line from within the project's directory:</p><div class="calibre2"><pre class="programlisting">
<span class="strong1"><strong class="calibre12">script/download-data.sh</strong></span>
</pre></div><p class="calibre11">The script will download and decompress the sample data into the project's data directory.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="tip03" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre22">If you have any difficulty running the download script or would like to follow manual instructions instead, visit the book's wiki at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://wiki.clojuredatascience.com">http://wiki.clojuredatascience.com</a> for assistance.</p></div></div><p class="calibre11">We'll begin investigating the data in the next section.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Inspecting the data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec11" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Inspecting the data</h1></div></div></div><p class="calibre11">Throughout this <a id="id9" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>chapter, and for many other chapters in this book, we'll be <a id="id10" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>using the Incanter library (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://incanter.org/">http://incanter.org/</a>) to load, manipulate, and display data.</p><p class="calibre11">Incanter is a modular suite of Clojure libraries that provides statistical computing and visualization capabilities. Modeled after the extremely popular R environment for data analysis, it brings together the power of Clojure, an interactive REPL, and a set of powerful abstractions for working with data.</p><p class="calibre11">Each module of Incanter focuses on a specific area of functionality. For example <code class="literal">incanter-stats</code> contains a suite of related functions for analyzing data and producing summary statistics, while <code class="literal">incanter-charts</code> provides a large number of visualization capabilities. <code class="literal">incanter-core</code> provides the most fundamental and generally useful functions for transforming data.</p><p class="calibre11">Each module can be included separately in your own code. For access to stats, charts, and Excel features, you could include the following in your <code class="literal">project.clj</code>:</p><div class="calibre2"><pre class="programlisting">  :dependencies [[incanter/incanter-core "1.5.5"]
                 [incanter/incanter-stats "1.5.5"]
                 [incanter/incanter-charts "1.5.5"]
                 [incanter/incanter-excel "1.5.5"]
                 ...]</pre></div><p class="calibre11">If you don't mind including more libraries than you need, you can simply include the full Incanter distribution instead:</p><div class="calibre2"><pre class="programlisting">:dependencies [[incanter/incanter "1.5.5"]
               ...]</pre></div><p class="calibre11">At Incanter's core is the concept of a dataset—a structure of rows and columns. If you have experience with relational databases, you can think of a dataset as a table. Each column in a dataset is named, and each row in the dataset has the same number of columns as every other. There are a several ways to load data into an Incanter dataset, and which we use will depend how our data is stored:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">If our data is a text file (a CSV or tab-delimited file), we can use the <code class="literal">read-dataset</code> function from <code class="literal">incanter-io</code></li><li class="listitem">If our data is an Excel file (for example, an <code class="literal">.xls</code> or <code class="literal">.xlsx</code> file), we can use the <code class="literal">read-xls</code> function from <code class="literal">incanter-excel</code></li><li class="listitem">For any other data source (an external database, website, and so on), as long as we can get our data into a Clojure data structure we can create a dataset with the <code class="literal">dataset</code> function in <code class="literal">incanter-core</code></li></ul></div><p class="calibre11">This chapter makes use of Excel data sources, so we'll be using <code class="literal">read-xls</code>. The function takes one required argument—the file to load—and an optional keyword argument specifying the sheet number or name. All of our examples have only one sheet, so we'll just provide the file argument as string:</p><div class="calibre2"><pre class="programlisting">(ns cljds.ch1.data
  (:require [clojure.java.io :as io]
            [incanter.core :as i]
            [incanter.excel :as xls]))</pre></div><p class="calibre11">In general, we will <a id="id11" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>not reproduce the namespace declarations from the example code. This is both for brevity and because the required namespaces can usually be inferred by the symbol used to reference them. For example, throughout this book we will always refer to <code class="literal">clojure.java.io</code> as <code class="literal">io</code>, <code class="literal">incanter.core</code> as <code class="literal">I</code>, and <code class="literal">incanter.excel</code> as <code class="literal">xls</code> wherever they are used.</p><p class="calibre11">We'll be loading several data sources throughout this chapter, so we've created a multimethod called <code class="literal">load-data</code> in the <code class="literal">cljds.ch1.data</code> namespace:</p><div class="calibre2"><pre class="programlisting">(defmulti load-data identity)

(defmethod load-data :uk [_]
  (-&gt; (io/resource "UK2010.xls")
      (str)
      (xls/read-xls)))</pre></div><p class="calibre11">In the preceding code, we define the <code class="literal">load-data</code> multimethod that dispatches on the <code class="literal">identity</code> of the first argument. We also define the implementation that will be called if the first argument is <code class="literal">:uk</code>. Thus, a call to <code class="literal">(load-data :uk)</code> will return an Incanter dataset containing the UK data. Later in the chapter, we'll define additional <code class="literal">load-data</code> implementations for other datasets.</p><p class="calibre11">The first row of the <code class="literal">UK2010.xls</code> spreadsheet contains column names. Incanter's <code class="literal">read-xls</code> function will preserve these as the column names of the returned dataset. Let's begin our exploration of the data by inspecting them now—the <code class="literal">col-names</code> function in <code class="literal">incanter.core</code> returns the column names as a vector. In the following code (and throughout the book, where we use functions from the <code class="literal">incanter.core</code> namespace) we require it as <code class="literal">i</code>:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-1 []
  (i/col-names (load-data :uk)))</pre></div><p class="calibre11">As described in running the examples earlier, functions beginning with <code class="literal">ex-</code> can be run on the command line with Leiningen like this:</p><div class="calibre2"><pre class="programlisting">
<span class="strong1"><strong class="calibre12">lein run –e 1.1</strong></span>
</pre></div><p class="calibre11">The output of the preceding command should be the following Clojure vector:</p><div class="calibre2"><pre class="programlisting">["Press Association Reference" "Constituency Name" "Region" "Election Year" "Electorate" "Votes" "AC" "AD" "AGS" "APNI" "APP" "AWL" "AWP" "BB" "BCP" "Bean" "Best" "BGPV" "BIB" "BIC" "Blue" "BNP" "BP Elvis" "C28" "Cam Soc" "CG" "Ch M" "Ch P" "CIP" "CITY" "CNPG" "Comm" "Comm L" "Con" "Cor D" "CPA" "CSP" "CTDP" "CURE" "D Lab" "D Nat" "DDP" "DUP" "ED" "EIP" "EPA" "FAWG" "FDP" "FFR" "Grn" "GSOT" "Hum" "ICHC" "IEAC" "IFED" "ILEU" "Impact" "Ind1" "Ind2" "Ind3" "Ind4" "Ind5" "IPT" "ISGB" "ISQM" "IUK" "IVH" "IZB" "JAC" "Joy" "JP" "Lab" "Land" "LD" "Lib" "Libert" "LIND" "LLPB" "LTT" "MACI" "MCP" "MEDI" "MEP" "MIF" "MK" "MPEA" "MRLP" "MRP" "Nat Lib" "NCDV" "ND" "New" "NF" "NFP" "NICF" "Nobody" "NSPS" "PBP" "PC" "Pirate" "PNDP" "Poet" "PPBF" "PPE" "PPNV" "Reform" "Respect" "Rest" "RRG" "RTBP" "SACL" "Sci" "SDLP" "SEP" "SF" "SIG" "SJP" "SKGP" "SMA" "SMRA" "SNP" "Soc" "Soc Alt" "Soc Dem" "Soc Lab" "South" "Speaker" "SSP" "TF" "TOC" "Trust" "TUSC" "TUV" "UCUNF" "UKIP" "UPS" "UV" "VCCA" "Vote" "Wessex Reg" "WRP" "You" "Youth" "YRDPL"]</pre></div><p class="calibre11">This is a very wide <a id="id12" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dataset. The first six columns in the data file are described as follows; subsequent columns break the number of votes down by party:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><span class="strong1"><strong class="calibre12">Press Association Reference</strong></span>: This is a number identifying the constituency (voting district, represented by one MP)</li><li class="listitem"><span class="strong1"><strong class="calibre12">Constituency Name</strong></span>: This is the common name given to the voting district</li><li class="listitem"><span class="strong1"><strong class="calibre12">Region</strong></span>: This is the geographic region of the UK where the constituency is based</li><li class="listitem"><span class="strong1"><strong class="calibre12">Election Year</strong></span>: This is the year in which the election was held</li><li class="listitem"><span class="strong1"><strong class="calibre12">Electorate</strong></span>: This is the total number of people eligible to vote in the constituency</li><li class="listitem"><span class="strong1"><strong class="calibre12">Votes</strong></span>: This is the total number of votes cast</li></ul></div><p class="calibre11">Whenever we're confronted with new data, it's important to take time to understand it. In the absence of detailed data definitions, one way we could do this is to begin by validating our assumptions about the data. For example, we expect that this dataset contains information about the 2010 election so let's review the contents of the <code class="literal">Election Year</code> column.</p><p class="calibre11">Incanter provides the <code class="literal">i/$</code> function (<code class="literal">i</code>, as before, signifying the <code class="literal">incanter.core</code> namespace) for selecting columns from a dataset. We'll encounter the function regularly throughout this chapter—it's Incanter's primary way of selecting columns from a variety of data representations and it provides several different arities. For now, we'll be providing just the name of the column we'd like to extract and the dataset from which to extract it:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-2 []
  (i/$ "Election Year" (load-data :uk)))

;; (2010.0 2010.0 2010.0 2010.0 2010.0 ... 2010.0 2010.0 nil)</pre></div><p class="calibre11">The years are returned as a single sequence of values. The output may be hard to interpret since the dataset contains <a id="id13" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>so many rows. As we'd like to know which unique values the column contains, we can use the Clojure core function <code class="literal">distinct</code>. One of the advantages of using Incanter is that its useful data manipulation functions augment those that Clojure already provides as shown in the following example:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-3 []
  (-&gt;&gt; (load-data :uk)
       (i/$ "Election Year")
       (distinct)))

;; (2010 nil)</pre></div><p class="calibre11">The <code class="literal">2010</code> year goes a long way to confirming our expectations that this data is from <code class="literal">2010</code>. The <code class="literal">nil</code> value is unexpected, though, and may indicate a problem with our data.</p><p class="calibre11">We don't yet know how many nils exist in the dataset and determining this could help us decide what to do next. A simple way of counting values such as this it to use the core library function <code class="literal">frequencies</code>, which returns a map of values to counts:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-4 [ ]
  (-&gt;&gt; (load-data :uk)
       (i/$ "Election Year")
       (frequencies)))

;; {2010.0 650 nil 1}</pre></div><p class="calibre11">In the preceding examples, we used Clojure's thread-last macro <code class="literal">-&gt;&gt;</code> to chain a several functions together for legibility.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="tip04" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre22">Along with Clojure's large core library of data manipulation functions, macros such as the one discussed earlier—including the thread-last macro <code class="literal">-&gt;&gt;</code>—are other great reasons for using Clojure to analyze data. Throughout this book, we'll see how Clojure can make even sophisticated analysis concise and comprehensible.</p></div></div><p class="calibre11">It wouldn't take us long <a id="id14" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>to confirm that in 2010 the UK had 650 electoral districts, known as constituencies. Domain knowledge such as this is invaluable when sanity-checking new data. Thus, it's highly probable that the <code class="literal">nil</code> value is extraneous and can be removed. We'll see how to do this in the next section.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Data scrubbing"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec12" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Data scrubbing</h1></div></div></div><p class="calibre11">It is a commonly repeated statistic that at least 80 percent of a data scientist's work is data scrubbing. This is the <a id="id15" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>process of detecting potentially corrupt or incorrect data and either correcting or filtering it out.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note04" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Data scrubbing is one of the most important (and time-consuming) aspects of working with data. It's a key step to ensuring that subsequent analysis is performed on data that is valid, accurate, and consistent.</p></div></div><p class="calibre11">The <code class="literal">nil</code> value at the <a id="id16" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>end of the election year column may indicate dirty data that ought to be removed. We've already seen that filtering <span class="strong1"><em class="calibre13">columns</em></span> of data can be accomplished with Incanter's <code class="literal">i/$</code> function. For filtering <span class="strong1"><em class="calibre13">rows</em></span> of data we can use Incanter's <code class="literal">i/query-dataset</code> function.</p><p class="calibre11">We let Incanter know which rows we'd like it to filter by passing a Clojure map of column names and predicates. Only rows for which all predicates return true will be retained. For example, to select only the <code class="literal">nil</code> values from our dataset:</p><div class="calibre2"><pre class="programlisting">(-&gt; (load-data :uk)
    (i/query-dataset {"Election Year" {:$eq nil}}))</pre></div><p class="calibre11">If you know SQL, you'll notice this is very similar to a <code class="literal">WHERE</code> clause. In fact, Incanter also provides the <code class="literal">i/$where</code> function, an alias to <code class="literal">i/query-dataset</code> that reverses the order of the arguments.</p><p class="calibre11">The query is a map of column names to predicates and each predicate is itself a map of operator to operand. Complex queries can be constructed by specifying multiple columns and multiple operators together. Query operators include:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">:$gt</code> greater than</li><li class="listitem"><code class="literal">:$lt</code> less than</li><li class="listitem"><code class="literal">:$gte</code> greater than or equal to</li><li class="listitem"><code class="literal">:$lte</code> less than or equal to</li><li class="listitem"><code class="literal">:$eq</code> equal to</li><li class="listitem"><code class="literal">:$ne</code> not equal to</li><li class="listitem"><code class="literal">:$in</code> to test for membership of a collection</li><li class="listitem"><code class="literal">:$nin</code> to test for non-membership of a collection</li><li class="listitem"><code class="literal">:$fn</code> a predicate function that should return a true response for rows to keep</li></ul></div><p class="calibre11">If none of the built-in operators suffice, the last operator provides the ability to pass a custom function instead.</p><p class="calibre11">We'll continue to use Clojure's thread-last macro to make the code intention a little clearer, and return the <a id="id17" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>row as a map of keys and values using the <code class="literal">i/to-map</code> <a id="id18" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-5 []
  (-&gt;&gt; (load-data :uk)
       (i/$where {"Election Year" {:$eq nil}})
       (i/to-map)))

;; {:ILEU nil, :TUSC nil, :Vote nil ... :IVH nil, :FFR nil}</pre></div><p class="calibre11">Looking at the results carefully, it's apparent that all (but one) of the columns in this row are <code class="literal">nil</code>. In fact, a bit of further exploration confirms that the non-nil row is a summary total and ought to be removed from the data. We can remove the problematic row by updating the predicate map to use the <code class="literal">:$ne</code> operator, returning only rows where the election year is not equal to <code class="literal">nil</code>:</p><div class="calibre2"><pre class="programlisting">(-&gt;&gt; (load-data :uk)
      (i/$where {"Election Year" {:$ne nil}}))</pre></div><p class="calibre11">The preceding function is one we'll almost always want to make sure we call in advance of using the data. One way of doing this is to add another implementation of our <code class="literal">load-data</code> multimethod, which also includes this filtering step:</p><div class="calibre2"><pre class="programlisting">(defmethod load-data :uk-scrubbed [_]
  (-&gt;&gt; (load-data :uk)
       (i/$where {"Election Year" {:$ne nil}})))</pre></div><p class="calibre11">Now with any code we write, can choose whether to refer to the <code class="literal">:uk </code>or <code class="literal">:uk-scrubbed</code> datasets.</p><p class="calibre11">By always loading the source file and performing our scrubbing on top, we're preserving an audit trail of the transformations we've applied. This makes it clear to us—and future readers of our code—what adjustments have been made to the source. It also means that, should we need to re-run <a id="id19" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>our analysis with new source data, we may be able to <a id="id20" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>just load the new file in place of the existing file.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Descriptive statistics"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec13" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Descriptive statistics</h1></div></div></div><p class="calibre11">Descriptive <a id="id21" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>statistics are numbers that are used to summarize and describe data. In the next chapter, we'll turn our attention to a more sophisticated analysis, the so-called <span class="strong1"><strong class="calibre12">inferential statistics</strong></span>, but for now we'll limit ourselves to simply describing what <a id="id22" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>we can observe about the data contained in the file.</p><p class="calibre11">To demonstrate what <a id="id23" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>we mean, let's look at the <code class="literal">Electorate</code> column of the data. This column lists the total number of registered voters in each constituency:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-6 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$ "Electorate")
       (count)))

;; 650</pre></div><p class="calibre11">We've filtered the <code class="literal">nil</code> field from the dataset; the preceding code should return a list of <code class="literal">650</code> numbers corresponding to the electorate in each of the UK constituencies.</p><p class="calibre11">Descriptive statistics, also called <span class="strong1"><strong class="calibre12">summary statistics</strong></span>, are ways of measuring attributes of sequences of numbers. They <a id="id24" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>help characterize the sequence and can act as a guide for further analysis. Let's start by calculating the two most basic statistics that we can from a sequence of numbers—its mean and its variance.</p><div class="calibre2" title="The mean"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec08" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The mean</h2></div></div></div><p class="calibre11">The most common way of measuring the average of a data set is with the mean. It's actually one of several <a id="id25" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>ways of measuring the <span class="strong1"><strong class="calibre12">central tendency</strong></span> of the data. The mean, or more precisely, the arithmetic mean, is a straightforward calculation—simply add up the values and divide by the count—but in spite of this it has a somewhat intimidating mathematical notation:</p><div class="mediaobject"><img src="Images/7180OS_01_01.jpg" alt="The mean" class="calibre23"/></div><p class="calibre11">where <span class="inlinemediaobject"><img src="Images/7180OS_01_02.jpg" alt="The mean" class="calibre24"/></span> is pronounced <span class="strong1"><em class="calibre13">x-bar</em></span>, the mathematical symbol often used to denote the mean.</p><p class="calibre11">To programmers coming to data science from fields outside mathematics or the sciences, this notation can be quite <a id="id26" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>confusing and alienating. Others may be entirely comfortable with this notation, and they can safely skip the next section.</p></div><div class="calibre2" title="Interpreting mathematical notation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec09" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Interpreting mathematical notation</h2></div></div></div><p class="calibre11">Although mathematical notation may appear obscure and upsetting, there are really only a handful of symbols that will occur frequently in the formulae in this book.</p><p class="calibre11">
<span class="strong1"><em class="calibre13">Σ</em></span> is pronounced <span class="strong1"><em class="calibre13">sigma</em></span> and means <span class="strong1"><em class="calibre13">sum</em></span>. When you see it in mathematical notation it means that a sequence is being added up. The symbols above and below the <span class="strong1"><em class="calibre13">sigma</em></span> indicate the range over which we'll be summing. They're rather like a C-style <code class="literal">for</code> loop and in the earlier formula indicate we'll be summing from <span class="strong1"><em class="calibre13">i=1</em></span> up to <span class="strong1"><em class="calibre13">i=n</em></span>. By convention <span class="strong1"><em class="calibre13">n</em></span> is the length of the sequence, and sequences in mathematical notation are one-indexed, not zero-indexed, so summing from <span class="strong1"><em class="calibre13">1</em></span> to <span class="strong1"><em class="calibre13">n</em></span> means that we're summing over the entire length of the sequence.</p><p class="calibre11">The expression immediately following the sigma is the sequence to be summed. In our preceding formula for the mean, <span class="strong1"><em class="calibre13">x</em></span><sub class="calibre25">i</sub> immediately follows the sigma. Since <span class="strong1"><em class="calibre13">i</em></span> will represent each index from <span class="strong1"><em class="calibre13">1</em></span> up to <span class="strong1"><em class="calibre13">n</em></span>, <span class="strong1"><em class="calibre13">x</em></span><sub class="calibre25">i</sub> represents each element in the sequence of <span class="strong1"><em class="calibre13">xs</em></span>.</p><p class="calibre11">Finally, <span class="inlinemediaobject"><img src="Images/7180OS_01_03.jpg" alt="Interpreting mathematical notation" class="calibre26"/></span> appears just before the sigma, indicating that the entire expression should be multiplied by <span class="strong1"><em class="calibre13">1</em></span> divided by <span class="strong1"><em class="calibre13">n</em></span> (also called the <span class="strong1"><strong class="calibre12">reciprocal of n</strong></span>). This can be simplified to just dividing by <span class="strong1"><em class="calibre13">n</em></span>.</p><div class="informaltable"><table border="1" class="calibre27"><colgroup class="calibre28"><col class="calibre29"/><col class="calibre29"/><col class="calibre29"/></colgroup><thead class="calibre30"><tr class="calibre31"><th valign="bottom" class="calibre32">
<p class="calibre19">Name</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Mathematical symbol</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Clojure equivalent</p>
</th></tr></thead><tbody class="calibre33"><tr class="calibre34"><td class="calibre35"> </td><td class="calibre35">
<p class="calibre19">
<span class="strong1"><em class="calibre13">n</em></span>
</p>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">(count xs)</code>
</p>
</td></tr><tr class="calibre36"><td class="calibre35">
<p class="calibre19">Sigma notation</p>
</td><td class="calibre35">
<div class="mediaobject"><img src="Images/7180OS_01_04.jpg" alt="Interpreting mathematical notation" class="calibre37"/></div>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">(reduce + xs)</code>
</p>
</td></tr><tr class="calibre38"><td class="calibre35">
<p class="calibre19">Pi notation</p>
</td><td class="calibre35">
<div class="mediaobject"><img src="Images/7180OS_01_05.jpg" alt="Interpreting mathematical notation" class="calibre39"/></div>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">(reduce * xs)</code>
</p>
</td></tr></tbody></table></div><p class="calibre11">Putting this all together, we get "add up the elements in the sequence from the first to the last and divide by the count". In Clojure, this can be written as:</p><div class="calibre2"><pre class="programlisting">(defn mean [xs]
  (/ (reduce + xs)
     (count xs)))</pre></div><p class="calibre11">Where <code class="literal">xs</code> stands for "the sequence of <span class="strong1"><em class="calibre13">xs</em></span>". We can use our new <code class="literal">mean</code> function to calculate the mean of the UK electorate:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-7 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$ "Electorate")
       (mean)))

;; 70149.94</pre></div><p class="calibre11">In fact, Incanter <a id="id27" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>already includes a function, <code class="literal">mean</code>, to calculate the mean of a sequence very efficiently in the <code class="literal">incanter.stats</code> namespace. In this chapter (and throughout the book), the <code class="literal">incanter.stats</code> namespace will be required as <code class="literal">s</code> wherever it's used.</p></div><div class="calibre2" title="The median"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec10" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The median</h2></div></div></div><p class="calibre11">The median is another common descriptive statistic for measuring the central tendency of a sequence. If you <a id="id28" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>ordered all the data from lowest to highest, the median is the middle value. If there is an even number of data points in the sequence, the median is usually defined as the mean of the middle two values.</p><p class="calibre11">The median is often represented in formulae by <span class="inlinemediaobject"><img src="Images/7180OS_01_06.jpg" alt="The median" class="calibre40"/></span>, pronounced <span class="strong1"><em class="calibre13">x-tilde</em></span>. It's one of the deficiencies of mathematical notation that there's no particularly standard way of expressing the formula <a id="id29" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>for the median value, but nonetheless it's fairly straightforward in Clojure:</p><div class="calibre2"><pre class="programlisting">(defn median [xs]
  (let [n   (count xs)
        mid (int (/ n 2))]
    (if (odd? n)
      (nth (sort xs) mid)
      (-&gt;&gt; (sort xs)
           (drop (dec mid))
           (take 2)
           (mean)))))</pre></div><p class="calibre11">The median of the UK electorate is:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-8 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$ "Electorate")
       (median)))

;; 70813.5</pre></div><p class="calibre11">Incanter also has a function for calculating the median value as <code class="literal">s/median</code>.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Variance"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec14" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Variance</h1></div></div></div><p class="calibre11">The mean and the <a id="id30" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>median are two alternative ways of describing the middle value of a sequence, but on their own they tell you very little about the values contained within it. For example, if we know the mean of a sequence of ninety-nine values is 50, we can still say very little about what values the sequence contains.</p><p class="calibre11">It may contain all the integers from one to ninety-nine, or forty-nine zeros and fifty ninety-nines. Maybe it contains negative one ninety-eight times and a single five-thousand and forty-eight. Or perhaps all the values are exactly fifty.</p><p class="calibre11">The variance of a sequence is its "spread" about the mean, and each of the preceding examples would have a different variance. In mathematical notation, the variance is expressed as:</p><div class="mediaobject"><img src="Images/7180OS_01_07.jpg" alt="Variance" class="calibre41"/></div><p class="calibre11">where <span class="strong1"><em class="calibre13">s</em></span><sup class="calibre42">2</sup> is the mathematical symbol often used to denote the variance.</p><p class="calibre11">This equation bears a number of similarities to the equation for the mean calculated previously. Instead of summing a single value, <span class="strong1"><em class="calibre13">x</em></span><sub class="calibre25">i</sub>, we are summing a function of <span class="inlinemediaobject"><img src="Images/7180OS_01_08.jpg" alt="Variance" class="calibre43"/></span>. Recall that the symbol <span class="inlinemediaobject"><img src="Images/7180OS_01_02.jpg" alt="Variance" class="calibre24"/></span> represents the mean value, so the function calculates the squared deviation of <span class="strong1"><em class="calibre13">xi</em></span> from the mean of all the <span class="strong1"><em class="calibre13">xs</em></span>.</p><p class="calibre11">We can turn the expression <span class="inlinemediaobject"><img src="Images/7180OS_01_08.jpg" alt="Variance" class="calibre43"/></span> into a function, <code class="literal">square-deviation</code>, that we map over the sequence of <code class="literal">xs</code>. We can also make use of the <code class="literal">mean</code> function we've already created to sum the <a id="id31" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>values in the sequence and divide by the count.</p><div class="calibre2"><pre class="programlisting">(defn variance [xs]
  (let [x-bar (mean xs)
        n     (count xs)
        square-deviation (fn [x]
                           (i/sq (- x x-bar)))]
    (mean (map square-deviation xs))))</pre></div><p class="calibre11">We're using Incanter's <code class="literal">i/sq</code> function to calculate the square of our expression.</p><p class="calibre11">Since we've squared the deviation before taking the mean, the units of variance are also squared, so the units of the variance of the UK electorate are "people squared". This is somewhat unnatural to reason about. We can make the units more natural by taking the square root of the variance <a id="id32" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>so the units are "people" again, and the result is called the <span class="strong1"><strong class="calibre12">standard deviation</strong></span>:</p><div class="calibre2"><pre class="programlisting">(defn standard-deviation [xs]
  (i/sqrt (variance xs)))

(defn ex-1-9 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$ "Electorate")
       (standard-deviation)))

;; 7672.77</pre></div><p class="calibre11">Incanter's implements <a id="id33" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>functions to calculate the variance and standard deviation as <code class="literal">s/variance</code> and <code class="literal">s/sd</code> respectively.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Quantiles"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec15" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Quantiles</h1></div></div></div><p class="calibre11">The median is one <a id="id34" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>way to calculate the <span class="strong1"><em class="calibre13">middle</em></span> value from a list, and the variance provides a way to measure the spread of the data about this midpoint. If the entire spread of data were represented on a scale of zero to one, the median would be the value at 0.5.</p><p class="calibre11">For example, consider the following sequence of numbers:</p><div class="calibre2"><pre class="programlisting">[10 11 15 21 22.5 28 30]</pre></div><p class="calibre11">There are seven numbers in the sequence, so the median is the fourth, or 21. This is also referred to as the 0.5 quantile. We can get a richer picture of a sequence of numbers by looking at the 0, 0.25, 0.5, 0.7, and 1.0 quantiles. Taken together, these numbers will not only show the median, but will also summarize the range of the data and how the numbers are distributed within it. They're sometimes referred to as the <span class="strong1"><em class="calibre13">five-number summary</em></span>.</p><p class="calibre11">One way to calculate the five-number summary for the UK electorate data is shown as follows:</p><div class="calibre2"><pre class="programlisting">(defn quantile [q xs]
  (let [n (dec (count xs))
        i (-&gt; (* n q)
              (+ 1/2)
              (int))]
    (nth (sort xs) i)))

(defn ex-1-10 []
  (let [xs (-&gt;&gt; (load-data :uk-scrubbed)
                (i/$ "Electorate"))
        f (fn [q]
            (quantile q xs))]
    (map f [0 1/4 1/2 3/4 1])))

;; (21780.0 66219.0 70991.0 75115.0 109922.0)</pre></div><p class="calibre11">Quantiles can also be calculated in Incanter directly with the <code class="literal">s/quantile</code> function. A sequence of desired quantiles is passed as the keyword argument <code class="literal">:probs</code>.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note05" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Incanter's <code class="literal">quantile</code> function uses a variant of the algorithm shown earlier called the <span class="strong1"><strong class="calibre12">phi-quantile</strong></span>, which performs linear interpolation between consecutive numbers in <a id="id35" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>certain cases. There are many alternative ways of <a id="id36" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>calculating quantiles—consult <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://en.wikipedia.org/wiki/Quantile">https://en.wikipedia.org/wiki/Quantile</a> for a discussion of the differences.</p></div></div><p class="calibre11">Where quantiles split the range <a id="id37" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>into four equal ranges as earlier, they are called <span class="strong1"><strong class="calibre12">quartiles</strong></span>. The difference <a id="id38" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>between the lower and upper quartile is referred to as the <span class="strong1"><strong class="calibre12">interquartile </strong></span><a id="id39" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><span class="strong1"><strong class="calibre12">range</strong></span>, also often abbreviated to just <span class="strong1"><strong class="calibre12">IQR</strong></span>. Like the variance about the mean, the IQR gives a measure of the spread of the data about the median.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Binning data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec16" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Binning data</h1></div></div></div><p class="calibre11">To develop an intuition for what these various calculations of variance are measuring, we can employ a technique <a id="id40" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>called <span class="strong1"><strong class="calibre12">binning</strong></span>. Where data is continuous, using <code class="literal">frequencies</code> (as we did with the election data to count the nils) is not practical since no two values may be the same. However, it's possible to get a broad sense of the structure of the data by grouping the data into discrete intervals.</p><p class="calibre11">The process of binning is to divide the range of values into a number of consecutive, equally-sized, smaller bins. Each value in the original series falls into exactly one bin. By counting the number of points falling into each bin, we can get a sense of the spread of the data:</p><div class="mediaobject"><img src="Images/7180OS_01_100.jpg" alt="Binning data" class="calibre44"/></div><p class="calibre11">The preceding illustration shows fifteen values of <span class="strong1"><em class="calibre13">x</em></span> split into five equally-sized bins. By counting the number of points falling into each bin we can clearly see that most points fall in the middle bin, with fewer points falling into the bins towards the edges. We can achieve the same in Clojure with the following <code class="literal">bin</code> function:</p><div class="calibre2"><pre class="programlisting">(defn bin [n-bins xs]
  (let [min-x    (apply min xs)
        max-x    (apply max xs)
        range-x  (- max-x min-x)
        bin-fn   (fn [x]
                   (-&gt; x
                       (- min-x)
                       (/ range-x)
                       (* n-bins)
                       (int)
                       (min (dec n-bins))))]
    (map bin-fn xs)))</pre></div><p class="calibre11">For example, we can bin range 0-14 into <code class="literal">5</code> bins like so:</p><div class="calibre2"><pre class="programlisting">(bin 5 (range 15))

;; (0 0 0 1 1 1 2 2 2 3 3 3 4 4 4)</pre></div><p class="calibre11">Once we've binned the values we can then use the <code class="literal">frequencies</code> function once again to count the number of points <a id="id41" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>in each bin. In the following code, we use the function to split the UK electorate data into five bins:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-11 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$ "Electorate")
       (bin 10)
       (frequencies)))

;; {1 26, 2 450, 3 171, 4 1, 0 2}</pre></div><p class="calibre11">The count of points in the extremal bins (0 and 4) is much lower than the bins in the middle—the counts seem to rise up towards the median and then down again. In the next section, we'll visualize the shape of these counts.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Histograms"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec17" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Histograms</h1></div></div></div><p class="calibre11">A histogram is one <a id="id42" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>way to visualize the distribution of a single sequence of values. Histograms simply take a continuous distribution, bin it, and plot the frequencies of points falling into each bin as a bar. The height of each bar in the histogram represents how many points in the data are contained in that bin.</p><p class="calibre11">We've already seen how to bin data ourselves, but <code class="literal">incanter.charts</code> contains a <code class="literal">histogram</code> function that will bin the data and visualize it as a histogram in two steps. We require <code class="literal">incanter.charts</code> as <code class="literal">c</code> in this chapter (and throughout the book).</p><div class="calibre2"><pre class="programlisting">(defn ex-1-12 []
  (-&gt; (load-data :uk-scrubbed)
      (i/$ "Electorate")
      (c/histogram)
      (i/view)))</pre></div><p class="calibre11">The preceding code generates the following chart:</p><div class="mediaobject"><img src="Images/7180OS_01_110.jpg" alt="Histograms" class="calibre45"/></div><p class="calibre11">We can configure <a id="id43" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the number of bins data is segmented into by passing the keyword argument <code class="literal">:nbins</code> as the second parameter to the histogram function:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-13 []
  (-&gt; (uk-electorate)
      (c/histogram :nbins 200)
      (i/view)))</pre></div><p class="calibre11">The preceding graph shows a single, high peak but expresses the shape of the data quite crudely. The following graph shows fine detail, but the volume of the bars obscures the shape of the distribution, particularly in the tails:</p><div class="mediaobject"><img src="Images/7180OS_01_120.jpg" alt="Histograms" class="calibre45"/></div><p class="calibre11">Choosing the number of bins to represent your data is a fine balance—too few bins and the shape of the data <a id="id44" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>will only be crudely represented, too many and noisy features may obscure the underlying structure.</p><div class="calibre2"><pre class="programlisting">(defn ex-1-14 []
  (-&gt; (i/$ "Electorate" (load-data :uk-scrubbed))
      (c/histogram :x-label "UK electorate"
                   :nbins 20)
      (i/view)))</pre></div><p class="calibre11">The following shows <a id="id45" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>a histogram of <code class="literal">20</code> bars instead:</p><div class="mediaobject"><img src="Images/7180OS_01_130.jpg" alt="Histograms" class="calibre45"/></div><p class="calibre11">This final chart containing <code class="literal">20</code> bins seems to be the best representation for this data so far.</p><p class="calibre11">Along with the mean and the median, the <span class="strong1"><em class="calibre13">mode</em></span> is another way of measuring the average value of a sequence—it's defined as the most frequently occurring value in the sequence. The mode is strictly only defined for sequences with at least one duplicated value; for many distributions, this is not the case and the mode is undefined. Nonetheless, the peak of the histogram is often referred to as the mode, since it corresponds to the most popular bin.</p><p class="calibre11">We can clearly see that the distribution is quite symmetrical about the mode, with values falling sharply either <a id="id46" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>side along shallow tails. This is data following an approximately normal distribution.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="The normal distribution"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec18" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The normal distribution</h1></div></div></div><p class="calibre11">A histogram will <a id="id47" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>tell you approximately how data is distributed throughout its range, and provide a visual means of classifying your data into one of a handful of common distributions. Many distributions occur frequently in data analysis, but none so <a id="id48" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>much as the normal distribution, also called the <span class="strong1"><strong class="calibre12">Gaussian distribution</strong></span>.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note06" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">The distribution is named the normal distribution because of how often it occurs in nature. Galileo noticed that the errors in his astronomical measurements followed a distribution where small deviations from the mean occurred more frequently than large deviations. It was the great mathematician Gauss' contribution to describing the mathematical shape of these errors that led to the distribution also being called the Gaussian distribution in his honor.</p></div></div><p class="calibre11">A distribution is like a compression algorithm: it allows a potentially large amount of data to be summarized very efficiently. The normal distribution requires just two parameters from which the rest of the data can be approximated—the mean and the standard deviation.</p><div class="calibre2" title="The central limit theorem"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec11" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The central limit theorem</h2></div></div></div><p class="calibre11">The reason for the <a id="id49" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>normal distribution's ubiquity is partly explained by the central limit theorem. Values generated from diverse distributions will tend to converge to the normal distribution under certain circumstances, as we will show next.</p><p class="calibre11">A common distribution in <a id="id50" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>programming is the <span class="strong1"><em class="calibre13">uniform</em></span> distribution. This is the distribution of numbers generated by Clojure's <code class="literal">rand</code> function: for a fair random number generator, all numbers have an equal chance of being generated. We can visualize this on a histogram by generating a random number between zero and one many times over and plotting the results.</p><div class="calibre2"><pre class="programlisting">(defn ex-1-15 []
  (let [xs (-&gt;&gt; (repeatedly rand)
                (take 10000))]
    (-&gt; (c/histogram xs
                     :x-label "Uniform distribution"
                     :nbins 20)
        (i/view))))</pre></div><p class="calibre11">The preceding <a id="id51" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>code will generate the following histogram:</p><div class="mediaobject"><img src="Images/7180OS_01_140.jpg" alt="The central limit theorem" class="calibre45"/></div><p class="calibre11">Each bar of the histogram is approximately the same height, corresponding to the equal probability of generating a number that falls into each bin. The bars aren't exactly the same height since the uniform distribution describes the theoretical output that our random sampling can't <a id="id52" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>mirror precisely. Over the next several chapters, we'll learn ways to precisely quantify the difference between theory and practice to determine whether the differences are large enough to be concerned with. In this case, they are not.</p><p class="calibre11">If instead we generate <a id="id53" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>a histogram of the means of sequences of <a id="id54" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>numbers, we'll end up with a distribution that looks rather different.</p><div class="calibre2"><pre class="programlisting">(defn ex-1-16 []
  (let [xs (-&gt;&gt; (repeatedly rand)
                (partition 10)
                (map mean)
                (take 10000))]
    (-&gt; (c/histogram xs
                     :x-label "Distribution of means"
                     :nbins 20)
        (i/view))))</pre></div><p class="calibre11">The preceding code will provide an output similar to the following histogram:</p><div class="mediaobject"><img src="Images/7180OS_01_150.jpg" alt="The central limit theorem" class="calibre45"/></div><p class="calibre11">Although it's not impossible for the mean to be close to zero or one, it's exceedingly improbable and grows less probable as both the number of averaged numbers and the number of sampled averages grow. In fact, the output is exceedingly close to the normal distribution.</p><p class="calibre11">This outcome—where the average effect of many small random fluctuations leads to the normal distribution—is <a id="id55" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>called the <span class="strong1"><strong class="calibre12">central limit theorem</strong></span>, sometimes abbreviated to <span class="strong1"><strong class="calibre12">CLT</strong></span>, and goes a long way towards explaining why the normal distribution <a id="id56" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>occurs so frequently in natural phenomena.</p><p class="calibre11">The central limit theorem wasn't named until the 20<sup class="calibre42">th</sup> century, although the effect had been documented as early as 1733 by the French mathematician Abraham de Moivre, who used the normal distribution to approximate the number of heads resulting from tosses of a fair coin. The outcome of coin tosses is best modeled with the binomial distribution, which we will introduce in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch04.xhtml" title="Chapter 4. Classification">Chapter 4</a>, <span class="strong1"><em class="calibre13">Classification</em></span>. While the central limit theorem provides a way to generate samples from an approximate normal distribution, Incanter's <code class="literal">distributions</code> namespace provides functions for generating samples efficiently from a variety of distributions, including the normal:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-17 []
  (let [distribution (d/normal-distribution)
        xs (-&gt;&gt; (repeatedly #(d/draw distribution))
                (take 10000))]
    (-&gt; (c/histogram xs
                     :x-label "Normal distribution"
                     :nbins 20)
        (i/view))))</pre></div><p class="calibre11">The preceding code generates the following histogram:</p><div class="mediaobject"><img src="Images/7180OS_01_155.jpg" alt="The central limit theorem" class="calibre45"/></div><p class="calibre11">The <code class="literal">d/draw</code> function will return one sample from the supplied distribution. The default mean and standard <a id="id57" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>deviation from <code class="literal">d/normal-distribution</code> are zero and one respectively.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Poincaré's baker"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec19" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Poincaré's baker</h1></div></div></div><p class="calibre11">There's a story that, while <a id="id58" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>almost certainly apocryphal, allows us to look in more detail at the way in which the central limit theorem allows us to reason about how distributions are formed. It concerns the celebrated nineteenth century French polymath Henri Poincaré who, so the story goes, weighed his bread every day for a year.</p><p class="calibre11">Baking was a regulated profession, and Poincaré discovered that, while the weights of the bread followed a normal distribution, the peak was at 950g rather than the advertised 1kg. He reported his baker to the authorities and so the baker was fined.</p><p class="calibre11">The next year, Poincaré continued to weigh his bread from the same baker. He found the mean value was now 1kg, but that the distribution was no longer symmetrical around the mean. The distribution was skewed to the right, consistent with the baker giving Poincaré only the heaviest of his loaves. Poincaré reported his baker to the authorities once more and his baker was fined a second time.</p><p class="calibre11">Whether the story is true <a id="id59" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>or not needn't concern us here; it's provided simply to illustrate a key point—the distribution of a sequence of numbers can tell us something important about the process that generated it.</p><div class="calibre2" title="Generating distributions"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec12" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Generating distributions</h2></div></div></div><p class="calibre11">To develop our <a id="id60" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>intuition about the normal distribution and variance, let's model an honest and dishonest baker using Incanter's distribution functions. We can model the honest baker as a normal distribution with a mean of 1,000, corresponding to a fair loaf of 1kg. We'll assume a variance in the baking process that results in a standard deviation of 30g.</p><div class="calibre2"><pre class="programlisting">(defn honest-baker [mean sd]
  (let [distribution (d/normal-distribution mean sd)]
    (repeatedly #(d/draw distribution))))

(defn ex-1-18 []
  (-&gt; (take 10000 (honest-baker 1000 30))
      (c/histogram :x-label "Honest baker"
                   :nbins 25)
      (i/view)))</pre></div><p class="calibre11">The preceding code will provide an output similar to the following histogram:</p><div class="mediaobject"><img src="Images/7180OS_01_160.jpg" alt="Generating distributions" class="calibre45"/></div><p class="calibre11">Now, let's model a <a id="id61" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>baker who sells only the heaviest of his loaves. We partition the sequence into groups of thirteen (a "baker's dozen") and pick the maximum value:</p><div class="calibre2"><pre class="programlisting">(defn dishonest-baker [mean sd]
  (let [distribution (d/normal-distribution mean sd)]
    (-&gt;&gt; (repeatedly #(d/draw distribution))
         (partition 13)
         (map (partial apply max)))))

(defn ex-1-19 []
  (-&gt; (take 10000 (dishonest-baker 950 30))
      (c/histogram :x-label "Dishonest baker"
                   :nbins 25)
      (i/view)))</pre></div><p class="calibre11">The preceding code will <a id="id62" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>produce a histogram similar to the following:</p><div class="mediaobject"><img src="Images/7180OS_01_170.jpg" alt="Generating distributions" class="calibre45"/></div><p class="calibre11">It should be apparent that this histogram does not look quite like the others we have seen. The mean value is still 1kg, but the spread of values around the mean is no longer symmetrical. We say that <a id="id63" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>this histogram indicates a <span class="strong1"><strong class="calibre12">skewed normal distribution</strong></span>.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Skewness"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec20" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Skewness</h1></div></div></div><p class="calibre11">Skewness is the <a id="id64" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>name for the asymmetry of a distribution about its mode. <span class="strong1"><strong class="calibre12">Negative skew</strong></span>, or <span class="strong1"><strong class="calibre12">left skew</strong></span>, indicates that the area under the graph is larger on the left side of the mode. <span class="strong1"><strong class="calibre12">Positive skew</strong></span>, or <span class="strong1"><strong class="calibre12">right skew</strong></span>, indicates that the area under the graph is larger on the right side of the mode.</p><div class="mediaobject"><img src="Images/7180OS_01_180.jpg" alt="Skewness" class="calibre46"/></div><p class="calibre11">Incanter has a built-in function for measuring skewness in the <code class="literal">stats</code> namespace:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-20 []
  (let [weights (take 10000 (dishonest-baker 950 30))]
    {:mean (mean weights)
     :median (median weights)
     :skewness (s/skewness weights)}))</pre></div><p class="calibre11">The preceding example shows that the skewness of the dishonest baker's output is about 0.4, quantifying the skew evident in the histogram.</p><div class="calibre2" title="Quantile-quantile plots"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec13" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Quantile-quantile plots</h2></div></div></div><p class="calibre11">We encountered <a id="id65" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>quantiles as a means of describing the distribution of <a id="id66" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>data earlier in the chapter. Recall that the <code class="literal">quantile</code> function accepts a number between zero and one and returns the value of the sequence at that point. 0.5 corresponds to the median value.</p><p class="calibre11">Plotting the quantiles of your data against the quantiles of the normal distribution allows us to see how our measured data compares against the theoretical distribution. Plots such as this are called <span class="strong1"><strong class="calibre12">Q-Q plots</strong></span> and they provide a quick and intuitive way of determining normality. For data corresponding closely to the normal distribution, the Q-Q Plot is a straight line. Deviations from a straight line indicate the manner in which the data deviates from the idealized normal distribution.</p><p class="calibre11">Let's plot Q-Q plots for both our honest and dishonest bakers side-by-side. Incanter's <code class="literal">c/qq-plot</code> function accepts the list of data points and generates a scatter chart of the sample quantiles plotted <a id="id67" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>against the quantiles from the theoretical <a id="id68" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>normal distribution:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-21 []
  (-&gt;&gt; (honest-baker 1000 30)
       (take 10000)
       (c/qq-plot)
       (i/view))
  (-&gt;&gt; (dishonest-baker 950 30)
       (take 10000)
       (c/qq-plot)
       (i/view)))</pre></div><p class="calibre11">The preceding code will produce the following plots:</p><div class="mediaobject"><img src="Images/7180OS_01_190.jpg" alt="Quantile-quantile plots" class="calibre45"/></div><p class="calibre11">The Q-Q plot for the <a id="id69" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>honest baker is shown earlier. The dishonest <a id="id70" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>baker's plot is next:</p><div class="mediaobject"><img src="Images/7180OS_01_200.jpg" alt="Quantile-quantile plots" class="calibre45"/></div><p class="calibre11">The fact that the line is curved indicates that the data is positively skewed; a curve in the other direction would indicate negative skew. In fact, Q-Q plots make it easier to discern a wide variety of <a id="id71" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>deviations from the standard normal <a id="id72" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>distribution, as shown in the following diagram:</p><div class="mediaobject"><img src="Images/7180OS_01_210.jpg" alt="Quantile-quantile plots" class="calibre47"/></div><p class="calibre11">Q-Q plots compare the distribution of the honest and dishonest baker against the theoretical normal <a id="id73" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>distribution. In the next section, we'll compare several <a id="id74" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>alternative ways of visually comparing two (or more) measured sequences of values with each other.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Comparative visualizations"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec21" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Comparative visualizations</h1></div></div></div><p class="calibre11">Q-Q plots provide a <a id="id75" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>great way to compare a measured, empirical distribution to a theoretical normal distribution. If we'd like to compare two <a id="id76" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>or more empirical distributions with each other, we can't use Incanter's Q-Q plot charts. We have a variety of other options, though, as shown in the next two sections.</p><div class="calibre2" title="Box plots"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec14" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Box plots</h2></div></div></div><p class="calibre11">Box plots, or <span class="strong1"><strong class="calibre12">box and whisker plots</strong></span>, are a way to visualize the descriptive statistics of median and <a id="id77" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>variance visually. We can generate <a id="id78" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>them using the following code:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-22 []
  (-&gt; (c/box-plot (-&gt;&gt; (honest-baker 1000 30)
                       (take 10000))
                  :legend true
                  :y-label "Loaf weight (g)"
                  :series-label "Honest baker")
      (c/add-box-plot (-&gt;&gt; (dishonest-baker 950 30)
                           (take 10000))
                      :series-label "Dishonest baker")
      (i/view)))</pre></div><p class="calibre11">This creates the following plot:</p><div class="mediaobject"><img src="Images/7180OS_01_220.jpg" alt="Box plots" class="calibre45"/></div><p class="calibre11">The boxes in the center of the plot represent the <span class="strong1"><strong class="calibre12">interquartile range</strong></span>. The median is the line across the middle of the box, and the mean is the large black dot. For the honest baker, the median <a id="id79" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>passes through the centre of <a id="id80" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the circle, indicating the mean and median are about the same. For the dishonest baker, the mean is offset from the median, indicating a skew.</p><p class="calibre11">The whiskers indicate the range of the data and outliers are represented by hollow circles. In just one chart, we're more clearly able to see the difference between the two distributions than we were on either the histograms or the Q-Q plots independently.</p></div><div class="calibre2" title="Cumulative distribution functions"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec15" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Cumulative distribution functions</h2></div></div></div><p class="calibre11">Cumulative <a id="id81" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>distribution functions, also known as <span class="strong1"><strong class="calibre12">CDFs</strong></span>, describe the probability that a value drawn from a <a id="id82" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>distribution will have a value less than <span class="strong1"><em class="calibre13">x</em></span>. Like all probability distributions, they value between <span class="strong1"><em class="calibre13">0</em></span> and <span class="strong1"><em class="calibre13">1</em></span>, with <span class="strong1"><em class="calibre13">0</em></span> representing impossibility and <span class="strong1"><em class="calibre13">1</em></span> representing certainty. For example, imagine that I'm about to throw a six-sided die. What's the probability that I'll roll less than a six?</p><p class="calibre11">For a fair die, the probability I'll row a five or lower is <span class="inlinemediaobject"><img src="Images/7180OS_01_09.jpg" alt="Cumulative distribution functions" class="calibre48"/></span>. Conversely, the probability I'll roll a one is only <span class="inlinemediaobject"><img src="Images/7180OS_01_10.jpg" alt="Cumulative distribution functions" class="calibre48"/></span>. Three or lower corresponds to even odds—a probability of 50 percent.</p><p class="calibre11">The CDF of die rolls follows the same pattern as all CDFs—for numbers at the lower end of the range, the CDF is close to zero, corresponding to a low probability of selecting numbers in this range or below. At the high end of the range, the CDF is close to one, since most values drawn from the sequence will be lower.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="note07" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">The CDF and quantiles are closely related to each other—the CDF is the inverse of the quantile function. If the 0.5 quantile corresponds to a value of 1,000, then the CDF for 1,000 is 0.5.</p></div></div><p class="calibre11">Just as Incanter's <code class="literal">s/quantile</code> function allows us to sample values from a distribution at specific points, the <code class="literal">s/cdf-empirical</code> function allows us to input a value from the sequence and return a value between zero and one. It is a higher-order function—one that will accept the value (in this case, a sequence of values) and return a function. The returned function can then be called as often as necessary with different input values, returning the CDF for each of them.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="note08" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Higher-order functions are functions that accept or return functions.</p></div></div><p class="calibre11">Let's plot the CDF of both the honest and dishonest bakers side by side. We can use Incanter's <code class="literal">c/xy-plot</code> for visualizing the CDF by plotting the source data—the samples from our honest and dishonest bakers—against the probabilities calculated against the empirical CDF. The <code class="literal">c/xy-plot</code> function expects the <span class="strong1"><em class="calibre13">x</em></span> values and the <span class="strong1"><em class="calibre13">y</em></span> values to be supplied as two separate sequences of values.</p><p class="calibre11">To plot both distributions on the same chart, we need to be able to provide multiple series to our <code class="literal">xy-plot</code>. Incanter offers functions for many of its charts to add additional series. In the case of an <code class="literal">xy-plot</code>, we can use the function <code class="literal">c/add-lines</code>, which accepts the chart as the first argument, and the <span class="strong1"><em class="calibre13">x</em></span> series and the <span class="strong1"><em class="calibre13">y</em></span> series of data as the next two arguments <a id="id83" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>respectively. You <a id="id84" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>can also pass an optional series label. We do this in the following code so we can tell the two series apart on the finished chart:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-23 []
  (let [sample-honest    (-&gt;&gt; (honest-baker 1000 30)
                              (take 1000))
        sample-dishonest (-&gt;&gt; (dishonest-baker 950 30)
                              (take 1000))
        ecdf-honest    (s/cdf-empirical sample-honest)
        ecdf-dishonest (s/cdf-empirical sample-dishonest)]
    (-&gt; (c/xy-plot sample-honest (map ecdf-honest sample-honest)
                   :x-label "Loaf Weight"
                   :y-label "Probability"
                   :legend true
                   :series-label "Honest baker")
        (c/add-lines sample-dishonest
                     (map ecdf-dishonest sample-dishonest)
                     :series-label "Dishonest baker")
        (i/view))))</pre></div><p class="calibre11">The preceding code generates the following chart:</p><div class="mediaobject"><img src="Images/7180OS_01_230.jpg" alt="Cumulative distribution functions" class="calibre45"/></div><p class="calibre11">Although it looks very different, this chart shows essentially the same information as the box and <a id="id85" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>whisker plot. We can <a id="id86" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>see that the two lines cross at approximately the median of 0.5, corresponding to 1,000g. The dishonest line is truncated at the lower tail and longer on the upper tail, corresponding to a skewed distribution.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="The importance of visualizations"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec22" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The importance of visualizations</h1></div></div></div><p class="calibre11">Simple visualizations <a id="id87" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>like those earlier are succinct ways of conveying a large quantity of information. They complement the summary statistics we calculated earlier in the chapter, and it's important that we use them. Statistics such as the mean and standard deviation necessarily conceal a lot of information as they reduce a sequence down to just a single number.</p><p class="calibre11">The statistician Francis Anscombe devised a collection of four scatter plots, known as <span class="strong1"><strong class="calibre12">Anscombe's Quartet</strong></span>, that <a id="id88" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>have nearly identical statistical properties (including <a id="id89" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the mean, variance, and standard deviation). In spite of this, it's visually apparent that the distribution of <span class="strong1"><em class="calibre13">xs</em></span> and <span class="strong1"><em class="calibre13">ys</em></span> are all very different:</p><div class="mediaobject"><img src="Images/7180OS_01_240.jpg" alt="The importance of visualizations" class="calibre49"/></div><p class="calibre11">Datasets don't have to be contrived to reveal valuable insights when graphed. Take for example this histogram of the marks earned by candidates in Poland's national Matura exam in 2013:</p><div class="mediaobject"><img src="Images/7180OS_01_250.jpg" alt="The importance of visualizations" class="calibre50"/></div><p class="calibre11">We might expect the abilities of students to be normally distributed and indeed—with the exception of a sharp spike around 30 percent —it is. What we can clearly see is the very human effect of examiners nudging student's grades over the pass mark.</p><p class="calibre11">In fact, the distributions for sequences drawn from large samples can be so reliable that any deviation from them can be evidence of illegal activity. Benford's law, also called the first-digit law, is a curious feature of random numbers generated over a large range. One occurs as the leading <a id="id90" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>digit about 30 percent of the time, while larger digits occur less and less frequently. For example, nine occurs as the leading digit less than 5 percent of the time.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note09" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Benford's law is named after physicist Frank Benford who stated it in 1938 and showed its consistency across a wide variety of data sources. It had been previously observed by Simon Newcomb over 50 years earlier, who noticed that the pages of his books of logarithm tables were more battered for numbers beginning with the digit one.</p></div></div><p class="calibre11">Benford showed that the law applied to data as diverse as electricity bills, street addresses, stock prices, population numbers, death rates, and lengths of rivers. The law is so consistent for data sets <a id="id91" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>covering large ranges of values that deviation from it has been accepted as evidence in trials for financial fraud.</p><div class="calibre2" title="Visualizing electorate data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec16" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Visualizing electorate data</h2></div></div></div><p class="calibre11">Let's return to the <a id="id92" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>election data and compare the electorate sequence we created earlier against the theoretical normal distribution CDF. We can use Incanter's <code class="literal">s/cdf-normal</code> function to generate a normal CDF from a sequence of values. The default mean is 0 and standard deviation is 1, so we'll need to provide the measured mean and standard deviation from the electorate data. These values for our electorate data are 70,150 and 7,679, respectively.</p><p class="calibre11">We generated an empirical CDF earlier in the chapter. The following example simply generates each of the two CDFs and plots them on a single <code class="literal">c/xy-plot</code>:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-24 []
  (let [electorate (-&gt;&gt; (load-data :uk-scrubbed)
                        (i/$ "Electorate"))
        ecdf   (s/cdf-empirical electorate)
        fitted (s/cdf-normal electorate
                             :mean (s/mean electorate)
                             :sd   (s/sd electorate))]
    (-&gt; (c/xy-plot electorate fitted
                   :x-label "Electorate"
                   :y-label "Probability"
                   :series-label "Fitted"
                   :legend true)
        (c/add-lines electorate (map ecdf electorate)
                     :series-label "Empirical")
        (i/view))))</pre></div><p class="calibre11">The preceding example generates the following plot:</p><div class="mediaobject"><img src="Images/7180OS_01_260.jpg" alt="Visualizing electorate data" class="calibre45"/></div><p class="calibre11">You can see from the proximity of the two lines to each other how closely this data resembles normality, although a slight skew is evident. The skew is in the opposite direction to the dishonest <a id="id93" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>baker CDF we plotted previously, so our electorate data is slightly skewed to the left.</p><p class="calibre11">As we're comparing our distribution against the theoretical normal distribution, let's use a Q-Q plot, which will do this by default:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-25 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$ "Electorate")
       (c/qq-plot)
       (i/view)))</pre></div><p class="calibre11">The following Q-Q plot does <a id="id94" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>an even better job of highlighting the left skew evident in the data:</p><div class="mediaobject"><img src="Images/7180OS_01_270.jpg" alt="Visualizing electorate data" class="calibre45"/></div><p class="calibre11">As we expected, the curve bows in the opposite direction to the dishonest baker Q-Q plot earlier in the chapter. This indicates that there is a greater number of constituencies that are smaller than we would expect if the data were more closely normally distributed.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Adding columns"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec23" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Adding columns</h1></div></div></div><p class="calibre11">So far this chapter, we've reduced the size of our dataset by filtering both rows and columns. Often we'll <a id="id95" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>want to add rows to a dataset instead, and Incanter supports this in several ways.</p><p class="calibre11">Firstly, we can choose whether to replace an existing column within the dataset or append an additional column to the dataset. Secondly, we can choose whether to supply the new column values to replace the existing column values directly, or whether to calculate the new values by applying a function to each row of the data.</p><p class="calibre11">The following chart lists our options and the corresponding Incanter function to use:</p><div class="informaltable"><table border="1" class="calibre27"><colgroup class="calibre28"><col class="calibre29"/><col class="calibre29"/><col class="calibre29"/></colgroup><thead class="calibre30"><tr class="calibre31"><th valign="bottom" class="calibre32"> </th><th valign="bottom" class="calibre32">
<p class="calibre19">Replace data</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Append data</p>
</th></tr></thead><tbody class="calibre33"><tr class="calibre34"><td class="calibre35">
<p class="calibre19">By providing a sequence</p>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">i/replace-column</code>
</p>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">i/add-column</code>
</p>
</td></tr><tr class="calibre51"><td class="calibre35">
<p class="calibre19">By applying a function</p>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">i/transform-column</code>
</p>
</td><td class="calibre35">
<p class="calibre19">
<code class="literal">i/add-derived-column</code>
</p>
</td></tr></tbody></table></div><p class="calibre11">When transforming or deriving a column based on a function, we pass the name of the new column to create, a function to apply for each row, and also a sequence of existing column names. The values contained in each of these existing columns will comprise the arguments to our function.</p><p class="calibre11">Let's show how to use the <code class="literal">i/add-derived-column</code> function with reference to a real example. The 2010 UK general election resulted in a hung parliament with no single party commanding an overall majority. A coalition between the Conservative and Liberal Democrat parties was formed. In the next section we'll find out how many people voted for either party, and what percentage of the total vote this was.</p><div class="calibre2" title="Adding derived columns"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec17" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Adding derived columns</h2></div></div></div><p class="calibre11">To find out what percentage of the electorate voted for either the Conservative or Liberal Democrat parties, we'll want to calculate the sum of votes for either party. Since we're creating a new field of data based on a function of the existing data, we'll want to use the <code class="literal">i/add-derived-column</code> function.</p><div class="calibre2"><pre class="programlisting">(defn ex-1-26 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/add-derived-column :victors [:Con :LD] +)))</pre></div><p class="calibre11">If we run this now, however, an exception will be generated:</p><div class="calibre2"><pre class="programlisting">ClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:126)</pre></div><p class="calibre11">Unfortunately Clojure is complaining that we're trying to add a <code class="literal">java.lang.String</code>. Clearly either (or both) the <code class="literal">Con</code> or the <code class="literal">LD</code> columns contain string values, but which? We can use frequencies <a id="id96" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>again to see the extent of the problem:</p><div class="calibre2"><pre class="programlisting">(-&gt;&gt; (load-data :uk-scrubbed)
     ($ "Con")
     (map type)
     (frequencies))

;; {java.lang.Double 631, java.lang.String 19}

(-&gt;&gt; (load-data :uk-scrubbed)
     ($ "LD")
     (map type)
     (frequencies))

;; {java.lang.Double 631, java.lang.String 19}</pre></div><p class="calibre11">Let's use the <code class="literal">i/$where</code> function we encountered earlier in the chapter to inspect just these rows:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-27 []
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$where #(not-any? number? [(% "Con") (% "LD")]))
       (i/$ [:Region :Electorate :Con :LD])))

;; |           Region | Electorate | Con | LD |
;; |------------------+------------+-----+----|
;; | Northern Ireland |    60204.0 |     |    |
;; | Northern Ireland |    73338.0 |     |    |
;; | Northern Ireland |    63054.0 |     |    |
;; ...</pre></div><p class="calibre11">This bit of exploration should be enough to convince us that the reason for these fields being blank is that candidates were not put forward in the corresponding constituencies. Should they be filtered out or assumed to be zero? This is an interesting question. Let's filter them out, since it wasn't even possible for voters to choose a Liberal Democrat or Conservative candidate in these constituencies. If instead we assumed a zero, we would artificially lower the mean number of people who—given the choice—voted for either of these parties.</p><p class="calibre11">Now that we know how to filter the problematic rows, let's add the derived columns for the victor and the victor's share of the vote, along with election turnout. We filter the rows to show only those where both a Conservative and Liberal Democrat candidate were put forward:</p><div class="calibre2"><pre class="programlisting">(defmethod load-data :uk-victors [_]
  (-&gt;&gt; (load-data :uk-scrubbed)
       (i/$where {:Con {:$fn number?} :LD {:$fn number?}})
       (i/add-derived-column :victors [:Con :LD] +)
       (i/add-derived-column :victors-share [:victors :Votes] /)
       (i/add-derived-column :turnout [:Votes :Electorate] /)))</pre></div><p class="calibre11">As a result, we now have three additional columns in our dataset: <code class="literal">:victors</code>, <code class="literal">:victors-share</code>, and <code class="literal">:turnout</code>. Let's <a id="id97" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>plot the victor's share of the vote as a Q-Q plot to see how it compares against the theoretical normal distribution:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-28 []
  (-&gt;&gt; (load-data :uk-victors)
       (i/$ :victors-share)
       (c/qq-plot)
       (i/view)))</pre></div><p class="calibre11">The preceding code generates the following plot:</p><div class="mediaobject"><img src="Images/7180OS_01_275.jpg" alt="Adding derived columns" class="calibre45"/></div><p class="calibre11">Referring back to the diagram of various Q-Q plot shapes earlier in the chapter reveals that the victor's share of the vote has "light tails" compared to the normal distribution. This means that more <a id="id98" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of the data is closer to the mean than we might expect from truly normally distributed data.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Comparative visualizations of electorate data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec24" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Comparative visualizations of electorate data</h1></div></div></div><p class="calibre11">Let's look <a id="id99" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>now at a dataset from another general election, this time from Russia in 2011. Russia is a much larger country, and its election data is much larger too. We'll be loading two large Excel files into the memory, which may exceed your default JVM heap size.</p><p class="calibre11">To expand the amount of memory available to Incanter, we can adjust the JVM settings in the project's <code class="literal">profile.clj</code>. The a vector of configuration flags for the JVM can be provided with the key <code class="literal">:jvm-opts</code>. Here we're using Java's <code class="literal">Xmx</code> flag to increase the heap size to 1GB. This should be more than enough.</p><div class="calibre2"><pre class="programlisting">  :jvm-opts ["-Xmx1G"]</pre></div><p class="calibre11">Russia's data is available in two data files. Fortunately the columns are the same in each, so they can be concatenated together end-to-end. Incanter's function <code class="literal">i/conj-rows</code> exists for precisely this purpose:</p><div class="calibre2"><pre class="programlisting">(defmethod load-data :ru [_]
  (i/conj-rows (-&gt; (io/resource "Russia2011_1of2.xls")
                   (str)
                   (xls/read-xls))
               (-&gt; (io/resource "Russia2011_2of2.xls")
                   (str)
                   (xls/read-xls))))</pre></div><p class="calibre11">In the <a id="id100" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>preceding code, we define a third implementation of the <code class="literal">load-data</code> multimethod to load and combine both Russia files.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note10" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">In addition to <code class="literal">conj-rows</code>, Incanter-core also defines <code class="literal">conj-columns</code> that will merge the columns of datasets provided they have the same number of rows.</p></div></div><p class="calibre11">Let's see what the Russia data column names are:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-29 []
  (-&gt; (load-data :ru)
      (i/col-names)))

;; ["Code for district"
;; "Number of the polling district (unique to state, not overall)"
;; "Name of district" "Number of voters included in voters list"
;; "The number of ballots received by the precinct election
;; commission" ...]</pre></div><p class="calibre11">The column names in the Russia dataset are very descriptive, but perhaps longer than we want to type out. Also, it would be convenient if columns that represent the same attributes as we've already seen in the UK election data (the victor's share and turnout for example) were labeled the same in both datasets. Let's rename them accordingly.</p><p class="calibre11">Along with a dataset, the <code class="literal">i/rename-cols</code> function expects to receive a map whose keys are the current column names with values corresponding to the desired new column name. If we combine this with the <code class="literal">i/add-derived-column</code> data we have already seen, we arrive at the following:</p><div class="calibre2"><pre class="programlisting">(defmethod load-data :ru-victors [_]
  (-&gt;&gt; (load-data :ru)
       (i/rename-cols
        {"Number of voters included in voters list" :electorate
         "Number of valid ballots" :valid-ballots
         "United Russia" :victors})
       (i/add-derived-column :victors-share
                             [:victors :valid-ballots] i/safe-div)
       (i/add-derived-column :turnout
                             [:valid-ballots :electorate] /)))</pre></div><p class="calibre11">The <code class="literal">i/safe-div</code> function is identical to <code class="literal">/</code> but will protect against division by zero. Rather than <a id="id101" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>raising an exception, it returns the value <code class="literal">Infinity</code>, which will be ignored by Incanter's statistical and charting functions.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Visualizing the Russian election data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec25" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Visualizing the Russian election data</h1></div></div></div><p class="calibre11">We previously <a id="id102" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>saw that a histogram of the UK election turnout was approximately normal (albeit with light tails). Now that we've loaded and transformed the Russian election data, let's see how it compares:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-30 []
  (-&gt; (i/$ :turnout (load-data :ru-victors))
      (c/histogram :x-label "Russia turnout"
                   :nbins 20)
      (i/view)))</pre></div><p class="calibre11">The preceding example generates the following histogram:</p><div class="mediaobject"><img src="Images/7180OS_01_320.jpg" alt="Visualizing the Russian election data" class="calibre45"/></div><p class="calibre11">This histogram doesn't look at all like the classic bell-shaped curves we've seen so far. There's a pronounced positive skew, and the voter turnout actually increases from 80 percent towards 100 percent—the opposite of what we would expect from normally-distributed data.</p><p class="calibre11">Given the <a id="id103" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>expectations set by the UK data and by the central limit theorem, this is a curious result. Let's visualize the data with a Q-Q plot instead:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-31 []
  (-&gt;&gt; (load-data :ru-victors)
       (i/$ :turnout)
       (c/qq-plot)
       (i/view)))</pre></div><p class="calibre11">This returns the following plot:</p><div class="mediaobject"><img src="Images/7180OS_01_330.jpg" alt="Visualizing the Russian election data" class="calibre45"/></div><p class="calibre11">This Q-Q plot is neither a straight line nor a particularly S-shaped curve. In fact, the Q-Q plot suggests a light tail at the top end of the distribution and a heavy tail at the bottom. This is almost the opposite of what we see on the histogram, which clearly indicates an extremely heavy right tail.</p><p class="calibre11">In fact, it's <a id="id104" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>precisely because the tail is so heavy that the Q-Q plot is misleading: the density of points between 0.5 and 1.0 on the histogram suggests that the peak should be around 0.7 with a right tail continuing beyond 1.0. It's clearly illogical that we would have a percentage exceeding 100 percent but the Q-Q plot doesn't account for this (it doesn't know we're plotting percentages), so the sudden absence of data beyond 1.0 is interpreted as a clipped right tail.</p><p class="calibre11">Given the central <a id="id105" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>limit theorem, and what we've observed with the UK election data, the tendency towards 100 percent voter turnout is curious. Let's compare the UK and Russia datasets side-by-side.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Comparative visualizations"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec26" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Comparative visualizations</h1></div></div></div><p class="calibre11">Let's suppose we'd <a id="id106" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>like to compare the distributions of electorate data between the UK and Russia. We've already seen in this chapter how to make use of CDFs and box plots, so let's investigate an alternative that's similar to a histogram.</p><p class="calibre11">We could try and plot both datasets on a histogram but this would be a bad idea. We wouldn't be able to interpret the results for two reasons:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">The sizes of the voting districts, and therefore the means of the distributions, are very different</li><li class="listitem">The number of voting districts overall is so different, so the histograms bars will have different heights</li></ul></div><p class="calibre11">An alternative to the histogram that addresses both of these issues is the <span class="strong1"><strong class="calibre12">probability mass function</strong></span> (<span class="strong1"><strong class="calibre12">PMF</strong></span>).</p><div class="calibre2" title="Probability mass functions"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec18" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Probability mass functions</h2></div></div></div><p class="calibre11">The probability <a id="id107" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>mass function, or PMF, has a lot in <a id="id108" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>common with a histogram. Instead of plotting the counts of values falling into bins, though, it instead plots the probability that a number drawn from a distribution will be exactly equal to a given value. As the function assigns a probability to every value that can possibly be returned by the distribution, and because probabilities are measured on a scale from zero to one, (with one corresponding to certainty), the area under the probability mass function is equal to one.</p><p class="calibre11">Thus, the PMF ensures that the area under our plots will be comparable between datasets. However, we still have the issue that the sizes of the voting districts—and therefore the means of the distributions—can't be compared. This can be addressed by a separate technique—normalization.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="note11" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Normalizing the data isn't related to the normal distribution. It's the name given to the general task of bringing one or more sequences of values into alignment. Depending on the context, it could mean simply adjusting the values so they fall within the same range, or more sophisticated procedures to ensure that the distributions of data are the same. In general, the goal of normalization is to facilitate the comparison of two or more series of data.</p></div></div><p class="calibre11">There are innumerable <a id="id109" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>ways to normalize data, but one of the most basic is to ensure that each series is in the range zero to one. None of <a id="id110" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>our values decrease below zero, so we can accomplish this normalization by simply dividing by the largest value:</p><div class="calibre2"><pre class="programlisting">(defn as-pmf [bins]
  (let [histogram (frequencies bins)
        total     (reduce + (vals histogram))]
    (-&gt;&gt; histogram
         (map (fn [[k v]]
                [k (/ v total)]))
         (into {}))))</pre></div><p class="calibre11">With the preceding function in place, we can normalize both the UK and Russia data and plot it side by side on the same axes:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-32 []
  (let [n-bins 40
        uk (-&gt;&gt; (load-data :uk-victors)
                (i/$ :turnout)
                (bin n-bins)
                (as-pmf))
        ru (-&gt;&gt; (load-data :ru-victors)
                (i/$ :turnout)
                (bin n-bins)
                (as-pmf))]
    (-&gt; (c/xy-plot (keys uk) (vals uk)
                   :series-label "UK"
                   :legend true
                   :x-label "Turnout Bins"
                   :y-label "Probability")
        (c/add-lines (keys ru) (vals ru)
                     :series-label "Russia")
        (i/view))))</pre></div><p class="calibre11">The <a id="id111" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>preceding example generates the following chart:</p><div class="mediaobject"><img src="Images/7180OS_01_340.jpg" alt="Probability mass functions" class="calibre45"/></div><p class="calibre11">After normalization, the two distributions can be compared more readily. It's clearly apparent how—in <a id="id112" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>spite of having a lower mean turnout <a id="id113" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>than the UK—the Russia election had a massive uplift towards 100-percent turnout. Insofar as it represents the combined effect of many independent choices, we would expect election results to conform to the central limit theorem and be approximately normally distributed. In fact, election results from around the world generally conform to this expectation.</p><p class="calibre11">Although not quite as high as the modal peak in the center of the distribution—corresponding to approximately 50 percent turnout—the Russian election data presents a very anomalous result. Researcher Peter Klimek and his colleagues at the Medical University of Vienna <a id="id114" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>have gone as far as to suggest that <a id="id115" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>this is a clear signature of ballot-rigging.</p></div><div class="calibre2" title="Scatter plots"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec19" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Scatter plots</h2></div></div></div><p class="calibre11">We've observed the <a id="id116" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>curious results for the turnout at the Russian election and identified that it has a different signature from the UK election. Next, let's see how the proportion of votes for the winning candidate is related to the turnout. After all, if the unexpectedly high turnout really is a sign of foul play by the incumbent <a id="id117" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>government, we'd anticipate that they'll be voting for themselves rather than anyone else. Thus we'd expect most, if not all, of these additional votes to be for the ultimate election winners.</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch03.xhtml" title="Chapter 3. Correlation">Chapter 3</a>, <span class="strong1"><em class="calibre13">Correlation</em></span>, will cover the statistics behind correlating two variables in much more detail, but for now it would be interesting simply to visualize the relationship between turnout and the proportion of votes for the winning party.</p><p class="calibre11">The final visualization we'll introduce this chapter is the scatter plot. Scatter plots are very useful for visualizing correlations between two variables: where a linear correlation exists, it will be evident as a diagonal tendency in the scatter plot. Incanter contains the <code class="literal">c/scatter-plot</code> function for this kind of chart with arguments the same as for the <code class="literal">c/xy-plot</code> function.</p><div class="calibre2"><pre class="programlisting">(defn ex-1-33 []
  (let [data (load-data :uk-victors)]
    (-&gt; (c/scatter-plot (i/$ :turnout data)
                        (i/$ :victors-share data)
                        :x-label "Turnout"
                        :y-label "Victor's Share")
        (i/view))))</pre></div><p class="calibre11">The preceding code generates the following chart:</p><div class="mediaobject"><img src="Images/7180OS_01_350.jpg" alt="Scatter plots" class="calibre45"/></div><p class="calibre11">Although the points are arranged broadly in a fuzzy ellipse, a diagonal tendency towards the top right of the <a id="id118" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>scatter plot is clearly apparent. This indicates <a id="id119" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>an interesting result—turnout is correlated with the proportion of votes for the ultimate election winners. We might have expected the reverse: voter complacency leading to a lower turnout where there was a clear victor in the running.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="note12" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">As mentioned earlier, the UK election of 2010 was far from ordinary, resulting in a hung parliament and a coalition government. In fact, the "winners" in this case represent two parties who had, up until election day, been opponents. A vote for either counts as a vote for the winners.</p></div></div><p class="calibre11">Next, we'll create the same scatter plot for the Russia election:</p><div class="calibre2"><pre class="programlisting">(defn ex-1-34 []
  (let [data (load-data :ru-victors)]
    (-&gt; (c/scatter-plot (i/$ :turnout data)
                        (i/$ :victors-share data)
                        :x-label "Turnout"
                        :y-label "Victor's Share")
        (i/view))))</pre></div><p class="calibre11">This generates <a id="id120" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the following plot:</p><div class="mediaobject"><img src="Images/7180OS_01_360.jpg" alt="Scatter plots" class="calibre45"/></div><p class="calibre11">Although a diagonal tendency in the Russia data is clearly evident from the outline of the points, the sheer volume of data obscures the internal structure. In the last section of this chapter, we'll show <a id="id121" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>a simple technique for extracting structure <a id="id122" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>from a chart such as the earlier one using opacity.</p></div><div class="calibre2" title="Scatter transparency"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch01lvl2sec20" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Scatter transparency</h2></div></div></div><p class="calibre11">In situations such <a id="id123" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>as the preceding one where <a id="id124" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>a scatter plot is overwhelmed by the volume of points, transparency can help to visualize the structure of the data. Since translucent points that overlap will be more opaque, and areas with fewer points will be more transparent, a scatter plot with semi-transparent points can show the density of the data much better than solid points can.</p><p class="calibre11">We can set the alpha transparency of points plotted on an Incanter chart with the <code class="literal">c/set-alpha</code> function. It accepts two arguments: the chart and a number between zero and one. One signifies fully opaque and zero fully transparent.</p><div class="calibre2"><pre class="programlisting">(defn ex-1-35 []
  (let [data (-&gt; (load-data :ru-victors)
                 (s/sample :size 10000))]
    (-&gt; (c/scatter-plot (i/$ :turnout data)
                        (i/$ :victors-share data)
                        :x-label "Turnout"
                        :y-label "Victor Share")
        (c/set-alpha 0.05)
        (i/view))))</pre></div><p class="calibre11">The preceding example generates the following chart:</p><div class="mediaobject"><img src="Images/7180OS_01_370.jpg" alt="Scatter transparency" class="calibre45"/></div><p class="calibre11">The preceding scatter plot shows the general tendency of the victor's share and the turnout to vary together. We can see a correlation between the two values, and a "hot spot" in the top right corner of the chart corresponding to close to 100-percent turnout and 100-percent <a id="id125" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>votes for the winning party. This <a id="id126" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>in particular is the sign that the researchers at the Medial University of Vienna have highlighted as being the signature of electoral fraud. It's evident in the results of other disputed elections around the world, such as those of the 2011 Ugandan presidential election, too.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip05" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre22">The district-level results for many other elections around the world are available at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.complex-systems.meduniwien.ac.at/elections/election.html">http://www.complex-systems.meduniwien.ac.at/elections/election.html</a>. Visit the site for links to the research paper and to download other datasets on which to practice what you've learned in this chapter about scrubbing and transforming real data.</p></div></div><p class="calibre11">We'll cover <a id="id127" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>correlation in more detail in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch03.xhtml" title="Chapter 3. Correlation">Chapter 3</a>, <span class="strong1"><em class="calibre13">Correlation</em></span>, when we'll learn how to quantify the strength of the relationship between <a id="id128" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>two values and build a predictive model based on it. We'll also revisit this data in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch10.xhtml" title="Chapter 10. Visualization">Chapter 10</a>, <span class="strong1"><em class="calibre13">Visualization</em></span> when we implement a custom two-dimensional histogram to visualize the relationship between turnout and the winner's proportion of the vote even more clearly.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch01lvl1sec27" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this first chapter, we've learned about summary statistics and the value of distributions. We've seen how even a simple analysis can provide evidence of potentially fraudulent activity.</p><p class="calibre11">In particular, we've encountered the central limit theorem and seen why it goes such a long way towards explaining the ubiquity of the normal distribution throughout data science. An appropriate distribution can represent the essence of a large sequence of numbers in just a few statistics and we've implemented several of them using pure Clojure functions in this chapter. We've also introduced the Incanter library and used it to load, transform, and visually compare several datasets. We haven't been able to do much more than note a curious difference between two distributions, however.</p><p class="calibre11">In the next chapter, we'll extend what we've learned about descriptive statistics to cover inferential statistics. These will allow us to quantify a measured difference between two or more distributions and decide whether a difference is statistically significant. We'll also learn about hypothesis testing—a framework for conducting robust experiments that allow us to draw conclusions from data.</p></div></div>



  </body></html>