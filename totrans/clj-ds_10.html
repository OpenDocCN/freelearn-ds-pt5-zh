<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch10" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 10. Visualization</h1></div></div></div><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre17"><td class="calibre18"> </td><td class="calibre18"><p class="calibre19"><em class="calibre13">"Numbers have an important story to tell. They rely on you to give them a clear and convincing voice."</em></p></td><td class="calibre18"> </td></tr><tr class="calibre17"><td class="calibre18"> </td><td colspan="2" class="calibre20">--<em class="calibre13">Stephen Few</em></td></tr></table></div><p class="calibre11">Every chapter in this book has made use of visualization in some way, primarily using Incanter. Incanter is an effective tool to produce a wide variety of charts as we work, and these are often the ones we'll reach out for first while trying to understand a dataset. This initial phase is often called <a id="id1345" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><strong class="calibre12">exploratory data analysis</strong> and, at this stage, we're interested in summarizing statistics such as the distribution of numerical data, the counts of the categorical data, and how the attributes in our data are correlated.</p><p class="calibre11">Having found a meaningful way to interpret data, we'll often want to communicate it to others. One of the most important tools for communication is visualization, and we may be required to convey subtle or complicated ideas to people without a strong analytical background. In this chapter, we'll use the library Quil—which grew out of software developed for visual artists—to produce attractive graphics that can help bring data to life. Visualization and communication design are large, rich fields that we will not cover in detail here. Instead, this chapter will offer two case studies showing how Clojure's data abstractions and Quil's drawing API can be used together for good effect.</p><p class="calibre11">We'll begin this chapter by coming full circle and returning to the data we used in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em>. We'll introduce Quil by demonstrating how to build a simple two-dimensional histogram from the Russian election data. Having covered the basics of drawing in Quil, we'll show how a few basic drawing instructions can combine to produce a compelling representation of the distribution of wealth in the United States.</p><div><div><div><div><h1 class="title2"><a id="ch10lvl1sec145" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Download the code and data</h1></div></div></div><p class="calibre11">In this <a id="id1346" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>chapter, we'll return to the data we used in the very <a id="id1347" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>first chapter of this book: data from the 2011 Russian election. Back, in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em>, we used a scatter plot with transparency to visualize the relationship between voter turnout and the victor's percentage of the vote. In this chapter, we'll produce code to render the data as a two-dimensional histogram.</p><p class="calibre11">We'll also be making use of the data on the distribution of wealth in the United States. This data is so small that we won't have anything to download: we'll type the figures directly into the source code.</p><div><div><h3 class="title4"><a id="note94" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">The source code for this chapter is available at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/clojuredatascience/ch10-visualization">https://github.com/clojuredatascience/ch10-visualization</a>.</p></div></div><p class="calibre11">The example <a id="id1348" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>code for this chapter contains a script to download <a id="id1349" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the election data we used in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em>. Once you've downloaded the source code, you can execute the script by running the following command line from within the project root:</p><div><pre class="programlisting">
<strong class="calibre12">script/download-data.sh</strong>
</pre></div><p class="calibre11">If you downloaded the data for <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em> previously, you can simply move the data files across into this chapter's data directory, if you prefer.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch10lvl1sec146" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Exploratory data visualization</h1></div></div></div><p class="calibre11">At the outset of <a id="id1350" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>any data science project, there is likely to be a period of iterative data exploration when you gain insight into the data. Throughout this book, Incanter has been our primary visualization tool. Although it <a id="id1351" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>includes a large number of charts there will be occasions when it won't contain the ideal chart for the data you seek to represent.</p><div><div><h3 class="title4"><a id="note95" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Other Clojure libraries are stepping in to offer exploratory data visualization capabilities. For <a id="id1352" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>examples, see <strong class="calibre12">clojurewerkz/envision</strong> <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/clojurewerkz/envision">https://github.com/clojurewerkz/envision</a> and Karsten Schmidt's <strong class="calibre12">thi-ng/geom</strong> at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/thi-ng/geom/tree/master/geom-viz">https://github.com/thi-ng/geom/tree/master/geom-viz</a>.</p></div></div><p class="calibre11">For example, back in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em>, we used a scatter plot with alpha transparency to visualize the voter turnout proportion against the proportion of votes for the winner. This wasn't an ideal chart, because we were primarily interested in the density of points in a particular area. Alpha transparency helped reveal the structure of the data, but it wasn't an unambiguous representation. Some points were still too feint to be visible or so numerous that they appeared as one:</p><div><img src="img/7180OS_10_100.jpg" alt="Exploratory data visualization" class="calibre45"/></div><p class="calibre11">We could have solved these problems with a two-dimensional histogram. This type of plot uses color to <a id="id1353" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>communicate areas of high and low density over two dimensions. The chart is split into a grid with each cell of the grid <a id="id1354" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>signifying a range in both dimensions. The more the points fall into a cell of the grid, the greater is the density within the range.</p><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec208" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Representing a two-dimensional histogram</h2></div></div></div><p class="calibre11">A <a id="id1355" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>histogram is simply a representation <a id="id1356" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of a continuous distribution into a series of bins. Histograms were introduced in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em> and, at the time, we wrote a binning function that would separate continuous data into discrete bins:</p><div><pre class="programlisting">(defn bin [n-bins xs]
  (let [min-x    (apply min xs)
        range-x  (- (apply max xs) min-x)
        max-bin  (dec n-bins)
        bin-fn   (fn [x]
                   (-&gt; (- x min-x)
                       (/ range-x)
                       (* n-bins)
                       (int)
                       (min max-bin)))]
    (map bin-fn xs)))</pre></div><p class="calibre11">This code will take a range of continuous <code class="literal">xs</code> and bucket them into distinct groups based on the <code class="literal">n-bins</code> parameter. For example, binning the range between 0 and 19 into 5 bins yields the following sequence:</p><div><pre class="programlisting">(defn ex-1-1 []
  (bin 5 (range 20)))

;;(0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4)</pre></div><p class="calibre11">The <code class="literal">bin</code> <a id="id1357" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function returns the bin index <a id="id1358" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>for each data point rather than the count, so we use Clojure's <code class="literal">frequencies</code> function to determine the count of the points falling into the bin:</p><div><pre class="programlisting">(defn ex-1-2 []
  (frequencies (bin 5 (range 20))))

;;{0 4, 1 4, 2 4, 3 4, 4 4}</pre></div><p class="calibre11">This is a reasonable representation of a one-dimensional histogram: as a map of the bins to be counted. To represent a two-dimensional histogram, we can simply perform the same calculation on both the <em class="calibre13">xs</em> and the <em class="calibre13">ys</em>. We map the vector function over the bin indices so that each point is converted into a representation of <code class="literal">[x-bin y-bin]</code>:</p><div><pre class="programlisting">(defn histogram-2d [xsys n-bins]
  (-&gt; (map vector
           (bin n-bins xs)
           (bin n-bins ys))
      (frequencies)))</pre></div><p class="calibre11">This function returns a map keyed by a vector of two values. The <code class="literal">frequencies</code> function will now count all the points that share both an <em class="calibre13">x</em> and a <em class="calibre13">y</em> bin:</p><div><pre class="programlisting">(defn ex-10-3 []
  (histogram-2d (range 20)
                (reverse (range 20)) 5))

;;{[0 4] 4, [1 3] 4, [2 2] 4, [3 1] 4, [4 0] 4}</pre></div><p class="calibre11">We'll want to plot real data with our histogram, so let's load the Russian data from <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch01.xhtml" title="Chapter 1. Statistics">Chapter 1</a>, <em class="calibre13">Statistics</em>. If you've downloaded the data into the  sample code's <code class="literal">data</code> directory, you can run the following code:</p><div><pre class="programlisting">(defn ex-10-4 []
  (let [data (load-data :ru-victors)]
    (histogram-2d (i/$ :turnout data)
                  (i/$ :victors-share data) 5)))

;; {[4 3] 6782, [2 2] 14680, [0 0] 3, [1 0] 61, [2 3] 2593,
;;  [3 3] 8171, [1 1] 2689, [3 4] 1188, [4 2] 3084, [3 0] 64,
;;  [4 1] 1131, [1 4] 13, [1 3] 105, [0 3] 6, [2 4] 193, [0 2] 10,
;;  [2 0] 496, [0 4] 1, [3 1] 3890, [2 1] 24302, [4 4] 10771,
;;  [1 2] 1170, [3 2] 13384, [0 1] 4, [4 0] 264}</pre></div><p class="calibre11">We can see <a id="id1359" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the huge range of values <a id="id1360" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>in the histogram bins: from just 1 in bin <code class="literal">[0 4]</code> to 24,302 in bin <code class="literal">[2 1]</code>. These counts will be the density values we plot on our histogram.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch10lvl1sec147" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Using Quil for visualization</h1></div></div></div><p class="calibre11">Quil (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://github.com/quil/quil">https://github.com/quil/quil</a>) is a <a id="id1361" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Clojure <a id="id1362" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>library that provides an enormous amount of flexibility to produce custom visualizations. It wraps Processing (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://processing.org/">https://processing.org/</a>), a <a id="id1363" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Java framework that's been actively developed for many years by <a id="id1364" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>visual artists and designers, which aims promote "software literacy in visual arts and visual literacy within technology".</p><p class="calibre11">Any visualization done with Quil involves creating a <em class="calibre13">sketch</em>. A sketch is processing's term for a running a program that consists of drawing instructions. Most API functions are available from the <code class="literal">quil.core</code> namespace. We'll include it in our code as <code class="literal">q</code>. Calling <code class="literal">q/sketch</code> without any arguments will cause an empty window to pop up (although it may be obscured by other windows).</p><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec209" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Drawing to the sketch window</h2></div></div></div><p class="calibre11">The default <a id="id1365" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>window size is 500px by 300px. We'd like our two-dimensional histogram to be square, so let's make the window 250px in both directions:</p><div><pre class="programlisting">(q/sketch :size [250 250])</pre></div><p class="calibre11">Since we have 5 bins for each of our two axes, it means that each bin will be represented by a square that is 50px wide and 50px high.</p><p class="calibre11">Quil provides the standard 2D shape primitives for drawing: points, lines, arcs, triangles, quadrilaterals, rectangles, and ellipses. To draw a rectangle, we call the <code class="literal">q/rect</code> function with the location specified as the <em class="calibre13">x</em> and <em class="calibre13">y</em> coordinates, as well as a width and height.</p><p class="calibre11">Let's draw a square at the origin, 50px across. There are a couple of ways to supply drawing instructions to Quil but, in this chapter, we'll pass what's known as a <code class="literal">setup</code> function. This is a function of no arguments that we pass to sketch. Our zero-argument function simply <a id="id1366" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>calls <code class="literal">rect</code> with a position [0, 0] and a width and height of 50:</p><div><pre class="programlisting">(defn ex-10-5 []
  (let [setup #(q/rect 0 0 50 50)]
    (q/sketch :setup setup
              :size [250 250])))</pre></div><p class="calibre11">The code generates the following image:</p><div><img src="img/7180OS_10_110.jpg" alt="Drawing to the sketch window" class="calibre368"/></div><p class="calibre11">The rectangle <a id="id1367" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>may not be where you expected it to be, depending on your familiarity with computer graphics.</p><div><div><h3 class="title6"><a id="note96" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Rectangles can also be drawn with rounded corners by passing a radius as the fifth argument. Different radii can be used for each corner by passing the values as arguments five to eight.</p></div></div><p class="calibre11">Before we <a id="id1368" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>proceed further, we need to understand Quil's coordinate system.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec210" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Quil's coordinate system</h2></div></div></div><p class="calibre11">The <a id="id1369" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>coordinate system Quil uses is the same as processing and most other computer graphics programs. If you're unfamiliar with drawing, this may seem counter-intuitive that the origin is at the top left corner of the display. The <em class="calibre13">y</em> axis runs down the screen and the <em class="calibre13">x</em> axis runs to the right.</p><p class="calibre11">Clearly, this is not the direction of the <em class="calibre13">y</em> axis on most graphs, which means that the <em class="calibre13">y</em> coordinate will often need to be flipped while drawing.</p><div><img src="img/7180OS_10_120.jpg" alt="Quil's coordinate system" class="calibre369"/></div><p class="calibre11">A common way to do this is to subtract the desired <em class="calibre13">y</em> value (as measured from the bottom of the sketch) from the height of the sketch. This transformation causes a <em class="calibre13">y</em> of zero to correspond to <a id="id1370" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the bottom of the sketch. Greater values of <em class="calibre13">y</em> will correspond to the values higher up the sketch.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec211" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Plotting the grid</h2></div></div></div><p class="calibre11">Let's put this <a id="id1371" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>into practice with a simple grid. The following function accepts a number of bins, <code class="literal">n-bins</code>, and a <code class="literal">size</code> parameter expressed as a vector of <code class="literal">[width height]</code>:</p><div><pre class="programlisting">defn draw-grid [{:keys [n-bins size]}]
  (let [[width height] size
        x-scale (/ width n-bins)
        y-scale (/ height n-bins)
        setup (fn []
                (doseq [x (range n-bins)
                        y (range n-bins)
                        :let [x-pos (* x x-scale)
                              y-pos (- height
                                       (* (inc y) y-scale))]]
                  (q/rect x-pos y-pos x-scale y-scale)))]
    (q/sketch :setup setup :size size)))</pre></div><p class="calibre11">From this, we can calculate <code class="literal">x-scale</code> and <code class="literal">y-scale</code>, a factor that enables us to convert bin index to pixel offset in each of the <em class="calibre13">x</em> and the <em class="calibre13">y</em> dimensions. These are used by our <code class="literal">setup</code> function that loops over both the <em class="calibre13">x</em> and the <em class="calibre13">y</em> bins, placing a rectangle for each bin.</p><div><div><h3 class="title6"><a id="note97" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Notice how we're executing the loop inside <code class="literal">doseq</code>. Our drawing instructions are executed as a side effect. If we don't do this, Clojure's lazy evaluation would cause nothing to be drawn.</p></div></div><p class="calibre11">The previous code generates the following graphic:</p><div><img src="img/7180OS_10_130.jpg" alt="Plotting the grid" class="calibre368"/></div><p class="calibre11">Having defined <a id="id1372" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the earlier function, we've almost created a histogram. We just need to color each square in the grid with a color that represents an appropriate value for each bin in the histogram. To achieve this, we'll need two more functions: one to fetch the value from the data corresponding to the bin and the other to interpret these values as a color.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec212" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Specifying the fill color</h2></div></div></div><p class="calibre11">Filling colors in <a id="id1373" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Quil is achieved with the <code class="literal">q/fill</code> function. Any fill we specify will continue to be used until we specify a new fill.</p><div><div><h3 class="title6"><a id="note98" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Many functions in Quil affect the current drawing context and are <em class="calibre13">stateful</em>. For example, when we specify a fill value, it will be used for all subsequent drawing instructions until the fill is altered. Other examples are fill, stroke, scale, and font.</p></div></div><p class="calibre11">The following code is an adapted version of our <code class="literal">draw-grid</code> function. The addition to <code class="literal">draw-filled-grid</code> is <code class="literal">fill-fn</code>: some way of coloring the rectangle at a point in the grid. The <code class="literal">fill-fn</code> function should be a function of two arguments, the <em class="calibre13">x</em> and <em class="calibre13">y</em> indices of the bin. It should return a representation that Quil can use as a fill:</p><div><pre class="programlisting">(defn draw-filled-grid [{:keys [n-bins size <strong class="calibre12">fill-fn</strong>]}]
  (let [[width height] size
        x-scale (/ width n-bins)
        y-scale (/ height n-bins)
        setup (fn []
                (doseq [x (range n-bins)
                        y (range n-bins)
                        :let [x-pos (* x x-scale)
                              y-pos (- height
                                       (* (inc y) y-scale))]]
                  (q/fill (<strong class="calibre12">fill-fn</strong> x y))
                  (q/rect x-pos y-pos x-scale y-scale)))]
    (q/sketch :setup setup :size size)))</pre></div><p class="calibre11">Quil's fill <a id="id1374" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function accepts multiple arities:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre12">One argument</strong>: The RGB value (either as a number or the <code class="literal">q/color</code> representation)</li><li class="listitem"><strong class="calibre12">Two arguments</strong>: The RGB, as with one argument, plus an alpha transparency</li><li class="listitem"><strong class="calibre12">Three arguments</strong>: The red, green, and blue components of the color as numbers between 0 and 255 inclusive</li><li class="listitem"><strong class="calibre12">Four arguments</strong>: The red, green, blue, and alpha components as numbers</li></ul></div><p class="calibre11">We'll see how to use the <code class="literal">color</code> representations shortly but, for now, we'll represent colors with a simple numeric representation: as a number between 0 and 255. When the same number is used for red, green, and blue (or when <code class="literal">fill</code> is called with one or two arguments), we get a gray color. 0 corresponds to black and 255 corresponds to white.</p><p class="calibre11">If we divide the frequency of the value in each bin in the histogram by the maximum value, we'll get a number between 0 and 1.0. Multiplying by 255 will yield a value that Quil will convert into a gray color for us. We do this in the following <code class="literal">fill-fn</code> implementation, passing it to the <code class="literal">draw-filled-grid</code> function that we defined earlier:</p><div><pre class="programlisting">(defn ex-10-6 []
  (let [data (load-data :ru-victors)
        n-bins 5
        hist (histogram-2d (i/$ :turnout data)
                           (i/$ :victors-share data)
                           n-bins)
        max-val (apply max (vals hist))
        fill-fn (fn [x y]
                  (-&gt; (get hist [x y] 0)
                      (/ max-val)
                      (* 255)))]
    (draw-filled-grid {:n-bins n-bins
                       :size [250 250]
                       :fill-fn fill-fn})))</pre></div><p class="calibre11">The previous <a id="id1375" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>code generates the following graphic:</p><div><img src="img/7180OS_10_140.jpg" alt="Specifying the fill color" class="calibre368"/></div><p class="calibre11">The chart is doing what we want, but it's a very crude representation of our data. Let's increase the number of bins to increase the resolution of our histogram:</p><div><pre class="programlisting">(defn ex-10-7 []
  (let [data (load-data :ru-victors)
        n-bins 25
        hist (histogram-2d (i/$ :turnout data)
                           (i/$ :victors-share data)
                           n-bins)
        max-val (apply max (vals hist))
        fill-fn (fn [x y]
                  (-&gt; (get hist [x y] 0)
                      (/ max-val)
                      (* 255)))]
    (draw-filled-grid {:n-bins n-bins
                       :size [250 250]
                       :fill-fn fill-fn})))</pre></div><p class="calibre11">This code <a id="id1376" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>generates the following graphic:</p><div><img src="img/7180OS_10_150.jpg" alt="Specifying the fill color" class="calibre368"/></div><p class="calibre11">With 25 rectangles along each of the <em class="calibre13">x</em> and the <em class="calibre13">y</em> axes, we have a finer-grained picture of the structure of the data. However, a side effect is that it's become hard to discern detail in the histogram, because of how dim most of the cells are. Part of the problem is that the top right corner has such a high value that even the central area (previously the brightest) is now not much more than a gray smudge.</p><p class="calibre11">There are two solutions to this problem:</p><div><ul class="itemizedlist"><li class="listitem">Mitigate the effect of the outlier by plotting the <em class="calibre13">z</em>-score instead of the actual value</li><li class="listitem">Diversify the range of visual queues by using a greater range of colors</li></ul></div><p class="calibre11">We'll discover how to convert values into a full spectrum of colors in the next section, but first, let's convert the histogram value to a <em class="calibre13">z</em>-score. Plotting <em class="calibre13">z</em>-scores is a distribution-aware way of coloring the chart that will go a long way toward diminishing the effect of the extreme outlier in the top right corner. With a <em class="calibre13">z</em>-score, we'll be plotting the number of standard deviations away from the mean for each cell.</p><p class="calibre11">To accomplish <a id="id1377" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>this, we need to know two things: the mean and the standard deviation of the frequencies in the histogram:</p><div><pre class="programlisting">(defn ex-10-8 []
  (let [data (load-data :ru-victors)
        n-bins 25
        hist (histogram-2d (i/$ :turnout data)
                           (i/$ :victors-share data)
                           n-bins)
        mean (s/mean (vals hist))
        sd   (s/sd   (vals hist))
        fill-fn (fn [x y]
                  (-&gt; (get hist [x y] 0)
                      (- mean)
                      (/ sd)
                      (q/map-range -1 3 0 255)))]
    (draw-filled-grid {:n-bins n-bins
                       :size [250 250]
                       :fill-fn fill-fn})))</pre></div><p class="calibre11">The preceding code subtracts the mean from each value in the histogram and divides it by the mean. This will yield a value with a mean of zero. <code class="literal">1</code> will represent one standard deviation from the mean, <code class="literal">2</code> will represent two standard deviations from the mean, and so on.</p><p class="calibre11">Quil exposes a useful <code class="literal">map-range</code> function that will take one range of values and map it onto another range of values. For example, we could take the desired range of standard deviations (-1 to 3 in the earlier example) and map them onto the range 0 and 255. This would correspond to four standard deviations of the distribution being represented as the full range of gray from black to white. Any data exceeding this range would simply be clipped.</p><div><img src="img/7180OS_10_160.jpg" alt="Specifying the fill color" class="calibre368"/></div><p class="calibre11">The result is a <a id="id1378" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>much more striking representation of the data in grayscale. The use of <em class="calibre13">z</em>-scores has brought more detail out in the main body of the histogram and we can perceive more of the variation in the tail.</p><p class="calibre11">However, the histogram is still not quite as clear as it could be, as distinguishing between the different shades of gray can be challenging. Where cells aren't adjacent to each other, it can be hard to determine whether they share the same value.</p><p class="calibre11">We can increase the range open to us by making use of color to represent each cell. This makes the histogram more like a heat map: "cooler" colors such as blue and green represent low values, while "hotter" colors such as orange and red represent the most dense regions of the heatmap.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec213" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Color and fill</h2></div></div></div><p class="calibre11">To create a heat <a id="id1379" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>map version of our two-dimensional histogram, we'll have to take our <em class="calibre13">z</em>-score and find some way of mapping it to a color value. Rather than showing a discrete palette of colors, say 5, our heat map should have a smooth palette containing all the colors in the spectrum.</p><div><div><h3 class="title6"><a id="note99" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">For those reading the print book or in black and white, you can download color images from Packt Publishing's website <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://www.packtpub.com/sites/default/files/downloads/Clojure_for_Data_Science_ColorImages.pdf">https://www.packtpub.com/sites/default/files/downloads/Clojure_for_Data_Science_ColorImages.pdf</a>.</p></div></div><p class="calibre11">This is exactly what the Quil function <code class="literal">q/lerp-color</code> does. Given two colors and a ratio between zero and one, <code class="literal">lerp-color</code> will return a new color that interpolates between them. An amount of zero will return the first color and one the second, while 0.5 will return a color halfway between the two:</p><div><pre class="programlisting">(defn z-score-&gt;heat [z-score]
  (let [colors [(q/color 0 0 255)   ;; Blue
                (q/color 0 255 255) ;; Turquoise
                (q/color 0 255 0)   ;; Green
                (q/color 255 255 0) ;; Yellow
                (q/color 255 0 0)]  ;; Red
        offset  (-&gt; (q/map-range z-score -1 3 0 3.999)
                    (max 0)
                    (min 3.999))]
    (q/lerp-color (nth colors offset)
                  (nth colors (inc offset))
                  (rem offset 1))))</pre></div><p class="calibre11">This code makes <a id="id1380" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>use of an array of colors in the order of the spectrum. We use <code class="literal">q/map-range</code> to determine which two colors we will interpolate between and call <code class="literal">q/lerp-color</code> with the floating-point portion of the range.</p><p class="calibre11">We've already implemented a <code class="literal">draw-filled-grid</code> function that accepts <code class="literal">fill-fn</code> to determine which color should be used to fill the grid. Let's pass our <code class="literal">z-score-&gt;heat</code> function to it now:</p><div><pre class="programlisting">(defn ex-10-9 []
  (let [data (load-data :ru-victors)
        n-bins 25
        hist (histogram-2d (i/$ :turnout data)
                           (i/$ :victors-share data)
                           n-bins)
        mean (s/mean (vals hist))
        sd   (s/sd   (vals hist))
        fill-fn (fn [x y]
                  (-&gt; (get hist [x y] 0)
                      (- mean)
                      (/ sd)
                      (z-score-&gt;heat)))]
    (draw-filled-grid {:n-bins n-bins
                       :size [250 250]
                       :fill-fn fill-fn})))</pre></div><p class="calibre11">This code <a id="id1381" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>generates the following graphic:</p><div><img src="img/7180OS_10_170.jpg" alt="Color and fill" class="calibre368"/></div><p class="calibre11">The heat map has exposed even more of the internal structure of the data. In particular, while the strong diagonal shape of the data is still evident, we can now see more of the variation within it. Details that were previously hard to determine (either because the region was too dense or too sparse) have become more apparent.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec214" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Outputting an image file</h2></div></div></div><p class="calibre11">Now that we're <a id="id1382" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>happy with the histogram, we want to output a high-quality version. By adding a call to <code class="literal">q/save</code> within the setup function, passing a filename, Quil will output to a file as well as the screen. The format of the image created will depend on the filename suffix: <code class="literal">.tif</code> for TIFF files, <code class="literal">.jpg</code> for JPEG files, <code class="literal">.png</code> for PNG files, and <code class="literal">.tga</code> for TARGA files:</p><div><pre class="programlisting">(defn draw-filled-grid [{:keys [n-bins size fill-fn]}]
  (let [[width height] size
        x-scale (/ width n-bins)
        y-scale (/ height n-bins)
        setup (fn []
                (doseq [x (range n-bins)
                        y (range n-bins)
                        :let [x-pos (* x x-scale)
                              y-pos (- height
                                       (* (inc y) y-scale))]]
                  (q/fill (fill-fn x y))
                  (q/rect x-pos y-pos x-scale y-scale))
                  <strong class="calibre12">(q/save "heatmap.png"))]</strong>
    (q/sketch :setup setup :size size)))</pre></div><p class="calibre11">We're also able to <a id="id1383" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>output to PDF, as we'll show with the next visualization.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch10lvl1sec148" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Visualization for communication</h1></div></div></div><p class="calibre11">In the <a id="id1384" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>course of our work as data scientists, we may find ourselves needing to communicate with a wide variety of people. Our close colleagues and managers may be able to read and interpret our Incanter charts, but they're unlikely to impress the CEO. We may also have a role that requires us to communicate with the general public.</p><p class="calibre11">In either case, we should focus on making visualizations that are simple and powerful, but which don't sacrifice the integrity of the data. A lack of statistical training is no barrier to being able to understand subtle and nuanced arguments and we should respect our audience's intelligence. The challenge for us as data scientists is to find a representation that conveys the message effectively to them.</p><p class="calibre11">For the remainder of this chapter, we'll work on a visualization that aims to communicate a more complex set of data in a succinct and faithful way.</p><div><div><h3 class="title4"><a id="note100" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">The visualization we're going to create is a version of one of the graphs presented in the <strong class="calibre12">Wealth Inequality in America</strong> video online at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://www.youtube.com/watch?v=QPKKQnijnsM">https://www.youtube.com/watch?v=QPKKQnijnsM</a>. Produced by anonymous film maker Politizane, the powerful video has gathered more than 16 million hits on YouTube.</p></div></div><p class="calibre11">As is often the case with graphical representations like these, our data will come from several different sources.</p><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec215" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Visualizing wealth distribution</h2></div></div></div><p class="calibre11">The <a id="id1385" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>first dataset we'll make use of is from an article by G. William Domhoff, research professor in psychology and sociology at the University of California, Santa Cruz. The numbers we will quote next are from an article entitled <strong class="calibre12">Wealth, Income, and Power</strong> at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www2.ucsc.edu/whorulesamerica/power/wealth.html">http://www2.ucsc.edu/whorulesamerica/power/wealth.html</a>.</p><p class="calibre11">Although the article is well worth reading in its entirety, a particularly striking graphic is a pie chart that shows the financial net worth breakdown of people in the U.S. in 2010:</p><div><img src="img/7180OS_10_180.jpg" alt="Visualizing wealth distribution" class="calibre370"/></div><p class="calibre11">The pie chart is striking for several reasons. Firstly, the concept that over 40 percent of the financial wealth is owned by such a small percentage is hard to comprehend. Secondly, each slice of the pie represents not just the vastly different quantities of wealth, but vastly different quantities of people, too: from 1 percent of the population to 80 percent of the population. Pie charts are notoriously difficult to read at the best of times, so this chart is doubly challenging.</p><div><div><h3 class="title6"><a id="note101" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Pie charts are generally not a good way to represent data, even where the totals do conceptually represent parts of the whole. Author and programmer Steve Fenton has documented many of the reasons and provided appropriate alternatives at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://www.stevefenton.co.uk/2009/04/pie-charts-are-bad/">https://www.stevefenton.co.uk/2009/04/pie-charts-are-bad/</a>.</p></div></div><p class="calibre11">Let's see <a id="id1386" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>how we could go about reinterpreting this data to make it more comprehensible. As a first step, let's extract the numbers we'll be working with that are presented in the following table:</p><div><table border="1" class="calibre27"><colgroup class="calibre28"><col class="calibre29"/><col class="calibre29"/></colgroup><thead class="calibre30"><tr class="calibre31"><th valign="bottom" class="calibre32">
<p class="calibre19">Percentile</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Total financial wealth, 2010</p>
</th></tr></thead><tbody class="calibre33"><tr class="calibre34"><td class="calibre35">
<p class="calibre19">0-79</p>
</td><td class="calibre35">
<p class="calibre19">5%</p>
</td></tr><tr class="calibre36"><td class="calibre35">
<p class="calibre19">80-89</p>
</td><td class="calibre35">
<p class="calibre19">11%</p>
</td></tr><tr class="calibre34"><td class="calibre35">
<p class="calibre19">90-95</p>
</td><td class="calibre35">
<p class="calibre19">13%</p>
</td></tr><tr class="calibre36"><td class="calibre35">
<p class="calibre19">96-99</p>
</td><td class="calibre35">
<p class="calibre19">30%</p>
</td></tr><tr class="calibre38"><td class="calibre35">
<p class="calibre19">100</p>
</td><td class="calibre35">
<p class="calibre19">42%</p>
</td></tr></tbody></table></div><p class="calibre11">A small improvement over the pie chart would be to represent the same data as a bar chart. While people generally struggle to interpret the relative sizes of the pie chart segments successfully, bar charts present no such problem. The next example simply creates a bar chart out of the earlier numbers:</p><div><pre class="programlisting">(defn ex-10-10 []
  (let [categories ["0-79" "80-89" "90-95" "96-99" "100"]
        percentage [5      11      13      30      42   ]]
    (-&gt; (c/bar-chart categories percentage
                     :x-label "Category"
                     :y-label "% Financial Wealth")
        (i/view))))</pre></div><p class="calibre11">This will return the following chart:</p><div><img src="img/7180OS_10_190.jpg" alt="Visualizing wealth distribution" class="calibre45"/></div><p class="calibre11">This is an improvement on the pie chart in the respect that it's easier to compare the relative sizes of the categories. A significant problem remains though: the number of people represented by each category are so vastly different. The bar to the left represents 80 percent of the population, while the bar to the right represents 1 percent of the population.</p><p class="calibre11">If we wanted to make this data more comprehensible, we could divide up the total into 100 equal units, each representing one percentile of the population. The width of each bar could be adjusted according to the number of percentiles it represents while preserving its area. Since each percentile unit represents an equal number of people, the resulting chart would allow <a id="id1387" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>us to more easily make comparisons across groups.</p><p class="calibre11">One way we could achieve this is by returning a sequence of 100 elements, one for each percentile of the population. The value of each element in the sequence would be the proportion of overall wealth accounted for by the percentile. We already know that the top 1 percent owns 42 percent of overall wealth, but the other groups would get a value adjusted downwards <a id="id1388" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>for the number of percentiles they span:</p><div><pre class="programlisting">(def wealth-distribution
  (concat (repeat 80 (/ 5  80))
          (repeat 10 (/ 11 10))
          (repeat 5  (/ 13 5))
          (repeat 4  (/ 30 4))
          (repeat 1  (/ 42 1))))

(defn ex-10-11 []
  (let [categories (range (count wealth-distribution))]
    (-&gt; (c/bar-chart categories wealth-distribution
                     :x-label "Percentile"
                     :y-label "% Financial Wealth")
        (i/view))))</pre></div><p class="calibre11">This example generates the following bar chart:</p><div><img src="img/7180OS_10_200.jpg" alt="Visualizing wealth distribution" class="calibre45"/></div><p class="calibre11">By applying a simple transformation, we're able to gain a much better understanding of the true <a id="id1389" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>distribution. Each bar now represents an equal proportion of the population and the area of each bar represents the proportion of wealth owned by the percentile.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec216" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Bringing data to life with Quil</h2></div></div></div><p class="calibre11">The <a id="id1390" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>transformation in the previous section results in a chart that shows the difference between the extreme ends of the scale almost too starkly: it's hard to interpret anything but the largest bars. One solution would be to display the numbers on a log scale or a log-log scale as we did elsewhere in the book. If the audience for this chart are statistically literate, this might be the most appropriate thing to do, but let's assume that the intended audience for our visualization is the general public.</p><p class="calibre11">The problem with the chart presented earlier is that the rightmost bar is so large that it overwhelms <a id="id1391" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>all the other bars. 80 percent of the area is represented by nothing more than a few pixels. In the next section, we'll make use of Quil to produce a visualization that makes better use of space while it simultaneously preserving the integrity of the chart.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec217" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Drawing bars of differing widths</h2></div></div></div><p class="calibre11">Over <a id="id1392" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the next several sections, we'll build up a visualization in stages. Since we'll be drawing a Quil sketch, we'll first define some constants that will allow us to produce drawing instructions relative to the dimensions of the sketch. Some constants are omitted from the next code for brevity:</p><div><pre class="programlisting">(def plot-x 56)
(def plot-y 60)
(def plot-width 757)
(def plot-height 400)
(def bar-width 7)</pre></div><p class="calibre11">With these in place, we can begin to represent the bar chart in a more comprehensible way. The following code takes the wealth distribution and plots all but the final bar as a series of rectangles. The <em class="calibre13">y</em>-scale is calculated so that the largest bar we will draw will fill the height of the plot:</p><div><pre class="programlisting">(defn draw-bars []
  (let [pc99    (vec (butlast wealth-distribution))
        pc1     (last wealth-distribution)
        y-max   (apply max pc99)
        y-scale (fn [x] (* (/ x y-max) plot-height))
        offset  (fn [i] (* (quot i 10) 7))]
    (dotimes [i 99] ;; Draw the 99%
      (let [bar-height (y-scale (nth pc99 i))]
        (q/rect (+ plot-x (* i bar-width) (offset i))
                (+ plot-y (- plot-height bar-height))
                bar-width bar-height)))
    (let [n-bars 5  ;; Draw the 1%
          bar-height (y-scale (/ pc1 n-bars))]
      (q/rect (+ plot-x (* 100 bar-width) (offset 100))
              (+ plot-y (- plot-height bar-height))
              (* bar-width n-bars) bar-height))))</pre></div><p class="calibre11">The bars we've drawn so far represent the 99 percent. The final bar will represent the final 1 percent of the population. So it fits the vertical scale we've devised without disappearing off the top of the sketch, we will make the bar correspondingly wider while preserving its area. As a result, the bar is 5 times shorter—but also 5 times wider—than the others:</p><div><pre class="programlisting">(defn ex-10-12 []
  (let [size [960 540]]
    (q/sketch :size size
              :setup draw-bars)))</pre></div><p class="calibre11">The <a id="id1393" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>example outputs the following graphic:</p><div><img src="img/7180OS_10_210.jpg" alt="Drawing bars of differing widths" class="calibre337"/></div><p class="calibre11">Already, we can see the relationship between largest bars more clearly, but it's not clearly apparent yet that it's a chart. In the next section, we'll add text to identify the subject of the chart and the range of the axes.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec218" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Adding a title and axis labels</h2></div></div></div><p class="calibre11">One of <a id="id1394" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the convenient aspects of <a id="id1395" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>specialized visualization tools such as Incanter is that the axes can be automatically generated for our charts. Quil provides no help for us here, but since the bar widths are known, it's not terribly hard for us to achieve. In the following code, we'll make use of the <code class="literal">text</code>, <code class="literal">text-align</code>, <code class="literal">text-size</code> functions to write text to our visualization:</p><div><pre class="programlisting">(defn group-offset [i]
  (* (quot i 10) 7))

(defn draw-axis-labels []
  (q/fill 0)
  (q/text-align :left)
  (q/text-size 12)
  (doseq [pc (range 0 (inc 100) 10)
          :let [offset (group-offset pc)
                x      (* pc bar-width)]]
    (q/text (str pc "%") (+ plot-x x offset) label-y))
    (q/text "\"The 1%\"" pc1-label-x  pc1-label-y))</pre></div><p class="calibre11">What we lose <a id="id1396" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>by using a nonspecialist <a id="id1397" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>charting library we gain in terms of flexibility. Next, we'll write a function to produce letterpress-style embossing on the text:</p><div><pre class="programlisting">(defn emboss-text [text x y]
  (q/fill 255)
  (q/text text x y)
  (q/fill 100)
  (q/text text x (- y 2)))

(defn draw-title []
  (q/text-size 35)
  (q/text-leading 35)
  (q/text-align :center :top)
  (emboss-text "ACTUAL DISTRIBUTION\nOF WEALTH IN THE US"
               title-x title-y))</pre></div><p class="calibre11">We use the <code class="literal">emboss-text</code> function to draw a large title at the center of our chart. Notice how we also specify the alignment of the text with the positions being measured optionally from the top, bottom, center, left, or right of the text:</p><div><pre class="programlisting">(defn ex-10-13 []
  (let [size [960 540]]
    (q/sketch :size size
              :setup #((draw-bars)
                       (draw-axis-labels)
     (draw-title)))))</pre></div><p class="calibre11">The earlier example generates the following graphic:</p><div><img src="img/7180OS_10_220.jpg" alt="Adding a title and axis labels" class="calibre371"/></div><p class="calibre11">This <a id="id1398" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>chart, which is a mix of bar <a id="id1399" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>heights and areas, and custom text visualization would be very difficult to achieve in a standard charting application. Using Quil, we have a toolbox that allows us to freely mix graphics and data with ease.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec219" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Improving the clarity with illustrations</h2></div></div></div><p class="calibre11">We're <a id="id1400" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>getting somewhere with our chart, but it's very spare at the moment. One way to add more visual interest would be with images. In the resources directory of the example project, are two SVG image files. One is a person icon and the other is a map of the United States sourced from Wikipedia.</p><div><div><h3 class="title6"><a id="note102" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre22">Wikipedia <a id="id1401" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>contains a wide variety of SVG maps issued under a flexible creative commons license. For example, maps of the United States at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://commons.wikimedia.org/wiki/Category:SVG_maps_of_the_United_States">https://commons.wikimedia.org/wiki/Category:SVG_maps_of_the_United_States</a>.</p></div></div><p class="calibre11">The map we're using in this chapter is available at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://commons.wikimedia.org/wiki/File:Blank_US_Map,_Mainland_with_no_States.svg">https://commons.wikimedia.org/wiki/File:Blank_US_Map,_Mainland_with_no_States.svg</a> and was made available by Lokal_Profil under a CC-BY-SA-2.5 license.</p><p class="calibre11">Using SVG images in Quil is a two-step process. First, we have to load the image into the memory using <code class="literal">q/load-shape</code>. This function accepts a single argument: the path to the SVG file that is to be loaded. Next, we have to actually draw the image on the screen. This is accomplished using the <code class="literal">q/shape </code>function, which expects a <em class="calibre13">x</em>, <em class="calibre13">y</em> position for the image and also an optional width and height. If we were using pixel-based images such as JPEGs or <a id="id1402" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>PNGs, we would instead use the corresponding <code class="literal">q/load-image</code> and <code class="literal">q/image</code> functions:</p><div><pre class="programlisting">(defn draw-shapes []
  (let [usa    (q/load-shape "resources/us-mainland.svg")
        person (q/load-shape "resources/person.svg")
        colors [(q/color 243 195 73)
                (q/color 231 119 46)
                (q/color 77  180 180)
                (q/color 231 74  69)
                (q/color 61  76  83)]]
    (.disableStyle usa)
    (.disableStyle person)
    (q/stroke 0 50)
    (q/fill 200)
    (q/shape usa 0 0)
    (dotimes [n 99]
      (let [quintile (quot n 20)
            x (-&gt; (* n bar-width)
                  (+ plot-x)
                  (+ (group-offset n)))]
        (q/fill (nth colors quintile))
        (q/shape person x icons-y icon-width icon-height)))
        (q/shape person
             (+ plot-x (* 100 bar-width) (group-offset 100))
             icons-y icon-width icon-height)))</pre></div><p class="calibre11">In this code, we called <code class="literal">.disableStyle</code> on both the <code class="literal">usa</code> and the <code class="literal">person</code> shapes. This is because SVG files may contain embedded style such as fill color, stroke color, or border width information that will affect the way Quil draws the shape. We'd like complete control over our representation, so we choose to disable all the styles.</p><p class="calibre11">Also, note that we're loading the person shape once and drawing it many times with <code class="literal">dotimes</code>. We are setting the color based on <code class="literal">quintile </code>in which the user falls:</p><div><pre class="programlisting">(defn ex-10-14 []
  (let [size [960 540]]
    (q/sketch :size size
              :setup #((draw-shapes)
                       (draw-bars)
                       (draw-axis-labels)
                       (draw-title)))))</pre></div><p class="calibre11">The result is shown in the next image:</p><div><img src="img/7180OS_10_230.jpg" alt="Improving the clarity with illustrations" class="calibre371"/></div><p class="calibre11">The graphic is beginning to look like one we could show people without blushing. The people icons help communicate the idea that each bar represents a percentile of the population. The <a id="id1403" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>bars are not very attractive yet. Since each bar represents the wealth of each person, let's represent each bar as a pile of bank notes. While this might appear to be an overly literal interpretation, it would actually make it clearer that the 1 percent bar is actually 5 times as wide as everyone else's.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec220" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Adding text to the bars</h2></div></div></div><p class="calibre11">By now, it <a id="id1404" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>should be no surprise that we can draw the banknotes as a series of rectangles:</p><div><pre class="programlisting">(defn banknotes [x y width height]
  (q/no-stroke)
  (q/fill 80 127 64)
  (doseq [y (range (* 3 (quot y 3)) (+ y height) 3)
          x (range x (+ x width) 7)]
    (q/rect x y 6 2)))</pre></div><p class="calibre11">The only slight complexity in the previous code is the need to adjust the starting <em class="calibre13">y</em> position as an even multiple of <code class="literal">3</code>. This will ensure that all the banknotes meet the <em class="calibre13">x</em> axis after an even number of multiples, irrespective of the height of the bar on the <em class="calibre13">y</em> axis. This is a side-effect <a id="id1405" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of drawing the bars from top to bottom, rather than vice versa.</p><p class="calibre11">We'll add the earlier function to our sketch in the following example:</p><div><pre class="programlisting">(defn ex-10-15 []
  (let [size [960 540]]
    (q/sketch :size size
              :setup #((draw-shapes)
                       (draw-banknotes)
                       (draw-axis-labels)
                       (draw-title)))))</pre></div><p class="calibre11">This will generates the following chart:</p><div><img src="img/7180OS_10_240.jpg" alt="Adding text to the bars" class="calibre371"/></div><p class="calibre11">This is now a <a id="id1406" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>reasonably complete chart representing the actual distribution of wealth in the United States. One of the strengths of the original YouTube video link provided earlier is that it contrasts the actual distribution with several other distributions: the distribution of wealth people expected and the distribution of wealth they would prefer.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec221" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Incorporating additional data</h2></div></div></div><p class="calibre11">Michael <a id="id1407" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Norton, a Harvard Business Professor, and Dan Ariely, a behavioral economist performed a study on more than 5,000 Americans to assess their perception of wealth distribution. When they were shown a variety of examples on wealth distribution and asked to identify which one was sourced from the United States, most chose a distribution much more balanced than it actually was. When asked to choose their ideal distribution of wealth, 92 percent picked one that was even more equitable.</p><p class="calibre11">The following graphic shows the results of this study:</p><div><img src="img/7180OS_10_250.jpg" alt="Incorporating additional data" class="calibre372"/></div><p class="calibre11">The preceding graphic was published by Mother Jones on <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.motherjones.com/politics/2011/02/income-inequality-in-america-chart-graph">http://www.motherjones.com/politics/2011/02/income-inequality-in-america-chart-graph</a> based on the data sourced form <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.people.hbs.edu/mnorton/norton%20ariely%20in%20press.pdf">http://www.people.hbs.edu/mnorton/norton%20ariely%20in%20press.pdf</a>.</p><p class="calibre11">The previous chart does a good job of showing the relative differences between people's perceptions and reality for each of the 5 quintiles. We'll be converting this data into an alternative representation so, like before, we can convert the data into a table representation.</p><p class="calibre11">Reading off the earlier chart and with reference to the linked paper, I've arrived at the following approximate breakdown by quintile:</p><div><table border="1" class="calibre27"><colgroup class="calibre28"><col class="calibre29"/><col class="calibre29"/><col class="calibre29"/><col class="calibre29"/></colgroup><thead class="calibre30"><tr class="calibre31"><th valign="bottom" class="calibre32">
<p class="calibre19">Quintile</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Ideal %</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Expected %</p>
</th><th valign="bottom" class="calibre32">
<p class="calibre19">Actual %</p>
</th></tr></thead><tbody class="calibre33"><tr class="calibre34"><td class="calibre35">
<p class="calibre19">100th</p>
</td><td class="calibre35">
<p class="calibre19">32.0%</p>
</td><td class="calibre35">
<p class="calibre19">58.5%</p>
</td><td class="calibre35">
<p class="calibre19">84.5%</p>
</td></tr><tr class="calibre36"><td class="calibre35">
<p class="calibre19">80th</p>
</td><td class="calibre35">
<p class="calibre19">22.0%</p>
</td><td class="calibre35">
<p class="calibre19">20.0%</p>
</td><td class="calibre35">
<p class="calibre19">11.5%</p>
</td></tr><tr class="calibre34"><td class="calibre35">
<p class="calibre19">60th</p>
</td><td class="calibre35">
<p class="calibre19">21.5%</p>
</td><td class="calibre35">
<p class="calibre19">12.0%</p>
</td><td class="calibre35">
<p class="calibre19">3.7%</p>
</td></tr><tr class="calibre36"><td class="calibre35">
<p class="calibre19">40th</p>
</td><td class="calibre35">
<p class="calibre19">14.0%</p>
</td><td class="calibre35">
<p class="calibre19">6.5%</p>
</td><td class="calibre35">
<p class="calibre19">0.2%</p>
</td></tr><tr class="calibre38"><td class="calibre35">
<p class="calibre19">20th</p>
</td><td class="calibre35">
<p class="calibre19">10.5%</p>
</td><td class="calibre35">
<p class="calibre19">3.0%</p>
</td><td class="calibre35">
<p class="calibre19">0.1%</p>
</td></tr></tbody></table></div><p class="calibre11">Let's take the <em class="calibre13">ideal</em> and <em class="calibre13">expected</em> distributions and find a way to plot them on our existing wealth distribution chart. Our bar chart already represents the relative wealth of different percentiles <a id="id1408" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>as an area. In order to make the two datasets comparable, we should also do the same with this data. The previous table assisted us by already representing the data as five equally sized groups, so we don't need to apply a transformation like we did with the data sourced from the pie chart.</p><p class="calibre11">However, let's use this as an opportunity to learn more about drawing complex shapes in Quil and see whether we can arrive at a presentation of the data more like the following diagram:</p><div><img src="img/7180OS_10_260.jpg" alt="Incorporating additional data" class="calibre373"/></div><p class="calibre11">The table provides the relative areas that we want to represent by the shapes labeled <strong class="calibre12">A</strong>, <strong class="calibre12">B</strong>, and <strong class="calibre12">C</strong>. In order to draw the earlier shapes, we'll have to calculate the heights <em class="calibre13">x</em>, <em class="calibre13">y</em>, and <em class="calibre13">z</em>. These will give us the coordinates that we can plot on our chart.</p><p class="calibre11">The width of the areas <strong class="calibre12">A</strong>, <strong class="calibre12">B</strong>, and <strong class="calibre12">C</strong> is <strong class="calibre12">w</strong>. Therefore, the product of <strong class="calibre12">x</strong> and <strong class="calibre12">w</strong> will equal the area of <strong class="calibre12">A</strong>:</p><div><img src="img/7180OS_10_01.jpg" alt="Incorporating additional data" class="calibre374"/></div><div><img src="img/7180OS_10_02.jpg" alt="Incorporating additional data" class="calibre375"/></div><p class="calibre11">It <a id="id1409" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>follows that the height of <em class="calibre13">x</em> is simply the area of <em class="calibre13">A</em> divided by <em class="calibre13">w</em>. <em class="calibre13">Y</em> is a little more complicated, but not much. The area of the triangular component of <em class="calibre13">B</em> is equal to:</p><div><img src="img/7180OS_10_03.jpg" alt="Incorporating additional data" class="calibre376"/></div><p class="calibre11">therefore:</p><div><img src="img/7180OS_10_04.jpg" alt="Incorporating additional data" class="calibre377"/></div><p class="calibre11">We can calculate <em class="calibre13">z</em> in the same way:</p><div><img src="img/7180OS_10_05.jpg" alt="Incorporating additional data" class="calibre377"/></div><p class="calibre11">Expanding our definitions gives the following equation for <em class="calibre13">z</em>:</p><div><img src="img/7180OS_10_06.jpg" alt="Incorporating additional data" class="calibre378"/></div><p class="calibre11">If we assume that <em class="calibre13">w</em> is 1 (all our quintiles are of a constant width), then we arrive at the following equations and so on for any number of sections:</p><div><img src="img/7180OS_10_07.jpg" alt="Incorporating additional data" class="calibre379"/></div><div><img src="img/7180OS_10_08.jpg" alt="Incorporating additional data" class="calibre380"/></div><div><img src="img/7180OS_10_09.jpg" alt="Incorporating additional data" class="calibre381"/></div><p class="calibre11">This can be <a id="id1410" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>expressed as a simple recursive function. The first of our proportions will be assigned the value <em class="calibre13">x</em>. Subsequent values can be calculated from it as follows:</p><div><pre class="programlisting">(defn area-points [proportions]
  (let [f (fn [prev area]
            (-&gt; (- area prev)
                (* 2)
                (+ prev)))
        sum (reduce + proportions)]
    (-&gt;&gt; (reductions f (first proportions) proportions)
         (map #(/ % sum)))))</pre></div><p class="calibre11">The <code class="literal">reductions</code> function behaves exactly like <code class="literal">reduce</code>, but preserves the intermediate steps of our calculation. Rather than a single value, we'll get back a sequence of values that correspond to the (proportional) heights of our <em class="calibre13">y</em>-coordinates.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec222" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Drawing complex shapes</h2></div></div></div><p class="calibre11">The <code class="literal">area-points</code> function defined in the previous section will provide a series of points for <a id="id1411" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>us to plot. However, we haven't yet covered the functions in Quil that will allow us to plot them. To draw lines, we could use the <code class="literal">q/line</code> function. The line function will accept a start and an end coordinate and draw a straight line between them. We would be able to construct an area graph this way, but it would have no fill. Lines simply describe outlines; we are not able to use them to construct colored shapes like we did with <code class="literal">q/rect </code>while making a histogram. To give our shapes a fill color, we need to build them up one vertex at a time.</p><p class="calibre11">To build arbitrarily complex shapes with Quil, we first call <code class="literal">q/begin-shape</code>. This is a stateful function that lets Quil know that we want to start building up a series of vertices. Subsequent calls to <code class="literal">q/vertex</code> will be associated with the shape that we're constructing. Finally, a call to <code class="literal">q/end-shape</code> will complete the shape. We'll draw it with the stroke and fill the styles specified in the current drawing context.</p><p class="calibre11">Let's see how it works by drawing some test shapes using the <code class="literal">area-points</code> function defined in the previous section:</p><div><pre class="programlisting">(defn plot-area [proportions px py width height]
  (let [ys      (area-points proportions)
        points  (map vector (range) ys)
        x-scale (/ width (dec (count ys)))
        y-scale (/ height (apply max ys))]
    (q/stroke 0)
    (q/fill 200)
    (q/begin-shape)
    (doseq [[x y] points]
      (q/vertex (+ px (* x x-scale))
                (- py (* y y-scale))))
      (q/end-shape)))

(defn ex-10-16 []
  (let [expected [3 6.5 12 20 58.5]
        width  640
        height 480
        setup (fn []
                (q/background 255)
                (plot-area expected 0 height width height))]
    (q/sketch :setup setup :size [width height])))</pre></div><p class="calibre11">This example plots the <code class="literal">[3 6.5 12 20 58.5]</code> series using the area-points function defined <a id="id1412" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>previously. This is the series of percentage values listed in the data table for the <code class="literal">expected</code> distribution of wealth in the United States. The <code class="literal">plot-area</code> function calls <code class="literal">begin-shape</code>, iterates over the sequence of <em class="calibre13">ys</em> returned by <code class="literal">area-points</code>, and calls <code class="literal">end-shape</code>. The result is as follows:</p><div><img src="img/7180OS_10_270.jpg" alt="Drawing complex shapes" class="calibre382"/></div><p class="calibre11">This <a id="id1413" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>isn't quite what we want. Although we're asking to fill the shape, we're not describing the full shape to be filled. Quil doesn't know how we want to close off the shape, so it's simply drawing an edge from the last point back to the first, cutting across the diagonal of our chart. Fortunately, the problem can be easily resolved by ensuring there are points at both the bottom corners of the diagram:</p><div><pre class="programlisting">(defn plot-full-area [proportions px py width height]
  (let [ys      (area-points proportions)
        points  (map vector (range) ys)
        x-scale (/ width (dec (count ys)))
        y-scale (/ height (apply max ys))]
    (q/stroke 0)
    (q/fill 200)
    (q/begin-shape)
    (q/vertex 0 height)
    (doseq [[x y] points]
      (q/vertex (+ px (* x x-scale))
                (- py (* y y-scale))))
    (q/vertex width height)
    (q/end-shape)))

(defn ex-10-17 []
  (let [expected [3 6.5 12 20 58.5]
        width  640
        height 480
        setup (fn []
                (q/background 255)
                (plot-full-area expected 0 height width height))]
    (q/sketch :setup setup :size [width height])))</pre></div><p class="calibre11">The <a id="id1414" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">plot-full-area</code> function adds an extra call to <code class="literal">vertex</code> before and after iterating over the sequence of <em class="calibre13">ys</em>. The points specified ensure that the shape is fully described before the call to <code class="literal">end-shape</code>. The result is shown in the following image:</p><div><img src="img/7180OS_10_280.jpg" alt="Drawing complex shapes" class="calibre382"/></div><p class="calibre11">This is better, and it's starting to look like an area plot. In the next section, we'll cover how to describe more complex shapes using curves. Although curves aren't required for our area plot, it will help make the results a little more attractive.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec223" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Drawing curves</h2></div></div></div><p class="calibre11">The <a id="id1415" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>area plot is starting to look good, but we could remove those sharp corners by making use of Quil's spline curves. Rather than building up the shape by adding vertices, we could call <code class="literal">q/curve-vertex</code> to smoothen out the joins between the edges.</p><p class="calibre11">The <code class="literal">q/curve-vertex</code> function implements a method of curve drawing known as Catmull-Rom splines. To draw a curve, we must specify at least four vertices: the first and last will be treated as the control points and the curve will be drawn between the middle two.</p><p class="calibre11">We <a id="id1416" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>visualize how Catmull-Rom splines work in the following diagram, which shows the path specified by points <em class="calibre13">a</em>, <em class="calibre13">b</em>, <em class="calibre13">c</em>, and <em class="calibre13">d</em>:</p><div><img src="img/7180OS_10_290.jpg" alt="Drawing curves" class="calibre383"/></div><p class="calibre11">The tangent to the curve at point <strong class="calibre12">c</strong> is parallel to <strong class="calibre12">X</strong>: the line described between points <strong class="calibre12">a</strong> and <strong class="calibre12">b</strong>; the tangent to the curve at <strong class="calibre12">b</strong> is parallel to <strong class="calibre12">Y</strong>: the line described by points <strong class="calibre12">c</strong> and <strong class="calibre12">d</strong>. Thus, to draw a curve, we'll need ensure we add these additional control points at the beginning and the end of our line. Each control point is added with <code class="literal">curve-vertex</code>, which we call once before we iterate over our points and then again at the end:</p><div><pre class="programlisting">(defn smooth-curve [xs ys]
  (let [points (map vector xs ys)]
    (apply q/curve-vertex (first points))
    (doseq [point points]
      (apply q/curve-vertex point))
    (apply q/curve-vertex (last points))))</pre></div><p class="calibre11">Now that we've defined a <code class="literal">smooth-curve</code> function, we'll use it in the following two functions, <code class="literal">smooth-stroke</code> and <code class="literal">smooth-area</code>:</p><div><pre class="programlisting">(defn smooth-stroke [xs ys]
  (q/begin-shape)
  (q/vertex (first xs) (first ys))
  (smooth-curve (rest xs) (rest ys))
  (q/end-shape))

(defn smooth-area [xs ys]
  (q/begin-shape)
  (q/vertex (first xs) (first ys))
  (smooth-curve (rest xs) (rest ys))
  (q/vertex (last xs) (first ys))
  (q/end-shape))</pre></div><p class="calibre11">The <a id="id1417" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">smooth-stroke</code> function will draw the shape defined by the <em class="calibre13">xs</em> and <em class="calibre13">ys</em> by creating vertices for each of them. The <code class="literal">smooth-area</code> function extends this by closing off the shape and avoiding the situation we saw previously with a fill that crosses the shape diagonally. Bringing the two functions together is <code class="literal">plot-curve</code>, a function that accepts the <em class="calibre13">xs</em> and <em class="calibre13">ys</em> to be plotted, plus a fill color, stroke color, and stroke weight to use:</p><div><pre class="programlisting">(defn plot-curve [xs ys fill-color
                  stroke-color stroke-weight]
  (let [points (map vector xs ys)]
    (q/no-stroke)
    (q/fill fill-color)
    (smooth-area xs ys)
    (q/no-fill)
    (q/stroke stroke-color)
    (q/stroke-weight stroke-weight)
    (smooth-stroke xs ys)))</pre></div><p class="calibre11">Let's call the <code class="literal">plot-curve</code> function on the same sequence of expected values we plotted earlier, and compare the difference:</p><div><pre class="programlisting">(defn plot-smooth-area [proportions px py width height]
  (let [ys      (cons 0 (area-points proportions))
        points  (map vector (range) ys)
        x-scale (/ width (dec (count ys)))
        y-scale (/ height (apply max ys) -1)]
    (plot-curve (map (point-&gt;px px x-scale) (range (count ys)))
                (map (point-&gt;px py y-scale) ys)
                (q/color 200)
                (q/color 0) 2)))

(defn ex-10-18 []
  (let [expected [3 6.5 12 20 58.5]
        width  640
        height 480
        setup (fn []
                (q/background 255)
                (plot-smooth-area expected 0 height
                                  width height))]
    (q/sketch :setup setup :size [width height])))</pre></div><p class="calibre11">This <a id="id1418" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>example generates the following image:</p><div><img src="img/7180OS_10_300.jpg" alt="Drawing curves" class="calibre382"/></div><p class="calibre11">The effect of the curve is subtle, but it provides a polish to our chart that would otherwise be lacking. The previous chart shows the <em class="calibre13">expected</em> distribution of wealth from the study by Norton <a id="id1419" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>and Ariely. Before we combine this with the <em class="calibre13">actual</em> wealth distribution plot we created earlier, let's see how it could be combined with the <em class="calibre13">ideal</em> distribution of wealth from the same study.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec224" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Plotting compound charts</h2></div></div></div><p class="calibre11">The <a id="id1420" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>earlier description shows how to create a single curved graph scaled to fit an area. As we've defined it, the <code class="literal">plot-smooth-area</code> function will fill the height we specify for every area we draw. This makes sense from a drawing perspective, but it doesn't make sense while trying to draw two comparable charts: we need to make sure they use the same scale.</p><p class="calibre11">In the next block of code, we'll calculate a scale based on the larger of the two graphs and then plot both using this scale. This ensures that all of the series we plot will be comparable with each <a id="id1421" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>other. The combined chart will fill the width and height we allot to it:</p><div><pre class="programlisting">(defn plot-areas [series px py width height]
  (let [series-ys (map area-points series)
        n-points  (count (first series-ys))
        x-scale   (point-&gt;px px (/ width (dec n-points)))
        xs        (map x-scale (range n-points))
        y-max     (apply max (apply concat series-ys))
        y-scale   (point-&gt;px py (/ height y-max -1))]
    (doseq [ys series-ys]
      (plot-curve (cons (first xs) xs)
                  (map y-scale (cons 0 ys))
                  (q/color 255 100)
                  (q/color 255 200) 3))))

(defn ex-10-19 []
  (let [expected [3 6.5 12 20 58.5]
        ideal    [10.5 14 21.5 22 32]
        width  640
        height 480
        setup (fn []
                (q/background 100)
                (plot-areas [expected ideal] 0 height
                            width height))]
    (q/sketch :setup setup :size [width height])))</pre></div><p class="calibre11">We plot both the <code class="literal">expected</code> and <code class="literal">ideal</code> series using the <code class="literal">plot-areas</code> function, having set a darker background to our sketch with the <code class="literal">background</code> function. In our call to <code class="literal">plot-curve</code>, we specify semitransparent white as the fill to be used. The following image shows the result:</p><div><img src="img/7180OS_10_310.jpg" alt="Plotting compound charts" class="calibre382"/></div><p class="calibre11">To combine this chart with the chart showing the actuals created previously, we simply need to adjust its scale to match. The highest point on this chart at the top right corresponds to a probability density of <a id="id1422" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>5 percent. The 96-99<sup class="calibre42">th</sup> percentiles on our actual plot represents 7.5 percent of the total, each on their plot. This means that we need to draw the previous chart at 2/3 of the height of the plot we already have for the axes to be comparable. Let's do this now, and add a series of labels to the two new series while we're at it:</p><div><pre class="programlisting">(defn draw-expected-ideal []
  (let [expected [3 6.5 12 20 58.5]
        ideal    [10.5 14 21.5 22 32]]
    (plot-areas [expected ideal]
                plot-x
                (+ plot-y plot-height)
                plot-width
                (* (/ plot-height 0.075) 0.05))
    (q/text-size 20)
    (emboss-text "EXPECTED" 400 430)
    (emboss-text "IDEAL" 250 430)))</pre></div><p class="calibre11">Finally, we call the <code class="literal">draw-expected-ideal</code> function from our sketch along with the other functions defined previously:</p><div><pre class="programlisting">(defn ex-10-20 []
  (let [size [960 540]]
    (q/sketch :size size
              :setup #((draw-shapes)
                       (draw-expected-ideal)
                       (draw-banknotes)
                       (draw-axis-labels)
                       (draw-title)))))</pre></div><p class="calibre11">The <a id="id1423" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>finished result is shown in the next graphic:</p><div><img src="img/7180OS_10_320.jpg" alt="Plotting compound charts" class="calibre371"/></div><p class="calibre11">Hopefully, you'll agree that the finished chart is attractive as well as informative. Most importantly, we've generated the chart by drawing instructions from actual data. The finished result has an integrity to it that would be harder to establish if the chart were produced by hand.</p></div><div><div><div><div><h2 class="title5"><a id="ch10lvl2sec225" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Output to PDF</h2></div></div></div><p class="calibre11">All the <a id="id1424" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>elements combined together yield a graphic of the kind that might end up in print. The drawing instructions we provided are vector-based—rather than pixel-based—so it will scale to any resolution required without loss of quality.</p><p class="calibre11">Rather than output to a pixel-based format using <code class="literal">save</code> as we did with the histogram, let's output to a PDF. The PDF format will preserve the scalability of our artwork and allow us to output at any resolution desired. To do this, we configure the sketch to use the PDF renderer by passing the <code class="literal">:pdf</code> keyword and also an <code class="literal">:output-file</code> path.</p><div><pre class="programlisting">(defn ex-10-21 []
  (let [size [960 540]]
    (q/sketch :size size
              :setup #((draw-shapes)
                       (draw-expected-ideal)
                       (draw-banknotes)
                       (draw-axis-labels)
                       (draw-title))
              <strong class="calibre12">:renderer :pdf</strong>
              <strong class="calibre12">:output-file "wealth-distribution.pdf"</strong>)))</pre></div><p class="calibre11">The final <a id="id1425" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>example will output our finished PDF file to the root of the project directory.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch10lvl1sec149" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this chapter, we've seen how very simple visualizations—using nothing but colored rectangles—can bring useful insight from data, and how a combination of Clojure core functions and Quil's drawing API can enable us to generate powerful graphics that communicate a message.</p><p class="calibre11">We achieved all of this using the Quil library. There's much more to Quil than what we've shown here: it enables interactive animation, it supports ClojureScript output for the web, and it can produce 3D rendering as well. Visualization is a huge topic too, and we couldn't hope to provide more than a few examples to pique your interest in this chapter. By showing how even basic drawing instructions using rectangles, curves, and SVGs can combine into powerful graphics, we hope to have inspired you with the possibilities to create your own custom visualizations.</p><p class="calibre11">This was the final chapter of <em class="calibre13">Clojure for Data Science</em>. Be sure to visit the book's website at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://clojuredatascience.com">http://clojuredatascience.com</a> for more information on the topics covered and links to further reading. We intend to provide an ongoing resource for data scientists in general and Clojure programmers in particular.</p><p class="calibre11">It was an ambitious task to convey the breadth and depth of a field as diverse and quickly evolving as data science using a language whose libraries are quickly evolving as well. Nonetheless, we hope <em class="calibre13">Clojure for Data Science</em> has given you an appreciation for some of the fundamental concepts of statistics, machine learning, and big data processing. This conceptual basis should serve you well, even as the technical options—and perhaps even your choice of programming language—continue evolving into the future.</p></div></div>



  </body></html>