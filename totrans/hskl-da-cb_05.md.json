["```py\n    data Tree a = Node { value\t:: a\n                       , left  :: (Tree a)\n                       , right:: (Tree a) }\n                | Leaf \n                deriving Show\n    ```", "```py\n    main = do\n      let n1 = Node { value = 1, left = Leaf, right = Leaf }\n      let n2 = Node { value = 2, left = Leaf, right = Leaf }\n      let n3 = Node { value = 3, left = n1,   right = n2 }\n      print n3\n    ```", "```py\n    $ runhaskell Main.hs\n\n    Node { value = 3\n     , left = Node  { value = 1\n     , left = Leaf\n     , right = Leaf }\n     , right = Node { value = 2\n     , left = Leaf\n     , right = Leaf }\n     }\n\n    ```", "```py\n    data Tree a = Node { value  :: a\n                       , children  :: [Tree a] } \n                       deriving Show\n    ```", "```py\n    main = do\n      let n1 = Node { value = 1, children = [] }\n      let n2 = Node { value = 2, children = [] }\n      let n3 = Node { value = 3, children = [] }\n      let n4 = Node { value = 6, children = [n1, n2, n3] }\n      print n4\n    ```", "```py\n    $ runhaskell Main.hs\n\n    Node { value = 6\n     , children = [ Node { value = 1\n     , children = [] }\n     , Node { value = 2\n     , children = [] }\n     , Node { value = 3\n     , children = [] } ] \n     }\n\n    ```", "```py\n    import Data.Tree (rootLabel, subForest, Tree(..))\n    import Data.List (tails)\n    ```", "```py\n    depthFirst :: Tree a -> [a]\n\n    depthFirst (Node r forest) = \n      r : concat [depthFirst t | t <- forest]\n    ```", "```py\n    add :: Tree Int -> Int\n\n    add (Node r forest) = r + sum [add t | t <- forest]\n    ```", "```py\n    someTree :: Tree Int\n\n    someTree = r\n      where r  = Node { rootLabel = 0, subForest = [n1, n4] }\n            n1 = Node { rootLabel = 1, subForest = [n2, n3] }\n            n2 = Node { rootLabel = 2, subForest = [] }\n            n3 = Node { rootLabel = 3, subForest = [] }\n            n4 = Node { rootLabel = 4, subForest = [] }\n    ```", "```py\n    main = do\n      print $ depthFirst someTree\n      print $ add someTree\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [0,1,2,3,4]\n    10\n\n    ```", "```py\ndata Tree a = Node { rootLabel :: a\n                   , subForest :: Forest a }\n```", "```py\n    import Data.Tree (rootLabel, subForest, Tree(..))\n    import Data.List (tails)\n    ```", "```py\n    breadthFirst :: Tree a -> [a]\n\n    breadthFirst t = bf [t]\n      where bf forest | null forest = []\n                      | otherwise   = map rootLabel forest ++\n                             bf (concat (map subForest forest))\n    ```", "```py\n    add :: Tree Int -> Int\n\n    add t = sum $ breadthFirst t\n    ```", "```py\n    someTree :: Tree Int\n\n    someTree = root\n      where root = Node { rootLabel = 0, subForest = [n1, n4] }\n            n1   = Node { rootLabel = 1, subForest = [n2, n3] }\n            n2   = Node { rootLabel = 2, subForest = [] }\n            n3   = Node { rootLabel = 3, subForest = [] }\n            n4   = Node { rootLabel = 4, subForest = [] }\n    ```", "```py\n    main = do\n      print $ breadthFirst someTree\n      print $ add someTree\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [0,1,4,2,3]\n    10\n\n    ```", "```py\ndata Tree a = Node { rootLabel :: a\n                   , subForest :: Forest a }\n```", "```py\n    import Data.Monoid (mempty, mappend)\n    import qualified Data.Foldable as F\n    import Data.Foldable (Foldable, foldMap)\n    ```", "```py\n    data Tree a = Node { value :: a\n                       , children :: [Tree a] }\n                       deriving Show\n    ```", "```py\n    instance Foldable Tree where\n      foldMap f Null = mempty\n      foldMap f (Node val xs) = foldr mappend (f val) \n                                 [foldMap f x | x <- xs]\n    ```", "```py\n    add :: Tree Integer -> Integer\n\n    add = F.foldr1 (+)\n    ```", "```py\n    someTree :: Tree Integer\n\n    someTree = root\n      where root = Node { value = 0, children = [n1, n4] }\n            n1   = Node { value = 1, children = [n2, n3] }\n            n2   = Node { value = 2, children = [] }\n            n3   = Node { value = 3, children = [] }\n            n4   = Node { value = 4, children = [] }\n    ```", "```py\n    main :: IO ()\n    main = print $ add someTree\n    ```", "```py\n    $ runhaskell Main.hs\n\n    10\n\n    ```", "```py\n    import Data.List (maximum)\n    import Data.Tree\n    ```", "```py\n    height :: Tree a -> Int\n\n    height (Node val []) = 1\n    height (Node val xs) = 1 + maximum (map height xs)\n    ```", "```py\n    someTree :: Tree Integer\n\n    someTree = root\n      where root = 0 [n1, n4]\n            n1   = 1 [n2, n3]\n            n2   = 2 []\n            n3   = 3 []\n            n4   = 4 []\n    ```", "```py\n    main = print $ height someTree\n    ```", "```py\n    $ runhaskell Main.hs\n\n    3\n\n    ```", "```py\n    module BSTree (insert, find, single) where\n    ```", "```py\n    data Tree a = Node\t{value\t:: a\n                       , left   :: (Tree a)\n                       , right  :: (Tree a)}\n                 | Null\n                 deriving (Eq, Show)\n    ```", "```py\n    single :: a -> Tree a\n\n    single n = Node n Null Null\n    ```", "```py\n    insert :: Ord a => Tree a -> a -> Tree a\n\n    insert (Node v l r) v'\n      | v' < v      = Node v (insert l v') r\n      | v' > v      = Node v l (insert r v')\n      | otherwise   = Node v l r\n\n    insert _ v' = Node v' Null Null\n    ```", "```py\n    find :: Ord a => Tree a -> a -> Bool\n\n    find (Node v l r) v'\n      | v' < v      = find l v'\n      | v' > v      = find r v'\n      | otherwise   = True\n\n    find Null v' = False\n    ```", "```py\n    import BSTree\n    ```", "```py\n    main = do\n      let tree = single 5\n      let nodes = [6,4,8,2,9]\n      let bst = foldl insert tree nodes\n    ```", "```py\n      print bst\n      print $ find bst 1\n      print $ find bst 2\n    ```", "```py\n    $ runhaskell Main.hs\n\n    Node { value = 5\n     , left = Node { value = 4\n     , left = Node { value = 2\n     , left = Null\n     , right = Null }\n     , right = Null }\n     , right = Node { value = 6\n     , left = Null\n     , right = Node { value = 8\n     , left = Null\n     , right = Node { value = 9\n     , left = Null\n     , right = Null }\n     }\n     }\n     }\n\n    False\n\n    True\n\n    ```", "```py\n    data Tree a = Node { value  :: a\n                       , left  :: (Tree a)\n                       , right :: (Tree a)}\n                | Null\n        deriving (Eq, Show)\n    ```", "```py\n    someTree :: Tree Int\n\n    someTree = root  \n      where root = Node 0 n1 n4\n            n1   = Node 1 n2 n3\n            n2   = Node 2 Null Null\n            n3   = Node 3 Null Null\n            n4   = Node 4 Null Null\n    ```", "```py\n    valid :: Ord t => Tree t -> Bool\n\n    valid (Node v l r) = leftValid && rightValid\n      where leftValid  = if notNull l \n                           then valid l && value l <= v \n                           else True\n            rightValid = if notNull r \n                           then valid r && v <= value r \n                           else True\n            notNull t  =  t /= Null\n    ```", "```py\n    main = print $ valid someTree\n    ```", "```py\n    $ runhaskell Main.hs\n\n    False\n\n    ```", "```py\n$ cabal install AvlTree\n\n```", "```py\n    import Data.Tree.AVL\n    import Data.COrdering\n    ```", "```py\n    main = do\n      let avl  = asTree fstCC [4,2,1,5,3,6]\n      let min  = tryReadL avl\n      let max  = tryReadR avl\n      print min\n      print max\n    ```", "```py\n    $ runhaskell Main.hs\n\n    Just 1\n    Just 6\n\n    ```", "```py\nimport qualified Data.Set as S\n\nmain = do\n  let s = S.fromList [4,2,1,5,3,6]\n  let min = S.findMin s\n  let max = S.findMax s\n  print min\n  print max \n```", "```py\n$ cabal install lens\n\n```", "```py\n    module MinHeap (empty, insert, deleteMin, weights) where\n\n    import Control.Lens (element, set)\n    import Data.Maybe (isJust, fromJust)\n    ```", "```py\n    data Heap v = Heap { items :: [Node v] }\n                  deriving Show\n\n    data Node v = Node { value :: v, weight :: Int }\n                  deriving Show\n    ```", "```py\n    empty = Heap []\n    ```", "```py\n    insert v w (Heap xs) = percolateUp position items'\n      where items'   = xs ++ [Node v w]\n            position = length items' - 1\n    ```", "```py\n    deleteMin (Heap xs) = percolateDown 1 items'\n      where items' = set (element 1) (last xs) (init xs)\n    ```", "```py\n    viewMin heap@(Heap (_:y:_)) = \n      Just (value y, weight y, deleteMin heap)\n    viewMin _                   = Nothing\n    ```", "```py\n    percolateDown i items\n       | isJust left && isJust right = percolateDown i' \n                                         (swap i i' items)\n       | isJust left = percolateDown l (swap i l items)\n       | otherwise = Heap items\n    ```", "```py\n      where left   = if l >= length items\n                       then Nothing\n                       else Just $ items !! l\n            right  = if r >= length items\n                       then Nothing\n                       else Just $ items !! r\n            i'     = if (weight (fromJust left)) < \n                          (weight (fromJust right))\n                     then l else r\n            l      = 2*i\n            r      = 2*i + 1\n    ```", "```py\n    percolateUp i items\n      | i == 1 = Heap items\n      | w < w' = percolateUp c (swap i c items)\n      | otherwise = Heap items\n       where  w  = weight $ items !! i\n              w' = weight $ items !! c\n              c  = i `div` 2\n    ```", "```py\n    swap i j xs = set (element j) vi (set (element i) vj xs)\n      where vi = xs !! i\n            vj = xs !! j\n    ```", "```py\n    weights heap = map weight ((tail.items) heap)\n    ```", "```py\n    import MinHeap\n\n    main = do\n      let heap = foldr (\\x -> insert x x) \n                   empty [11, 5, 3, 4, 8]\n      print $ weights heap\n      print $ weights $ iterate deleteMin heap !! 1\n      print $ weights $ iterate deleteMin heap !! 2\n      print $ weights $ iterate deleteMin heap !! 3\n      print $ weights $ iterate deleteMin heap !! 4\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [3,5,4,8,11]\n    [4,5,11,8]\n    [5,8,11]\n    [8,11]\n    [11]\n\n    ```", "```py\n    import Data.Heap (MinHeap, MaxHeap, empty, insert, view)\n    ```", "```py\n    minheapFromList :: [Int] -> MinHeap Int\n    minheapFromList ls = foldr insert empty ls\n    ```", "```py\n    maxheapFromList :: [Int] -> MaxHeap Int\n    maxheapFromList ls = foldr insert empty ls\n    ```", "```py\n    main = do\n      let myList = [11, 5, 3, 4, 8]\n      let minHeap = minheapFromList myList\n      let maxHeap = maxheapFromList myList\n      print $ view minHeap\n      print $ view maxHeap\n    ```", "```py\n    $ runhaskell Main.hs\n    Just (3, fromList [(4,()),(11,()),(5,()),(8,())])\n    Just (11, fromList [(8,()),(3,()),(5,()),(4,())])\n\n    ```", "```py\n    import Data.List (group, sort)\n    import MinHeap\n    import Network.HTTP ( getRequest, getResponseBody, simpleHTTP )\n    import Data.Char (isAscii)\n    import Data.Maybe (fromJust)\n    import Data.Map (fromList, (!))\n    ```", "```py\n    freq xs = map (\\x -> (head x, length x)) . \n                group . sort $ xs\n    ```", "```py\n    data HTree  =  HTree { value :: Char\n                         , left  :: HTree\n                         , right :: HTree }\n                | Null\n                deriving (Eq, Show)\n    ```", "```py\n    single v = HTree v Null Null\n    ```", "```py\n    htree heap = if length (items heap) == 2\n                 then case fromJust (viewMin heap) of \n                        (a,b,c) -> a\n                 else htree $ insert newNode (w1 + w2) heap3\n\n      where (min1, w1, heap2) = fromJust $ viewMin heap\n            (min2, w2, heap3) = fromJust $ viewMin heap2\n            newNode           = HTree { value  = ' '\n                                      , left   = min1\n                                      , right  = min2 }\n    ```", "```py\n    codes htree = codes' htree \"\"\n\n      where codes' (HTree v l r) str\n                | l==Null && r==Null = [(v, str)]\n                | r==Null            = leftCodes\n                | l==Null            = rightCodes\n                | otherwise          = leftCodes ++ rightCodes\n                where  leftCodes  = codes' l ('0':str)\n                       rightCodes = codes' r ('1':str)\n    ```", "```py\n    encode str m = concat $ map (m !) str\n    ```", "```py\n    main = do\n      rsp <- simpleHTTP (getRequest \n               \"http://norvig.com/big.txt\")\n      html <- fmap (takeWhile isAscii) (getResponseBody rsp)\n      let freqs = freq html\n      let heap = foldr (\\(v,w) -> insert (single v) w) \n                   empty freqs\n      let m = fromList $ codes $ htree heap\n      print $ encode \"hello world\" m\n    ```", "```py\n    $ runhaskell Main.hs\n\n    \"010001110011110111110001011101000100011011011110010\"\n\n    ```", "```py\ndecode :: String -> HTree -> String\ndecode str htree = decode' str htree\n  where  decode' \"\" _ = \"\"\n      decode' ('0':str) (HTree _ l _)\n        | leaf l    = value l : decode' str htree\n        | otherwise = decode' str l\n      decode' ('1':str) (HTree v _ r)\n        | leaf r    = value r : decode' str htree\n        | otherwise = decode' str r\n      leaf tree = left tree == Null && right tree == Null\n```"]