- en: Chapter 4. Data Hashing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 数据哈希
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Hashing a primitive data type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希原始数据类型
- en: Hashing a custom data type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希自定义数据类型
- en: Running popular cryptographic hash functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行流行的加密哈希函数
- en: Running a cryptographic checksum on a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件运行加密校验和
- en: Performing fast comparisons between data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据类型之间进行快速比较
- en: Using a high-performance hash table
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高性能哈希表
- en: Using Google's CityHash hash functions for strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google的CityHash哈希函数对字符串进行哈希
- en: Computing Geohash for location coordinates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算位置坐标的Geohash
- en: Using a bloom filter to remove unique items
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布隆过滤器去除唯一项
- en: Running MurmurHash, a simple but speedy hashing algorithm
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行MurmurHash，一个简单但快速的哈希算法
- en: Measuring image similarity with perceptual hashes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用感知哈希测量图像相似度
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch04.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch04.jpg)'
- en: A **hash** is a lossy way of representing an object into a small and typically
    fixed-length value. Hashing data embellishes us with speedy lookups and lightweight
    handling of massive datasets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**是一种有损的方式，将对象表示为一个小而通常是固定长度的值。哈希数据使我们能够快速查找和轻松处理大量数据集。'
- en: The output of a hashing function is referred to as a **digest**. One of the
    principal properties of a good hashing function is that it must be deterministic,
    which means a given input must always produce the same corresponding output. Sometimes,
    two different inputs may end up producing the same output, and we call that a
    **collision**. Given a hash alone, we cannot invert the process to rediscover
    the object within an adequate time. To minimize the chances of a collision, another
    property of a hash function called **uniformity** is used. In other words, the
    probability of each output occurring should be nearly the same.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的输出被称为**摘要**。一个好的哈希函数的主要特性之一是它必须是确定性的，这意味着给定的输入必须始终产生相同的输出。有时，两个不同的输入可能最终产生相同的输出，我们称之为**碰撞**。仅凭哈希值，我们无法反转过程在合理的时间内重新发现原始对象。为了最小化碰撞的几率，哈希函数的另一个特性叫做**均匀性**。换句话说，每个输出出现的概率应该几乎相同。
- en: We will start by first producing a simple digest from an input. Then in the
    next recipe, we will run the hashing algorithm on our custom-made data type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从输入生成一个简单的摘要。然后，在下一个食谱中，我们将对自定义数据类型运行哈希算法。
- en: Another important application of hashing is in cryptography. We will cover some
    of the most popular cryptographic hashing algorithms such as SHA-512\. We will
    also apply these hashes on files for computing checksums to ensure file integrity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的另一个重要应用是在加密学中。我们将介绍一些最流行的加密哈希算法，如SHA-512。我们还将应用这些哈希对文件进行校验和计算，以确保文件完整性。
- en: Lastly, we will cover many nontraditional hashing approaches including CityHash,
    GeoHashing, bloom filters, MurmurHash, and pHash.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍许多非传统的哈希方法，包括CityHash、GeoHashing、布隆过滤器、MurmurHash和pHash。
- en: Hashing a primitive data type
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希原始数据类型
- en: This recipe demonstrates how to use a simple hash function on various primitive
    data types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了如何在各种原始数据类型上使用简单的哈希函数。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `Data.Hashable` package from Cabal as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cabal安装`Data.Hashable`包，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Import the hashing function with the following line:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行导入哈希函数：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Test the `hash` function on a string as follows; this function is actually
    a wrapper around the `hashWithSalt` function with a default salt value:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`hash`函数对字符串的作用，如下所示；该函数实际上是一个包装器，围绕着默认盐值的`hashWithSalt`函数：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test out the `hashWithSalt` functions using different initial salt values as
    follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的初始盐值测试`hashWithSalt`函数，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also hash tuples and lists as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以如下对元组和列表进行哈希：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice in the following output how the first three hashes produce different
    results even though their input is the same:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意以下输出中的前三个哈希尽管输入相同，却产生了不同的结果：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Hashing with a salt means applying the hash function only after slightly modifying
    it. It's as if we "salted up" the input before processing it through the hash
    function. Even the slightest change in salt values produces dramatically different
    hashed digests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用盐值进行哈希意味着在稍微修改数据后再应用哈希函数。就像我们在通过哈希函数处理输入之前“加盐”了一样。即使盐值稍有变化，也会产生完全不同的哈希摘要。
- en: We need this concept of a salt for better password security. Hash functions
    always produce the same output for the same input, and this is both good and bad.
    There are databases of rainbow tables for every commonly used password in existence
    for all major hashing algorithms. If a website with a login system service (such
    as Packt Publishing) stores the password using cryptographic hashes, but without
    being salted, then it's no better than plain text if the password itself is considered
    weak. If a service such as Packt Publishing uses salt in its cryptographic hashing
    (and it should), then it's an added layer of security and rainbow tables are rendered
    useless.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这种盐的概念来提高密码安全性。哈希函数对于相同的输入总是产生相同的输出，这既有好处也有坏处。对于所有主要的哈希算法，都有现成的彩虹表数据库，其中包含每个常用密码。如果一个具有登录系统服务的网站（例如
    Packt Publishing）使用加密哈希存储密码，但没有使用盐，那么如果密码本身被认为是弱密码，它与明文密码没有区别。如果像 Packt Publishing
    这样的服务在其加密哈希中使用盐（并且应该使用），那么它就增加了一层安全性，而彩虹表则变得无用。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'The previous code produced a hash of a string, but the algorithm is not limited
    to just strings. The following data types also implement `hashable`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码生成了一个字符串的哈希，但这个算法不限于字符串。以下数据类型也实现了 `hashable`：
- en: Bool
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bool
- en: Char
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Char
- en: Int
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int
- en: Int8
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int8
- en: Int16
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int16
- en: Int32
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int32
- en: Int64
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Int64
- en: Word
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word
- en: Word8
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word8
- en: Word16
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word16
- en: Word32
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word32
- en: Word64
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Word64
- en: ByteString
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ByteString
- en: List of hashable items
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可哈希项的列表
- en: Tuple of hashable items
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希项的元组
- en: Maybe of a hashable item
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许是一个可哈希的项
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: For using a hash function on a custom-made data type, refer to the *Hashing
    a custom data type* recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何对自定义数据类型使用哈希函数，请参考 *哈希一个自定义数据类型* 这个配方。
- en: Hashing a custom data type
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希一个自定义数据类型
- en: Even a custom-defined data type can be hashed easily. Dealing with hashed digests
    is often useful when the data itself is too space consuming to manage directly.
    By referencing a data by its digest, we can easily skip the cost of carrying around
    whole data types. This is especially useful in data analysis.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是自定义定义的数据类型也可以轻松进行哈希。当数据本身占用空间过大，无法直接管理时，处理哈希摘要通常非常有用。通过使用数据的摘要引用，我们可以轻松避免携带整个数据类型的开销。这在数据分析中尤其有用。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'Install the `Data.Hashable` package from Cabal as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式从 Cabal 安装 `Data.Hashable` 包：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Use the GHC language extension `DeriveGeneric` to autodefine the hash functions
    for our custom data types as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GHC 语言扩展 `DeriveGeneric` 自动定义我们自定义数据类型的哈希函数，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Import the relevant packages using the following lines of code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行导入相关包：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a custom data type and let `GHC` autodefine its hashable instance as
    follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义数据类型，并让 `GHC` 自动定义其哈希实例，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `main`, create three points. Let two of them be the same, and let the third
    point be different, as shown in the following code snippet:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 中，创建三个点。让其中两个相同，第三个不同，如以下代码片段所示：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Print the hash values of identical points as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印相同点的哈希值，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Print the hash values of different points as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印不同点的哈希值，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We can define a custom hashing function on our own data types by providing
    an instance for Hashable. The Hashable instance only requires the implementation
    of `hashWithSalt :: Int -> a -> Int`. To help implement `hashWithSalt`, we also
    have two useful functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过为 `Hashable` 提供实例来为自定义数据类型定义哈希函数。`Hashable` 实例只需要实现 `hashWithSalt ::
    Int -> a -> Int`。为了帮助实现 `hashWithSalt`，我们还提供了两个有用的函数：'
- en: 'Hashing a pointer with salt is performed as shown in the following code snippet:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盐对指针进行哈希操作，如以下代码片段所示：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Hashing a byte array with salt is performed as shown in the following code
    snippet:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盐对字节数组进行哈希操作，如以下代码片段所示：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To hash a built-in primitive, refer to the *Hashing a primitive data type* recipe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要哈希一个内建的原始类型，请参考 *哈希一个原始数据类型* 这个配方。
- en: Running popular cryptographic hash functions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行流行的加密哈希函数
- en: A cryptographic hash function has specific properties that make it different
    from other hash functions. First of all, producing a possible input message from
    a given hash digest output should be intractable, meaning that it must take an
    exponentially long time to solve in practice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个加密哈希函数具有特定的属性，使其与其他哈希函数不同。首先，从给定的哈希摘要输出生成可能的输入消息应该是不可行的，意味着在实践中解决这个问题必须耗费指数级的时间。
- en: For example, if a hash produces the digest `66fc01ae071363ceaa4178848c2f6224`,
    then in principle, discovering the content used to generate a digest should be
    difficult.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In practice, some hash functions are easier to crack than others. For example,
    MD5 and SHA-1 are considered trivial to crack and should not be used, but are
    demonstrated later for completeness. More information about how MD5 and SHA-1
    are insecure can be found at [http://www.win.tue.nl/hashclash/rogue-ca](http://www.win.tue.nl/hashclash/rogue-ca)
    and [https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html](https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html)
    respectively.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `Crypto.Hash` package from Cabal as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the cryptographic hash function library as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define each hash functions by explicitly associating the data types as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test out each cryptographic hash function on the same input, as shown in the
    following code snippet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final output can be seen in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it…](img/6331OS_04_05.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run one of these cryptographic hash functions on a file to perform an integrity
    check, refer to the *Running a cryptographic checksum on a file* recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Running a cryptographic checksum on a file
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most effective methods to determine whether a file on a computer
    is different from another file elsewhere is by comparing their cryptographic hashes.
    If the two hashes are equal, it's only highly probable that the files are equal,
    but not strictly necessary due to the possibility of collisions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading a file online, such as Arch Linux from [https://www.archlinux.org/download](https://www.archlinux.org/download),
    it is a good idea to ensure the cryptographic hashes match up. For example, have
    a look at the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a cryptographic checksum on a file](img/6331OS_04_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the corresponding hashes for the Arch Linux download
    as of late May, 2014.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Notice how both MD5 and SHA1 hashes are provided. This recipe will show how
    to compute these hashes in Haskell to ensure data integrity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We will compute the SHA256, SHA512, and MD5 hashes of its own source file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `Crypto.Hash` package from Cabal as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file named `Main.hs` and insert the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the `MD5` hash function as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the `SHA256` hash function as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the `SHA512` hash function as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open a file of the `ByteString` type using the `readFile` function provided
    by the `Data.ByteString` package as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Test out the various hashes on the file as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following output is generated:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To apply the cryptographic hash functions on data types instead, refer to the
    *Running popular cryptographic hash functions* recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Performing fast comparisons between data types
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StableName` package allows us to establish constant time comparisons of
    arbitrary data types. The Hackage documentation elegantly describes this ([http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-StableName.html)):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '*"Stable names solve the following problem: suppose you want to build a hash
    table with Haskell objects as keys, but you want to use pointer equality for comparison;
    maybe because the keys are large and hashing would be slow, or perhaps because
    the keys are infinite in size. We can''t build a hash table using the address
    of the object as the key, because objects get moved around by the garbage collector,
    meaning a re-hash would be necessary after every garbage collection."*'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the built-in `StableName` package as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a custom data type as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `main`, define two points as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Get the stable name of each point and display it using the following set of
    commands:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice in the following result how we can easily obtain the stable name of
    arbitrary data types:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using a high-performance hash table
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haskell already comes with a `Data.Map` module based on size-balanced binary
    trees. There exist better-optimized hash table libraries such as `Data.HashMap`
    from the unordered-containers package.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: For example, both `Data.Map` and `Data.HashMap` have insertion and lookup time
    complexities of O(log n); however, the latter uses a large base, so in practice
    these operations are constant time. More documentation on `Data.HashMap` can be
    found at [http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html](http://hackage.haskell.org/package/unordered-containers-0.2.4.0/docs/Data-HashMap-Lazy.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the unordered-contains library from Hackage to create
    a mapping of word size to a set of words of that size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download a large corpus of text and name the file `big.txt` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Install the `Data.HashMap` package using Cabal as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `HashMap` package as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a helper function to define an empty hash map using the following line
    of code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define a function to insert a word to the hash map using the following code
    snippet:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Find all words of a specific length from a map as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Construct the hashmap from a corpus of text using the following line of code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Read the large corpus of text, construct the hash map, and print the number
    of words of each length, as shown in the following code snippet:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we plot the data, we can discover an interesting trend as shown in the following
    figure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/6331OS_04_01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technical specifics about the library are explained in the following blog post
    by the author:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html](http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Using Google's CityHash hash functions for strings
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google's CityHash hash functions are optimized for hashing strings, but are
    not meant to be cryptographically secure. CityHash is ideal for implementing a
    hash table dealing with strings. We will use it in this recipe to produce both
    64-bit and 128-bit digests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `cityhash` package from Cabal as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the relevant packages as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Test the various hashing function on an input string using the following code
    snippet:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Display the output as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Google describes its package on its blog announcement at [http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html](http://google-opensource.blogspot.com/2011/04/introducing-cityhash.html)
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*"The key advantage of our approach is that most steps contain at least two
    independent mathematical operations. Modern CPUs tend to perform best with this
    type of code."*'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see a more generic hashing function, refer to the *Hashing a primitive data
    type* and *Hashing a custom data type* recipes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Computing a Geohash for location coordinates
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Geohash is a practical encoding of latitude-longitude coordinates. It does
    not behave like a typical hash function since minor changes in location only produce
    minor changes in the output digest. Geohash allows efficient proximity search
    and arbitrary precision determined by the specified length of the digest.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the Geohashing library as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How to do it…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `Geohash` library as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a geohash of a latitude-longitude coordinate pair as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Display the geohash using the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a geohash of another similar latitude-longitude coordinate pair as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Display the geohash using the following code snippet:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output is as follows. Notice how the geohash appears to share the same prefix
    due to their closeness.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using a bloom filter to remove unique items
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A bloom filter is an abstract data type that tests whether an item exists in
    a set. Unlike a typical hash map data structure, a bloom filter only takes up
    a constant amount of space. The advantage comes in handy when dealing with billions
    of data, such as representations of DNA strands as strings: "GATA", "CTGCTA",
    and so on.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will use a bloom filter to try to remove unique DNA strands
    from a list. This is often desired because a typical DNA sample may contain thousands
    of strands that only appear once. The major disadvantage of a bloom filter is
    that false positive results for membership are possible. The bloom filter may
    accidentally claim that an element exists. Though false negatives are not possible:
    a bloom filter will never claim that an element does not exist when it actually
    does.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the bloom filter package from Cabal as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the bloom filter package as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a function to remove the unique elements from a list. First check to
    see if each item exists in the bloom filter; if so, add it to a hash map. If not,
    add it to the bloom filter, as presented in the following code snippet:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the algorithm on a couple of DNA strand examples as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We see the following strands that likely occur at least twice:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bloom filter is composed of a couple of hashing functions and a list of numbers
    initialized at zero. When inserting an element to this data structure, hashes
    are computed from each of the hashing functions and the corresponding item in
    the list is updated. Membership tests on a bloom filter are conducted by computing
    each of the hash functions in the input and testing whether all corresponding
    list elements are above some threshold value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6331OS_04_06.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: For example, in the preceding figure, three hash functions are applied to every
    input. When a hash is calculated for **x**, **y**, and **z**, the corresponding
    element in the list representing the bloom filter is incremented. We can determine
    whether **w** exists in this bloom filter by computing the three hashes and checking
    if corresponding indices are all at a desired value. In this case, **w** does
    not exist in the bloom filter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Running MurmurHash, a simple but speedy hashing algorithm
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the priority of a hashing function should be in maximizing its computation
    speed. The MurmurHash algorithm exists for this reason. When dealing with massive
    **data sets**, speed is essential.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are negative qualities of a fast hashing algorithm. If hashing algorithm
    A is 10 times faster than hashing algorithm B, then it's also 10 times faster
    to stumble upon the content used to create a digest with A than with B using a
    random content search. A hashing algorithm should be fast, but not so fast as
    to impact the security of the algorithm.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the Murmur hashing algorithm from Cabal as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the Murmur hashing algorithm as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define a custom data type and implement an instance to use Murmur as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the hashing algorithm on various inputs, using the following code snippet:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following hashes are produced:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Measuring image similarity with perceptual hashes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A perceptual hash produces a small digest from an image file where slight changes
    in the images only produce a slight change in the hash. This can be useful to
    quickly compare thousands of images.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `pHash` library from [www.phash.org](http://www.phash.org). On
    a Debian-based system, we can install it by using `apt-get` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Install the `phash` library from Cabal as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Find three nearly identical images. We will use the following image:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_04_02.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: This is the second image that we will be using
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_04_03.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'And the following image is the third:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_04_04.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `phash` library as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`phash`库，代码如下：
- en: '[PRE66]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Hash an image as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一张图片进行哈希处理，结果如下：
- en: '[PRE67]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Hash a similar image as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一张相似的图片进行哈希处理，结果如下：
- en: '[PRE68]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Hash a slightly different image as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对一张稍微不同的图片进行哈希处理，结果如下：
- en: '[PRE69]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Compute the similarity of the first two images using the following code snippet:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段计算前两张图片的相似度：
- en: '[PRE70]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Compute the similarity of the first to the third image as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算第一张图片与第三张图片的相似度，结果如下：
- en: '[PRE71]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output hashes are as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出哈希值如下：
- en: '[PRE72]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It's much easier to visualize how similar these hashes are in hexadecimal (or
    binary), since Hamming distance operates in bits.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制（或二进制）中可视化这些哈希值的相似性要容易得多，因为哈明距离是按比特操作的。
- en: 'The hexadecimal representation of the three images are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 三张图片的十六进制表示如下：
- en: '**Image 1**: c316b1bc36947e1c'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片 1**: c316b1bc36947e1c'
- en: '**Image 2**: c912b1fc36947e1c'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片 2**: c912b1fc36947e1c'
- en: '**Image 3**: 851639bc3650fe9c'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片 3**: 851639bc3650fe9c'
- en: By comparing these values, we can see that images 1 and 2 differ by only four,
    whereas images 1 and 3 differ by a whopping 10 characters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较这些值，我们可以看到，图片1和图片2仅相差四个字符，而图片1和图片3相差整整10个字符。
