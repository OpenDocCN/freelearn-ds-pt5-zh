["```py\n$ cabal install twitter-conduit\n\n```", "```py\n$ cabal install yocto\n\n```", "```py\n    $ export OAUTH_CONSUMER_KEY=\"Your OAuth Consumer Key\"\n    $ export OAUTH_CONSUMER_SECRET=\"Your OAuth Consumer Secret\"\n\n    ```", "```py\n    $ export OAUTH_ACCESS_TOKEN=\"Your OAuth Access Token\"\n    $ export OAUTH_ACCESS_SECRET=\"Your OAuth Access Secret\"\n\n    ```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n\n    import qualified Data.Conduit as C\n    import qualified Data.Conduit.List as CL\n    import qualified Data.Text.IO as T\n    import qualified Data.Text as T\n\n    import Control.Monad.IO.Class (liftIO)\n    import Network.HTTP (getResponseBody, getRequest, simpleHTTP, urlEncode)\n    import Text.JSON.Yocto\n    import Web.Twitter.Conduit (stream, statusesFilterByTrack)\n    import Common\n    import Control.Lens ((^!), (^.), act)\n    import Data.Map ((!))\n    import Data.List (isInfixOf, or)\n    import Web.Twitter.Types \n    ```", "```py\n    main :: IO ()\n\n    main = do\n      let query = \"haskell\"\n      T.putStrLn $ T.concat [ \"Streaming Tweets that match \\\"\"\n                            , query, \"\\\"...\"]\n      analyze query\n    ```", "```py\n    analyze :: T.Text -> IO ()\n\n    analyze query = runTwitterFromEnv' $ do\n      src <- stream $ statusesFilterByTrack query\n      src C.$$+- CL.mapM_ (^! act (liftIO . process))\n    ```", "```py\n    process :: StreamingAPI -> IO ()\n\n    process (SStatus s) = do\n      let theUser = userScreenName $ statusUser s\n      let theTweet = statusText s\n      T.putStrLn $ T.concat [theUser, \": \", theTweet]\n      val <- sentiment $ T.unpack theTweet\n      let record = (T.unpack theUser) ++ \",\" ++ \n                   (show.fromRational) val ++ \"\\n\"\n      appendFile \"output.csv\" record\n      print val\n    ```", "```py\n    process s = return ()\n    ```", "```py\n    clean :: String -> String\n\n    clean str = unwords $ filter \n                (\\w -> not (or \n                       [ isInfixOf \"@\" w\n                       , isInfixOf \"#\" w\n                       , isInfixOf \"http://\" w ]))\n                (words str)\n    ```", "```py\n    sentiment :: String -> IO Rational\n    sentiment str = do \n      let baseURL = \"http://www.sentiment140.com/api/classify?text=\"\n      resp <- simpleHTTP $ getRequest $ \n              baseURL ++ (urlEncode.clean) str\n      body <- getResponseBody resp\n      let p = polarity (decode body) / 4.0\n      return p\n    ```", "```py\n    polarity :: Value -> Rational\n\n    polarity (Object m) = polarity' $ m ! \"results\"\n      where polarity' (Object m) = fromNumber $ m ! \"polarity\"\n            fromNumber (Number n) = n\n    polarity _ = -1\n    ```", "```py\n    $ runhaskell Main.hs\n    Streaming Tweets that match \"x-men\"…\n\n    ```", "```py\nanalyze:: IO ()\nanalyze = runTwitterFromEnv' $ do\n  src <- statusesFilterByFollow [ 103285804, 450331119\n                                , 64895420]\n  src C.$$+- CL.mapM_ (^! act (liftIO . process))\n```", "```py\nanalyze :: IO ()\nanalyze = runTwitterFromEnv' $ do\n  src <- stream userstream\n  src C.$$+- CL.mapM_ (^! act (liftIO . process))\n```", "```py\n    import Network\n    import Control.Monad (forever)\n    import System.IO\n    import Text.Printf\n    ```", "```py\n    server = \"irc.freenode.org\"\n    port   = 6667\n    chan   = \"#haskelldata\"\n    nick   = \"awesome-bot\"\n    ```", "```py\n    main = do\n      h <- connectTo server (PortNumber (fromIntegral port))\n      hSetBuffering h NoBuffering\n      write h \"NICK\" nick\n      write h \"USER\" (nick++\" 0 * :tutorial bot\")\n      write h \"JOIN\" chan\n      listen h\n\n    write :: Handle -> String -> String -> IO ()\n    write h s t = do\n      hPrintf h \"%s %s\\r\\n\" s t\n      printf    \"> %s %s\\n\" s t\n    ```", "```py\n    listen :: Handle -> IO ()\n    listen h = forever $ do\n      s <- hGetLine h\n      putStrLn s\n    ```", "```py\n$ cabal install simpleirc\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n\n    import Network.SimpleIRC\n    import Data.Maybe\n    import qualified Data.ByteString.Char8 as B\n    ```", "```py\n    onMessage :: EventFunc\n    onMessage s m = do\n      case msg of\n        \"host?\" ->  sendMsg s chan $ botMsg\n        otherwise -> return ()\n      where chan = fromJust $ mChan m\n            msg = mMsg m\n            host = case mHost m of\n              Just h -> h\n              Nothing -> \"unknown\"\n            nick = case mNick m of\n              Just n -> n\n              Nothing -> \"unknown user\"\n            botMsg = B.concat [ \"Hi \", nick, \"\n                              , your host is \", host]\n    ```", "```py\n    events = [(Privmsg onMessage)]\n    ```", "```py\n    freenode = \n      (mkDefaultConfig \"irc.freenode.net\" \"awesome-bot\")\n      { cChannels = [\"#haskelldata\"]\n      , cEvents   = events\n      }\n    ```", "```py\n    main = connect freenode False True\n    ```", "```py\n    import Network.HTTP\n    import Control.Concurrent (threadDelay)\n    import qualified Data.Text as T\n    ```", "```py\n    url = \"http://www.reddit.com/r/pics/new.json\"\n    ```", "```py\n    latest :: IO String\n\n    latest = simpleHTTP (getRequest url) >>= getResponseBody\n    ```", "```py\n    poll :: IO a\n\n    poll = do\n      body <- latest\n      print $ doWork body\n      threadDelay (10 * 10^6)\n      poll\n    ```", "```py\n    main :: IO a\n    main = do\n      putStrLn $ \"Polling \" ++ url ++ \" …\"\n      poll\n    ```", "```py\n    doWork str = length $ T.breakOnAll \n                  (T.pack \"imgur.com/\") (T.pack str)\n    ```", "```py\n$ cabal install fsnotify\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n    import Filesystem.Path.CurrentOS\n    import System.FSNotify\n    import Filesystem\n    import Filesystem.Path (filename)\n    ```", "```py\n    main :: IO ()\n\n    main = do\n      wd <- getWorkingDirectory\n      print wd\n\n      man <- startManager\n      watchTree man wd (const True) doWork\n      putStrLn \"press return to stop\"\n\n      getLine\n      putStrLn \"watching stopped, press return to exit\"\n\n      stopManager man\n      getLine\n      return ()\n    ```", "```py\n    doWork :: Event -> IO ()  \n\n    doWork (Added filepath time) = \n      putStrLn $ (show $ filename filepath) ++ \" added\"\n    doWork (Modified filepath time) = \n      putStrLn $ (show $ filename filepath) ++ \" modified\"\n    doWork (Removed filepath time) = \n      putStrLn $ (show $ filename filepath) ++ \" removed\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    press return to stop\n    FilePath \"hello.txt\" added\n    FilePath \"hello.txt\" modified\n    FilePath \"hello.txt\" removed\n\n    ```", "```py\n    import Network ( listenOn, withSocketsDo, accept\n                   , PortID(..), Socket )\n    import System.Environment (getArgs)\n    import System.IO ( hSetBuffering, hGetLine, hPutStrLn\n                     , BufferMode(..), Handle )\n    import Control.Concurrent (forkIO)\n    ```", "```py\n    main :: IO ()\n\n    main = withSocketsDo $ do\n        let port = PortNumber 9001\n        sock <- listenOn port\n        putStrLn $ \"Listening…\"\n        sockHandler sock\n    ```", "```py\n    sockHandler :: Socket -> IO ()\n\n    sockHandler sock = do\n        (h, _, _) <- accept sock\n        putStrLn \"Connected!\"\n        hSetBuffering h LineBuffering\n        forkIO $ process h\n        forkIO $ respond h\n        sockHandler sock\n    ```", "```py\n    process :: Handle -> IO ()\n    process h = do\n        line <- hGetLine h\n        print line\n        process h\n    ```", "```py\n    respond h = withSocketsDo $ do\n      txt <- getLine\n      hPutStrLn h txt\n      respond h\n    ```", "```py\n    import Network (connectTo, withSocketsDo, PortID(..))\n    import System.Environment (getArgs)\n    import System.IO ( hSetBuffering, hPutStrLn\n                     , hGetLine, BufferMode(..) )\n    ```", "```py\n    main = withSocketsDo $ do\n      let port = PortNumber 9001\n      h <- connectTo \"localhost\" port\n      putStrLn $ \"Connected!\"\n      hSetBuffering h LineBuffering\n      forkIO $ respond h\n      forkIO $ process h\n      loop\n    ```", "```py\n    respond h = do\n      txt <- getLine\n      hPutStrLn h txt\n      respond h\n    ```", "```py\n    process h = do\n      line <- hGetLine h\n      print line\n      process h\n    ```", "```py\n    $ runhaskell Main.hs\n\n    ```", "```py\n    $ runhaskell client.hs\n\n    ```", "```py\n    Hello?\n    \"yup, I can hear you!\"\n\n    ```", "```py\nsudo apt-get install libopencv-dev libsdl1.2-dev ftgl-dev\n\n```", "```py\ncabal install cv-combinators\n\n```", "```py\n    import AI.CV.ImageProcessors\n    import qualified AI.CV.OpenCV.CV as CV\n    import qualified Control.Processor as Processor\n    import Control.Processor ((--<))\n    import AI.CV.OpenCV.Types (PImage)\n    import AI.CV.OpenCV.CxCore (CvRect(..), CvSize(..))\n    import Prelude hiding (id)\n    import Control.Arrow ((&&&), (***))\n    import Control.Category ((>>>), id)\n    ```", "```py\n    captureDev :: ImageSource\n    captureDev = camera 0\n    ```", "```py\n    resizer :: ImageProcessor\n    resizer = resize 320 240 CV.CV_INTER_LINEAR\n    ```", "```py\n    faceDetect :: Processor.IOProcessor PImage [CvRect]\n\n    faceDetect = haarDetect  \"/usr/share/opencv/haarcascades/haarcascade_frontalface_alt.xml\" 1.1 3 CV.cvHaarFlagNone (CvSize 20 20)\n    ```", "```py\n    eyeDetect :: Processor.IOProcessor PImage [CvRect]\n    eyeDetect = haarDetect \"/usr/share/opencv/haarcascades/haarcascade_eye.xml\" 1.1 3 CV.cvHaarFlagNone (CvSize 20 20)\n    ```", "```py\n    faceRects = (id &&& faceDetect) >>> drawRects\n\n    eyeRects = (id &&& eyeDetect) >>> drawRects\n    ```", "```py\n    start = captureDev >>> resizer --< (faceRects *** eyeRects) \n                 >>> (window 0 *** window 1)\n    ```", "```py\n    main :: IO ()\n    main = runTillKeyPressed start\n    ```", "```py\n    $ runhaskell Main.hs\n\n    ```", "```py\n$ sudo apt-get install c2hs libopencv-dev\n\n```", "```py\n$ cabal install CV -fopencv24\n\n```", "```py\n    {-#LANGUAGE ScopedTypeVariables#-}\n    module Main where\n    import CV.Image (loadImage, rgbToGray, getSize)\n    import CV.Video (captureFromCam, streamFromVideo)\n    import Utils.Stream (runStream_, takeWhileS, sideEffect)\n    import CV.HighGUI (showImage, waitKey)\n    import CV.TemplateMatching ( simpleTemplateMatch\n                               , MatchType(..) )\n    import CV.ImageOp ((<#))\n    import CV.Drawing (circleOp, ShapeStyle(..))\n    ```", "```py\n    main = do\n      Just t <- loadImage \"lena.jpg\"\n      Just c <- captureFromCam 0\n      runStream_ . sideEffect (process t) . \n        takeWhileS (\\_ -> True) $ streamFromVideo c\n    ```", "```py\n    process t img = do\n      let gray = rgbToGray img\n      let ((mx, my), _) = \n        simpleTemplateMatch CCOEFF_NORMED gray t\n      let circleSize = (fst (getSize t)) `div` 2\n      let circleCenter = (mx + circleSize, my + circleSize)\n      showImage \"test\" (img <# circleOp (0,0,0) \n        circleCenter circleSize (Stroked 3))\n      waitKey 100\n      return ()\n    ```", "```py\n    $ runhaskell Main.hs\n\n    ```"]