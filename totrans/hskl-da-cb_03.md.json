["```py\n    import Data.Char (intToDigit, chr, ord) \n    import Numeric (showIntAtBase)\n    ```", "```py\n    n 'inBase' b = showIntAtBase b numToLetter n \"\"\n    ```", "```py\n    numToLetter :: Int -> Char\n    numToLetter n\n      | n < 10 = intToDigit n\n      | otherwise = chr (ord 'a' n – 10)\n    ```", "```py\n    main :: IO ()\n    main = do\n      putStrLn $ 8 'inBase' 12\n      putStrLn $ 10 'inBase' 12\n      putStrLn $ 12 'inBase' 12\n      putStrLn $ 47 'inBase' 12\n    ```", "```py\n    $ runhaskell Main.hs\n\n    8\n    a\n    10\n    3b\n\n    ```", "```py\n    import Data.Char (ord, digitToInt, isDigit)\n    import Numeric (readInt)\n    ```", "```py\n    str 'base' b = readInt b isValidDigit letterToNum str\n    ```", "```py\n    letterToNum :: Char -> Int\n    letterToNum d\n      | isDigit d = digitToInt d\n      | otherwise = ord d - ord 'a' + 10\n\n    isValidDigit :: Char -> Int\n    isValidDigit d = letterToNum d >= 0\n    ```", "```py\n    main :: IO ()\n    main = do\n      print $ \"8\" 'base' 12\n      print $ \"a\" 'base' 12\n      print $ \"10\" 'base' 12\n      print $ \"3b\" 'base' 12\n    ```", "```py\n    [(8,\"\")]\n    [(10,\"\")]\n    [(12,\"\")]\n    [(47,\"\")]\n\n    ```", "```py\n    import Data.ByteString (breakSubstring)\n    import qualified Data.ByteString.Char8 as C\n    ```", "```py\n    substringFound :: String -> String -> Bool\n\n    substringFound query str = \n      (not . C.null . snd) $ \n      breakSubstring (C.pack query) (C.pack str)\n    ```", "```py\n    main = do\n      print $ substringFound \"scraf\" \"swedish scraf mafia\"\n      print $ substringFound \"flute\" \"swedish scraf mafia\"\n    ```", "```py\n    True\n    False\n\n    ```", "```py\n{-# LANGUAGE OverloadedStrings #-}\nimport Data.ByteString (isInfixOf)\n\nmain = do\n  print $ isInfixOf \"scraf\" \"swedish scraf mafia\"\n  print $ isInfixOf \"flute\" \"swedish scraf mafia\"\n```", "```py\n    import Data.Map (fromList, (!), findWithDefault)\n    ```", "```py\n    indexMap xs = fromList $ zip [0..] xs\n\n    revIndexMap xs = fromList $ zip (reverse xs) [0..]\n    ```", "```py\n    bmh :: Ord a => [a] -> [a] -> Maybe Int\n\n    bmh pat xs = bmh' (length pat - 1) (reverse pat) xs pat\n    ```", "```py\n    bmh' :: Ord a => Int -> [a] -> [a] -> [a] -> Maybe Int \n\n    bmh' n [] xs pat = Just (n + 1)\n    bmh' n (p:ps) xs pat \n      | n >= length xs   = Nothing\n      | p == (indexMap xs) ! n = bmh' (n - 1) ps xs pat\n      | otherwise              = bmh' (n + findWithDefault\n                                      (length pat) (sMap ! n) pMap) \n                                      (reverse pat) xs pat\n      where sMap = indexMap xs\n            pMap = revIndexMap pat\n    ```", "```py\n    main :: IO ()\n    main = print $ bmh \"Wor\" \"Hello World\"\n    ```", "```py\n    Just 6\n\n    ```", "```py\n$ cabal install stringsearch\n\n```", "```py\nimport Data.ByteString.Search\nimport qualified Data.ByteString.Char8 as C\n```", "```py\nmain = print $ indices (C.pack \"abc\") (C.pack \"bdeabcdabc\")\n```", "```py\n[3,7]\n\n```", "```py\nshortNeedles = [\"abc\", \"cba\"]\nlongNeedles = [\"very big words\", \"some long string\"]\n\nmain = do\n  corpus <- BS.readFile \"big.txt\"\n  map (\\x -> (not.null) (indices x corpus)) shortNeedles     \n    'deepseq' return ()\n```", "```py\n$ ghc -O2 Main.hs –rtsopts\n\n$ ./Main +RTS -sstder\n\n```", "```py\n$ cabal install stringsearch\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n    ```", "```py\n    import Data.ByteString.Search.KarpRabin (indicesOfAny)\n    import qualified Data.ByteString as BS\n    ```", "```py\n    main = do\n      let needles = [ \"preparing to go away\"\n                    , \"is some letter of recommendation\"]\n      haystack <- BS.readFile \"big.txt\"\n    ```", "```py\n      print $ indicesOfAny needles haystack\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [(3738968,[1]),(5632846,[0]),(5714386,[0])]\n\n    ```", "```py\n$ cat input.txt\n\nfirst line\nsecond line\nwords are split by space\ncomma,separated,values\nor any delimiter you want\n\n```", "```py\n$ cabal install split\n\n```", "```py\n    import Data.List.Split (splitOn)\n    ```", "```py\n    main = do \n      input <- readFile \"input.txt\"\n      let ls = lines input\n      print $ ls\n    ```", "```py\n    [ \"first line\",\"second line\"\n    , \"words are split by space\"\n    , \"comma,separated,values\"\n    , \"or any delimiter you want\"]\n\n    ```", "```py\n      let ws = words $ ls !! 2\n      print ws\n    ```", "```py\n    [\"words\",\"are\",\"split\",\"by\",\"space\"]\n\n    ```", "```py\n      let cs = splitOn \",\" $ ls !! 3\n      print cs\n    ```", "```py\n    [\"comma\",\"separated\",\"values\"]\n\n    ```", "```py\n      let ds = splitOn \"an\" $ ls !! 4\n      print ds\n    ```", "```py\n    [\"or any d\",\"limit\",\"r you want\"]\n\n    ```", "```py\n$ cabal install data-memocombinators\n\n```", "```py\n    import qualified Data.MemoCombinators as Memo\n    ```", "```py\n    memoize :: (String -> String -> r) -> String -> String -> r\n    memoize = Memo.memo2 \n        (Memo.list Memo.char) (Memo.list Memo.char)\n    ```", "```py\n    lcs :: String -> String -> String\n\n    lcs = memoize lcs'\n      where lcs' xs'@(x:xs) ys'@(y:ys)\n        | x == y = x : lcs xs ys\n        | otherwise = longer (lcs xs' ys) (lcs xs ys')\n        lcs' _ _ = []\n    ```", "```py\n      longer as bs\n        | length as > length bs = as\n        | otherwise = bs\n    ```", "```py\n    main :: IO ()\n    main = do\n      let xs = \"find the lights\"\n      let ys = \"there are four lights\"\n      print $ lcs xs ys\n    ```", "```py\n    \"the lights\"\n\n    ```", "```py\n$ cabal install phonetic-code\n\n```", "```py\n    import Text.PhoneticCode.Soundex (soundexNARA, soundexSimple)\n    import Text.PhoneticCode.Phonix (phonix)\n    ```", "```py\n    ws = [\"haskell\", \"hackle\", \"haggle\", \"hassle\"]\n    ```", "```py\n    main :: IO ()\n    main = do\n      print $ map soundexNARA ws\n      print $ map soundexSimple ws\n      print $ map phonix ws\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [\"H240\",\"H240\",\"H240\",\"H240\"]\n\n    [\"H240\",\"H240\",\"H240\",\"H240\"]\n\n    [\"H82\",\"H2\",\"H2\",\"H8\"]\n\n    ```", "```py\n$ cabal install data-memocombinators\n\n```", "```py\n    import qualified Data.MemoCombinators as Memo\n    ```", "```py\n    lev :: Eq a => [a] -> [a] -> Int\n    lev a b = levM (length a) (length b)\n      where levM = memoize lev'\n        lev' i j\n          | min i j == 0 = max i j\n          | otherwise    = minimum \n            [ ( 1 + levM (i-1) j )\n            , ( 1 + levM i (j-1) )\n            , ( ind i j + levM (i-1) (j-1) ) ]\n    ```", "```py\n      ind i j\n        | a !! (i-1) == b !! (j-1) = 0\n        | otherwise = 1\n    ```", "```py\n    memoize = Memo.memo2 (Memo.integral) (Memo.integral)\n    ```", "```py\n    main = print $ lev \"mercury\" \"sylvester\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    8\n\n    ```", "```py\n    import Data.List (elemIndices)\n    ```", "```py\n    jaro :: Eq a => [a] -> [a] -> Double\n\n    jaro s1 s2\n      | m == 0    = 0.0\n      | otherwise = (1/3) * (m/ls1 + m/ls2 + (m-t)/m)\n    ```", "```py\n      where ls1 = toDouble $ length s1\n\n            ls2 = toDouble $ length s2\n\n             m' = matching s1 s2 d\n\n             d = fromIntegral $ \n             max (length s1) (length s2) 'div' 2 – 1\n\n             m = toDouble m'\n\n             t = toDouble $ (m' - matching s1 s2 0) 'div' 2\n    ```", "```py\n    toDouble :: Integral a => a -> Double\n\n    toDouble n = (fromIntegral n) :: Double\n    ```", "```py\n    matching :: Eq a => [a] -> [a] -> Int -> Int\n\n    matching s1 s2 d = length $ filter \n      (\\(c,i) -> not (null (matches s2 c i d))) \n      (zip s1 [0..])\n    ```", "```py\n    matches :: Eq a => [a] -> a -> Int -> Int -> [Int]\n\n    matches str c i d = filter (<= d) $ \n      map (dist i) (elemIndices c str)\n      where dist a b = abs $ a - b\n    ```", "```py\n    main = do\n      print $ jaro \"marisa\" \"magical\"\n      print $ jaro \"haskell\" \"hackage\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    0.746031746031746\n    0.7142857142857142\n\n    ```", "```py\n    import Data.Char (toLower)\n    import Data.List (group, sort)\n    ```", "```py\n    edits1 :: String -> [String]\n\n    edits1 word = unique $ \n                  deletes ++ transposes ++ replaces ++ inserts\n      where splits   = [ (take i word', drop i word') | \n        i <- [0..length word']]\n    ```", "```py\n      deletes = [ a ++ (tail b) | \n        (a,b) <- splits, (not.null) b]\n    ```", "```py\n      transposes = [a ++ [b!!1] ++ [head b] ++ (drop 2 b) | \n        (a,b) <- splits, length b > 1 ]\n    ```", "```py\n      replaces  = [ a ++ [c] ++ (drop 1 b) \n        | (a,b) <- splits\n        , c <- alphabet\n        , (not.null) b ]\n    ```", "```py\n      inserts = [a ++ [c] ++ b \n      | (a,b) <- splits\n      , c <- alphabet ]\n    ```", "```py\n      alphabet = ['a'..'z']\n      word' = map toLower word\n    ```", "```py\n      unique :: [String] -> [String]\n      unique = map head.group.sort\n    ```", "```py\n    main = print $ edits1 \"hi\"\n    ```", "```py\n[\"ahi\",\"ai\",\"bhi\",\"bi\",\"chi\",\"ci\",\"dhi\",\"di\",\"ehi\",\"ei\",\"fhi\",\"fi\",\"ghi\",\"gi\",\"h\",\"ha\",\"hai\",\"hb\",\"hbi\",\"hc\",\"hci\",\"hd\",\"hdi\",\"he\",\"hei\",\"hf\",\"hfi\",\"hg\",\"hgi\",\"hh\",\"hhi\",\"hi\",\"hia\",\"hib\",\"hic\",\"hid\",\"hie\",\"hif\",\"hig\",\"hih\",\"hii\",\"hij\",\"hik\",\"hil\",\"him\",\"hin\",\"hio\",\"hip\",\"hiq\",\"hir\",\"his\",\"hit\",\"hiu\",\"hiv\",\"hiw\",\"hix\",\"hiy\",\"hiz\",\"hj\",\"hji\",\"hk\",\"hki\",\"hl\",\"hli\",\"hm\",\"hmi\",\"hn\",\"hni\",\"ho\",\"hoi\",\"hp\",\"hpi\",\"hq\",\"hqi\",\"hr\",\"hri\",\"hs\",\"hsi\",\"ht\",\"hti\",\"hu\",\"hui\",\"hv\",\"hvi\",\"hw\",\"hwi\",\"hx\",\"hxi\",\"hy\",\"hyi\",\"hz\",\"hzi\",\"i\",\"ih\",\"ihi\",\"ii\",\"jhi\",\"ji\",\"khi\",\"ki\",\"lhi\",\"li\",\"mhi\",\"mi\",\"nhi\",\"ni\",\"ohi\",\"oi\",\"phi\",\"pi\",\"qhi\",\"qi\",\"rhi\",\"ri\",\"shi\",\"si\",\"thi\",\"ti\",\"uhi\",\"ui\",\"vhi\",\"vi\",\"whi\",\"wi\",\"xhi\",\"xi\",\"yhi\",\"yi\",\"zhi\",\"zi\"]\n\n```", "```py\nedits1' :: [String] -> [String]\nedits1' ls = unique $ concat $ map edits1 ls\n\neditsN :: String -> Int -> [String]\neditsN word n = iterate edits1' (edits1 word) !! n\n```", "```py\n    import Data.Char (isAlpha, isSpace, toLower)\n    import Data.List (group, sort, maximumBy)\n    import Data.Ord (comparing)\n    import Data.Map (fromListWith, Map, member, (!))\n    ```", "```py\n    autofix :: Map String Int -> String -> String\n\n    autofix m sentence = unwords $ \n                         map (correct m) (words sentence)\n    ```", "```py\n    getWords :: String -> [String]\n\n    getWords str = words $ \n                   filter (\\x -> isAlpha x || isSpace x) lower\n\n      where lower = map toLower str\n    ```", "```py\n    train :: [String] -> Map String Int\n\n    train = fromListWith (+) . ('zip' repeat 1)\n    ```", "```py\n    edits 1 :: String -> [String]\n\n    edits1 word = unique $ \n                  deletes ++ transposes ++ replaces ++ inserts\n\n      where splits = [ (take i word', drop i word') \n                      | i <- [0..length word']]\n\n      deletes = [ a ++ (tail b) \n                      | (a,b) <- splits\n                      , (not.null) b ]\n\n      transposes = [ a ++ [b !! 1] ++ [head b] ++ (drop 2 b) \n                      | (a,b) <- splits, length b > 1 ]\n\n      replaces = [ a ++ [c] ++ (drop 1 b) \n                      | (a,b) <- splits, c <- alphabet\n                      , (not.null) b ]\n\n      inserts = [a ++ [c] ++ b | \n                        (a,b) <- splits, c <- alphabet ]\n\n      alphabet = ['a'..'z']\n\n      word' = map toLower word\n    ```", "```py\n    knownEdits2 :: String -> Map String a -> [String]\n\n    knownEdits2 word m = unique $ [ e2 \n                                  | e1 <- edits1 word\n                                  , e2 <- edits1 e1\n                                  , e2 'member' m]\n    ```", "```py\n    unique :: [String] -> [String]\n\n    unique = map head.group.sort\n    ```", "```py\n    known :: [String] -> Map String a -> [String]\n\n    known ws m = filter ('member' m) ws\n    ```", "```py\n    correct :: Map String Int -> String -> String\n\n    correct m word = maximumBy (comparing (m!)) candidates\n      where candidates = head $ filter (not.null) \n                         [ known [word] m \n                         , known (edits1 word) m\n                         , knownEdits2 word m\n                         , [word] ]\n    ```", "```py\n    main :: IO ()\n\n    main = do\n      rawText <- readFile \"big.txt\"\n      let m = train $ getWords rawText\n      let sentence = \"such codez many hsakell very spel so korrect\"\n      print $ autofix m sentence\n    ```", "```py\n    $ runhaskell Main.hs\n\n    \"such code many haskell very spell so correct\"\n\n    ```"]