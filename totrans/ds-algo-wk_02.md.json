["```py\n# source_code/2/naive_bayes.py \n# A program that reads the CSV file with the data and returns\n# the Bayesian probability for the unknown value denoted by ? to\n# belong to a certain class.\n# An input CSV file should be of the following format:\n# 1\\. items in a row should be separated by a comma ','\n# 2\\. the first row should be a heading - should contain a name for each\n# column of the data.\n# 3\\. the remaining rows should contain the data itself - rows with\n# complete and rows with the incomplete data.\n# A row with complete data is the row that has a non-empty and\n# non-question mark value for each column. A row with incomplete data is\n# the row that has the last column with the value of a question mark ?.\n# Please, run this file on the example chess.csv to understand this help\n# better:\n# $ python naive_bayes.py chess.csv\n\nimport imp\nimport sys\nsys.path.append('../common')\nimport common  # noqa\n\n# Calculates the Bayesian probability for the rows of incomplete data and\n# returns them completed by the Bayesian probabilities. complete_data\n# are the rows with the data that is complete and are used to calculate\n# the conditional probabilities to complete the incomplete data.\ndef bayes_probability(heading, complete_data, incomplete_data,\n                      enquired_column):\n    conditional_counts = {}\n    enquired_column_classes = {}\n    for data_item in complete_data:\n        common.dic_inc(enquired_column_classes,\n                       data_item[enquired_column])\n        for i in range(0, len(heading)):\n            if i != enquired_column:\n                common.dic_inc(\n                    conditional_counts, (\n                        heading[i], data_item[i],\n                        data_item[enquired_column]))\n\n    completed_items = []\n    for incomplete_item in incomplete_data:\n        partial_probs = {}\n        complete_probs = {}\n        probs_sum = 0\n        for enquired_group in enquired_column_classes.items():\n            # For each class in the of the enquired variable A calculate\n            # the probability P(A)*P(B1|A)*P(B2|A)*...*P(Bn|A) where\n            # B1,...,Bn are the remaining variables.\n            probability = float(common.dic_key_count(\n                enquired_column_classes,\n                enquired_group[0])) / len(complete_data)\n            for i in range(0, len(heading)):\n                if i != enquired_column:\n                    probability = probability * (float(\n                        common.dic_key_count(\n                            conditional_counts, (\n                                heading[i], incomplete_item[i],\n                                enquired_group[0]))) / (\n                        common.dic_key_count(enquired_column_classes,\n                                             enquired_group[0])))\n            partial_probs[enquired_group[0]] = probability\n            probs_sum += probability\n\n        for enquired_group in enquired_column_classes.items():\n            complete_probs[enquired_group[0]\n                           ] = partial_probs[enquired_group[0]\n                                             ] / probs_sum\n        incomplete_item[enquired_column] = complete_probs\n        completed_items.append(incomplete_item)\n    return completed_items\n\n# Program start\nif len(sys.argv) < 2:\n    sys.exit('Please, input as an argument the name of the CSV file.')\n\n(heading, complete_data, incomplete_data,\n enquired_column) = common.csv_file_to_ordered_data(sys.argv[1])\n\n# Calculate the Bayesian probability for the incomplete data\n# and output it.\ncompleted_data = bayes_probability(\n    heading, complete_data, incomplete_data, enquired_column)\nprint completed_data\n```", "```py\n# source_code/common/common.py \n# Increments integer values in a dictionary.\ndef dic_inc(dic, key):\n    if key is None:\n        pass\n    if dic.get(key, None) is None:\n        dic[key] = 1\n    else:\n        dic[key] = dic[key] + 1\n\ndef dic_key_count(dic, key):\n    if key is None:\n        return 0\n    if dic.get(key, None) is None:\n        return 0\n    else:\n        return int(dic[key])\n```", "```py\nsource_code/2/naive_bayes/chess.csv\nTemperature,Wind,Sunshine,Play\nCold,Strong,Cloudy,No\nWarm,Strong,Cloudy,No\nWarm,None,Sunny,Yes\nHot,None,Sunny,No\nHot,Breeze,Cloudy,Yes\nWarm,Breeze,Sunny,Yes\nCold,Breeze,Cloudy,No\nCold,None,Sunny,Yes\nHot,Strong,Cloudy,Yes\nWarm,None,Cloudy,Yes\nWarm,Strong,Sunny,? \n```", "```py\n$ python naive_bayes.py chess.csv\n[\n    ['Warm', 'Strong', 'Sunny', {\n        'Yes': 0.66666666666666_66,\n        'No': 0.33333333333333337\n    }]\n]\n```", "```py\n# source_code/2/chess_reduced.csv\nTemperature,Wind,Play\nCold,Strong,No\nWarm,Strong,No\nWarm,None,Yes\nHot,None,No\nHot,Breeze,Yes\nWarm,Breeze,Yes\nCold,Breeze,No\nCold,None,Yes\nHot,Strong,Yes\nWarm,None,Yes\nWarm,Strong,?\n```", "```py\npython naive_bayes.py chess_reduced.csv\n[['Warm', 'Strong', {'Yes': 0.49999999999999994, 'No': 0.5}]]\n```"]