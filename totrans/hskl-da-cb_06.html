<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Graph Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Graph Fundamentals</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Representing a graph from a list of edges</li><li class="listitem" style="list-style-type: disc">Representing a graph from an adjacency list</li><li class="listitem" style="list-style-type: disc">Conducting a topological sort on a graph</li><li class="listitem" style="list-style-type: disc">Traversing a graph depth-first</li><li class="listitem" style="list-style-type: disc">Traversing a graph breadth-first</li><li class="listitem" style="list-style-type: disc">Visualizing a graph using Graphviz</li><li class="listitem" style="list-style-type: disc">Using Directed Acyclic Word Graphs</li><li class="listitem" style="list-style-type: disc">Working with hexagonal and square grid networks</li><li class="listitem" style="list-style-type: disc">Finding maximal cliques in a graph</li><li class="listitem" style="list-style-type: disc">Determining whether any two graphs are isomorphic</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Introduction</h1></div></div></div><div class="mediaobject"><img src="graphics/ch06.jpg" alt="Introduction"/></div><p>This section on graphs is a natural extension to the previous one about trees. Graphs are an essential data structure for representing networks, and this chapter will cover some important algorithms.</p><p>A graph <a id="id354" class="indexterm"/>relieves some of the restrictions from a tree, which allows one to represent network data such as biological gene relationship, social networks, and road topologies. Haskell supports multiple graph data structure libraries with various helpful tools and algorithms. This section will cover basic topics such as graph representation, topological sort, traversal, and graph-specific packages.</p></div></div>
<div class="section" title="Representing a graph from a list of edges"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Representing a graph from a list of edges</h1></div></div></div><p>A graph can be <a id="id355" class="indexterm"/>defined <a id="id356" class="indexterm"/>by a list of edges, where an edge is<a id="id357" class="indexterm"/> a tuple of vertices. In the <code class="literal">Data.Graph</code> package, a vertex is simply <code class="literal">Int</code>. In this recipe, we use the <code class="literal">buildG</code> function to construct a graph data structure out of a list of edges.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec210"/>Getting ready</h2></div></div></div><p>We will be constructing the graph represented in the following diagram:</p><div class="mediaobject"><img src="graphics/6331OS_06_01.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec211"/>How to do it...</h2></div></div></div><p>Create a new file, which we will name <code class="literal">Main.hs</code>, and insert the following code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">Data.Graph</code> package:<div class="informalexample"><pre class="programlisting">import Data.Graph</pre></div></li><li class="listitem">Construct a <a id="id358" class="indexterm"/>graph using the <code class="literal">buildG</code> function from the imported library:<div class="informalexample"><pre class="programlisting">myGraph :: Graph

myGraph= buildG bounds edges  
  where  bounds = (1,4)
      edges = [ (1,3), (1,4)
              , (2,3), (2,4) 
              , (3,4) ]</pre></div></li><li class="listitem">Print out the graph, its edges, and its vertices:<div class="informalexample"><pre class="programlisting">main = do
  print $ "The edges are " ++ (show.edges) myGraph
  print $ "The vertices are " ++ (show.vertices) myGraph</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec212"/>How it works...</h2></div></div></div><p>A list of edges<a id="id359" class="indexterm"/> is fed to the <code class="literal">buildG :: Bounds -&gt; [Edge] -&gt; Graph</code> function to <a id="id360" class="indexterm"/>form a graph data structure. The first argument specifies the lower and upper bounds for the vertices, and the second argument specifies the list of edges that make up the graph.</p><p>This graph data type is<a id="id361" class="indexterm"/> actually a Haskell array of vertices to a list of vertices. It uses the built-in <code class="literal">Data.Array</code> package, meaning we can use all the functions provided in <code class="literal">Data.Array</code> in our graphs.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec213"/>See also</h2></div></div></div><p>For another way to construct a graph, see the next recipe, <span class="emphasis"><em>Representing a graph from an adjacency list</em></span>.</p></div></div>
<div class="section" title="Representing a graph from an adjacency list"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec76"/>Representing a graph from an adjacency list</h1></div></div></div><p>It may be more <a id="id362" class="indexterm"/>convenient to<a id="id363" class="indexterm"/> construct a graph given an adjacency list. In this recipe, we will use the built-in package <code class="literal">Data.Graph</code> to read a mapping of a vertex to a list of connected vertices.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec214"/>Getting ready</h2></div></div></div><p>We will be constructing the graph represented in the following diagram:</p><div class="mediaobject"><img src="graphics/6331OS_06_01.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec215"/>How to do it...</h2></div></div></div><p>Create a new file, which we will name <code class="literal">Main.hs</code>, and insert the following code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">Data.Graph</code> package:<div class="informalexample"><pre class="programlisting">import Data.Graph</pre></div></li><li class="listitem">Use the <code class="literal">graphFromEdges'</code> function to <a id="id364" class="indexterm"/>obtain a <a id="id365" class="indexterm"/>tuple that contains the graph. A graph data structure, <code class="literal">Graph</code>, is in the first element of the tuple returned. The second element of the tuple contains mappings from a vertex number to its corresponding value, <code class="literal">Vertex -&gt; (node, key, [key])</code>:<div class="informalexample"><pre class="programlisting">myGraph :: Graph

myGraph = fst $ graphFromEdges'   [ ("Node 1", 1, [3, 4] )
                                  , ("Node 2", 2, [3, 4]) 
                                  , ("Node 3", 3, [4])
                                  , ("Node 4", 4, []) ]</pre></div></li><li class="listitem">Print out<a id="id366" class="indexterm"/> some graph computations:<div class="informalexample"><pre class="programlisting">main = do
  putStrLn $ "The edges are "++ (show.edges) myGraph 
  putStrLn $ "The vertices are "++ (show.vertices) myGraph </pre></div></li><li class="listitem">Running the code displays the edges and vertices of the graph:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>The edges are [(0,2), (0,3), (1,2), (1,3), (2,3)]</strong></span>
<span class="strong"><strong>The vertices are [0, 1, 2, 3]</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec216"/>How it works...</h2></div></div></div><p>We may notice that the keys of each vertex have been automatically assigned by the algorithm. The <code class="literal">graphFromEdges'</code> function actually returns a tuple of the type <code class="literal">(Graph, Vertex -&gt; (node, key, [key]))</code>, where the first element is the graph data structure, and the second element is a mapping of the vertex number to its actual key. </p><p>Just like the previous recipe, this graph data structure is actually an array from the <code class="literal">Data.Array</code> package, meaning we can use all the functions provided in <code class="literal">Data.Array</code> in our graphs.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec217"/>See also</h2></div></div></div><p>If we instead wish to create a graph from a list of edges, the previous recipe, <span class="emphasis"><em>Representing a graph from an adjacency list</em></span> does the job.</p></div></div>
<div class="section" title="Conducting a topological sort on a graph"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Conducting a topological sort on a graph</h1></div></div></div><p>If a graph is directed, the<a id="id367" class="indexterm"/> topological sort is one of the natural<a id="id368" class="indexterm"/> orderings of the graph. In a network of dependencies, the topological sort will reveal a possible enumeration through all the vertices that satisfy such dependencies. </p><p>Haskell's built-in graph package comes with a very useful function, <code class="literal">topSort</code>, to conduct a topological sort over <a id="id369" class="indexterm"/>a graph. In this recipe, we will be creating a graph of dependencies and enumerating a topological sort through it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec218"/>Getting ready</h2></div></div></div><p>We will be reading the data from the user input. Each pair of lines will represent a dependency.</p><p>Create a file <code class="literal">input.txt</code> with the following pairs of lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat input.txt</strong></span>

<span class="strong"><strong>understand Haskell</strong></span>
<span class="strong"><strong>do Haskell data analysis</strong></span>
<span class="strong"><strong>understand data analysis</strong></span>
<span class="strong"><strong>do Haskell data analysis</strong></span>
<span class="strong"><strong>do Haskell data analysis</strong></span>
<span class="strong"><strong>find patterns in big data</strong></span>
</pre></div><p>This file describes a list of dependencies, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One must understand Haskell in order to do Haskell data analysis</li><li class="listitem" style="list-style-type: disc">One must understand data analysis to do Haskell data analysis</li><li class="listitem" style="list-style-type: disc">One must do Haskell data analysis to find patterns in big data</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>We will use the <code class="literal">topsort</code> algorithm<a id="id370" class="indexterm"/> provided by <code class="literal">Data.Graph</code>. Beware, this function does not detect cyclic dependencies.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec219"/>How to do it...</h2></div></div></div><p>In a new file, which we will call <code class="literal">Main.hs</code>, insert the following code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the following from the graph, map, and list packages:<div class="informalexample"><pre class="programlisting">import Data.Graph
import Data.Map (Map, (!), fromList)
import Data.List (nub)</pre></div></li><li class="listitem">Read<a id="id371" class="indexterm"/> from the input and construct a graph from the dependencies. Run our topological sort on the graph and print out a valid order:<div class="informalexample"><pre class="programlisting">main = do
  ls &lt;- fmap lines getContents
  let g = graph ls
  putStrLn $ showTopoSort ls g</pre></div></li><li class="listitem">Construct a<a id="id372" class="indexterm"/> graph from a list of strings, where each pair of lines represents a dependency:<div class="informalexample"><pre class="programlisting">graph :: Ord k =&gt; [k] -&gt; Graph

graph ls = buildG bounds edges
  where bounds = (1, (length.nub) ls)
    edges = tuples $ map (mappingStrToNum !) ls
    mappingStrToNum = fromList $ zip (nub ls) [1..]
    tuples (a:b:cs) = (a, b) : tuples cs
    tuples _ = []</pre></div></li><li class="listitem">Sort the graph topologically and print out a valid ordering of the items:<div class="informalexample"><pre class="programlisting">showTopoSort :: [String] -&gt; Graph -&gt; String

showTopoSort ls g = 
  unlines $ map (mappingNumToStr !) (topSort g)
  where mappingNumToStr = fromList $ zip [1..] (nub ls)</pre></div></li><li class="listitem">Compile the code and feed it with the text file of dependencies:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs &lt; input.txt</strong></span>

<span class="strong"><strong>understand data analysis</strong></span>
<span class="strong"><strong>understand Haskell</strong></span>
<span class="strong"><strong>do Haskell data analysis</strong></span>
<span class="strong"><strong>find patterns in big data</strong></span>
</pre></div></li></ol></div></div></div>
<div class="section" title="Traversing a graph depth-first"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Traversing a graph depth-first</h1></div></div></div><p>Using<a id="id373" class="indexterm"/> depth-first search, one<a id="id374" class="indexterm"/> can traverse a graph to view the nodes in the desired order. Implementing a topological sort, solving mazes, and finding connected components are all examples of useful algorithms that rely on a depth-first traversal of a graph.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec220"/>How to do it...</h2></div></div></div><p>Start editing a new source file, which we will name <code class="literal">Main.hs</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the required packages:<div class="informalexample"><pre class="programlisting">import Data.Graph
import Data.Array ((!))</pre></div></li><li class="listitem">Construct the graph from the adjacency list:<div class="informalexample"><pre class="programlisting">graph :: (Graph, Vertex -&gt; (Int, Int, [Int]))

graph = graphFromEdges'  [ (1, 1, [3, 4] )
                         , (2, 2, [3, 4]) 
                         , (3, 3, [4])
                         , (4, 4, []) ]</pre></div></li><li class="listitem">Scan the graph depth-first:<div class="informalexample"><pre class="programlisting">depth g i = depth' g [] i
depth' g2(gShape, gMapping) seen i = 
  key : concat (map goDeeper adjacent)
  where goDeeper v = if v `elem` seen 
                      then [] 
                      else depth' g (i:seen) v
         adjacent = gShape ! i
         (_, key, _) = gMapping i</pre></div></li><li class="listitem">Print out the list of vertices visited:<div class="informalexample"><pre class="programlisting">main = print $ depth graph 0</pre></div></li><li class="listitem">Run the algorithm to see the order of traversal.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>
<span class="strong"><strong>[1, 3, 4, 4]</strong></span>
</pre></div></li></ol></div><p>We start at node 1 (which is at index 0). We traverse the first edge to 3. From number 3, we traverse to the first edge to 4. Since 4 has no outbound edges, we traverse back to 3. Since 3 has no remaining outbound edges, we traverse back to 1. From 1, we traverse the second edge to 4.</p></div></div>
<div class="section" title="Traversing a graph breadth-first"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec79"/>Traversing a graph breadth-first</h1></div></div></div><p>Using<a id="id375" class="indexterm"/> breadth-first search, one <a id="id376" class="indexterm"/>can traverse a graph to view the nodes in the desired order. In an infinite graph, a depth-first traversal may never return back to the starting node. One of the most notable examples of a breadth-first traversal algorithm is finding the shortest path between two nodes.</p><p>In this recipe, we will print out the breadth-first traversal of the nodes in a graph.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec221"/>How to do it...</h2></div></div></div><p>Insert the following code in a new file, which can be called <code class="literal">Main.hs</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the required packages:<div class="informalexample"><pre class="programlisting">import Data.Graph
import Data.Array ((!))</pre></div></li><li class="listitem">Construct the graph from a list of edges:<div class="informalexample"><pre class="programlisting">graph :: Graph
graph = buildG bounds edges
  where  bounds = (1,7)
         edges = [ (1,2), (1,5)
                 , (2,3), (2,4) 
                 , (5,6), (5,7) 
                 , (3,1) ]</pre></div></li><li class="listitem">Scan the graph breadth-first:<div class="informalexample"><pre class="programlisting">breadth g i = bf [] [i]
  where bf :: [Int] -&gt; [Int] -&gt; [Int]
        bf seen forest | null forest = []
                       | otherwise   = forest ++ 
                                       bf (forest ++ seen) 
                             (concat (map goDeeper forest))
          where goDeeper v = if elem v seen 
                              then [] else (g ! v)</pre></div></li><li class="listitem">Print out the list of vertices visited depth-first:<div class="informalexample"><pre class="programlisting">main = do
  print $ breadth graph 1</pre></div></li><li class="listitem">Running the code shows the traversal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>
<span class="strong"><strong>[1, 5, 2, 7, 6, 4, 3, 1]</strong></span>
</pre></div></li></ol></div></div></div>
<div class="section" title="Visualizing a graph using Graphviz"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Visualizing a graph using Graphviz</h1></div></div></div><p>One <a id="id377" class="indexterm"/>can easily draw an image<a id="id378" class="indexterm"/> that represents a graph using the <code class="literal">graphviz</code> library. In the world of data analysis, visually interpreting an image can reveal peculiarities about the data that the human eye can easily pick up. This recipe will let us construct a diagram out of the data we are dealing with. More visualization techniques are explained in <a class="link" href="ch11.html" title="Chapter 11. Visualizing Data">Chapter 11</a>, <span class="emphasis"><em>Visualizing Data</em></span>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec222"/>Getting ready</h2></div></div></div><p>Install the<a id="id379" class="indexterm"/> <code class="literal">graphviz</code> library from <a class="ulink" href="http://www.graphviz.org/Download.php">http://www.graphviz.org/Download.php</a> as the Haskell package requires it.</p><p>Next, install the package from cabal by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install graphviz</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec223"/>How to do it...</h2></div></div></div><p>In a new file, insert the following code. We will name our file <code class="literal">Main.hs</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the package:<div class="informalexample"><pre class="programlisting">import Data.GraphViz</pre></div></li><li class="listitem">Create the graph from nodes and edges:<div class="informalexample"><pre class="programlisting">graph :: DotGraph Int

graph = graphElemsToDot graphParams nodes edges</pre></div></li><li class="listitem">Use the default parameters for creating the graph. This function can be modified to modify the graph's visual parameters:<div class="informalexample"><pre class="programlisting">graphParams :: GraphvizParams Int String Bool () String

graphParams = defaultParams</pre></div></li><li class="listitem">Create the code from the corresponding edges:<div class="informalexample"><pre class="programlisting">nodes :: [(Int, String)]

nodes = map (\x -&gt; (x, "")) [1..4]


edges:: [(Int, Int, Bool)]

edges= [ (1, 3, True)
       , (1, 4, True) 
    , (2, 3, True)
    , (2, 4, True)
    , (3, 4, True)]</pre></div></li><li class="listitem">Execute<a id="id380" class="indexterm"/> <code class="literal">main</code> to <a id="id381" class="indexterm"/>output the graph:<div class="informalexample"><pre class="programlisting">main = addExtension (runGraphviz graph) Png "graph"</pre></div><div class="mediaobject"><img src="graphics/6331OS_06_02.jpg" alt="How to do it..."/></div></li></ol></div></div></div>
<div class="section" title="Using Directed Acyclic Word Graphs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec81"/>Using Directed Acyclic Word Graphs</h1></div></div></div><p>We use<a id="id382" class="indexterm"/> <span class="strong"><strong>Directed Acyclic Word Graphs</strong></span> (<span class="strong"><strong>DAWG</strong></span>) to retrieve very quickly from a large corpus of strings at an<a id="id383" class="indexterm"/> extremely small cost in space complexity. Imagine compressing all words in a dictionary using a DAWG to perform efficient lookups for words. It is a powerful data structure that can come in handy when dealing with a large corpus of words. A very nice introduction to DAWGs can be found in Steve Hanov's blog post here: <a class="ulink" href="http://stevehanov.ca/blog/index.php?id=115">http://stevehanov.ca/blog/index.php?id=115</a>.</p><p>We can use this recipe to incorporate a DAWG in our code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec224"/>Getting ready</h2></div></div></div><p>Install the <a id="id384" class="indexterm"/>DAWG package using cabal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install dawg</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec225"/>How to do it...</h2></div></div></div><p>We name a new file <code class="literal">Main.hs</code> and insert the following code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the following packages:<div class="informalexample"><pre class="programlisting">import qualified Data.DAWG.Static as D
import Network.HTTP ( simpleHTTP, getRequest,  
                      getResponseBody)
import Data.Char (toLower, isAlphaNum, isSpace)
import Data.Maybe (isJust)</pre></div></li><li class="listitem">In <code class="literal">main</code>, download<a id="id385" class="indexterm"/> a large corpus of text to store:<div class="informalexample"><pre class="programlisting">main = do
  let url = "http://norvig.com/big.txt"
  body &lt;- simpleHTTP (getRequest url) &gt;&gt;= getResponseBody</pre></div></li><li class="listitem">Look up <a id="id386" class="indexterm"/>some strings from the DAWG constructed by the corpus:<div class="informalexample"><pre class="programlisting">  let corp = corpus body
  print $ isJust $ D.lookup "hello" corp
  print $ isJust $ D.lookup "goodbye" corp</pre></div></li><li class="listitem">Construct a getter function:<div class="informalexample"><pre class="programlisting">getWords :: String -&gt; [String]

getWords str = words $ map toLower wordlike
  where wordlike = 
           filter (\x -&gt; isAlphaNum x || isSpace x) str</pre></div></li><li class="listitem">Create a DAWG from the corpus dictionary:<div class="informalexample"><pre class="programlisting">corpus :: String -&gt; D.DAWG Char () ()

corpus str = D.fromLang $ getWords str</pre></div></li><li class="listitem">Running the code reveals that the two words indeed exist in the massive corpus. Notice that there will be a time-consuming prepossessing step to build the DAWG:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ runhaskell Main.hs</strong></span>

<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>A naive approach may <a id="id387" class="indexterm"/>be to use the <code class="literal">isInfixOf</code> function from <code class="literal">Data.List</code> to perform a substring search. On a typical ThinkPad T530 with 8 GB RAM on an Intel i5 processor, performing the <code class="literal">isInfixOf</code> operation takes around 0.16 seconds on average. However, if we preprocess a DAWG data structure, lookups take less than 0.01 seconds!</p></div></div></div></div>
<div class="section" title="Working with hexagonal and square grid networks"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec82"/>Working with hexagonal and square grid networks</h1></div></div></div><p>Sometimes, the <a id="id388" class="indexterm"/>graph we're dealing with has a strict structure, such as a <a id="id389" class="indexterm"/>hexagonal or square grid. Many video games use a hexagonal grid layout to facilitate diagonal movement because moving diagonally in a square grid complicates the values of the traveled distance. On the other hand, square grid structures are often used within graphs to traverse pixels for image manipulation algorithms such as flood fill.</p><div class="mediaobject"><img src="graphics/6331OS_06_03.jpg" alt="Working with hexagonal and square grid networks"/></div><p>There is a very useful library in the Haskell package listing to deal with such topologies. We can obtain the indices of a grid to traverse the world, which is essentially a path embedded in a graph. For each grid index, we can query the library to find the neighboring indices, effectively using grids as a graph.</p><div class="section" title="Getting started"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec226"/>Getting started</h2></div></div></div><p>Review the package documentation located at <a class="ulink" href="https://github.com/mhwombat/grid/wiki">https://github.com/mhwombat/grid/wiki</a>.</p><p>Install the grid package using cabal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install grid</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec227"/>How to do it...</h2></div></div></div><p>In a new file, which <a id="id390" class="indexterm"/>we will name <code class="literal">Main.hs</code>, insert the following code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the following libraries:<div class="informalexample"><pre class="programlisting">import Math.Geometry.Grid (indices, neighbours)
import Math.Geometry.Grid.Hexagonal (hexHexGrid)
import Math.Geometry.Grid.Square (rectSquareGrid)
import Math.Geometry.GridMap ((!))
import Math.Geometry.GridMap.Lazy (lazyGridMap)</pre></div></li><li class="listitem">In <code class="literal">main</code>, print <a id="id391" class="indexterm"/>out some examples of hexagonal and grid functions:<div class="informalexample"><pre class="programlisting">main = do
  let putStrLn' str = putStrLn ('\n':str)
  putStrLn' "Indices of hex grid:"
  print $ indices hex
  putStrLn' "Neighbors around (1,1) of hex grid:"
  print $ neighbours hex (1,1)
  putStrLn' "Indices of rect grid:"
  print $ indices rect
  putStrLn' "Neighbors around (1,1) of rect grid:"
  print $ neighbours rect (1,1)
  putStrLn' "value of hex at index (1,1)"
  print $ hexM ! (1,1)</pre></div></li><li class="listitem">Use a helper function to construct a hexagonal grid:<div class="informalexample"><pre class="programlisting">hex = hexHexGrid 4</pre></div></li><li class="listitem">Use a helper function to construct a square grid:<div class="informalexample"><pre class="programlisting">rect = rectSquareGrid 3 5</pre></div></li><li class="listitem">Create a hexagonal grid with the associated numerical values:<div class="informalexample"><pre class="programlisting">hexM = lazyGridMap hex [1..]</pre></div></li></ol></div></div></div>
<div class="section" title="Finding maximal cliques in a graph"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec83"/>Finding maximal cliques in a graph</h1></div></div></div><p>Haskell comes <a id="id392" class="indexterm"/>with a<a id="id393" class="indexterm"/> luxury of vital graph libraries, conveniently one of which is the clique detection library from <code class="literal">Data.Algorithm.MaximualCliques</code>. A <span class="strong"><strong>clique</strong></span> <a id="id394" class="indexterm"/>in a graph is a subgraph where all the nodes have connections between themselves, and is depicted as follows:</p><div class="mediaobject"><img src="graphics/6331OS_06_04.jpg" alt="Finding maximal cliques in a graph"/></div><p>For example, the preceding graph contains two cliques shaded in different colors. Perhaps, the graph represents web pages that link to each other. We can visually infer that there might be two clusters of Internet communities due to the structure of the graph. As the network of connections increases, finding the greatest clique becomes an exponentially difficult problem.</p><p>In this recipe, we will use an efficient implementation of the maximal clique problem.</p><div class="section" title="Getting started"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec228"/>Getting started</h2></div></div></div><p>Install the clique library using cabal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install maximal-cliques</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec229"/>How to do it...</h2></div></div></div><p>Write the following code in a new file, which we will name <code class="literal">Main.hs</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the required library:<div class="informalexample"><pre class="programlisting">import Data.Algorithm.MaximalCliques</pre></div></li><li class="listitem">In <code class="literal">main</code>, print out the max cliques:<div class="informalexample"><pre class="programlisting">main = print $ getMaximalCliques edges nodes</pre></div></li><li class="listitem">Create the following graph:<div class="informalexample"><pre class="programlisting">edges 1 5 = True  
edges 1 2 = True
edges 2 3 = True
edges 2 5 = True
edges 4 5 = True
edges 3 4 = True
edges 4 6 = True
edges _ _ = False</pre></div></li><li class="listitem">Determine the node range:<div class="informalexample"><pre class="programlisting">nodes = [1..6]</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec230"/>How it works...</h2></div></div></div><p>The library<a id="id395" class="indexterm"/> applies the <a id="id396" class="indexterm"/>recursive <a id="id397" class="indexterm"/>Bron-Kerbosch pivoting algorithm for identifying a maximal clique in an undirected graph. The core idea in the algorithm is to intelligently backtrack until a maximum clique is found.</p></div></div>
<div class="section" title="Determining whether any two graphs are isomorphic"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec84"/>Determining whether any two graphs are isomorphic</h1></div></div></div><p>Graphs can<a id="id398" class="indexterm"/> have arbitrary labels, but their topology may be isomorphic. In the world of data analysis, we can examine different graphical networks and identify clusters of nodes that have identical connection patterns. This helps us discover when two seemingly different graphical networks end up with the same network mapping. Maybe then we can declare a one-to-one isomorphism between the nodes and learn something profound about the nature of the graphs.</p><p>We will use the<a id="id399" class="indexterm"/> <code class="literal">isIsomorphic</code> function from <code class="literal">Data.Graph.Automorphism</code> to detect whether two graphs are identical in their connection.</p><p>In this recipe, we will let the library calculate whether the two graphs in the following diagram are isomorphic in their connections:</p><div class="mediaobject"><img src="graphics/6331OS_06_05.jpg" alt="Determining whether any two graphs are isomorphic"/></div><div class="section" title="Getting started"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec231"/>Getting started</h2></div></div></div><p>Install<a id="id400" class="indexterm"/> the Automorphism library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cabal install hgal</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec232"/>How to do it...</h2></div></div></div><p>Write the<a id="id401" class="indexterm"/> following code in a new file, which we will name <code class="literal">Main.hs</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the following packages:<div class="informalexample"><pre class="programlisting">import Data.Graph
import Data.Graph.Automorphism</pre></div></li><li class="listitem">Construct a graph:<div class="informalexample"><pre class="programlisting">graph = buildG (0,4) [ (1, 3), (1, 4) 
                     , (1, 2), (2, 3)
                     , (2, 4), (3, 4) ]</pre></div></li><li class="listitem">Construct another graph:<div class="informalexample"><pre class="programlisting">graph' = buildG (0,4) [ (3, 1), (3, 2) 
                      , (3, 4), (4, 1)
                      , (4, 2), (1, 2) ]</pre></div></li><li class="listitem">Check whether the graphs have the same topology:<div class="informalexample"><pre class="programlisting">main = print $ isIsomorphic graph graph'</pre></div></li></ol></div></div></div></body></html>