<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 9. Analytics Study: Graph Algorithms - US Domestic Flight Data Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Analytics Study: Graph Algorithms - US Domestic Flight Data Analysis</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>"It is a capital mistake to theorize before one has data."</p></blockquote></div><p>                                                              – <span class="emphasis"><em>Sherlock Holmes</em></span>
</p><p>In this chapter, we focus on a fundamental computer science data model called graphs and the different types of algorithm commonly used on them. As a data scientist or developer, it is very important to be familiar with graphs and quickly recognize when they provide the right solution to solve a particular data problem. For example, graphs are very well suited to GPS-based applications such as Google Maps, to find the best route from point A to point B, taking into account all kinds of parameters, including whether the user is driving, walking or taking public transport, or whether the user wants the shortest route or one that maximizes the use of highways regardless of overall distance. Some of these parameters can also be real-time parameters, such as traffic conditions, and the weather. Another important class of applications that uses graphs is social networks, such as Facebook or Twitter, where vertices represent individuals and edges represent relationships, such as <span class="emphasis"><em>is a friend</em></span>, and <span class="emphasis"><em>follows</em></span>.</p><p>We'll start this chapter with a high-level introduction to graphs and associated graph algorithms. We'll then introduce <code class="literal">networkx</code> which is a Python library that makes it easy to load, manipulate, and visualize graph data structures as well as provide a rich set of graph algorithms. We'll continue the discussion by building sample analytics that analyzes US flight data using various graph algorithms where airports are used as vertices and flights as edges. As always, we'll also operationalize these analytics by building a simple dashboard PixieApp. We'll finish this chapter by building a forecasting model applying time series techniques we've learned in <a class="link" href="ch08.xhtml" title="Chapter 8. Analytics Study: Prediction - Financial Time Series Analysis and Forecasting">Chapter 8</a>, <span class="emphasis"><em>Analytics Study: Prediction - Financial Time Series Analysis and Forecasting</em></span> to historical flight data.</p><div class="section" title="Introduction to graphs"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Introduction to graphs</h1></div></div></div><p>The introduction of graphs <a id="id639" class="indexterm"/>and the associated graph theory is widely attributed to Leonhard Euler in 1736 when he worked on the problem of the <span class="emphasis"><em>Seven Bridges of Königsberg</em></span> (<a class="ulink" href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg</a>).</p><p>The city was divided by the Pregel river which at some point formed two islands, and seven bridges were built according to the layout shown in the following diagram. The problem was to find a way for a person to walk across each and every bridge once and only once and come back to the starting point. Euler proved that there was no solution to this problem and while doing this gave birth to graph theory. The fundamental idea was to transform the city diagram into a graph where each land mass is a vertex, and each bridge is an edge that linked two vertices (that is, land mass). The problem was then reduced to finding a path, which is a continuous sequence of edges and vertices, that contains each and every bridge only once.</p><p>The following diagram shows how Euler simplified the <span class="emphasis"><em>Seven Bridges of Königsberg</em></span> problem into a graph problem:</p><div class="mediaobject"><img src="Images/B09699_09_01.jpg" alt="Introduction to graphs" width="1000" height="432"/><div class="caption"><p>Simplifying the Seven Bridges of Königsberg problem into a graph problem</p></div></div><p>Using a more formal definition, <span class="strong"><strong>graphs</strong></span> are the data structures that represent pairwise relationships (called <span class="strong"><strong>edges</strong></span>) between objects (called <span class="strong"><strong>vertices</strong></span> or <span class="strong"><strong>nodes</strong></span>). It is common to use the following notation to represent a graph: <span class="emphasis"><em>G = (V, E)</em></span> where <span class="emphasis"><em>V</em></span> is the set of vertices and <span class="emphasis"><em>E</em></span> is the set of edges.</p><p>There are mainly two broad categories of graphs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Directed graphs (called digraphs)</strong></span>: The order in the <a id="id640" class="indexterm"/>pairwise relationship matters, that is, the edge (A-B) going from vertex <span class="strong"><strong>A</strong></span> to vertex <span class="strong"><strong>B</strong></span> is different from the edge (B-A) going from vertex <span class="strong"><strong>B</strong></span> to vertex <span class="strong"><strong>A</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Undirected graphs</strong></span>: The order in the pairwise <a id="id641" class="indexterm"/>relationship doesn't matter, that is, edge (A-B) is the same as an edge (B-A).</li></ul></div><p>The following diagram shows the representation of a sample graph both as undirected (edges have no arrows) and directed (edges have arrows):</p><div class="mediaobject"><img src="Images/B09699_09_02.jpg" alt="Introduction to graphs" width="1000" height="547"/></div><div class="section" title="Graph representations"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec57"/>Graph representations</h2></div></div></div><p>There are <a id="id642" class="indexterm"/>mainly two ways of representing a graph:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adjacency matrix</strong></span>: Represents the graph <a id="id643" class="indexterm"/>using an <span class="emphasis"><em>n</em></span> by <span class="emphasis"><em>n</em></span> matrix (we'll call it <span class="emphasis"><em>A</em></span>), where <span class="emphasis"><em>n</em></span> is the number of vertices in the <a id="id644" class="indexterm"/>graph. The vertices are indexed using 1 to <span class="emphasis"><em>n</em></span> integers. We use 
<span class="inlinemediaobject"><img src="Images/B09699_09_37.jpg" alt="Graph representations" width="64" height="32"/></span> to denote that an edge exists between vertex <span class="emphasis"><em>i</em></span> and vertex <span class="emphasis"><em>j</em></span> and 
<span class="inlinemediaobject"><img src="Images/B09699_09_38.jpg" alt="Graph representations" width="67" height="32"/></span>  to denote that no edge exists between vertex <span class="emphasis"><em>i</em></span> and vertex <span class="emphasis"><em>j</em></span>. In the case of undirected graphs, we would always have 
<span class="inlinemediaobject"><img src="Images/B09699_09_39.jpg" alt="Graph representations" width="52" height="32"/></span><span class="inlinemediaobject"><img src="Images/B09699_09_40.jpg" alt="Graph representations" width="32" height="32"/></span> because the order doesn't matter. However, in the case of digraphs where order matters, <span class="emphasis"><em>A</em></span><span class="emphasis"><em><sub>i,j</sub></em></span> may be different from <span class="emphasis"><em>A</em></span><span class="emphasis"><em><sub>j,i</sub></em></span>.
The following example shows how to represent a sample graph in an adjacency matrix both directed and undirected:<div class="mediaobject"><img src="Images/B09699_09_03.jpg" alt="Graph representations" width="1000" height="447"/><div class="caption"><p>Adjacency matrix representation of a graph (both directed and undirected)</p></div></div><p>It is important to note that the adjacency matrix representation has a constant <a id="id645" class="indexterm"/>space complexity which is <span class="inlinemediaobject"><img src="Images/B09699_09_41.jpg" alt="Graph representations" width="55" height="37"/></span> where <span class="emphasis"><em>n</em></span> is the number of vertices, but it <a id="id646" class="indexterm"/>has a time complexity of <span class="emphasis"><em>O(1)</em></span> which is constant time to compute whether two vertices are connected with an edge between them. The high space complexity might be OK when the graph is dense (lots of edges) but could be a waste of space when the graph is sparse, in which case we might prefer the following adjacency list representation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note310"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The big O notation (<a class="ulink" href="https://en.wikipedia.org/wiki/Big_O_notation">https://en.wikipedia.org/wiki/Big_O_notation</a>) is commonly used in code analysis to represent the performance of an algorithm by evaluating its behavior as the input size grows. It is used both for evaluating running time (number of instructions needed to run the algorithm) and space requirements (how much storage will it need over time).</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adjacency list</strong></span>: For each vertex, we <a id="id647" class="indexterm"/>maintain a list of all the vertices connected by an edge. In the case of an undirected graph, each edge is <a id="id648" class="indexterm"/>represented twice, one for each endpoint, which is not the case for a digraph where the order matters.<p>The following figure shows the adjacency list representation of a graph, both directed and undirected:</p><div class="mediaobject"><img src="Images/B09699_09_04.jpg" alt="Graph representations" width="1000" height="571"/><div class="caption"><p>Adjacency list representation of a graph (both directed and undirected)</p></div></div><p>Contrary to the adjacency matrix representation, the adjacency list representation has a smaller space complexity which is <span class="emphasis"><em>O (m + n)</em></span> where <span class="emphasis"><em>m</em></span> is the <a id="id649" class="indexterm"/>number of edges and <span class="emphasis"><em>n</em></span> is the number of vertices. However, the time complexity <a id="id650" class="indexterm"/>increases to <span class="emphasis"><em>O(m)</em></span> compared to <span class="emphasis"><em>O(1)</em></span> for the adjacency matrix. For these reasons, it is preferable to use the adjacency list representation when the graph is sparsely connected (that is, doesn't have a lot of edges).</p></li></ul></div><p>As hinted in the preceding discussion, which graph representation to use depends heavily on the graph density but also on the type of algorithms we are planning to use. In the next section, we discuss the most commonly used graph algorithms.</p></div><div class="section" title="Graph algorithms"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec58"/>Graph algorithms</h2></div></div></div><p>The following is a list <a id="id651" class="indexterm"/>of the most commonly used graph algorithms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Search</strong></span>: In the context of the graph, searching means finding paths between two vertices. A path is defined as a continuous sequence of edges and vertices. The motivation <a id="id652" class="indexterm"/>for searching paths in a graph can be multiple; it could be that you're interested in finding the shortest path according to some predefined distance criteria, such as the minimum number of edges (for example, GPS route mapping) or you simply want to know that a path between two vertices exists (for example, ensure that every machine in a network is reachable from any other machine). A generic algorithm to search for a path is to start from the given vertex, <span class="emphasis"><em>discover</em></span> all the vertices that are connected to it, mark the discovered vertices as explored (so we don't find them twice) and continue the same exploration for each discovered vertex until we find the target vertex, or we run out of vertices. There are two commonly used flavors of this search algorithm: Breadth First Search and Depth First Search, each having their own use cases for which they are better suited. The difference between these two algorithms consists of the way we find the unexplored vertices:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Breadth First Search (BFS)</strong></span>: The unexplored nodes that are immediate <a id="id653" class="indexterm"/>neighbors are explored first. When the immediate neighborhood has been explored, start exploring the neighborhood of each <a id="id654" class="indexterm"/>node in the layer, until the end of the graph is reached. Because we are exploring all vertices that are directly connected first, this algorithm guarantees to find the shortest path which corresponds to the number of neighborhoods found. An extension to BFS is the famous Dijkstra shortest path algorithm where each edge is associated with a non-negative weight. In this case, the shortest path may not be the one with the least number of hops but rather a path that minimizes the sum of all weights. One example application of the Dijkstra shortest path is to find the shortest route between two points on a map.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Depth First Search (DFS)</strong></span>: For each immediate neighbor vertex, aggressively explore its neighbors first going as deeply as you can <a id="id655" class="indexterm"/>and then start backtracking when you run out of neighbors. Example of applications for DFS include finding the topological sort <a id="id656" class="indexterm"/>and strongly connected components of a digraph. For reference, a topological sort is a linear ordering of the vertices such that each vertex in the linear order follows the edge direction of the next one (that is, it doesn't move backward). See <a class="ulink" href="https://en.wikipedia.org/wiki/Topological_sorting">https://en.wikipedia.org/wiki/Topological_sorting</a> for more information.</li></ul></div><p>The following diagram demonstrates the differences in finding the unexplored nodes between BFS and DFS:</p><div class="mediaobject"><img src="Images/B09699_09_05.jpg" alt="Graph algorithms" width="997" height="578"/><div class="caption"><p>Order of finding unexplored vertices in BFS and DFS</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connected components and strongly connected components</strong></span>: Connected components of a graph are groups of vertices where there is a path between any two vertices. Note <a id="id657" class="indexterm"/>that the definition only specifies that a path must exist which means that two vertices do not have to have an <a id="id658" class="indexterm"/>edge between them as long as a <a id="id659" class="indexterm"/>path exists. In the case of a digraph, the connected component is called a <span class="strong"><strong>strongly connected component</strong></span> because of the <a id="id660" class="indexterm"/>additional direction constraint that requires that not only should any vertex A have a path to any other vertex B, but that B must also have a path to A.<p>The following diagram shows the strongly connected components or a sample directed graph:</p><div class="mediaobject"><img src="Images/B09699_09_06.jpg" alt="Graph algorithms" width="720" height="652"/><div class="caption"><p>Strongly connected components of a directed graph</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Centrality</strong></span>: The centrality indicator of a vertex provides an indication of how important the vertex is with <a id="id661" class="indexterm"/>regard to the other vertices in the graph. There are multiple important applications for these centrality indices. For example, identifying the most influential person in a social network or ranking a web search by pages that are the most important, and so on.<p>There are multiple indices of centrality, but we'll focus on the following four that we'll use later in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Degree</strong></span>: The degree of a vertex is the number of edges for which the vertex is one of <a id="id662" class="indexterm"/>the endpoints. In the case of a digraph, it's the number of edges for which the vertex is either a source or a target, and we call <span class="strong"><strong>indegree</strong></span> the number of edges for which the vertex is a target and <span class="strong"><strong>outdegree</strong></span> the number of edges for which the vertex is a source.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PageRank</strong></span>: This is the famous algorithm developed by the founders of Google, Larry Page, and Sergey Brin. PageRank is used to rank the search results <a id="id663" class="indexterm"/>by providing a measure of importance for a given website that includes counting the number of links to that website from other websites. It also factors in an estimation of the quality of these links (that is, how trustworthy is the site linking to yours).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Closeness</strong></span>: Closeness centrality is inversely proportional to the average length of the <a id="id664" class="indexterm"/>shortest path between the given vertex and all the other vertices in the graph. The intuition is that the closer a vertex is to all the other nodes, the more important it is.<p>The closeness centrality can be calculated with the following simple equation:</p><div class="mediaobject"><img src="Images/B09699_09_42.jpg" alt="Graph algorithms" width="167" height="64"/><div class="caption"><p>(Source: https://en.wikipedia.org/wiki/Centrality#Closeness_centrality)</p></div></div><p>Where <span class="emphasis"><em>d(y,x)</em></span> is the length of the edge between node <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shortest path betweenness</strong></span>: Measure based on how many times the given vertex is part of the shortest path between any two nodes. The intuition is <a id="id665" class="indexterm"/>that the more a vertex contributes to shortest paths, the more important it is. The mathematical equation for shortest path betweenness is provided here:<div class="mediaobject"><img src="Images/B09699_09_46.jpg" alt="Graph algorithms" width="420" height="60"/><div class="caption"><p>(Source: https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality)</p></div></div><p>Where <span class="inlinemediaobject"><img src="Images/B09699_09_43.jpg" alt="Graph algorithms" width="27" height="30"/></span> is the total number of shortest paths from vertex <span class="emphasis"><em>s</em></span> to vertex <span class="emphasis"><em>t</em></span> and <span class="inlinemediaobject"><img src="Images/B09699_09_44.jpg" alt="Graph algorithms" width="54" height="34"/></span> is the subset of <span class="inlinemediaobject"><img src="Images/B09699_09_45.jpg" alt="Graph algorithms" width="27" height="30"/></span> that pass through <span class="emphasis"><em>v</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note311"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: More information on centrality can be found here:</p><p>
<a class="ulink" href="https://en.wikipedia.org/wiki/Centrality">https://en.wikipedia.org/wiki/Centrality</a>
</p></div></div></li></ul></div></li></ul></div></div><div class="section" title="Graph and big data"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec59"/>Graph and big data</h2></div></div></div><p>Our graph discussion has so far focused on data that can fit into a single machine, but what happens <a id="id666" class="indexterm"/>when we have very large graphs with billions of vertices and edges where loading the entire data into <a id="id667" class="indexterm"/>memory would not be possible? A natural solution would be to distribute the data across a cluster of multiple nodes which process the data in parallel and have the individual results merged to form the final answer. Fortunately, there are multiple frameworks that provide such graph-parallel capabilities, and they pretty much all include the implementation for most of the commonly-used <a id="id668" class="indexterm"/>graph algorithms. Examples of popular open-source frameworks are Apache Spark GraphX (<a class="ulink" href="https://spark.apache.org/graphx">https://spark.apache.org/graphx</a>) and Apache Giraph (<a class="ulink" href="http://giraph.apache.org">http://giraph.apache.org</a>) which is <a id="id669" class="indexterm"/>currently used by Facebook to analyze its social network. </p><p>Without diving into too much detail, it's important to know that these frameworks are <a id="id670" class="indexterm"/>all inspired from the <span class="strong"><strong>bulk synchronous parallel</strong></span> (<span class="strong"><strong>BSP</strong></span>) model of distributed computation (<a class="ulink" href="https://en.wikipedia.org/wiki/Bulk_synchronous_parallel">https://en.wikipedia.org/wiki/Bulk_synchronous_parallel</a>) which uses messages between machines to find vertices across the cluster. The key point to remember is that these frameworks are usually very easy to use, for example, it would have been fairly easy to write this chapter's analytics using Apache Spark GraphX.</p><p>In this section, we've reviewed only a fraction of all the graph algorithms available and going deeper would be beyond the scope of this book. Implementing these algorithms yourself would take a considerable amount of time, but fortunately, there are plenty of open source libraries that provide fairly complete implementations of the graph algorithms and that are easy to use and integrate into your application. In the rest of this chapter, we'll use the <code class="literal">networkx</code> open source Python library.</p></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Getting started with the networkx graph library"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Getting started with the networkx graph library</h1></div></div></div><p>Before we start, if not <a id="id671" class="indexterm"/>already done, we need to install the <code class="literal">networkx</code> library using the <code class="literal">pip</code> tool. Execute the following code in its own cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>!pip install networkx</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note312"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: As always, don't forget to restart the kernel after the installation is complete.</p></div></div><p>Most of the algorithms provided by <code class="literal">networkx</code> are directly callable from the main module. Therefore a user will only need the following <code class="literal">import</code> statement:</p><div class="informalexample"><pre class="programlisting">import networkx as nx</pre></div><div class="section" title="Creating a graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec60"/>Creating a graph</h2></div></div></div><p>As a starting point, let's review the different types of graphs supported by <code class="literal">networkx</code> and the constructors <a id="id672" class="indexterm"/>that create empty graphs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Graph</code>: An undirected graph with only one edge between vertices allowed. Self-loop edges are permitted. Constructor example:<div class="informalexample"><pre class="programlisting">G = nx.Graph()</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Digraph</code>: Subclass of <code class="literal">Graph</code> that implements a directed graph. Constructor example:<div class="informalexample"><pre class="programlisting">G = nx.DiGraph()</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">MultiGraph</code>: Undirected graph that allows multiple edges between vertices. Constructor example:<div class="informalexample"><pre class="programlisting">G = nx.MultiGraph()</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">MultiDiGraph</code>: Directed graph that allows multiples edges between vertices. Constructor example:<div class="informalexample"><pre class="programlisting">G = nx.MultiDiGraph()</pre></div></li></ul></div><p>The <code class="literal">Graph</code> class provides many methods for adding and removing vertices and edges. Here is a subset of the available methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">add_edge(u_of_edge, v_of_edge, **attr)</code>: Add an edge between vertex <code class="literal">u</code> and vertex <code class="literal">v</code>, with optional additional attributes that will be associated with the edge. The vertices u and v will automatically be created if they don't already exist in the graph.</li><li class="listitem" style="list-style-type: disc"><code class="literal">remove_edge(u, v)</code>: Remove the edge between <code class="literal">u</code> and <code class="literal">v</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">add_node(self, node_for_adding, **attr)</code>: Add a node to the graph with optional additional attributes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">remove_node(n)</code>: Remove the node identified by the given argument <code class="literal">n</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">add_edges_from(ebunch_to_add, **attr)</code>: Add multiple edges in bulk with optional additional attributes. The edges must be given as a list of two-tuples <code class="literal">(u,v)</code> or three-tuples <code class="literal">(u,v,d)</code> where <code class="literal">d</code> is the dictionary that contains edge data.</li><li class="listitem" style="list-style-type: disc"><code class="literal">add_nodes_from(self, nodes_for_adding, **attr)</code>: Add multiple nodes in bulk with <a id="id673" class="indexterm"/>optional additional attributes. The nodes can be provided as a list, dict, set, array, and so on.</li></ul></div><p>As an exercise, let's build the directed graph we've been using as a sample from the beginning:</p><div class="mediaobject"><img src="Images/B09699_09_07.jpg" alt="Creating a graph" width="470" height="506"/><div class="caption"><p>Sample graph to be created programmatically using networkx</p></div></div><p>The following code starts by creating a <code class="literal">DiGraph()</code> object, adds all the nodes in one call using the <code class="literal">add_nodes_from()</code> method, and then starts adding the edges using, for illustration, a combination of <code class="literal">add_edge()</code> and <code class="literal">add_edges_from()</code>:</p><div class="informalexample"><pre class="programlisting">G = <span class="strong"><strong>nx.DiGraph()</strong></span>
G.<span class="strong"><strong>add_nodes_from</strong></span>(['A', 'B', 'C', 'D', 'E'])
G.<span class="strong"><strong>add_edge</strong></span>('A', 'B')
G.add_edge('B', 'B')
G.<span class="strong"><strong>add_edges_from</strong></span>([('A', 'E'),('A', 'D'),('B', 'C'),('C', 'E'),('D', 'C')])</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note313"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode1.py</a>
</p></div></div><p>The <code class="literal">Graph</code> class also provides easy access to its properties through variable class views. For example, you can iterate over the vertices and edges of a graph using <code class="literal">G.nodes</code> and <code class="literal">G.edges</code>, but also access an individual edge with the following notation: <code class="literal">G.edges[u,v]</code>.</p><p>The following code iterates over the nodes of a graph and prints them:</p><div class="informalexample"><pre class="programlisting">for n in G.nodes:
    print(n)</pre></div><p>The <code class="literal">networkx</code> library also provides a rich set of prebuilt graph generators that can be useful for testing your <a id="id674" class="indexterm"/>algorithms. For example, you can easily generate a complete graph using the <code class="literal">complete_graph()</code> generator as shown in the following code:</p><div class="informalexample"><pre class="programlisting">G_complete = nx.complete_graph(10)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note314"/>Note</h3><p>You can find a complete list of all the available graph generators here:</p><p>
<a class="ulink" href="https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators">https://networkx.github.io/documentation/networkx-2.1/reference/generators.html#generators</a>
</p></div></div></div><div class="section" title="Visualizing a graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec61"/>Visualizing a graph</h2></div></div></div><p>NetworkX supports multiple rendering engines including Matplotlib, Graphviz AGraph (<a class="ulink" href="http://pygraphviz.github.io">http://pygraphviz.github.io</a>) and Graphviz with pydot (<a class="ulink" href="https://github.com/erocarrera/pydot">https://github.com/erocarrera/pydot</a>). Even though Graphviz provides very powerful drawing capabilities, I found it very hard to install. Matplotlib, however, is already preinstalled in Jupyter Notebooks which gets you started very quickly.</p><p>The core drawing <a id="id675" class="indexterm"/>function is called <code class="literal">draw_networkx</code> which takes a graph as an argument and a bunch of optional keyword arguments that let you style the graph, such as color, width, and the label font of the nodes and edges. The overall layout of the graph drawing is configured by passing the <code class="literal">GraphLayout</code> object through the <code class="literal">pos</code> keyword argument. The default layout is <code class="literal">spring_layout</code> (which uses a force-directed algorithm), but NetworkX supports many others, including <code class="literal">circular_layout</code>, <code class="literal">random_layout</code>, and <code class="literal">spectral_layout</code>. You can find a list of all the available layouts here: <a class="ulink" href="https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout">https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html#module-networkx.drawing.layout</a>.</p><p>For convenience, <code class="literal">networkx</code> encapsulates each of these layouts into its own high-level drawing methods that call reasonable default values so that the caller doesn't have to deal with the intricacies of each of these layouts. For example, the <code class="literal">draw()</code> method will draw the graph with a <code class="literal">sprint_layout</code>, <code class="literal">draw_circular()</code> with a <code class="literal">circular_layout</code>, and <code class="literal">draw_random()</code>with a <code class="literal">random_layout</code>.</p><p>In the following sample code, we use the <code class="literal">draw()</code> method to visualize the <code class="literal">G_complete</code> graph we created earlier:</p><div class="informalexample"><pre class="programlisting">%matplotlib inline
import matplotlib.pyplot as plt
nx.draw(G_complete, with_labels=True)
plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note315"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode2.py</a>
</p></div></div><p>The results are shown in the following output:</p><div class="mediaobject"><img src="Images/B09699_09_08.jpg" alt="Visualizing a graph" width="862" height="576"/><div class="caption"><p>Drawing of a complete graph with 10 nodes</p></div></div><p>Drawing graphs with <code class="literal">networkx</code> is both easy and fun, and because it's using Matplotlib, you can beautify them even further using the Matplotlib drawing capabilities. I encourage the reader to experiment <a id="id676" class="indexterm"/>further by visualizing different graphs in a Notebook. In the next section, we'll start implementing a sample application that analyzes flight data using graph algorithms.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Part 1 – Loading the US domestic flight data into a graph"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Part 1 – Loading the US domestic flight data into a graph</h1></div></div></div><p>To initialize the Notebook, let's <a id="id677" class="indexterm"/>run the following code, in its own cell, to import the packages which we'll be using quite heavily <a id="id678" class="indexterm"/>in the rest of this chapter:</p><div class="informalexample"><pre class="programlisting">import pixiedust
import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt</pre></div><p>We'll also be using the <span class="emphasis"><em>2015 Flight Delays and Cancellations</em></span> dataset available on the Kaggle website at this location: <a class="ulink" href="https://www.kaggle.com/usdot/datasets">https://www.kaggle.com/usdot/datasets</a>. The dataset is composed of three files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">airports.csv</code>: List of all U.S. airports <a id="id679" class="indexterm"/>including their <span class="strong"><strong>IATA</strong></span> code (<span class="strong"><strong>International Air Transport Association</strong></span>: <a class="ulink" href="https://openflights.org/data.html">https://openflights.org/data.html</a>), city, state, longitude, and latitude.</li><li class="listitem" style="list-style-type: disc"><code class="literal">airlines.csv</code>: List of U.S. airlines including their IATA code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">flights.csv</code>: List of flights that occurred in 2015. This data includes date, origin and destination airports, scheduled and actual times, and delays.</li></ul></div><p>The <code class="literal">flights.csv</code> file contains close to 6 million records, which need to be cleaned up to remove all flights that do not have an IATA three letter code in the origin or destination airport. We also want to remove the rows that have a missing value in the <code class="literal">ELAPSED_TIME</code> column. Failure to do so would cause problems when we load the data into a graph structure. Another issue is that the dataset contains a few time columns, such as <code class="literal">DEPARTURE_TIME</code>, and <code class="literal">ARRIVAL_TIME</code>, and to save space, these columns only store the time in <code class="literal">HHMM</code> format, while the actual date is stored in the <code class="literal">YEAR</code>, <code class="literal">MONTH</code>, and <code class="literal">DAY</code> column. One of the analyses we will do in this chapter will need a complete datetime for the <code class="literal">DEPARTURE_TIME</code>, and since it is a time-consuming operation to do this transformation, we do it now and store it in the processed version of <code class="literal">flights.csv</code> that we'll store on GitHub. This operation uses the pandas <code class="literal">apply()</code> method that is called with the <code class="literal">to_datetime()</code> function and <code class="literal">axis=1</code> (indicating that the transformation is applied on each row).</p><p>Another issue is that we want to store the files on GitHub, but there is a maximum file size limitation of 100 M. So, to make the file smaller than 100 M, we also remove some of the columns that won't be needed in the analysis we're trying to build and then zip the file before storing it on GitHub. Of course, another benefit is that the DataFrame will load faster with a smaller file.</p><p>After downloading the files from the Kaggle website, we run the following code which first loads the CSV file into a pandas DataFrame, remove the unwanted rows and columns, and write the data back to a file:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note316"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: The original data is stored in a file called <code class="literal">flights.raw.csv</code>.</p><p>Running the following code may take some time due to the large size of the file which contains 6 million records.</p></div></div><div class="informalexample"><pre class="programlisting">import pandas as pd
import datetime
import numpy as np

# clean up the flights data in flights.csv
flights = pd.read_csv('flights.raw.csv', low_memory=False)

# select only the rows that have a 3 letter IATA code in the ORIGIN and DESTINATION airports
mask = (flights["ORIGIN_AIRPORT"].str.len() == 3) &amp; (flights["DESTINATION_AIRPORT"].str.len() == 3)
<span class="strong"><strong>flights = flights[ mask ]</strong></span>

# remove the unwanted columns
dropped_columns=["SCHEDULED_DEPARTURE","SCHEDULED_TIME",
"CANCELLATION_REASON","DIVERTED","DIVERTED","TAIL_NUMBER",
"TAXI_OUT","WHEELS_OFF","WHEELS_ON",
"TAXI_IN","SCHEDULED_ARRIVAL", "ARRIVAL_TIME", "AIR_SYSTEM_DELAY","SECURITY_DELAY",
"AIRLINE_DELAY","LATE_AIRCRAFT_DELAY", "WEATHER_DELAY"]
<span class="strong"><strong>flights.drop(dropped_columns, axis=1, inplace=True)</strong></span>

# remove the row that have NA in the ELAPSED_TIME column
<span class="strong"><strong>flights.dropna(subset=["ELAPSED_TIME"], inplace=True)</strong></span>

# remove the row that have NA in the DEPARTURE_TIME column
flights.dropna(subset=["ELAPSED_TIME"], inplace=True)

# Create a new DEPARTURE_TIME columns that has the actual datetime
def <span class="strong"><strong>to_datetime</strong></span>(row):
    departure_time = str(int(row["DEPARTURE_TIME"])).zfill(4)
    hour = int(departure_time[0:2])
    return datetime.datetime(year=row["YEAR"], month=row["MONTH"],
                             day=row["DAY"],
                             hour = 0 if hour &gt;= 24 else hour,
                             minute=int(departure_time[2:4])
                            )
flights["DEPARTURE_TIME"] = flights.apply(<span class="strong"><strong>to_datetime, axis=1</strong></span>)

# write the data back to file without the index
<span class="strong"><strong>flights.to_csv('flights.csv', index=False)</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note317"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode3.py</a>
</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note318"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: As documented in the <code class="literal">pandas.read_csv</code> documentation (<a class="ulink" href="http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html">http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.read_csv.html</a>), we use the keyword argument <code class="literal">low_memory=False</code> to make sure the data is not loaded in chunks which could cause problems with type inference, especially with very large files.</p></div></div><p>For convenience, the three files are stored at the following GitHub location: <a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis">https://github.com/DTAIEB/Thoughtful-Data-Science/tree/master/chapter%209/USFlightsAnalysis</a>.</p><p>The following code uses the <code class="literal">pixiedust.sampleData()</code> method to load the data into three pandas DataFrames corresponding to <code class="literal">airlines</code>, <code class="literal">airports</code>, and <code class="literal">flights</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>airports</strong></span> = pixiedust.sampleData("https://github.com/DTAIEB/Thoughtful-Data-Science/raw/master/chapter%209/USFlightsAnalysis/airports.csv")
<span class="strong"><strong>airlines</strong></span> = pixiedust.sampleData("https://github.com/DTAIEB/Thoughtful-Data-Science/raw/master/chapter%209/USFlightsAnalysis/airlines.csv")
<span class="strong"><strong>flights</strong></span> = pixiedust.sampleData("https://github.com/DTAIEB/Thoughtful-Data-Science/raw/master/chapter%209/USFlightsAnalysis/flights.zip")</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note319"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode4.py</a>
</p><p>
<span class="strong"><strong>Note</strong></span>: The GitHub URL uses the <code class="literal">/raw/</code> segment which indicates that we want to download the raw file as opposed to the HTML for the corresponding GitHub page.</p></div></div><p>The next step is to load the data into a <code class="literal">networkx</code> directed weighted graph object using the <code class="literal">flights</code> DataFrame as the <code class="literal">edge</code> list and the values from the <code class="literal">ELAPSED_TIME</code> column as the weight. We first deduplicate all the flights that have the same airports as origin and destination, by grouping them using the <code class="literal">pandas.groupby()</code> method with a multi-index that has <code class="literal">ORIGIN_AIRPORT</code> and <code class="literal">DESTINATION_AIRPORT</code> as the keys. We then select the <code class="literal">ELAPSED_TIME</code> column <a id="id680" class="indexterm"/>from the <code class="literal">DataFrameGroupBy</code> object and aggregate the results using the <code class="literal">mean()</code> method. This will give us a new DataFrame <a id="id681" class="indexterm"/>that has the mean average <code class="literal">ELAPSED_TIME</code> for each flight with the same origin and destination airport:</p><div class="informalexample"><pre class="programlisting">edges = flights.groupby(<span class="strong"><strong>["ORIGIN_AIRPORT","DESTINATION_AIRPORT"]</strong></span>) [["ELAPSED_TIME"]].<span class="strong"><strong>mean()</strong></span>
edges</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note320"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode5.py</a>
</p></div></div><p>The results are shown in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_09_09.jpg" alt="Part 1 – Loading the US domestic flight data into a graph" width="696" height="994"/><div class="caption"><p>Flights grouped by origin and destination with mean average ELAPSED_TIME</p></div></div><p>Before using this DataFrame <a id="id682" class="indexterm"/>to create the directed <a id="id683" class="indexterm"/>graph, we need to reset the index from a multi-index to a regular single index converting the index columns into regular columns. For that, we simply use the <code class="literal">reset_index()</code> method as shown here:</p><div class="informalexample"><pre class="programlisting">edges = edges.<span class="strong"><strong>reset_index()</strong></span>
edges</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note321"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode6.py</a>
</p></div></div><p>We now have a DataFrame with the right shape, ready to be used to create the directed graph, as shown in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_09_10.jpg" alt="Part 1 – Loading the US domestic flight data into a graph" width="760" height="828"/><div class="caption"><p>Flights grouped by origin and destination with mean average ELAPSED_TIME and a single index</p></div></div><p>To create the <a id="id684" class="indexterm"/>directed weighted graph, we use the NetworkX <code class="literal">from_pandas_edgelist()</code> method which takes a pandas DataFrame as the input source. We <a id="id685" class="indexterm"/>also specify the source and target columns, as well as the weight column (in our case <code class="literal">ELAPSED_TIME</code>). Finally, we tell NetworkX that we want to create a directed graph by using the <code class="literal">create_using</code> keyword arguments, passing an instance of <code class="literal">DiGraph</code> as a value.</p><p>The following code shows how to call the <code class="literal">from_pandas_edgelist()</code> method:</p><div class="informalexample"><pre class="programlisting">flight_graph = nx.from_pandas_edgelist(
    <span class="strong"><strong>flights</strong></span>, "ORIGIN_AIRPORT","DESTINATION_AIRPORT",
    "ELAPSED_TIME",
    create_using = <span class="strong"><strong>nx.DiGraph()</strong></span> )</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note322"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode7.py</a>
<span class="strong"><strong>Note</strong></span>: NetworkX supports the creation of graphs by converting from multiple formats including dictionaries, lists, NumPy and SciPy matrices and of course pandas. You can find more information about these conversion capabilities here:</p><p>
<a class="ulink" href="https://networkx.github.io/documentation/networkx-2.1/reference/convert.html">https://networkx.github.io/documentation/networkx-2.1/reference/convert.html</a>
</p></div></div><p>We can quickly validate that our graph has the right values by directly printing its nodes and edges:</p><div class="informalexample"><pre class="programlisting">print("Nodes: {}".format(flight_graph.nodes))
print("Edges: {}".format(flight_graph.edges))</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note323"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode8.py</a>
</p></div></div><p>Which produces the following output (truncated):</p><div class="informalexample"><pre class="programlisting">Nodes: ['BOS', 'TYS', 'RKS', 'AMA', 'BUF', 'BHM', 'PPG', …, 'CWA', 'DAL', 'BFL']
Edges: [('BOS', 'LAX'), ('BOS', 'SJC'), ..., ('BFL', 'SFO'), ('BFL', 'IAH')]</pre></div><p>We can also create better visualization by using the built-in drawing APIs available in <code class="literal">networkx</code> which support multiple rendering engines including Matplotlib, Graphviz AGraph (<a class="ulink" href="http://pygraphviz.github.io">http://pygraphviz.github.io</a>) and Graphviz with pydot (<a class="ulink" href="https://github.com/erocarrera/pydot">https://github.com/erocarrera/pydot</a>).</p><p>For simplicity, we'll <a id="id686" class="indexterm"/>use the NetworkX <code class="literal">draw()</code> method which uses the readily available Matplotlib engine. To beautify the visualization, we <a id="id687" class="indexterm"/>configure it with proper width and height <code class="literal">(12, 12)</code> and add a colormap with vivid color (we use the <code class="literal">cool</code> and <code class="literal">spring</code> colormap from <code class="literal">matplolib.cm</code>, see: <a class="ulink" href="https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html">https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html</a>).</p><p>The following code shows the implementation of the graph visualization:</p><div class="informalexample"><pre class="programlisting">import matplotlib.cm as cm
fig = plt.figure(figsize = <span class="strong"><strong>(12,12)</strong></span>)
nx.draw(flight_graph, <span class="strong"><strong>arrows=True</strong></span>, with_labels=True,
        width = 0.5,style="dotted",
        node_color=range(len(flight_graph)),
        cmap=<span class="strong"><strong>cm.get_cmap(name="cool")</strong></span>,
        edge_color=range(len(flight_graph.edges)),
        edge_cmap=<span class="strong"><strong>cm.get_cmap(name="spring")</strong></span>
       )
plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note324"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode9.py</a>
</p></div></div><p>Which produces the following results:</p><div class="mediaobject"><img src="Images/B09699_09_11.jpg" alt="Part 1 – Loading the US domestic flight data into a graph" width="1000" height="961"/><div class="caption"><p>Quick visualization of our directed graph using Matplotlib</p></div></div><p>In the preceding chart, the nodes are positioned using a default graph layout called <code class="literal">spring_layout</code>, which is a force-directed layout. One benefit of this layout is that it quickly reveals the nodes <a id="id688" class="indexterm"/>with the most edge connections which are located at the center of the graph. We can change the graph layout by <a id="id689" class="indexterm"/>using the <code class="literal">pos</code> keyword argument when calling the <code class="literal">draw()</code> method. <code class="literal">networkx</code> supports other types of layout including <code class="literal">circular_layout</code>, <code class="literal">random_layout</code>, <code class="literal">shell_layout</code>, and <code class="literal">spectral_layout</code>.</p><p>For example, using a <code class="literal">random_layout</code>:</p><div class="informalexample"><pre class="programlisting">import matplotlib.cm as cm
fig = plt.figure(figsize = (12,12))
nx.draw(flight_graph, arrows=True, with_labels=True,
        width = 0.5,style="dotted",
        node_color=range(len(flight_graph)),
        cmap=cm.get_cmap(name="cool"),
        edge_color=range(len(flight_graph.edges)),
        edge_cmap=cm.get_cmap(name="spring"),
        <span class="strong"><strong>pos = nx.random_layout(flight_graph)</strong></span>
       )
plt.show()
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note325"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode10.py</a>
</p></div></div><p>We get the following results:</p><div class="mediaobject"><img src="Images/B09699_09_12.jpg" alt="Part 1 – Loading the US domestic flight data into a graph" width="613" height="607"/><div class="caption"><p>Flight data graph using a random_layout</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note326"/>Note</h3><p>Note: You can find more information about these layouts here:</p><p>
<a class="ulink" href="https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html">https://networkx.github.io/documentation/networkx-2.1/reference/drawing.html</a>
</p></div></div><div class="section" title="Graph centrality"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec62"/>Graph centrality</h2></div></div></div><p>The next interesting thing to analyze about the graph is its centrality indices which allow us to discover which <a id="id690" class="indexterm"/>nodes are the most important vertices. As an exercise, we'll compute four types of centrality index: <span class="strong"><strong>degree</strong></span>, <span class="strong"><strong>PageRank</strong></span>, <span class="strong"><strong>closeness</strong></span>, and <span class="strong"><strong>shortest path betweenness</strong></span>. We'll then augment the airports DataFrame to add a column for each of the centrality indices and visualize the results in a Mapbox map using PixieDust <code class="literal">display()</code>.</p><p>Computing the degree of the digraph is very easy with <code class="literal">networkx</code>; simply use the <code class="literal">degree</code> property of the <code class="literal">flight_graph</code> object as follows:</p><div class="informalexample"><pre class="programlisting">print(flight_graph.degree)</pre></div><p>This outputs an array of tuples with the airport code and the degree index as follows:</p><div class="informalexample"><pre class="programlisting">[('BMI', 14), ('RDM', 8), ('SBN', 13), ('PNS', 18), ………, ('JAC', 26), ('MEM', 46)]</pre></div><p>We now want to add a <code class="literal">DEGREE</code> column to the airport DataFrame that contains the degree value from the preceding array for each of the airport rows. To do that, we'll need to create a new DataFrame that has two columns: <code class="literal">IATA_CODE</code> and <code class="literal">DEGREE</code> and perform a pandas <code class="literal">merge()</code> operation on the <code class="literal">IATA_CODE</code>.</p><p>The merge operation is illustrated in the following diagram:</p><div class="mediaobject"><img src="Images/B09699_09_13.jpg" alt="Graph centrality" width="1000" height="747"/><div class="caption"><p>Merging the degree DataFrame to the airports DataFrame</p></div></div><p>The following code shows how to implement the aforementioned steps. We first create a JSON payload by iterating over the <code class="literal">flight_path.degree</code> output and use the <code class="literal">pd.DataFrame()</code> constructor to <a id="id691" class="indexterm"/>create the DataFrame. We then use <code class="literal">pd.merge()</code> using <code class="literal">airports</code> and <code class="literal">degree_df</code> as arguments. We also use the <code class="literal">on</code> argument with value <code class="literal">IATA_CODE</code> which is the key column we'll want to do the join on:</p><div class="informalexample"><pre class="programlisting">degree_df = pd.DataFrame([<span class="strong"><strong>{"IATA_CODE":k, "DEGREE":v}</strong></span> for k,v in flight_graph.degree], columns=["IATA_CODE", "DEGREE"])
airports_centrality = pd.merge(<span class="strong"><strong>airports</strong></span>, degree_df, on=<span class="strong"><strong>'IATA_CODE'</strong></span>)
airports_centrality</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note327"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode11.py</a>
</p></div></div><p>The results are shown <a id="id692" class="indexterm"/>in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_09_14.jpg" alt="Graph centrality" width="738" height="278"/><div class="caption"><p>Airport DataFrame augmented with the DEGREE column</p></div></div><p>To visualize the data in a Mapbox map, we simply use <code class="literal">PixieDust.display()</code> on the <code class="literal">airport_centrality</code> DataFrame:</p><div class="informalexample"><pre class="programlisting">display(airports_centrality)</pre></div><p>The following screenshot shows the options dialog:</p><div class="mediaobject"><img src="Images/B09699_09_15.jpg" alt="Graph centrality" width="703" height="542"/><div class="caption"><p>Mapbox options for displaying the airports</p></div></div><p>After clicking <span class="strong"><strong>OK</strong></span> on the <a id="id693" class="indexterm"/>options dialog, we get the following results:</p><div class="mediaobject"><img src="Images/B09699_09_16.jpg" alt="Graph centrality" width="807" height="507"/><div class="caption"><p>Showing the airport with degree centrality</p></div></div><p>For the other centrality indices, we can notice that the corresponding computation functions all return a JSON output (as opposed to an array for the degree attribute) with the <code class="literal">IATA_CODE</code> airport code as key and the centrality index as value.</p><p>For example, if we are computing the PageRank using the following code:</p><div class="informalexample"><pre class="programlisting">nx.pagerank(flight_graph)</pre></div><p>We get the following results:</p><div class="informalexample"><pre class="programlisting">{'ABE': 0.0011522441195896051,
 'ABI': 0.0006671948649909588,
 ...
 'YAK': 0.001558809391270303,
 'YUM': 0.0006214341604372096}</pre></div><p>With this in mind, instead of repeating the same steps as we did for <code class="literal">degree</code>, we can implement a generic function called <code class="literal">compute_centrality()</code> that takes the function that computes the <a id="id694" class="indexterm"/>centrality and a column name as arguments, create a temporary DataFrame that contains the computed centrality values, and merge it with the <code class="literal">airports_centrality</code> DataFrame.</p><p>The following code shows the implementation for <code class="literal">compute_centrality()</code>:</p><div class="informalexample"><pre class="programlisting">from six import iteritems
def <span class="strong"><strong>compute_centrality</strong></span>(g, centrality_df, compute_fn, col_name, *args, **kwargs):
    # create a temporary DataFrame that contains the computed centrality values
    temp_df = pd.DataFrame(
        [{"IATA_CODE":k, col_name:v} for k,v in iteritems(<span class="strong"><strong>compute_fn(g, *args, **kwargs</strong></span>))],
        columns=["IATA_CODE", col_name]
    )
    # make sure to remove the col_name from the centrality_df is already there
    if col_name in centrality_df.columns:
        centrality_df.drop([col_name], axis=1, inplace=True)
    # merge the 2 DataFrame on the IATA_CODE column
    centrality_df = pd.merge(<span class="strong"><strong>centrality_df, temp_df, on='IATA_CODE'</strong></span>)
    return <span class="strong"><strong>centrality_df</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note328"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode12.py</a>
</p></div></div><p>We can now simply call the <code class="literal">compute_centrality()</code> method with the three compute functions <code class="literal">nx.pagerank()</code>, <code class="literal">nx.closeness_centrality()</code>, and <code class="literal">nx.betweenness_centrality()</code> with the columns <code class="literal">PAGE_RANK</code>, <code class="literal">CLOSENESS</code>, and <code class="literal">BETWEENNESS</code> respectively <a id="id695" class="indexterm"/>as shown in the following code:</p><div class="informalexample"><pre class="programlisting">airports_centrality = compute_centrality(flight_graph, airports_centrality, <span class="strong"><strong>nx.pagerank</strong></span>, "<span class="strong"><strong>PAGE_RANK</strong></span>")
airports_centrality = compute_centrality(flight_graph, airports_centrality, <span class="strong"><strong>nx.closeness_centrality</strong></span>, "<span class="strong"><strong>CLOSENESS</strong></span>")
airports_centrality = compute_centrality(
    flight_graph, airports_centrality, <span class="strong"><strong>nx.betweenness_centrality</strong></span>, "<span class="strong"><strong>BETWEENNESS</strong></span>", k=len(flight_graph))
airports_centrality</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note329"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode13.py</a>
</p></div></div><p>The <code class="literal">airports_centrality</code> DataFrame now has the extra columns as shown in the following output:</p><div class="mediaobject"><img src="Images/B09699_09_17.jpg" alt="Graph centrality" width="1000" height="454"/><div class="caption"><p>Airports DataFrame augmented with PAGE_RANK, CLOSENESS and BETWEENNESS values</p></div></div><p>As an exercise, we can verify that the four centrality indices provide consistent results for the top airports. Using the pandas <code class="literal">nlargest()</code> method, we can get the top 10 airports for the four indices as shown in the following code:</p><div class="informalexample"><pre class="programlisting">for col_name in [<span class="strong"><strong>"DEGREE", "PAGE_RANK", "CLOSENESS", "BETWEENNESS"</strong></span>]:
    print("{} : {}".format(
        <span class="strong"><strong>col_name</strong></span>,
        airports_centrality.<span class="strong"><strong>nlargest(10, col_name)</strong></span>["IATA_CODE"].values)
    )</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note330"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode14.py</a>
</p></div></div><p>Which produces the following results:</p><div class="informalexample"><pre class="programlisting">DEGREE : ['ATL' 'ORD' 'DFW' 'DEN' 'MSP' 'IAH' 'DTW' 'SLC' 'EWR' 'LAX']
PAGE_RANK : ['ATL' 'ORD' 'DFW' 'DEN' 'MSP' 'IAH' 'DTW' 'SLC' 'SFO' 'LAX']
CLOSENESS : ['ATL' 'ORD' 'DFW' 'DEN' 'MSP' 'IAH' 'DTW' 'SLC' 'EWR' 'LAX']
BETWEENNESS : ['ATL' 'DFW' 'ORD' 'DEN' 'MSP' 'SLC' 'DTW' 'ANC' 'IAH' 'SFO']</pre></div><p>As we can see, Atlanta airport comes up as the top airport for all centrality indices. As an exercise, let's create a generic method called <code class="literal">visualize_neighbors()</code> that visualizes all the neighbors of a given <a id="id696" class="indexterm"/>node and call it with the Atlanta node. In this method, we create a subgraph centered around the parent node by adding an edge from itself to all its neighbors. We use the NetworkX <code class="literal">neighbors()</code> method to get all the neighbors of a specific node.</p><p>The following code shows the implementation of the <code class="literal">visualize_neighbors()</code> method:</p><div class="informalexample"><pre class="programlisting">import matplotlib.cm as cm
def visualize_neighbors(parent_node):
    fig = plt.figure(figsize = (12,12))
    # Create a subgraph and add an edge from the parent node to all its neighbors
    graph = nx.DiGraph()
    for neighbor in flight_graph.neighbors(parent_node):
        graph.add_edge(parent_node, neighbor)
    # draw the subgraph
    nx.draw(graph, arrows=True, with_labels=True,
            width = 0.5,style="dotted",
            node_color=range(len(graph)),
            cmap=cm.get_cmap(name="cool"),
            edge_color=range(len(graph.edges)),
            edge_cmap=cm.get_cmap(name="spring"),
           )
    plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note331"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode15.py</a>
</p></div></div><p>We then call the <code class="literal">visualize_neighbors()</code> method on the <code class="literal">ATL</code> node:</p><div class="informalexample"><pre class="programlisting">visualize_neighbors("ATL")</pre></div><p>Which produces the following output:</p><div class="mediaobject"><img src="Images/B09699_09_18.jpg" alt="Graph centrality" width="1000" height="953"/><div class="caption"><p>Visualization of the top node ATL and its neighbors</p></div></div><p>We complete this <span class="emphasis"><em>Part 1</em></span> section by computing the shortest path between two nodes using the famous Dijkstra algorithm (<a class="ulink" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a>). We'll experiment with different weight attributes to check if we are getting different results.</p><p>As an example, let's compute the shortest path between Boston Logan Airport in Massachusetts (<code class="literal">BOS</code>) and Pasco Tri-Cities Airport in Washington (<code class="literal">PSC</code>) using the NetworkX <code class="literal">dijkstra_path()</code> method (<a class="ulink" href="https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html">https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.dijkstra_path.html</a>).</p><p>We first use the <code class="literal">ELAPSED_TIME</code> column as the weight attribute:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note332"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: As a reminder, <code class="literal">ELAPSED_TIME</code> is the average flight time for each of the flights with the same origin and destination airports that we computed earlier in this section.</p></div></div><div class="informalexample"><pre class="programlisting">nx.<span class="strong"><strong>dijkstra_path</strong></span>(flight_graph, "BOS", "PSC", weight="<span class="strong"><strong>ELAPSED_TIME</strong></span>")</pre></div><p>Which returns:</p><div class="informalexample"><pre class="programlisting">['BOS', 'MSP', 'PSC']</pre></div><p>Unfortunately, the centrality indices we computed earlier are not part of the <code class="literal">flight_graph</code> DataFrame, so using it as the column name for the <code class="literal">weight</code> attribute won't work. However, the <code class="literal">dijkstra_path()</code> also allows us to use a function to dynamically compute the weight. Since we want to try for different centrality indices, we need to create a factory method (<a class="ulink" href="https://en.wikipedia.org/wiki/Factory_method_pattern">https://en.wikipedia.org/wiki/Factory_method_pattern</a>) that will create a function for a given centrality index passed as an argument. This argument is used as a closure for a nested wrapper function that conforms to the <code class="literal">dijkstra_path()</code> method's <code class="literal">weight</code> argument. We also <a id="id697" class="indexterm"/>use a <code class="literal">cache</code> dictionary to remember the computed weights for a given airport, since the algorithm will call the function multiple times for the same airport. If the weight is not in the cache, we look it up in the <code class="literal">airports_centrality</code> DataFrame using the <code class="literal">centrality_indice_col</code> parameter. The final weight is computed by getting the inverse of the centrality value, since the Dijkstra algorithm favors paths with shorter distances.</p><p>The following code shows the implementation of the <code class="literal">compute_weight</code> factory method:</p><div class="informalexample"><pre class="programlisting"># use a cache so we don't recompute the weight for the same airport every time
<span class="strong"><strong>cache</strong></span> = {}
def compute_weight(<span class="strong"><strong>centrality_indice_col</strong></span>):
    # wrapper function that conform to the dijkstra weight argument
    def <span class="strong"><strong>wrapper</strong></span>(source, target, attribute):
        # try the cache first and compute the weight if not there
        source_weight = <span class="strong"><strong>cache.get(source, None)</strong></span>
        if source_weight is None:
            # look up the airports_centrality for the value
            source_weight = airports_centrality.loc[airports_centrality["IATA_CODE"] == source][centrality_indice_col].values[0]
            cache[source] = source_weight
        target_weight = cache.get(target, None)
        if target_weight is None:
            target_weight = airports_centrality.loc[airports_centrality["IATA_CODE"] == target][centrality_indice_col].values[0]
            cache[target] = target_weight
        # Return weight is inversely proportional to the computed weighted since
        # the Dijkstra algorithm give precedence to shorter distances
        return float(1/source_weight) + float(1/target_weight)
    return wrapper</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note333"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode16.py</a>
</p></div></div><p>We can now call the NetworkX <code class="literal">dijkstra_path()</code> method for each of the centrality indices. Note that we don't use BETWEENNESS because some of the values are equal to zero which can't be used as a <a id="id698" class="indexterm"/>weight. We also need to clear the cache before calling the <code class="literal">dijkstra_path()</code> method because using different centrality indices will produce different values for each airport.</p><p>The following code shows how to compute the shortest path for each centrality index:</p><div class="informalexample"><pre class="programlisting">for col_name in [<span class="strong"><strong>"DEGREE", "PAGE_RANK", "CLOSENESS"</strong></span>]:
    #clear the cache
    cache.clear()
    print("{} : {}".format(
        col_name,
        nx.dijkstra_path(flight_graph, "BOS", "PSC",
                         weight=<span class="strong"><strong>compute_weight(col_name)</strong></span>)
    ))</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note334"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode17.py</a>
</p></div></div><p>The following result is produced:</p><div class="informalexample"><pre class="programlisting">DEGREE : ['BOS', 'DEN', 'PSC']
PAGE_RANK : ['BOS', 'DEN', 'PSC']
CLOSENESS : ['BOS', 'DEN', 'PSC']</pre></div><p>It is interesting to note that, as expected, the computed shortest path is the same for the three centrality indices, going through Denver airport which is a top central airport. However, it is not the same as<a id="id699" class="indexterm"/> the one computed using the <code class="literal">ELAPSED_TIME</code> weight which would have us go through Minneapolis instead.</p><p>In this section, we have shown how to load US flight data into a graph data structure, compute different centrality indices and use them to compute the shortest path between airports. We also discussed different ways of visualizing the graph data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note335"/>Note</h3><p>The complete Notebook for <span class="emphasis"><em>Part 1</em></span> can be found here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%201.ipynb</a>
</p></div></div><p>In the next section, we'll create the <code class="literal">USFlightsAnalysis</code> PixieApp that operationalizes these analytics.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Part 2 – Creating the USFlightsAnalysis PixieApp"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Part 2 – Creating the USFlightsAnalysis PixieApp</h1></div></div></div><p>For the first iteration of our <code class="literal">USFlightsAnalysis</code>, we want to implement a simple user story that leverages the <a id="id700" class="indexterm"/>analytics created in <span class="emphasis"><em>Part 1</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The welcome screen will show two drop-down controls for selecting an origin and a destination airport</li><li class="listitem" style="list-style-type: disc">When an airport is selected, we show a graph showing the selected airports and its immediate neighbors</li><li class="listitem" style="list-style-type: disc">When both airports are selected, the user clicks on the <span class="strong"><strong>Analyze</strong></span> button to show a Mapbox map with all the airports</li><li class="listitem" style="list-style-type: disc">The user can select one of the centrality indices available as checkboxes to show the shortest flight path according to the selected centrality</li></ul></div><p>Let's first look at the implementation for the welcome screen which is implemented in the default route of the <code class="literal">USFlightsAnalysis</code> PixieApp. The following code defines the <code class="literal">USFlightsAnalysis</code> class which is decorated with the <code class="literal">@PixieApp</code> decorator to make it a PixieApp. It contains a <code class="literal">main_screen()</code> method that is decorated with the <code class="literal">@route()</code> decorator to make it the default route. This method returns an HTML fragment that will be used as the welcome screen when the PixieApp starts. The HTML fragment is composed of two parts: one that shows the drop-down control for selecting the origin airport and one that contains the <a id="id701" class="indexterm"/>drop-down control for selecting the destination airport. We use a Jinja2 <code class="literal">{%for...%}</code> loop that goes over each of the airports (returned by the <code class="literal">get_airports()</code> method) to generate a set of <code class="literal">&lt;options&gt;</code> elements. Under each of these controls, we add a placeholder <code class="literal">&lt;div&gt;</code> element that will host the graph visualization when an airport is selected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note336"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: As always, we use the <code class="literal">[[USFlightsAnalysis]]</code> notation to denote that the code shows only a partial implementation and therefore the reader should not attempt to run it as is until the full implementation is provided.</p><p>We'll explain later on why the <code class="literal">USFlightsAnalysis</code> class inherits from the <code class="literal">MapboxBase</code> class.</p></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
from pixiedust.display.app import *
from pixiedust.apps.mapboxBase import MapboxBase
from collections import OrderedDict

@PixieApp
class USFlightsAnalysis(MapboxBase):
    ...
    @route()
    def main_screen(self):
        return """
&lt;style&gt;
    div.outer-wrapper {
        display: table;width:100%;height:300px;
    }
    div.inner-wrapper {
        display: table-cell;vertical-align: middle;height: 100%;width: 100%;
    }
&lt;/style&gt;
&lt;div class="outer-wrapper"&gt;
    &lt;div class="inner-wrapper"&gt;
        &lt;div class="col-sm-6"&gt;
            &lt;div class="rendererOpt" style="font-weight:bold"&gt;
                 Select origin airport:
            &lt;/div&gt;
            &lt;div&gt;
                &lt;select id="origin_airport{{prefix}}"
                        pd_refresh="<span class="strong"><strong>origin_graph{{prefix}}</strong></span>"&gt;
                    &lt;option value="" selected&gt;&lt;/option&gt;
                    <span class="strong"><strong>{%for code, airport in this.get_airports() %}</strong></span>
<span class="strong"><strong>                    &lt;option value="{{code}}"&gt;{{code}} - {{airport}}&lt;/option&gt;</strong></span>
<span class="strong"><strong>                    {%endfor%}</strong></span>
                &lt;/select&gt;
            &lt;/div&gt;
            &lt;div id="<span class="strong"><strong>origin_graph{{prefix}}</strong></span>" pd_options="<span class="strong"><strong>visualize_graph=$val(origin_airport{{prefix}})</strong></span>"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="input-group col-sm-6"&gt;
            &lt;div class="rendererOpt" style="font-weight:bold"&gt;
                 Select destination airport:
            &lt;/div&gt;
            &lt;div&gt;
                &lt;select id="destination_airport{{prefix}}"
                        pd_refresh="<span class="strong"><strong>destination_graph{{prefix}}</strong></span>"&gt;
                    &lt;option value="" selected&gt;&lt;/option&gt;
                    <span class="strong"><strong>{%for code, airport in this.get_airports() %}</strong></span>
<span class="strong"><strong>                    &lt;option value="{{code}}"&gt;{{code}} - {{airport}}&lt;/option&gt;</strong></span>
<span class="strong"><strong>                    {%endfor%}</strong></span>
                &lt;/select&gt;
            &lt;/div&gt;
            &lt;div id="<span class="strong"><strong>destination_graph{{prefix}}</strong></span>"
pd_options="<span class="strong"><strong>visualize_graph=$val(destination_airport{{prefix}})</strong></span>"&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div style="text-align:center"&gt;
    &lt;button class="btn btn-default" type="button"
pd_options="org_airport=$val(origin_airport{{prefix}});dest_airport=$val(destination_airport{{prefix}})"&gt;
        &lt;pd_script type="preRun"&gt;
            if ($("#origin_airport{{prefix}}").val() == "" || $("#destination_airport{{prefix}}").val() == ""){
                alert("Please select an origin and destination airport");
                return false;
            }
            return true;
        &lt;/pd_script&gt;
        Analyze
    &lt;/button&gt;
&lt;/div&gt;
"""

def get_airports(self):
    return <span class="strong"><strong>[tuple(l) for l in airports_centrality[["IATA_CODE", "AIRPORT"]].values.tolist()]</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note337"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode18.py</a>
</p></div></div><p>When the user selects the origin airport, a <code class="literal">pd_refresh</code> targetted at the placeholder <code class="literal">&lt;div&gt;</code> element with ID <code class="literal">origin_graph{{prefix}}</code>, is triggered. In turn, this <code class="literal">&lt;div&gt;</code> element triggers a route using the state: <code class="literal">visualize_graph=$val(origin_airport{{prefix}}</code>. As a reminder, the <code class="literal">$val()</code> directive is resolved at runtime by fetching the airport value of the <code class="literal">origin_airport{{prefix}}</code> drop-down element. A similar implementation is used for the destination airport.</p><p>The code for the <code class="literal">visualize_graph</code> route is provided here. It simply calls the <code class="literal">visualize_neighbors()</code> method that we implemented in <span class="emphasis"><em>Part 1</em></span>, which we slightly change in <span class="emphasis"><em>Part 2</em></span> to add an <a id="id702" class="indexterm"/>optional figure size parameter to accommodate the size of the host <code class="literal">&lt;div&gt;</code> element. As a reminder, we also use the <code class="literal">@captureOutput</code> decorator since the <code class="literal">visualize_neighbors()</code> method is directly writing to the output of the selected cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
@route(visualize_graph="*")
@captureOutput
def visualize_graph_screen(self, visualize_graph):
    visualize_neighbors(visualize_graph, (5,5))</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note338"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode19.py</a>
</p></div></div><p>The <code class="literal">Analyze</code> button is triggering the <code class="literal">compute_path_screen()</code> route which is associated with the <code class="literal">org_airport</code> and <code class="literal">dest_airport</code> state parameters. We also want to make sure that both airports are selected before allowing the <code class="literal">compute_path_screen()</code> route to proceed. To do that, we use a <code class="literal">&lt;pd_script&gt;</code> child element with <code class="literal">type="preRun"</code> that contains JavaScript code that will be executed before the route is triggered. The contract is for this code to return the Boolean <code class="literal">true</code> if we want to let the route proceed, or to return <code class="literal">false</code> otherwise.</p><p>For the <code class="literal">Analyze</code> button we check that both drop-downs have a value and return <code class="literal">true</code> if that's the case or else raise an error message and return <code class="literal">false</code>:</p><div class="informalexample"><pre class="programlisting">&lt;button class="btn btn-default" type="button" pd_options="org_airport=$val(origin_airport{{prefix}});dest_airport=$val(destination_airport{{prefix}})"&gt;
   &lt;pd_script type="preRun"&gt;
<span class="strong"><strong>       if ($("#origin_airport{{prefix}}").val() == "" || $("#destination_airport{{prefix}}").val() == ""){</strong></span>
<span class="strong"><strong>           alert("Please select an origin and destination airport");</strong></span>
<span class="strong"><strong>           return false;</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>       return true;</strong></span>
   &lt;/pd_script&gt;
      Analyze
   &lt;/button&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note339"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode20.html</a>
</p></div></div><p>The following output shows the end results when selecting BOS as the origin airport and PSC as the destination:</p><div class="mediaobject"><img src="Images/B09699_09_19.jpg" alt="Part 2 – Creating the USFlightsAnalysis PixieApp" width="1000" height="520"/><div class="caption"><p>Welcome screen with both airports selected</p></div></div><p>Let's now look at the implementation of the <code class="literal">compute_path_screen()</code> route which is responsible for showing the <a id="id703" class="indexterm"/>Mapbox map of all the airports and the shortest path based on the selected centrality index as a layer which is an extra visualization superimposed on the overall map.</p><p>The following code shows its implementation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
@route(org_airport="*", dest_airport="*")
def compute_path_screen(self, org_airport, dest_airport):
    return """
&lt;div class="container-fluid"&gt;
    &lt;div class="form-group col-sm-2" style="padding-right:10px;"&gt;
        &lt;div&gt;&lt;strong&gt;Centrality Indices&lt;/strong&gt;&lt;/div&gt;
<span class="strong"><strong>        {% for centrality in this.centrality_indices.keys() %}</strong></span>
        &lt;div class="rendererOpt checkbox checkbox-primary"&gt;
            &lt;input type="checkbox"
                   pd_refresh="flight_map{{prefix}}"
pd_script="<span class="strong"><strong>self.compute_toggle_centrality_layer('{{org_airport}}', '{{dest_airport}}', '{{centrality}}')</strong></span>"&gt;
            &lt;label&gt;{{centrality}}&lt;/label&gt;
        &lt;/div&gt;
<span class="strong"><strong>        {%endfor%}</strong></span>
    &lt;/div&gt;
    &lt;div class="form-group col-sm-10"&gt;
        &lt;h1 class="rendererOpt"&gt;Select a centrality index to show the shortest flight path
        &lt;/h1&gt;
        &lt;div id="flight_map{{prefix}}" pd_entity="<span class="strong"><strong>self.airports_centrality</strong></span>" pd_render_onload&gt;
            &lt;pd_options&gt;
<span class="strong"><strong>            {</strong></span>
<span class="strong"><strong>              "keyFields": "LATITUDE,LONGITUDE",</strong></span>
<span class="strong"><strong>              "valueFields": "AIRPORT,DEGREE,PAGE_RANK,ELAPSED_TIME,CLOSENESS",</strong></span>
<span class="strong"><strong>              "custombasecolorsecondary": "#fffb00",</strong></span>
<span class="strong"><strong>              "colorrampname": "Light to Dark Red",</strong></span>
<span class="strong"><strong>              "handlerId": "mapView",</strong></span>
<span class="strong"><strong>              "quantiles": "0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0",</strong></span>
<span class="strong"><strong>              "kind": "choropleth",</strong></span>
<span class="strong"><strong>              "rowCount": "1000",</strong></span>
<span class="strong"><strong>              "numbins": "5",</strong></span>
<span class="strong"><strong>              "mapboxtoken": "pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4M29iazA2Z2gycXA4N2pmbDZmangifQ.-g_vE53SD2WrJ6tFX7QHmA",</strong></span>
<span class="strong"><strong>              "custombasecolor": "#ffffff"</strong></span>
<span class="strong"><strong>            }</strong></span>
            &lt;/pd_options&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
"""</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note340"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode21.py</a>
</p></div></div><p>The central <code class="literal">&lt;div&gt;</code> element of this screen is the Mapbox map which by default shows the Mapbox map of all the airports. As <a id="id704" class="indexterm"/>shown in the code above, the <code class="literal">&lt;pd_options&gt;</code> child element is taken directly from the corresponding cell metadata where we configured the map in <span class="emphasis"><em>Part 1</em></span>.</p><p>On the left-hand side, we generate a set of checkboxes corresponding to each centrality index, using a Jinja2 <code class="literal">{%for …%}</code> loop over the <code class="literal">centrality_indices</code> variable. We initialize this variable in the <code class="literal">setup()</code> method of the <code class="literal">USFlightsAnalysis</code> PixieApp which is guaranteed to be called when the PixieApp starts. This variable is an OrderedDict (<a class="ulink" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">https://docs.python.org/3/library/collections.html#collections.OrderedDict</a>) with keys as the centrality index and values as a color scheme that will be used in the Mapbox rendering:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
def setup(self):
   self.centrality_indices = OrderedDict([
      ("ELAPSED_TIME","rgba(256,0,0,0.65)"),
      ("DEGREE", "rgba(0,256,0,0.65)"),
      ("PAGE_RANK", "rgba(0,0,256,0.65)"),
      ("CLOSENESS", "rgba(128,0,128,0.65)")
  ])</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note341"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode22.py</a>
</p></div></div><p>The following output shows the analysis screen with no centrality index selected:</p><div class="mediaobject"><img src="Images/B09699_09_20.jpg" alt="Part 2 – Creating the USFlightsAnalysis PixieApp" width="1000" height="578"/><div class="caption"><p>Analysis screen with no centrality index selected</p></div></div><p>We now arrive at the step <a id="id705" class="indexterm"/>where the user selects a centrality index to trigger a shortest path search. Each of the checkboxes have a <code class="literal">pd_script</code> attribute that calls the <code class="literal">compute_toggle_centrality_layer()</code> method. This method is responsible for calling the NetworkX <code class="literal">dijkastra_path()</code> method with a <code class="literal">weight</code> argument generated by calling the <code class="literal">compute_weight()</code> method that we discussed in <span class="emphasis"><em>Part 1</em></span>. This method returns an array with each airport that constitutes the shortest path. Using this path, we <a id="id706" class="indexterm"/>then create a JSON object that contains the GeoJSON payload as a set of lines to be displayed on the map.</p><p>At this point, it's worth pausing to discuss what a layer is. A <span class="strong"><strong>layer</strong></span> is defined using the GeoJSON format (<a class="ulink" href="http://geojson.org">http://geojson.org</a>) which we briefly discussed in <a class="link" href="ch05.xhtml" title="Chapter 5. Python and PixieDust Best Practices and Advanced Concepts">Chapter 5</a>, <span class="emphasis"><em>Python and PixieDust Best Practices and Advanced Concepts</em></span>. As a reminder, a GeoJSON payload is a JSON object with a specific schema that includes among other things a <code class="literal">geometry</code> element that defines the shape of the object being drawn.</p><p>For example, we can define a line using the <code class="literal">LineString</code> type and an array of longitude and latitude coordinates for both ends of the line:</p><div class="informalexample"><pre class="programlisting">{
    "geometry": {
        "type": "<span class="strong"><strong>LineString</strong></span>",
        "coordinates": [
            <span class="strong"><strong>[-93.21692, 44.88055],</strong></span>
<span class="strong"><strong>            [-119.11903000000001, 46.26468]</strong></span>
        ]
    },
    "type": "Feature",
    "properties": {}
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note342"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode23.json</a>
</p></div></div><p>Assuming we can generate this GeoJSON payload from the shortest path, we may wonder how to pass it to the PixieDust Mapbox renderer so that it can be displayed. Well, the mechanism is pretty simple: the Mapbox renderer will introspect the host PixieApp for any class variable that conforms to a specific format and use it to generate the Mapbox layer to be displayed. To help with conforming with this mechanism, we use the <code class="literal">MapboxBase</code> utility class that we briefly introduced earlier. This class has a <code class="literal">get_layer_index()</code> method that takes a unique name (we use the <code class="literal">centrality</code> index) as an argument and returns its index. It also takes an extra optional argument that creates the layer in case it doesn't already exist. We then call the <code class="literal">toggleLayer()</code> method passing the layer index as an argument to turn the layer on and off.</p><p>The following code shows the implementation of the <code class="literal">compute_toggle_centrality_layer()</code> method that implements the aforementioned steps:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
def compute_toggle_centrality_layer(self, org_airport, dest_airport, centrality):
    cache.clear()
    cities = <span class="strong"><strong>nx.dijkstra_path</strong></span>(flight_graph, org_airport, dest_airport, weight=<span class="strong"><strong>compute_weight(centrality)</strong></span>)
    layer_index = <span class="strong"><strong>self.get_layer_index</strong></span>(centrality, {
        "name": centrality,
        "geojson": {
            "type": "FeatureCollection",
            "features":[
                {"type":"Feature",
                 "properties":{"route":"{} to {}".format(cities[i], cities[i+1])},
                 "geometry":{
                     "type":"LineString",
                     "coordinates":[
                         <span class="strong"><strong>self.get_airport_location(cities[i]),</strong></span>
<span class="strong"><strong>                         self.get_airport_location(cities[i+1])</strong></span>
                     ]
                 }
                } <span class="strong"><strong>for i in range(len(cities) - 1)</strong></span>
            ]
        },
        <span class="strong"><strong>"paint":{</strong></span>
<span class="strong"><strong>            "line-width": 8,</strong></span>
<span class="strong"><strong>            "line-color": self.centrality_indices[centrality]</strong></span>
<span class="strong"><strong>        }</strong></span>
    })
<span class="strong"><strong>    self.toggleLayer(layer_index)</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note343"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode24.py</a>
</p></div></div><p>The coordinates in the geometry object are computed using the <code class="literal">get_airport_location()</code> method that queries the <code class="literal">airports_centrality</code> DataFrame that we created in <span class="emphasis"><em>Part 1</em></span>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
def get_airport_location(self, airport_code):
    row = <span class="strong"><strong>airports_centrality.loc[airports["IATA_CODE"] == airport_code]</strong></span>
    if row is not None:
        return [row["LONGITUDE"].values[0], row["LATITUDE"].values[0]]
    return None</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note344"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode25.py</a>
</p></div></div><p>The layer object passed to the <code class="literal">get_layer_index()</code> method has the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: String that uniquely identifies the layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">geojson</code>: GeoJSON object that defines the features and geometry of the layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">url</code>: Used only if <code class="literal">geojson</code> is not present. Points at a URL that returns a GeoJSON payload.</li><li class="listitem" style="list-style-type: disc"><code class="literal">paint</code>: Optional extra <a id="id707" class="indexterm"/>properties specific to Mapbox specification that defines how the layer data is styled, for example, color, width, and opacity.</li><li class="listitem" style="list-style-type: disc"><code class="literal">layout</code>: Optional extra properties specific to Mapbox specification that defines how the layer data is drawn, for example, fill, visibility, and symbol.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note345"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: You can find more information about Mapbox layout and paint properties here:</p><p>
<a class="ulink" href="https://www.mapbox.com/mapbox-gl-js/style-spec/#layers">https://www.mapbox.com/mapbox-gl-js/style-spec/#layers</a>
</p></div></div><p>In the preceding code, we specify extra <code class="literal">paint</code> properties to configure the <code class="literal">line-width</code> and the <code class="literal">line-color</code> which we take from the <code class="literal">centrality_indices</code> JSON object defined in the <code class="literal">setup()</code> method.</p><p>The following output shows the shortest path for a flight from <code class="literal">BOS</code> to <code class="literal">PSC</code> using the <span class="strong"><strong>ELAPSED_TIME</strong></span> (in red) and the <span class="strong"><strong>DEGREE</strong></span> (in green) centrality indices:</p><div class="mediaobject"><img src="Images/B09699_09_21.jpg" alt="Part 2 – Creating the USFlightsAnalysis PixieApp" width="1000" height="570"/><div class="caption"><p>Displaying the shortest path from BOS to PSC using the ELAPSED_TIME and DEGREE centrality indices</p></div></div><p>In this section, we've built a PixieApp that provides visualization of the shortest path between two airports using the PixieDust <a id="id708" class="indexterm"/>Mapbox renderer. We've shown how to create a new layer to enrich the map with extra information using the <code class="literal">MapboxBase</code> utility class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note346"/>Note</h3><p>You can find the completed Notebook for <span class="emphasis"><em>Part 2</em></span> here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%202.ipynb</a>
</p></div></div><p>In the next section, we'll add additional data exploration related to flight delays and associated airlines.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp</h1></div></div></div><p>In this section, we want to extend the route analysis screen of the <code class="literal">USFlightsAnalysis</code> PixieApp to add two charts showing the historical arrival delay for each airline that flies out of the selected origin airport: one for all the flights coming out of the origin airport and one for all the <a id="id709" class="indexterm"/>flights regardless of airport. This will give us a way to compare visually whether the delay for a particular <a id="id710" class="indexterm"/>airport is better or worse than for all the other airports.</p><p>We start by implementing a method that selects the flights for a given airline. We also add an optional airport argument that can be used to control whether we include all flights or only the one that originates from this airport. The returned DataFrame should have two columns: <code class="literal">DATE</code> and <code class="literal">ARRIVAL_DELAY</code>.</p><p>The following code shows the implementation of this method:</p><div class="informalexample"><pre class="programlisting">def compute_delay_airline_df(<span class="strong"><strong>airline</strong></span>, <span class="strong"><strong>org_airport</strong></span>=None):
    # create a mask for selecting the data
    mask = (<span class="strong"><strong>flights["AIRLINE"] == airline</strong></span>)
    if org_airport is not None:
        # Add the org_airport to the mask
        mask = mask &amp; (<span class="strong"><strong>flights["ORIGIN_AIRPORT"] == org_airport</strong></span>)
    # Apply the mask to the Pandas dataframe
    df = flights[mask]
    # Convert the YEAR, MONTH and DAY column into a DateTime
    df["DATE"] = pd.to_datetime(flights[['YEAR','MONTH', 'DAY']])
    # Select only the columns that we need
    return df[["DATE", "ARRIVAL_DELAY"]]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note347"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode26.py</a>
</p></div></div><p>We can test the preceding code by using it with Delta flights from Boston. We can then call the PixieDust <code class="literal">display()</code> method to create a line chart that we'll use in the PixieApp:</p><div class="informalexample"><pre class="programlisting">bos_delay = compute_delay_airline_df(<span class="strong"><strong>"DL", "BOS"</strong></span>)
display(bos_delay)</pre></div><p>In the PixieDust output we select the <span class="strong"><strong>Line Chart</strong></span> menu and configure the options dialog as follows:</p><div class="mediaobject"><img src="Images/B09699_09_22.jpg" alt="Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp" width="1000" height="779"/><div class="caption"><p>The options dialog for generating an arrival delay line chart for Delta flights out of Boston</p></div></div><p>When clicking <span class="strong"><strong>OK</strong></span>, we get the following chart:</p><div class="mediaobject"><img src="Images/B09699_09_23.jpg" alt="Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp" width="1000" height="733"/><div class="caption"><p>Chart delay for all Delta flights coming out of Boston</p></div></div><p>As we are going to use this chart in the PixieApp, it is a good idea to copy the JSON configuration from the <span class="strong"><strong>Edit Cell Metadata</strong></span> dialog box:</p><div class="mediaobject"><img src="Images/B09699_09_24.jpg" alt="Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp" width="1000" height="607"/><div class="caption"><p>PixieDust display() configuration for the delay chart that needs to be copied for the PixieApp</p></div></div><p>Now that we know how to generate a delay chart, we can start designing the PixieApp. We start by changing the <a id="id711" class="indexterm"/>layout of the main screen to use the <code class="literal">TemplateTabbedApp</code> helper class that gives us the tabbed layout for free. The <a id="id712" class="indexterm"/>overall analysis screen is now driven by the <code class="literal">RouteAnalysisApp</code> child PixieApp that contains two tabs: the <code class="literal">Search Shortest Route</code> tab associated with the <code class="literal">SearchShortestRouteApp</code> child PixieApp and the <code class="literal">Explore Airlines</code> tab associated with the <code class="literal">AirlinesApp</code> child PixieApp.</p><p>The following diagram provides a high-level flow of all the classes involved in the new layout:</p><div class="mediaobject"><img src="Images/B09699_09_25.jpg" alt="Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp" width="1000" height="494"/><div class="caption"><p>New tabbed layout class diagram</p></div></div><p>The implementation for the <code class="literal">RouteAnalysisApp</code> is pretty straightforward using the <code class="literal">TemplateTabbedApp</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">from pixiedust.apps.template import TemplateTabbedApp

@PixieApp
class RouteAnalysisApp(TemplateTabbedApp):
    def setup(self):
        self.apps = [
            {"title": "Search Shortest Route",
             "app_class": "SearchShortestRouteApp"},
            {"title": "Explore Airlines",
             "app_class": "AirlinesApp"}
        ]
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note348"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode27.py</a>
</p></div></div><p>The <code class="literal">SearchShortestRouteApp</code> child PixieApp is basically a copy of the main PixieApp class we created in <span class="emphasis"><em>Part 2</em></span>. The only <a id="id713" class="indexterm"/>difference is <a id="id714" class="indexterm"/>that it is a child PixieApp of the <code class="literal">RouteAnalysisApp</code> which itself is a child PixieApp of the <code class="literal">USFlightsAnalysis</code> main PixieApp. Therefore, we need a mechanism for passing the origin and destination airport down to the respective child PixieApps. To achieve this, we use the <code class="literal">pd_options</code> attribute when instantiating the <code class="literal">RouteAnalysisApp</code> child PixieApp.</p><p>In the <code class="literal">USFlightAnalysis</code> class, we change the <code class="literal">analyze_route</code> method to return a simple <code class="literal">&lt;div&gt;</code> element that triggers the <code class="literal">RouteAnalysisApp</code>. We also add a <code class="literal">pd_options</code> attribute with the <code class="literal">org_airport</code> and <code class="literal">dest_airport</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[USFlightsAnalysis]]</strong></span>
@route(org_airport="*", dest_airport="*")
def analyze_route(self, org_airport, dest_airport):
    return """
&lt;div pd_app="<span class="strong"><strong>RouteAnalysisApp</strong></span>"
pd_options="<span class="strong"><strong>org_airport={{org_airport}};dest_airport={{dest_airport}}</strong></span>"
     pd_render_onload&gt;
&lt;/div&gt;
        """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note349"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode28.py</a>
</p></div></div><p>Conversely, in the <code class="literal">setup()</code> method of the <code class="literal">SearchShortestRouteApp</code> child PixieApp, we read <a id="id715" class="indexterm"/>the values for <code class="literal">org_airport</code> and <code class="literal">dest_airport</code> from the options dictionary of the <code class="literal">parent_pixieapp</code>, as shown in the <a id="id716" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[SearchShortestRouteApp]]</strong></span>
from pixiedust.display.app import *
from pixiedust.apps.mapboxBase import MapboxBase
from collections import OrderedDict

@PixieApp
class SearchShortestRouteApp(MapboxBase):
    def setup(self):
<span class="strong"><strong>        self.org_airport = self.parent_pixieapp.options.get("org_airport")</strong></span>
<span class="strong"><strong>        self.dest_airport = self.parent_pixieapp.options.get("dest_airport")</strong></span>
        self.centrality_indices = OrderedDict([
            ("ELAPSED_TIME","rgba(256,0,0,0.65)"),
            ("DEGREE", "rgba(0,256,0,0.65)"),
            ("PAGE_RANK", "rgba(0,0,256,0.65)"),
            ("CLOSENESS", "rgba(128,0,128,0.65)")
        ])
        ...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note350"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode29.py</a></p><p><span class="strong"><strong>Note</strong></span>: The rest of the implementation of the <code class="literal">SearchShortestRouteApp</code> has been ommitted for brevity since it's exactly the same as in <span class="emphasis"><em>Part 2</em></span>. To access the implementation, please refer to the completed <span class="emphasis"><em>Part 3</em></span> Notebook.</p></div></div><p>The last PixieApp class to implement is the <code class="literal">AirlinesApp</code>, which that will display all the delay charts. Similar to the <code class="literal">SearchShortestRouteApp</code>, we store <code class="literal">org_airport</code> and <code class="literal">dest_airport</code> from the <code class="literal">parent_pixieapp</code> options dictionary. We also compute a list of tuples (code and name) for <a id="id717" class="indexterm"/>all the airlines that have flights out of the given <code class="literal">org_airport</code>. To do that, we use the pandas <code class="literal">groupby()</code> method <a id="id718" class="indexterm"/>on the <code class="literal">AIRLINE</code> column and get a list of the index values as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[AirlinesApp]]</strong></span>
@PixieApp
class AirlinesApp():
    def setup(self):
        <span class="strong"><strong>self.org_airport = self.parent_pixieapp.options.get("org_airport")</strong></span>
<span class="strong"><strong>        self.dest_airport = self.parent_pixieapp.options.get("dest_airport")</strong></span>
        self.airlines = flights[flights["ORIGIN_AIRPORT"] == self.org_airport].<span class="strong"><strong>groupby("AIRLINE")</strong></span>.size().<span class="strong"><strong>index.values.tolist()</strong></span>
        self.airlines = [(a, <span class="strong"><strong>airlines.loc[airlines["IATA_CODE"] == a]["AIRLINE"].values[0]</strong></span>) for a in self.airlines]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note351"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode30.py</a>
</p></div></div><p>In the main screen of the <code class="literal">AirlinesApp</code>, we generate a set of rows for each of the airlines using the Jinja2 <code class="literal">{%for...%}</code> loop. In each row, we add two <code class="literal">&lt;div&gt;</code> elements that will hold the delay line chart for the given airline: one for flights coming out of the origin airport and one for all the flights for this airline. Each <code class="literal">&lt;div&gt;</code> element has a <code class="literal">pd_options attribute,</code> with the <code class="literal">org_airport</code> and <code class="literal">dest_airport</code> as state attributes, which triggers the <code class="literal">delay_airline_screen</code> route. We also add a <code class="literal">delay_org_airport</code> Boolean state attribute to denote which type of delay chart we want to display. To make sure the <code class="literal">&lt;div&gt;</code> element is rendered immediately, we add the <code class="literal">pd_render_onload</code> attribute as well.</p><p>The following code shows the implementation of the <code class="literal">AirlinesApp</code> default route:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[AirlinesApp]]</strong></span>
@route()
    def main_screen(self):
        return """
&lt;div class="container-fluid"&gt;
    {%<span class="strong"><strong>for airline_code, airline_name in this.airlines</strong></span>%}
    &lt;div class="row" style="max-e"&gt;
        &lt;h1 style="color:red"&gt;{{airline_name}}&lt;/h1&gt;
        &lt;div class="col-sm-6"&gt;
            &lt;div pd_render_onload pd_options="<span class="strong"><strong>delay_org_airport=true;airline_code={{airline_code}};airline_name={{airline_name}}</strong></span>"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-6"&gt;
            &lt;div pd_render_onload pd_options="<span class="strong"><strong>delay_org_airport=false;airline_code={{airline_code}};airline_name={{airline_name}}</strong></span>"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    {%<span class="strong"><strong>endfor</strong></span>%}
&lt;/div&gt;
        """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note352"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode31.py</a>
</p></div></div><p>The <code class="literal">delay_airline_screen()</code> route has three parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">delay_org_airport</code>: <code class="literal">true</code> if we only want the flights coming out of the origin airport, and <code class="literal">false</code> if we <a id="id719" class="indexterm"/>want all the flights for the given airline. We use this flag to build the mask for filtering <a id="id720" class="indexterm"/>the data out of the flights DataFrame.</li><li class="listitem" style="list-style-type: disc"><code class="literal">airline_code</code>: The IATA code for the given airline.</li><li class="listitem" style="list-style-type: disc"><code class="literal">airline_name</code>: The full name of the airline. We'll use this when building the UI in the Jinja2 template.</li></ul></div><p>In the body of the <code class="literal">delay_airline_screen()</code> method, we also compute the average delay for the selected data in the <code class="literal">average_delay</code> local variable. As a reminder, in order to use this variable in the Jinja2 template, we use the <code class="literal">@templateArgs</code> decorator, which automatically makes all local variables available in the Jinja2 template.</p><p>The <code class="literal">&lt;div&gt;</code> element that holds the chart has a <code class="literal">pd_entity</code> attribute that uses the <code class="literal">compute_delay_airline_df()</code> method that we created at the beginning of this section. However, we needed to rewrite this method as a member of the class since the arguments have <a id="id721" class="indexterm"/>changed: <code class="literal">org_airport</code> is now a class variable, and <code class="literal">delay_org_airport</code> is now a String Boolean. We also add a <code class="literal">&lt;pd_options&gt;</code> child <a id="id722" class="indexterm"/>element with the PixieDust <code class="literal">display()</code> JSON configuration that we copied from the <span class="strong"><strong>Edit Cell Metadata</strong></span> dialog.</p><p>The following code shows the implementation of the <code class="literal">delay_airline_screen()</code> route:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[AirlinesApp]]</strong></span>
@route(delay_org_airport="*",airline_code="*", airline_name="*")
    @templateArgs
    def <span class="strong"><strong>delay_airline_screen</strong></span>(self, delay_org_airport, airline_code, airline_name):
        mask = (flights["AIRLINE"] == airline_code)
        if delay_org_airport == "true":
            mask = mask &amp; (flights["ORIGIN_AIRPORT"] == self.org_airport)
        <span class="strong"><strong>average_delay = round(flights[mask]["ARRIVAL_DELAY"].mean(), 2)</strong></span>
        return """
{%if <span class="strong"><strong>delay_org_airport == "true"</strong></span> %}
&lt;h4&gt;Delay chart for all flights out of {{this.org_airport}}&lt;/h4&gt;
{%else%}
&lt;h4&gt;Delay chart for all flights&lt;/h4&gt;
{%endif%}
&lt;h4 style="margin-top:5px"&gt;Average delay: {{average_delay}} minutes&lt;/h4&gt;
&lt;div pd_render_onload pd_entity="<span class="strong"><strong>compute_delay_airline_df('{{airline_code}}', '{{delay_org_airport}}')</strong></span>"&gt;
    &lt;pd_options&gt;
    <span class="strong"><strong>{</strong></span>
<span class="strong"><strong>      "keyFields": "DATE",</strong></span>
<span class="strong"><strong>      "handlerId": "lineChart",</strong></span>
<span class="strong"><strong>      "valueFields": "ARRIVAL_DELAY",</strong></span>
<span class="strong"><strong>      "noChartCache": "true"</strong></span>
<span class="strong"><strong>    }</strong></span>
    &lt;/pd_options&gt;
&lt;/div&gt;
        """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note353"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode32.py</a>
</p></div></div><p>The <code class="literal">compute_delay_airline_df()</code> method has two arguments: airlines that correspond to the IATA code and the <code class="literal">delay_org_airport</code> String Boolean. We already covered <a id="id723" class="indexterm"/>implementation of this method, but the <a id="id724" class="indexterm"/>new adapted code is provided here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[AirlinesApp]]</strong></span>
def compute_delay_airline_df(self, airline, delay_org_airport):
        mask = (flights["AIRLINE"] == airline)
        if <span class="strong"><strong>delay_org_airport == "true"</strong></span>:
            mask = mask &amp; (flights["ORIGIN_AIRPORT"] == self.org_airport)
        df = flights[mask]
        df["DATE"] = <span class="strong"><strong>pd.to_datetime(flights[['YEAR','MONTH', 'DAY']])</strong></span>
        return <span class="strong"><strong>df[["DATE", "ARRIVAL_DELAY"]]</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note354"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode33.py</a>
</p></div></div><p>Running the <code class="literal">USFlightsAnalysis</code> PixieApp with BOS and PSC as the origin and destination airports respectively, we click on the <span class="strong"><strong>Explore Airlines</strong></span> tab.</p><p>The results are shown in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_09_26.jpg" alt="Part 3 – Adding data exploration to the USFlightsAnalysis PixieApp" width="558" height="689"/><div class="caption"><p>Delay line charts for all the airlines that provide services from Boston airport</p></div></div><p>In this section, we provide another example of how to use the PixieApp programming model to <a id="id725" class="indexterm"/>build powerful dashboards that provide visualization and insights into the output of the analytics developed <a id="id726" class="indexterm"/>in the Notebook.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note355"/>Note</h3><p>The completed Notebook for <span class="emphasis"><em>Part 3</em></span> of the <code class="literal">USFlightsAnalysis</code> PixieApp can be found here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%203.ipynb</a>
</p></div></div><p>In the next section, we'll build an ARIMA model that tries to predict flight delays.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Part 4 – Creating an ARIMA model for predicting flight delays"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Part 4 – Creating an ARIMA model for predicting flight delays</h1></div></div></div><p>In <a class="link" href="ch08.xhtml" title="Chapter 8. Analytics Study: Prediction - Financial Time Series Analysis and Forecasting">Chapter 8</a>, <span class="emphasis"><em>Analytics Study: Prediction - Financial Time Series Analysis and Forecasting</em></span>, we used time series analysis to build a forecasting model for predicting financial stocks. We can actually use the same <a id="id727" class="indexterm"/>technique in flight delays since, after all, we are also dealing here with time series, and so in this section, we'll follow the exact same steps. For each destination airport and optional airline, we'll build a pandas DataFrame that contains matching flight information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note356"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: We'll use the <code class="literal">statsmodels</code> library again. Make sure to install it if you haven't done so already and refer to <a class="link" href="ch08.xhtml" title="Chapter 8. Analytics Study: Prediction - Financial Time Series Analysis and Forecasting">Chapter 8</a>, <span class="emphasis"><em>Analytics Study: Prediction - Financial Time Series Analysis and Forecasting</em></span> for more information.</p></div></div><p>As an example, let's focus on all the Delta (<code class="literal">DL</code>) flights with <code class="literal">BOS</code> as the destination:</p><div class="informalexample"><pre class="programlisting">df = flights[(flights["AIRLINE"] == "DL") &amp; (flights["ORIGIN_AIRPORT"] == "BOS")]</pre></div><p>Using the <code class="literal">ARRIVAL_DELAY</code> column as a value for our time series, we plot the ACF and PACF plots to identify trends and seasonality as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import statsmodels.tsa.api as smt
<span class="strong"><strong>smt.graphics.plot_acf(df['ARRIVAL_DELAY'], lags=100)</strong></span>
plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note357"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode34.py</a>
</p></div></div><p>The result is shown in the following screenshot:</p><div class="mediaobject"><img src="Images/B09699_09_27.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="780" height="526"/><div class="caption"><p>Autocorrelation function for the ARRIVAL_DELAY data</p></div></div><p>Similarly, we also plot the partial autocorrelation function using the following code:</p><div class="informalexample"><pre class="programlisting">import statsmodels.tsa.api as smt
<span class="strong"><strong>smt.graphics.plot_pacf(df['ARRIVAL_DELAY'], lags=50)</strong></span>
plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note358"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode35.py</a>
</p></div></div><p>The results are shown here:</p><div class="mediaobject"><img src="Images/B09699_09_28.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="794" height="536"/><div class="caption"><p>Partial Autocorrelation for the ARRIVAL_DELAY data</p></div></div><p>From the preceding charts, we can hypothesize that the data has a trend and/or seasonality, and <a id="id728" class="indexterm"/>that it is not stationary. Using the log difference technique that we explained in <a class="link" href="ch08.xhtml" title="Chapter 8. Analytics Study: Prediction - Financial Time Series Analysis and Forecasting">Chapter 8</a>, <span class="emphasis"><em>Analytics Study: Prediction - Financial Time Series Analysis and Forecasting</em></span>, we transform the series and visualize it with the PixieDust <code class="literal">display()</code> method, as shown in the following code:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note359"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: We also make sure to remove the rows with NA and Infinite values by first calling the <code class="literal">replace()</code> method to replace <code class="literal">np.inf</code> and <code class="literal">-np.inf</code> with <code class="literal">np.nan</code>, and then call the <code class="literal">dropna()</code> method to remove all the rows with the <code class="literal">np.nan</code> value.</p></div></div><div class="informalexample"><pre class="programlisting">import numpy as np
<span class="strong"><strong>train_set, test_set = df[:-14], df[-14:]</strong></span>
train_set.index = train_set["DEPARTURE_TIME"]
test_set.index = test_set["DEPARTURE_TIME"]
<span class="strong"><strong>logdf = np.log(train_set['ARRIVAL_DELAY'])</strong></span>
logdf.index = train_set['DEPARTURE_TIME']
<span class="strong"><strong>logdf_diff = pd.DataFrame(logdf - logdf.shift()).reset_index()</strong></span>
<span class="strong"><strong>logdf_diff.replace([np.inf, -np.inf], np.nan, inplace=True)</strong></span>
<span class="strong"><strong>logdf_diff.dropna(inplace=True)</strong></span>
display(logdf_diff)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note360"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode36.py</a>
</p></div></div><p>The following screenshot shows the PixieDust option dialog:</p><div class="mediaobject"><img src="Images/B09699_09_29.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="1000" height="994"/><div class="caption"><p>Options dialog for the log difference of the ARRIVAL_DELAY data</p></div></div><p>After clicking <span class="strong"><strong>OK</strong></span>, we get the following results:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note361"/>Note</h3><p>
<span class="strong"><strong>Note</strong></span>: When running the preceding code, you may not get the exact same chart as shown in the following screenshot. This is because we configure the <span class="strong"><strong># of Rows to Display</strong></span> in the options dialog to be <code class="literal">100</code> which means that PixieDust will take a sample of size 100 before creating the chart.</p></div></div><div class="mediaobject"><img src="Images/B09699_09_30.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="1000" height="700"/><div class="caption"><p>Log difference line chart of the ARRIVAL_DELAY data</p></div></div><p>The preceding <a id="id729" class="indexterm"/>chart looks stationary; we can reinforce this hypothesis by plotting the ACF and PACF again on the log difference as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>smt.graphics.plot_acf(logdf_diff["ARRIVAL_DELAY"], lags=100)</strong></span>
plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note362"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode37.py</a>
</p></div></div><p>The results are as follows:</p><div class="mediaobject"><img src="Images/B09699_09_31.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="684" height="486"/><div class="caption"><p>ACF chart for the log difference of the ARRIVAL_DELAY data</p></div></div><p>In the following code, we do the same thing for the PACF:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>smt.graphics.plot_pacf(logdf_diff["ARRIVAL_DELAY"], lags=100)</strong></span>
plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note363"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode38.py</a>
</p></div></div><p>The results are as follows:</p><div class="mediaobject"><img src="Images/B09699_09_32.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="696" height="480"/><div class="caption"><p>PACF chart for the log difference of the ARRIVAL_DELAY data</p></div></div><p>As a reminder from <a class="link" href="ch08.xhtml" title="Chapter 8. Analytics Study: Prediction - Financial Time Series Analysis and Forecasting">Chapter 8</a>, <span class="emphasis"><em>Analytics Study: Prediction - Financial Time Series Analysis and Forecasting</em></span>, an ARIMA model <a id="id730" class="indexterm"/>is composed of three orders: <span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>d</em></span>, and <span class="emphasis"><em>q</em></span>. From the preceding two charts, we can infer these orders for the ARIMA model we want to build:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Autoregression order p is 1</strong></span>: Corresponds to the first time the ACF crosses the significance level</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Integration order d is 1</strong></span>: We had to do a log difference once</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Moving average order q is 1</strong></span>: Corresponds to the first time the PACF crosses the significance level</li></ul></div><p>Based on these hypotheses, we can build an ARIMA model using the <code class="literal">statsmodels</code> package and get information about its residual error, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">from statsmodels.tsa.arima_model import ARIMA

import warnings
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    arima_model_class = ARIMA(<span class="strong"><strong>train_set['ARRIVAL_DELAY']</strong></span>,
                              dates=<span class="strong"><strong>train_set['DEPARTURE_TIME']</strong></span>,
                              order=<span class="strong"><strong>(1,1,1)</strong></span>)
    arima_model = arima_model_class.fit(disp=0)
    print(<span class="strong"><strong>arima_model.resid.describe()</strong></span>)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note364"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode39.py</a>
</p></div></div><p>The results are shown as follows:</p><div class="informalexample"><pre class="programlisting">count    13882.000000
<span class="strong"><strong>mean         0.003116</strong></span>
std         48.932043
min       -235.439689
25%        -17.446822
50%         -5.902274
75%          6.746263
max       1035.104295
dtype: float64</pre></div><p>As we can see, the <a id="id731" class="indexterm"/>mean error is only 0.003 which is pretty good, so we're ready to run the model with values from the <code class="literal">train_set</code> and visualize the discrepencies with the actual values.</p><p>The following code uses the ARIMA <code class="literal">plot_predict()</code> method to create the chart:</p><div class="informalexample"><pre class="programlisting">def plot_predict(model, dates_series, num_observations):
    fig,ax = plt.subplots(figsize = (12,8))
    model.plot_predict(
        start = <span class="strong"><strong>dates_series[len(dates_series)-num_observations]</strong></span>,
        end = <span class="strong"><strong>dates_series[len(dates_series)-1]</strong></span>,
        ax = ax
    )
    plt.show()
plot_predict(arima_model, <span class="strong"><strong>train_set['DEPARTURE_TIME']</strong></span>, <span class="strong"><strong>100</strong></span>)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note365"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode40.py</a>
</p></div></div><p>The results are shown as follows:</p><div class="mediaobject"><img src="Images/B09699_09_33.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="1000" height="649"/><div class="caption"><p>Forecast versus actual</p></div></div><p>In the preceding chart, we can clearly see that the forecast line is much smoother than the actual values. This <a id="id732" class="indexterm"/>makes sense since, in reality, there are always unexpected reasons for delays that can be treated as outliers and therefore hard to model.</p><p>We still need to use the <code class="literal">test_set</code> to validate the model with data not yet seen by the model. The following code creates a <code class="literal">compute_test_set_predictions()</code> method to compare forecast and test data and visualize the results using the PixieDust <code class="literal">display()</code> method:</p><div class="informalexample"><pre class="programlisting">def compute_test_set_predictions(train_set, test_set):
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        history = <span class="strong"><strong>train_set['ARRIVAL_DELAY'].values</strong></span>
        forecast = np.array([])
        for t in range(len(test_set)):
            prediction = <span class="strong"><strong>ARIMA(history, order=(1,1,0)).fit(disp=0).forecast()</strong></span>
            history = np.append(history, test_set['ARRIVAL_DELAY'].iloc[t])
            forecast = np.append(forecast, prediction[0])
        return pd.DataFrame(
          <span class="strong"><strong>{"forecast": forecast,</strong></span>
<span class="strong"><strong>           "test": test_set['ARRIVAL_DELAY'],</strong></span>
<span class="strong"><strong>           "Date": pd.date_range(start=test_set['DEPARTURE_TIME'].iloc[len(test_set)-1], periods = len(test_set))</strong></span>
<span class="strong"><strong>          }</strong></span>
        )

results = <span class="strong"><strong>compute_test_set_predictions(train_set, test_set)</strong></span>
display(results)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note366"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode41.py</a>
</p></div></div><p>The PixieDust options dialog is shown here:</p><div class="mediaobject"><img src="Images/B09699_09_34.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="1000" height="879"/><div class="caption"><p>Options dialog for the forecast versus test comparison line chart</p></div></div><p>After clicking <span class="strong"><strong>OK</strong></span>, we get the following results:</p><div class="mediaobject"><img src="Images/B09699_09_35.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="1000" height="693"/><div class="caption"><p>Forecast versus Test Data line chart</p></div></div><p>We are now ready to integrate this model into our <code class="literal">USFlightsAnalysis</code> PixieApp, by adding a third tab to the <code class="literal">RouteAnalysisApp</code> main screen called <code class="literal">Flight Delay Prediction</code>. This tab will be driven by a new child PixieApp called <code class="literal">PredictDelayApp</code> that will let the user <a id="id733" class="indexterm"/>select a flight segment of the shortest path computed using the Dijkstra shortest path algorithm with <code class="literal">DEGREE</code> as the centrality index. The user will also be able to select an airline, in which case the training data will be limited to flights operated by the selected airline.</p><p>In the following code, we create the <code class="literal">PredictDelayApp</code> child PixieApp and implement the <code class="literal">setup()</code> method that computes the Dijkstra shortest path for the selected origin and destination airports:</p><div class="informalexample"><pre class="programlisting">[[PredictDelayApp]]
import warnings
import numpy as np
from statsmodels.tsa.arima_model import ARIMA

@PixieApp
class PredictDelayApp():
    def setup(self):
        self.org_airport = self.parent_pixieapp.options.get("org_airport")
        self.dest_airport = self.parent_pixieapp.options.get("dest_airport")
        self.airlines = flights[flights["ORIGIN_AIRPORT"] == self.org_airport].groupby("AIRLINE").size().index.values.tolist()
        self.airlines = [(a, airlines.loc[airlines["IATA_CODE"] == a]["AIRLINE"].values[0]) for a in self.airlines]
        path = nx.dijkstra_path(flight_graph, self.org_airport, self.dest_airport, weight=compute_weight("DEGREE"))
        self.paths = [(path[i], path[i+1]) for i in range(len(path) - 1)]</pre></div><p>In the default route of the <code class="literal">PredictDelayApp</code>, we use the Jinja2 <code class="literal">{%for..%}</code> loop to build two drop-down boxes that display the flight segment and the airlines, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">[[PredictDelayApp]]
@route()
    def main_screen(self):
        return """
&lt;div class="container-fluid"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-sm-6"&gt;
            &lt;div class="rendererOpt" style="font-weight:bold"&gt;
                Select a flight segment:
            &lt;/div&gt;
            &lt;div&gt;
                &lt;select id="segment{{prefix}}" <span class="strong"><strong>pd_refresh="prediction_graph{{prefix}}"</strong></span>&gt;
                    &lt;option value="" selected&gt;&lt;/option&gt;
                    <span class="strong"><strong>{%for start, end in this.paths %}</strong></span>
<span class="strong"><strong>                    &lt;option value="{{start}}:{{end}}"&gt;{{start}} -&gt; {{end}}&lt;/option&gt;</strong></span>
<span class="strong"><strong>                    {%endfor%}</strong></span>
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-6"&gt;
            &lt;div class="rendererOpt" style="font-weight:bold"&gt;
                Select an airline:
            &lt;/div&gt;
            &lt;div&gt;
                &lt;select id="airline{{prefix}}" <span class="strong"><strong>pd_refresh="prediction_graph{{prefix}}"</strong></span>&gt;
                    &lt;option value="" selected&gt;&lt;/option&gt;
                    <span class="strong"><strong>{%for airline_code, airline_name in this.airlines%}</strong></span>
<span class="strong"><strong>                    &lt;option value="{{airline_code}}"&gt;{{airline_name}}&lt;/option&gt;</strong></span>
<span class="strong"><strong>                    {%endfor%}</strong></span>
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-sm-12"&gt;
            &lt;div id="prediction_graph{{prefix}}"
                <span class="strong"><strong>pd_options="flight_segment=$val(segment{{prefix}});airline=$val(airline{{prefix}})"</strong></span>&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
        """</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note367"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode42.py</a>
</p></div></div><p>The two drop-downs have a <code class="literal">pd_refresh</code> attribute that points to the <code class="literal">&lt;div&gt;</code> element with ID <code class="literal">prediction_graph{{prefix}}</code>. When triggered, this <code class="literal">&lt;div&gt;</code> element invokes the <code class="literal">predict_screen()</code> route using the <code class="literal">flight_segment</code> and <code class="literal">airline</code> state attributes.</p><p>In the <code class="literal">predict_screen()</code> route, we use the <code class="literal">flight_segment</code> and <code class="literal">airline</code> arguments to create the <a id="id734" class="indexterm"/>training dataset, build an ARIMA model that forecasts the model, and visualize the results in a line chart that compares the forecast and the actual values.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note368"/>Note</h3><p>Time series forecast models are limited to predictions that are close to the actual data, and since we only have data from 2015, we can't really use this model to predict more recent data. Of course, in a production application, it is assumed that we have flight data that is current and therefore this wouldn't be a problem.</p></div></div><p>The following code shows the implementation of the <code class="literal">predict_screen()</code> route:</p><div class="informalexample"><pre class="programlisting">[[PredictDelayApp]]
@route(flight_segment="*", airline="*")
<span class="strong"><strong>    @captureOutput</strong></span>
    def predict_screen(self, flight_segment, airline):
        if flight_segment is None or flight_segment == "":
            return "&lt;div&gt;Please select a flight segment&lt;/div&gt;"
<span class="strong"><strong>        airport = flight_segment.split(":")[1]</strong></span>
<span class="strong"><strong>        mask = (flights["DESTINATION_AIRPORT"] == airport)</strong></span>
        if airline is not None and airline != "":
<span class="strong"><strong>            mask = mask &amp; (flights["AIRLINE"] == airline)</strong></span>
        df = flights[mask]
        df.index = df["DEPARTURE_TIME"]
        df = df.tail(50000)
<span class="strong"><strong>        df = df[~df.index.duplicated(keep='first')]</strong></span>
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            arima_model_class = <span class="strong"><strong>ARIMA(df["ARRIVAL_DELAY"], dates=df['DEPARTURE_TIME'], order=(1,1,1))</strong></span>
            arima_model = <span class="strong"><strong>arima_model_class.fit(disp=0)</strong></span>
            fig, ax = plt.subplots(figsize = (12,8))
            num_observations = 100
            date_series = df["DEPARTURE_TIME"]
<span class="strong"><strong>            arima_model.plot_predict(</strong></span>
<span class="strong"><strong>                start = str(date_series[len(date_series)-num_observations]),</strong></span>
<span class="strong"><strong>                end = str(date_series[len(date_series)-1]),</strong></span>
<span class="strong"><strong>                ax = ax</strong></span>
<span class="strong"><strong>            )</strong></span>
            plt.show()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note369"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode43.py</a>
</p></div></div><p>In the following <a id="id735" class="indexterm"/>code, we also wanted to make sure that the dataset index is deduplicated to avoid errors when plotting the results. This is done by filtering the duplicated indices using <code class="literal">df = df[~df.index.duplicated(keep='first')]</code>.</p><p>The last thing left to do is to wire the <code class="literal">PredictDelayApp</code> child PixieApp to the <code class="literal">RouteAnalysisApp</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">from pixiedust.apps.template import TemplateTabbedApp

@PixieApp
class RouteAnalysisApp(TemplateTabbedApp):
    def setup(self):
        self.apps = [
            {"title": "Search Shortest Route",
             "app_class": "SearchShortestRouteApp"},
            {"title": "Explore Airlines",
             "app_class": "AirlinesApp"},
            <span class="strong"><strong>{"title": "Flight Delay Prediction",</strong></span>
<span class="strong"><strong>              "app_class": "PredictDelayApp"}</strong></span>
        ]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note370"/>Note</h3><p>You can find the code file here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/sampleCode44.py</a>
</p></div></div><p>When we run the <code class="literal">USFlightsAnalysis</code> PixieApp using BOS and PSC as we did in the previous sections. In the <span class="strong"><strong>Flight Delay Prediction</strong></span> tab, we select the <span class="strong"><strong>BOS-&gt;DEN</strong></span> flight segment.</p><p>The results are shown as follows:</p><div class="mediaobject"><img src="Images/B09699_09_36.jpg" alt="Part 4 – Creating an ARIMA model for predicting flight delays" width="1000" height="780"/><div class="caption"><p>Forecast for the Boston to Denver flight segment</p></div></div><p>In this section, we've shown how to use time series forecasting models to predict flight delays based on historical data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note371"/>Note</h3><p>You can find the complete Notebook here:</p><p>
<a class="ulink" href="https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb">https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%209/USFlightsAnalysis/US%20Flight%20data%20analysis%20-%20Part%204.ipynb</a>
</p></div></div><p>As a reminder, while <a id="id736" class="indexterm"/>this is only a sample application which has a lot of room for improvement, the techniques for operationalizing data analytics using the PixieApp programming model would apply just the same in any other project.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, we've discussed graphs and its associated graph theory, exploring its data structure and algorithms. We've also briefly introduced the <code class="literal">networkx</code> Python library that provides a rich set of APIs for manipulating and visualizing graphs. We then applied these techniques toward building a sample application that analyzes flight data by treating it as a graph problem with airports being the vertices and flights the edges. As always, we've also shown how to operationalize these analytics into a simple yet powerful dashboard that can run directly in the Jupyter Notebook and then optionally be deployed as a web analytics application with the PixieGateway microservice.</p><p>This chapter completes the series of sample applications that cover many important industry use cases. In the next chapter, I offer some final thoughts about the theme of this book which is to bridge the gap between data science and engineering by making working with data simple and accessible to all. </p></div></div>



  </body></html>