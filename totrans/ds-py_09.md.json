["```py\n!pip install networkx\n\n```", "```py\nimport networkx as nx\n```", "```py\n    G = nx.Graph()\n    ```", "```py\n    G = nx.DiGraph()\n    ```", "```py\n    G = nx.MultiGraph()\n    ```", "```py\n    G = nx.MultiDiGraph()\n    ```", "```py\nG = nx.DiGraph()\nG.add_nodes_from(['A', 'B', 'C', 'D', 'E'])\nG.add_edge('A', 'B')\nG.add_edge('B', 'B')\nG.add_edges_from([('A', 'E'),('A', 'D'),('B', 'C'),('C', 'E'),('D', 'C')])\n```", "```py\nfor n in G.nodes:\n    print(n)\n```", "```py\nG_complete = nx.complete_graph(10)\n```", "```py\n%matplotlib inline\nimport matplotlib.pyplot as plt\nnx.draw(G_complete, with_labels=True)\nplt.show()\n```", "```py\nimport pixiedust\nimport networkx as nx\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```", "```py\nimport pandas as pd\nimport datetime\nimport numpy as np\n\n# clean up the flights data in flights.csv\nflights = pd.read_csv('flights.raw.csv', low_memory=False)\n\n# select only the rows that have a 3 letter IATA code in the ORIGIN and DESTINATION airports\nmask = (flights[\"ORIGIN_AIRPORT\"].str.len() == 3) & (flights[\"DESTINATION_AIRPORT\"].str.len() == 3)\nflights = flights[ mask ]\n\n# remove the unwanted columns\ndropped_columns=[\"SCHEDULED_DEPARTURE\",\"SCHEDULED_TIME\",\n\"CANCELLATION_REASON\",\"DIVERTED\",\"DIVERTED\",\"TAIL_NUMBER\",\n\"TAXI_OUT\",\"WHEELS_OFF\",\"WHEELS_ON\",\n\"TAXI_IN\",\"SCHEDULED_ARRIVAL\", \"ARRIVAL_TIME\", \"AIR_SYSTEM_DELAY\",\"SECURITY_DELAY\",\n\"AIRLINE_DELAY\",\"LATE_AIRCRAFT_DELAY\", \"WEATHER_DELAY\"]\nflights.drop(dropped_columns, axis=1, inplace=True)\n\n# remove the row that have NA in the ELAPSED_TIME column\nflights.dropna(subset=[\"ELAPSED_TIME\"], inplace=True)\n\n# remove the row that have NA in the DEPARTURE_TIME column\nflights.dropna(subset=[\"ELAPSED_TIME\"], inplace=True)\n\n# Create a new DEPARTURE_TIME columns that has the actual datetime\ndef to_datetime(row):\n    departure_time = str(int(row[\"DEPARTURE_TIME\"])).zfill(4)\n    hour = int(departure_time[0:2])\n    return datetime.datetime(year=row[\"YEAR\"], month=row[\"MONTH\"],\n                             day=row[\"DAY\"],\n                             hour = 0 if hour >= 24 else hour,\n                             minute=int(departure_time[2:4])\n                            )\nflights[\"DEPARTURE_TIME\"] = flights.apply(to_datetime, axis=1)\n\n# write the data back to file without the index\nflights.to_csv('flights.csv', index=False)\n\n```", "```py\nairports = pixiedust.sampleData(\"https://github.com/DTAIEB/Thoughtful-Data-Science/raw/master/chapter%209/USFlightsAnalysis/airports.csv\")\nairlines = pixiedust.sampleData(\"https://github.com/DTAIEB/Thoughtful-Data-Science/raw/master/chapter%209/USFlightsAnalysis/airlines.csv\")\nflights = pixiedust.sampleData(\"https://github.com/DTAIEB/Thoughtful-Data-Science/raw/master/chapter%209/USFlightsAnalysis/flights.zip\")\n```", "```py\nedges = flights.groupby([\"ORIGIN_AIRPORT\",\"DESTINATION_AIRPORT\"]) [[\"ELAPSED_TIME\"]].mean()\nedges\n```", "```py\nedges = edges.reset_index()\nedges\n```", "```py\nflight_graph = nx.from_pandas_edgelist(\n    flights, \"ORIGIN_AIRPORT\",\"DESTINATION_AIRPORT\",\n    \"ELAPSED_TIME\",\n    create_using = nx.DiGraph() )\n```", "```py\nprint(\"Nodes: {}\".format(flight_graph.nodes))\nprint(\"Edges: {}\".format(flight_graph.edges))\n```", "```py\nNodes: ['BOS', 'TYS', 'RKS', 'AMA', 'BUF', 'BHM', 'PPG', …, 'CWA', 'DAL', 'BFL']\nEdges: [('BOS', 'LAX'), ('BOS', 'SJC'), ..., ('BFL', 'SFO'), ('BFL', 'IAH')]\n```", "```py\nimport matplotlib.cm as cm\nfig = plt.figure(figsize = (12,12))\nnx.draw(flight_graph, arrows=True, with_labels=True,\n        width = 0.5,style=\"dotted\",\n        node_color=range(len(flight_graph)),\n        cmap=cm.get_cmap(name=\"cool\"),\n        edge_color=range(len(flight_graph.edges)),\n        edge_cmap=cm.get_cmap(name=\"spring\")\n       )\nplt.show()\n```", "```py\nimport matplotlib.cm as cm\nfig = plt.figure(figsize = (12,12))\nnx.draw(flight_graph, arrows=True, with_labels=True,\n        width = 0.5,style=\"dotted\",\n        node_color=range(len(flight_graph)),\n        cmap=cm.get_cmap(name=\"cool\"),\n        edge_color=range(len(flight_graph.edges)),\n        edge_cmap=cm.get_cmap(name=\"spring\"),\n        pos = nx.random_layout(flight_graph)\n       )\nplt.show()\n\n```", "```py\nprint(flight_graph.degree)\n```", "```py\n[('BMI', 14), ('RDM', 8), ('SBN', 13), ('PNS', 18), ………, ('JAC', 26), ('MEM', 46)]\n```", "```py\ndegree_df = pd.DataFrame([{\"IATA_CODE\":k, \"DEGREE\":v} for k,v in flight_graph.degree], columns=[\"IATA_CODE\", \"DEGREE\"])\nairports_centrality = pd.merge(airports, degree_df, on='IATA_CODE')\nairports_centrality\n```", "```py\ndisplay(airports_centrality)\n```", "```py\nnx.pagerank(flight_graph)\n```", "```py\n{'ABE': 0.0011522441195896051,\n 'ABI': 0.0006671948649909588,\n ...\n 'YAK': 0.001558809391270303,\n 'YUM': 0.0006214341604372096}\n```", "```py\nfrom six import iteritems\ndef compute_centrality(g, centrality_df, compute_fn, col_name, *args, **kwargs):\n    # create a temporary DataFrame that contains the computed centrality values\n    temp_df = pd.DataFrame(\n        [{\"IATA_CODE\":k, col_name:v} for k,v in iteritems(compute_fn(g, *args, **kwargs))],\n        columns=[\"IATA_CODE\", col_name]\n    )\n    # make sure to remove the col_name from the centrality_df is already there\n    if col_name in centrality_df.columns:\n        centrality_df.drop([col_name], axis=1, inplace=True)\n    # merge the 2 DataFrame on the IATA_CODE column\n    centrality_df = pd.merge(centrality_df, temp_df, on='IATA_CODE')\n    return centrality_df\n\n```", "```py\nairports_centrality = compute_centrality(flight_graph, airports_centrality, nx.pagerank, \"PAGE_RANK\")\nairports_centrality = compute_centrality(flight_graph, airports_centrality, nx.closeness_centrality, \"CLOSENESS\")\nairports_centrality = compute_centrality(\n    flight_graph, airports_centrality, nx.betweenness_centrality, \"BETWEENNESS\", k=len(flight_graph))\nairports_centrality\n```", "```py\nfor col_name in [\"DEGREE\", \"PAGE_RANK\", \"CLOSENESS\", \"BETWEENNESS\"]:\n    print(\"{} : {}\".format(\n        col_name,\n        airports_centrality.nlargest(10, col_name)[\"IATA_CODE\"].values)\n    )\n```", "```py\nDEGREE : ['ATL' 'ORD' 'DFW' 'DEN' 'MSP' 'IAH' 'DTW' 'SLC' 'EWR' 'LAX']\nPAGE_RANK : ['ATL' 'ORD' 'DFW' 'DEN' 'MSP' 'IAH' 'DTW' 'SLC' 'SFO' 'LAX']\nCLOSENESS : ['ATL' 'ORD' 'DFW' 'DEN' 'MSP' 'IAH' 'DTW' 'SLC' 'EWR' 'LAX']\nBETWEENNESS : ['ATL' 'DFW' 'ORD' 'DEN' 'MSP' 'SLC' 'DTW' 'ANC' 'IAH' 'SFO']\n```", "```py\nimport matplotlib.cm as cm\ndef visualize_neighbors(parent_node):\n    fig = plt.figure(figsize = (12,12))\n    # Create a subgraph and add an edge from the parent node to all its neighbors\n    graph = nx.DiGraph()\n    for neighbor in flight_graph.neighbors(parent_node):\n        graph.add_edge(parent_node, neighbor)\n    # draw the subgraph\n    nx.draw(graph, arrows=True, with_labels=True,\n            width = 0.5,style=\"dotted\",\n            node_color=range(len(graph)),\n            cmap=cm.get_cmap(name=\"cool\"),\n            edge_color=range(len(graph.edges)),\n            edge_cmap=cm.get_cmap(name=\"spring\"),\n           )\n    plt.show()\n```", "```py\nvisualize_neighbors(\"ATL\")\n```", "```py\nnx.dijkstra_path(flight_graph, \"BOS\", \"PSC\", weight=\"ELAPSED_TIME\")\n```", "```py\n['BOS', 'MSP', 'PSC']\n```", "```py\n# use a cache so we don't recompute the weight for the same airport every time\ncache = {}\ndef compute_weight(centrality_indice_col):\n    # wrapper function that conform to the dijkstra weight argument\n    def wrapper(source, target, attribute):\n        # try the cache first and compute the weight if not there\n        source_weight = cache.get(source, None)\n        if source_weight is None:\n            # look up the airports_centrality for the value\n            source_weight = airports_centrality.loc[airports_centrality[\"IATA_CODE\"] == source][centrality_indice_col].values[0]\n            cache[source] = source_weight\n        target_weight = cache.get(target, None)\n        if target_weight is None:\n            target_weight = airports_centrality.loc[airports_centrality[\"IATA_CODE\"] == target][centrality_indice_col].values[0]\n            cache[target] = target_weight\n        # Return weight is inversely proportional to the computed weighted since\n        # the Dijkstra algorithm give precedence to shorter distances\n        return float(1/source_weight) + float(1/target_weight)\n    return wrapper\n```", "```py\nfor col_name in [\"DEGREE\", \"PAGE_RANK\", \"CLOSENESS\"]:\n    #clear the cache\n    cache.clear()\n    print(\"{} : {}\".format(\n        col_name,\n        nx.dijkstra_path(flight_graph, \"BOS\", \"PSC\",\n                         weight=compute_weight(col_name))\n    ))\n```", "```py\nDEGREE : ['BOS', 'DEN', 'PSC']\nPAGE_RANK : ['BOS', 'DEN', 'PSC']\nCLOSENESS : ['BOS', 'DEN', 'PSC']\n```", "```py\n[[USFlightsAnalysis]]\nfrom pixiedust.display.app import *\nfrom pixiedust.apps.mapboxBase import MapboxBase\nfrom collections import OrderedDict\n\n@PixieApp\nclass USFlightsAnalysis(MapboxBase):\n    ...\n    @route()\n    def main_screen(self):\n        return \"\"\"\n<style>\n    div.outer-wrapper {\n        display: table;width:100%;height:300px;\n    }\n    div.inner-wrapper {\n        display: table-cell;vertical-align: middle;height: 100%;width: 100%;\n    }\n</style>\n<div class=\"outer-wrapper\">\n    <div class=\"inner-wrapper\">\n        <div class=\"col-sm-6\">\n            <div class=\"rendererOpt\" style=\"font-weight:bold\">\n                 Select origin airport:\n            </div>\n            <div>\n                <select id=\"origin_airport{{prefix}}\"\n                        pd_refresh=\"origin_graph{{prefix}}\">\n                    <option value=\"\" selected></option>\n                    {%for code, airport in this.get_airports() %}\n <option value=\"{{code}}\">{{code}} - {{airport}}</option>\n {%endfor%}\n                </select>\n            </div>\n            <div id=\"origin_graph{{prefix}}\" pd_options=\"visualize_graph=$val(origin_airport{{prefix}})\"></div>\n        </div>\n        <div class=\"input-group col-sm-6\">\n            <div class=\"rendererOpt\" style=\"font-weight:bold\">\n                 Select destination airport:\n            </div>\n            <div>\n                <select id=\"destination_airport{{prefix}}\"\n                        pd_refresh=\"destination_graph{{prefix}}\">\n                    <option value=\"\" selected></option>\n                    {%for code, airport in this.get_airports() %}\n <option value=\"{{code}}\">{{code}} - {{airport}}</option>\n {%endfor%}\n                </select>\n            </div>\n            <div id=\"destination_graph{{prefix}}\"\npd_options=\"visualize_graph=$val(destination_airport{{prefix}})\">\n            </div>\n        </div>\n    </div>\n</div>\n<div style=\"text-align:center\">\n    <button class=\"btn btn-default\" type=\"button\"\npd_options=\"org_airport=$val(origin_airport{{prefix}});dest_airport=$val(destination_airport{{prefix}})\">\n        <pd_script type=\"preRun\">\n            if ($(\"#origin_airport{{prefix}}\").val() == \"\" || $(\"#destination_airport{{prefix}}\").val() == \"\"){\n                alert(\"Please select an origin and destination airport\");\n                return false;\n            }\n            return true;\n        </pd_script>\n        Analyze\n    </button>\n</div>\n\"\"\"\n\ndef get_airports(self):\n    return [tuple(l) for l in airports_centrality[[\"IATA_CODE\", \"AIRPORT\"]].values.tolist()]\n\n```", "```py\n[[USFlightsAnalysis]]\n@route(visualize_graph=\"*\")\n@captureOutput\ndef visualize_graph_screen(self, visualize_graph):\n    visualize_neighbors(visualize_graph, (5,5))\n```", "```py\n<button class=\"btn btn-default\" type=\"button\" pd_options=\"org_airport=$val(origin_airport{{prefix}});dest_airport=$val(destination_airport{{prefix}})\">\n   <pd_script type=\"preRun\">\n if ($(\"#origin_airport{{prefix}}\").val() == \"\" || $(\"#destination_airport{{prefix}}\").val() == \"\"){\n alert(\"Please select an origin and destination airport\");\n return false;\n }\n return true;\n   </pd_script>\n      Analyze\n   </button>\n```", "```py\n[[USFlightsAnalysis]]\n@route(org_airport=\"*\", dest_airport=\"*\")\ndef compute_path_screen(self, org_airport, dest_airport):\n    return \"\"\"\n<div class=\"container-fluid\">\n    <div class=\"form-group col-sm-2\" style=\"padding-right:10px;\">\n        <div><strong>Centrality Indices</strong></div>\n {% for centrality in this.centrality_indices.keys() %}\n        <div class=\"rendererOpt checkbox checkbox-primary\">\n            <input type=\"checkbox\"\n                   pd_refresh=\"flight_map{{prefix}}\"\npd_script=\"self.compute_toggle_centrality_layer('{{org_airport}}', '{{dest_airport}}', '{{centrality}}')\">\n            <label>{{centrality}}</label>\n        </div>\n {%endfor%}\n    </div>\n    <div class=\"form-group col-sm-10\">\n        <h1 class=\"rendererOpt\">Select a centrality index to show the shortest flight path\n        </h1>\n        <div id=\"flight_map{{prefix}}\" pd_entity=\"self.airports_centrality\" pd_render_onload>\n            <pd_options>\n {\n \"keyFields\": \"LATITUDE,LONGITUDE\",\n \"valueFields\": \"AIRPORT,DEGREE,PAGE_RANK,ELAPSED_TIME,CLOSENESS\",\n \"custombasecolorsecondary\": \"#fffb00\",\n \"colorrampname\": \"Light to Dark Red\",\n \"handlerId\": \"mapView\",\n \"quantiles\": \"0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0\",\n \"kind\": \"choropleth\",\n \"rowCount\": \"1000\",\n \"numbins\": \"5\",\n \"mapboxtoken\": \"pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4M29iazA2Z2gycXA4N2pmbDZmangifQ.-g_vE53SD2WrJ6tFX7QHmA\",\n \"custombasecolor\": \"#ffffff\"\n }\n            </pd_options>\n        </div>\n    </div>\n</div>\n\"\"\"\n```", "```py\n[[USFlightsAnalysis]]\ndef setup(self):\n   self.centrality_indices = OrderedDict([\n      (\"ELAPSED_TIME\",\"rgba(256,0,0,0.65)\"),\n      (\"DEGREE\", \"rgba(0,256,0,0.65)\"),\n      (\"PAGE_RANK\", \"rgba(0,0,256,0.65)\"),\n      (\"CLOSENESS\", \"rgba(128,0,128,0.65)\")\n  ])\n```", "```py\n{\n    \"geometry\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n            [-93.21692, 44.88055],\n [-119.11903000000001, 46.26468]\n        ]\n    },\n    \"type\": \"Feature\",\n    \"properties\": {}\n}\n```", "```py\n[[USFlightsAnalysis]]\ndef compute_toggle_centrality_layer(self, org_airport, dest_airport, centrality):\n    cache.clear()\n    cities = nx.dijkstra_path(flight_graph, org_airport, dest_airport, weight=compute_weight(centrality))\n    layer_index = self.get_layer_index(centrality, {\n        \"name\": centrality,\n        \"geojson\": {\n            \"type\": \"FeatureCollection\",\n            \"features\":[\n                {\"type\":\"Feature\",\n                 \"properties\":{\"route\":\"{} to {}\".format(cities[i], cities[i+1])},\n                 \"geometry\":{\n                     \"type\":\"LineString\",\n                     \"coordinates\":[\n                         self.get_airport_location(cities[i]),\n self.get_airport_location(cities[i+1])\n                     ]\n                 }\n                } for i in range(len(cities) - 1)\n            ]\n        },\n        \"paint\":{\n \"line-width\": 8,\n \"line-color\": self.centrality_indices[centrality]\n }\n    })\n self.toggleLayer(layer_index)\n\n```", "```py\n[[USFlightsAnalysis]]\ndef get_airport_location(self, airport_code):\n    row = airports_centrality.loc[airports[\"IATA_CODE\"] == airport_code]\n    if row is not None:\n        return [row[\"LONGITUDE\"].values[0], row[\"LATITUDE\"].values[0]]\n    return None\n```", "```py\ndef compute_delay_airline_df(airline, org_airport=None):\n    # create a mask for selecting the data\n    mask = (flights[\"AIRLINE\"] == airline)\n    if org_airport is not None:\n        # Add the org_airport to the mask\n        mask = mask & (flights[\"ORIGIN_AIRPORT\"] == org_airport)\n    # Apply the mask to the Pandas dataframe\n    df = flights[mask]\n    # Convert the YEAR, MONTH and DAY column into a DateTime\n    df[\"DATE\"] = pd.to_datetime(flights[['YEAR','MONTH', 'DAY']])\n    # Select only the columns that we need\n    return df[[\"DATE\", \"ARRIVAL_DELAY\"]]\n```", "```py\nbos_delay = compute_delay_airline_df(\"DL\", \"BOS\")\ndisplay(bos_delay)\n```", "```py\nfrom pixiedust.apps.template import TemplateTabbedApp\n\n@PixieApp\nclass RouteAnalysisApp(TemplateTabbedApp):\n    def setup(self):\n        self.apps = [\n            {\"title\": \"Search Shortest Route\",\n             \"app_class\": \"SearchShortestRouteApp\"},\n            {\"title\": \"Explore Airlines\",\n             \"app_class\": \"AirlinesApp\"}\n        ]\n\n```", "```py\n[[USFlightsAnalysis]]\n@route(org_airport=\"*\", dest_airport=\"*\")\ndef analyze_route(self, org_airport, dest_airport):\n    return \"\"\"\n<div pd_app=\"RouteAnalysisApp\"\npd_options=\"org_airport={{org_airport}};dest_airport={{dest_airport}}\"\n     pd_render_onload>\n</div>\n        \"\"\"\n```", "```py\n[[SearchShortestRouteApp]]\nfrom pixiedust.display.app import *\nfrom pixiedust.apps.mapboxBase import MapboxBase\nfrom collections import OrderedDict\n\n@PixieApp\nclass SearchShortestRouteApp(MapboxBase):\n    def setup(self):\n self.org_airport = self.parent_pixieapp.options.get(\"org_airport\")\n self.dest_airport = self.parent_pixieapp.options.get(\"dest_airport\")\n        self.centrality_indices = OrderedDict([\n            (\"ELAPSED_TIME\",\"rgba(256,0,0,0.65)\"),\n            (\"DEGREE\", \"rgba(0,256,0,0.65)\"),\n            (\"PAGE_RANK\", \"rgba(0,0,256,0.65)\"),\n            (\"CLOSENESS\", \"rgba(128,0,128,0.65)\")\n        ])\n        ...\n```", "```py\n[[AirlinesApp]]\n@PixieApp\nclass AirlinesApp():\n    def setup(self):\n        self.org_airport = self.parent_pixieapp.options.get(\"org_airport\")\n self.dest_airport = self.parent_pixieapp.options.get(\"dest_airport\")\n        self.airlines = flights[flights[\"ORIGIN_AIRPORT\"] == self.org_airport].groupby(\"AIRLINE\").size().index.values.tolist()\n        self.airlines = [(a, airlines.loc[airlines[\"IATA_CODE\"] == a][\"AIRLINE\"].values[0]) for a in self.airlines]\n```", "```py\n[[AirlinesApp]]\n@route()\n    def main_screen(self):\n        return \"\"\"\n<div class=\"container-fluid\">\n    {%for airline_code, airline_name in this.airlines%}\n    <div class=\"row\" style=\"max-e\">\n        <h1 style=\"color:red\">{{airline_name}}</h1>\n        <div class=\"col-sm-6\">\n            <div pd_render_onload pd_options=\"delay_org_airport=true;airline_code={{airline_code}};airline_name={{airline_name}}\"></div>\n        </div>\n        <div class=\"col-sm-6\">\n            <div pd_render_onload pd_options=\"delay_org_airport=false;airline_code={{airline_code}};airline_name={{airline_name}}\"></div>\n        </div>\n    </div>\n    {%endfor%}\n</div>\n        \"\"\"\n```", "```py\n[[AirlinesApp]]\n@route(delay_org_airport=\"*\",airline_code=\"*\", airline_name=\"*\")\n    @templateArgs\n    def delay_airline_screen(self, delay_org_airport, airline_code, airline_name):\n        mask = (flights[\"AIRLINE\"] == airline_code)\n        if delay_org_airport == \"true\":\n            mask = mask & (flights[\"ORIGIN_AIRPORT\"] == self.org_airport)\n        average_delay = round(flights[mask][\"ARRIVAL_DELAY\"].mean(), 2)\n        return \"\"\"\n{%if delay_org_airport == \"true\" %}\n<h4>Delay chart for all flights out of {{this.org_airport}}</h4>\n{%else%}\n<h4>Delay chart for all flights</h4>\n{%endif%}\n<h4 style=\"margin-top:5px\">Average delay: {{average_delay}} minutes</h4>\n<div pd_render_onload pd_entity=\"compute_delay_airline_df('{{airline_code}}', '{{delay_org_airport}}')\">\n    <pd_options>\n    {\n \"keyFields\": \"DATE\",\n \"handlerId\": \"lineChart\",\n \"valueFields\": \"ARRIVAL_DELAY\",\n \"noChartCache\": \"true\"\n }\n    </pd_options>\n</div>\n        \"\"\"\n```", "```py\n[[AirlinesApp]]\ndef compute_delay_airline_df(self, airline, delay_org_airport):\n        mask = (flights[\"AIRLINE\"] == airline)\n        if delay_org_airport == \"true\":\n            mask = mask & (flights[\"ORIGIN_AIRPORT\"] == self.org_airport)\n        df = flights[mask]\n        df[\"DATE\"] = pd.to_datetime(flights[['YEAR','MONTH', 'DAY']])\n        return df[[\"DATE\", \"ARRIVAL_DELAY\"]]\n\n```", "```py\ndf = flights[(flights[\"AIRLINE\"] == \"DL\") & (flights[\"ORIGIN_AIRPORT\"] == \"BOS\")]\n```", "```py\nimport statsmodels.tsa.api as smt\nsmt.graphics.plot_acf(df['ARRIVAL_DELAY'], lags=100)\nplt.show()\n```", "```py\nimport statsmodels.tsa.api as smt\nsmt.graphics.plot_pacf(df['ARRIVAL_DELAY'], lags=50)\nplt.show()\n```", "```py\nimport numpy as np\ntrain_set, test_set = df[:-14], df[-14:]\ntrain_set.index = train_set[\"DEPARTURE_TIME\"]\ntest_set.index = test_set[\"DEPARTURE_TIME\"]\nlogdf = np.log(train_set['ARRIVAL_DELAY'])\nlogdf.index = train_set['DEPARTURE_TIME']\nlogdf_diff = pd.DataFrame(logdf - logdf.shift()).reset_index()\nlogdf_diff.replace([np.inf, -np.inf], np.nan, inplace=True)\nlogdf_diff.dropna(inplace=True)\ndisplay(logdf_diff)\n```", "```py\nsmt.graphics.plot_acf(logdf_diff[\"ARRIVAL_DELAY\"], lags=100)\nplt.show()\n```", "```py\nsmt.graphics.plot_pacf(logdf_diff[\"ARRIVAL_DELAY\"], lags=100)\nplt.show()\n```", "```py\nfrom statsmodels.tsa.arima_model import ARIMA\n\nimport warnings\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    arima_model_class = ARIMA(train_set['ARRIVAL_DELAY'],\n                              dates=train_set['DEPARTURE_TIME'],\n                              order=(1,1,1))\n    arima_model = arima_model_class.fit(disp=0)\n    print(arima_model.resid.describe())\n```", "```py\ncount    13882.000000\nmean         0.003116\nstd         48.932043\nmin       -235.439689\n25%        -17.446822\n50%         -5.902274\n75%          6.746263\nmax       1035.104295\ndtype: float64\n```", "```py\ndef plot_predict(model, dates_series, num_observations):\n    fig,ax = plt.subplots(figsize = (12,8))\n    model.plot_predict(\n        start = dates_series[len(dates_series)-num_observations],\n        end = dates_series[len(dates_series)-1],\n        ax = ax\n    )\n    plt.show()\nplot_predict(arima_model, train_set['DEPARTURE_TIME'], 100)\n```", "```py\ndef compute_test_set_predictions(train_set, test_set):\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        history = train_set['ARRIVAL_DELAY'].values\n        forecast = np.array([])\n        for t in range(len(test_set)):\n            prediction = ARIMA(history, order=(1,1,0)).fit(disp=0).forecast()\n            history = np.append(history, test_set['ARRIVAL_DELAY'].iloc[t])\n            forecast = np.append(forecast, prediction[0])\n        return pd.DataFrame(\n          {\"forecast\": forecast,\n \"test\": test_set['ARRIVAL_DELAY'],\n \"Date\": pd.date_range(start=test_set['DEPARTURE_TIME'].iloc[len(test_set)-1], periods = len(test_set))\n }\n        )\n\nresults = compute_test_set_predictions(train_set, test_set)\ndisplay(results)\n```", "```py\n[[PredictDelayApp]]\nimport warnings\nimport numpy as np\nfrom statsmodels.tsa.arima_model import ARIMA\n\n@PixieApp\nclass PredictDelayApp():\n    def setup(self):\n        self.org_airport = self.parent_pixieapp.options.get(\"org_airport\")\n        self.dest_airport = self.parent_pixieapp.options.get(\"dest_airport\")\n        self.airlines = flights[flights[\"ORIGIN_AIRPORT\"] == self.org_airport].groupby(\"AIRLINE\").size().index.values.tolist()\n        self.airlines = [(a, airlines.loc[airlines[\"IATA_CODE\"] == a][\"AIRLINE\"].values[0]) for a in self.airlines]\n        path = nx.dijkstra_path(flight_graph, self.org_airport, self.dest_airport, weight=compute_weight(\"DEGREE\"))\n        self.paths = [(path[i], path[i+1]) for i in range(len(path) - 1)]\n```", "```py\n[[PredictDelayApp]]\n@route()\n    def main_screen(self):\n        return \"\"\"\n<div class=\"container-fluid\">\n    <div class=\"row\">\n        <div class=\"col-sm-6\">\n            <div class=\"rendererOpt\" style=\"font-weight:bold\">\n                Select a flight segment:\n            </div>\n            <div>\n                <select id=\"segment{{prefix}}\" pd_refresh=\"prediction_graph{{prefix}}\">\n                    <option value=\"\" selected></option>\n                    {%for start, end in this.paths %}\n <option value=\"{{start}}:{{end}}\">{{start}} -> {{end}}</option>\n {%endfor%}\n                </select>\n            </div>\n        </div>\n        <div class=\"col-sm-6\">\n            <div class=\"rendererOpt\" style=\"font-weight:bold\">\n                Select an airline:\n            </div>\n            <div>\n                <select id=\"airline{{prefix}}\" pd_refresh=\"prediction_graph{{prefix}}\">\n                    <option value=\"\" selected></option>\n                    {%for airline_code, airline_name in this.airlines%}\n <option value=\"{{airline_code}}\">{{airline_name}}</option>\n {%endfor%}\n                </select>\n            </div>\n        </div>\n    </div>\n    <div class=\"row\">\n        <div class=\"col-sm-12\">\n            <div id=\"prediction_graph{{prefix}}\"\n                pd_options=\"flight_segment=$val(segment{{prefix}});airline=$val(airline{{prefix}})\">\n            </div>\n        </div>\n    </div>\n</div>\n        \"\"\"\n```", "```py\n[[PredictDelayApp]]\n@route(flight_segment=\"*\", airline=\"*\")\n @captureOutput\n    def predict_screen(self, flight_segment, airline):\n        if flight_segment is None or flight_segment == \"\":\n            return \"<div>Please select a flight segment</div>\"\n airport = flight_segment.split(\":\")[1]\n mask = (flights[\"DESTINATION_AIRPORT\"] == airport)\n        if airline is not None and airline != \"\":\n mask = mask & (flights[\"AIRLINE\"] == airline)\n        df = flights[mask]\n        df.index = df[\"DEPARTURE_TIME\"]\n        df = df.tail(50000)\n df = df[~df.index.duplicated(keep='first')]\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            arima_model_class = ARIMA(df[\"ARRIVAL_DELAY\"], dates=df['DEPARTURE_TIME'], order=(1,1,1))\n            arima_model = arima_model_class.fit(disp=0)\n            fig, ax = plt.subplots(figsize = (12,8))\n            num_observations = 100\n            date_series = df[\"DEPARTURE_TIME\"]\n arima_model.plot_predict(\n start = str(date_series[len(date_series)-num_observations]),\n end = str(date_series[len(date_series)-1]),\n ax = ax\n )\n            plt.show()\n```", "```py\nfrom pixiedust.apps.template import TemplateTabbedApp\n\n@PixieApp\nclass RouteAnalysisApp(TemplateTabbedApp):\n    def setup(self):\n        self.apps = [\n            {\"title\": \"Search Shortest Route\",\n             \"app_class\": \"SearchShortestRouteApp\"},\n            {\"title\": \"Explore Airlines\",\n             \"app_class\": \"AirlinesApp\"},\n            {\"title\": \"Flight Delay Prediction\",\n \"app_class\": \"PredictDelayApp\"}\n        ]\n```"]