- en: NumPy and pandas
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood data analysis, its process, and its installation
    on different platforms, it's time to learn about NumPy arrays and `pandas` DataFrames.
    This chapter acquaints you with the fundamentals of NumPy arrays and `pandas`
    DataFrames. By the end of this chapter, you will have a basic understanding of
    NumPy arrays, and `pandas` DataFrames and their related functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas` is named after panel data (an econometric term) and Python data analysis
    and is a popular open-source Python library. We shall learn about basic `pandas`
    functionalities, data structures, and operations in this chapter. The official
    `pandas` documentation insists on naming the project `pandas` in all lowercase
    letters. The other convention the `pandas` project insists on is the `import pandas
    as pd` import statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, our focus will be on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NumPy arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy array numerical data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating array shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stacking of NumPy arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partitioning NumPy arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the data type of NumPy arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating NumPy views and copies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing NumPy arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean and fancy indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcasting arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `pandas` DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `pandas` Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and querying the Quandl data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing `pandas` DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping and joining `pandas` DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with missing values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating pivot tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code and the dataset at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code blocks are available at `ch2.ipynb`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter uses four CSV files (`WHO_first9cols.csv`, `dest.csv`, `purchase.csv`,
    and `tips.csv`) for practice purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use the NumPy, `pandas`, and Quandl Python libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy can be installed on a PC using `pip` or `brew` but if the user is using
    the Jupyter Notebook, then there is no need to install it. NumPy is already installed
    in the Jupyter Notebook. I will suggest to you to please use the Jupyter Notebook
    as your IDE because we are executing all the code in the Jupyter Notebook. We
    have already shown in [Chapter 1](d6dfd6dc-2d6e-4984-a2d6-e205384cd2a8.xhtml),
    *Getting Started with Python Libraries*, how to install Anaconda, which is a complete
    suite for data analysis. NumPy arrays are a series of homogenous items. Homogenous
    means the array will have all the elements of the same data type. Let's create
    an array using NumPy. You can create an array using the `array()` function with
    a list of items. Users can also fix the data type of an array. Possible data types
    are `bool`, `int`, `float`, `long`, `double`, and `long double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to create an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to create a NumPy array is with `arange()`. It creates an evenly
    spaced NumPy array. Three values – start, stop, and step – can be passed to the
    `arange(start,[stop],step)` function. The start is the initial value of the range,
    the stop is the last value of the range, and the step is the increment in that
    range. The stop parameter is compulsory. In the following example, we have used
    `1` as the start and `11` as the stop parameter. The `arange(1,11)` function will
    return 1 to 10 values with one step because the step is, by default, 1\. The `arrange()`
    function generates a value that is one less than the stop parameter value. Let''s
    understand this through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the `array()` and `arange()` functions, there are other options,
    such as `zeros()`, `ones()`, `full()`, `eye()`, and `random()`, which can also
    be used to create a NumPy array, as these functions are initial placeholders.
    Here is a detailed description of each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zeros()`: The `zeros()`function creates an array for a given dimension with
    all zeroes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ones()`: The `ones()` function creates an array for a given dimension with
    all ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fulls()`: The `full()` function generates an array with constant values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eyes()`: The `eye()` function creates an identity matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`random()`: The `random()` function creates an array with any given dimension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand these functions through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have seen some built-in functions for creating arrays
    with all-zero values, all-one values, and all-constant values. After that, we
    have created the identity matrix using the `eye()` function and a random matrix
    using the `random.random()` function. Let's see some other array features in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Array features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, NumPy arrays are a homogeneous kind of data structure that has the
    same types of items. The main benefit of an array is its certainty of storage
    size because of its same type of items. A Python list uses a loop to iterate the
    elements and perform operations on them. Another benefit of NumPy arrays is to
    offer vectorized operations instead of iterating each item and performing operations
    on it. NumPy arrays are indexed just like a Python list and start from 0\. NumPy
    uses an optimized C API for the fast processing of the array operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make an array using the `arange()` function, as we did in the previous
    section, and let''s check its data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you use `type()`, it returns `numpy.ndarray`. This means that the `type()`
    function returns the type of the container. When you use `dtype()`, it will return
    `int64`, since it is the type of the elements. You may also get the output as
    `int32` if you are using 32-bit Python. Both cases use integers (32- and 64-bit).
    One-dimensional NumPy arrays are also known as vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find out the shape of the vector that we produced a few minutes ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the vector has 10 elements with values ranging from 1 to 10\.
    The `shape` property of the array is a tuple; in this instance, it is a tuple
    of one element, which holds the length in each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting array elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will see how to select the elements of the array. Let''s
    see an example of a 2*2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the matrix is created using the `array()` function
    with the input list of lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting array elements is pretty simple. We just need to specify the index
    of the matrix as `a[m,n]`. Here, `m` is the row index and `n` is the column index
    of the matrix. We will now select each item of the matrix one by one as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code sample, we have tried to access each element of an array
    using array indices. You can also understand this by the diagram mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b919f96a-3be5-4592-821a-1f8494af6bbb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see it has four blocks and each block represents
    the element of an array. The values written in each block show its indices.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have understood the fundamentals of arrays. Now, let's jump
    to arrays of numerical data types.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy array numerical data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers three types of numerical data types: integer type, float type,
    and complex type. In practice, we need more data types for scientific computing
    operations with precision, range, and size. NumPy offers a bulk of data types
    with mathematical types and numbers. Let''s see the following table of NumPy numerical
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Type** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | This is a Boolean type that stores a bit and takes `True` or `False`
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `inti` | Platform integers can be either `int32` or `int64`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int8` | Byte store values range from `-128` to `127`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int16` | This stores integers ranging from `-32768` to `32767`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | This stores integers ranging from `-2 ** 31` to `2 ** 31 -1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | This stores integers ranging from `-2 ** 63` to `2 ** 63 -1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8` | This stores unsigned integers ranging from `0` to `255`. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16` | This stores unsigned integers ranging from `0` to `65535`. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | This stores unsigned integers ranging from `0` to `2 ** 32 – 1`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | This stores unsigned integers ranging from `0` to `2 ** 64 – 1`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `float16` | Half-precision float; sign bit with 5 bits exponent and 10 bits
    mantissa. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | Single-precision float; sign bit with 8 bits exponent and 23
    bits mantissa. |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` or `float` | Double-precision float; sign bit with 11 bits exponent
    and 52 bits mantissa. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | Complex number stores two 32-bit floats: real and imaginary
    number. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` or `complex` | Complex number stores two 64-bit floats: real
    and imaginary number. |'
  prefs: []
  type: TYPE_TB
- en: 'For each data type, there exists a matching conversion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Many functions have a data type argument, which is frequently optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to be aware that you are not allowed to change a complex number
    into an integer. If you try to convert complex data types into integers, then
    you will get `TypeError`. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcf3bbd1-687f-456d-b900-f5dd18413eb2.png)'
  prefs: []
  type: TYPE_IMG
- en: You will get the same error if you try the conversion of a complex number into
    a floating point.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can convert float values into complex numbers by setting individual
    pieces. You can also pull out the pieces using the `real` and `imag` attributes.
    Let''s see that using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you have defined a complex number using the `complex()`
    method. Also, you have extracted the real and imaginary values using the `real`
    and `imag` attributes. Let's now jump to `dtype` objects.
  prefs: []
  type: TYPE_NORMAL
- en: dtype objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen in earlier sections of the chapter that `dtype` tells us the type
    of individual elements of an array. NumPy array elements have the same data type,
    which means that all elements have the same `dtype`. `dtype` objects are instances
    of the `numpy.dtype` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`dtype` objects also tell us the size of the data type in bytes using the `itemsize`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Data type character codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Character codes are included for backward compatibility with Numeric. Numeric
    is the predecessor of NumPy. Its use is not recommended, but the code is supplied
    here because it pops up in various locations. You should use the `dtype` object
    instead. The following table lists several different data types and the character
    codes related to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Character Code** |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | i |'
  prefs: []
  type: TYPE_TB
- en: '| Unsigned integer | u |'
  prefs: []
  type: TYPE_TB
- en: '| Single-precision float | f |'
  prefs: []
  type: TYPE_TB
- en: '| Double-precision float | d |'
  prefs: []
  type: TYPE_TB
- en: '| Bool | b |'
  prefs: []
  type: TYPE_TB
- en: '| Complex | D |'
  prefs: []
  type: TYPE_TB
- en: '| String | S |'
  prefs: []
  type: TYPE_TB
- en: '| Unicode | U |'
  prefs: []
  type: TYPE_TB
- en: '| Void | V |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s take a look at the following code to produce an array of single-precision
    floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the following code creates an array of complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: dtype constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are lots of ways to create data types using constructors. Constructors
    are used to instantiate or assign a value to an object. In this section, we will
    understand data type creation with the help of a floating-point data example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out a general Python float, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To try out a single-precision float with a character code, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To try out a double-precision float with a character code, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To try out a `dtype` constructor with a two-character code, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first character stands for the type and a second character is a number
    specifying the number of bytes in the type, for example, 2, 4, or 8.
  prefs: []
  type: TYPE_NORMAL
- en: dtype attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dtype` class offers several useful attributes. For example, we can get
    information about the character code of a data type using the `dtype` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type` attribute corresponds to the type of object of the array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know all about the various data types used in NumPy arrays, let's
    start manipulating them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating array shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, our main focus is on array manipulation. Let''s learn some
    new Python functions of NumPy, such as `reshape()`, `flatten()`, `ravel()`, `transpose()`,
    and `resize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reshape()` will change the shape of the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another operation that can be applied to arrays is `flatten()`. `flatten()`
    transforms an n-dimensional array into a one-dimensional array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ravel()` function is similar to the `flatten()` function. It also transforms
    an n-dimensional array into a one-dimensional array. The main difference is that
    `flatten()` returns the actual array while `ravel()` returns the reference of
    the original array. The `ravel()` function is faster than the `flatten()` function
    because it does not occupy extra memory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `transpose()` function is a linear algebraic function that transposes the
    given two-dimensional matrix. The word transpose means converting rows into columns
    and columns into rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resize()` function changes the size of the NumPy array. It is similar
    to `reshape()` but it changes the shape of the original array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In all the code in this section, we have seen built-in functions such as `reshape()`,
    `flatten()`, `ravel()`, `transpose()`, and `resize()` for manipulating size. Now,
    it's time to learn about the stacking of NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The stacking of NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy offers a stack of arrays. Stacking means joining the same dimensional
    arrays along with a new axis. Stacking can be done horizontally, vertically, column-wise,
    row-wise, or depth-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal stacking**: In horizontal stacking, the same dimensional arrays
    are joined along with a horizontal axis using the `hstack()` and `concatenate()`
    functions. Let''s see the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created one 3*3 array; it''s time to create another 3*3 array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating two arrays, we will perform horizontal stacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, two arrays are stacked horizontally along the *x* axis.
    The `concatenate()` function can also be used to generate the horizontal stacking
    with axis parameter value `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, two arrays have been stacked horizontally using the `concatenate()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical stacking**: In vertical stacking, the same dimensional arrays are
    joined along with a vertical axis using the `vstack()` and `concatenate()` functions.
    Let''s see the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, two arrays are stacked vertically along the *y* axis.
    The `concatenate()` function can also be used to generate vertical stacking with
    axis parameter value `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, two arrays are stacked vertically using the `concatenate()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Depth stacking**: In depth stacking, the same dimensional arrays are joined
    along with a third axis (depth) using the `dstack()` function. Let''s see the
    following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, two arrays are stacked in depth along with a third axis
    (depth).
  prefs: []
  type: TYPE_NORMAL
- en: '**Column stacking**: Column stacking stacks multiple sequence one-dimensional
    arrays as columns into a single two-dimensional array. Let''s see an example of
    column stacking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have created a one-dimensional NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have created another one-dimensional NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created two one-dimensional arrays and stacked
    them column-wise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Row stacking**: Row stacking stacks multiple sequence one-dimensional arrays
    as rows into a single two-dimensional arrays. Let''s see an example of row stacking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, two one-dimensional arrays are stacked row-wise.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how to partition a NumPy array into multiple sub-arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy arrays can be partitioned into multiple sub-arrays. NumPy offers three
    types of split functionality: vertical, horizontal, and depth-wise. All the split
    functions by default split into the same size arrays but we can also specify the
    split location. Let''s look at each of the functions in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal splitting**: In horizontal split, the given array is divided into
    *N* equal sub-arrays along the horizontal axis using the `hsplit()` function.
    Let''s see how to split an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `hsplit(arr, 3)` function divides the array into
    three sub-arrays. Each part is a column of the original array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical splitting**: In vertical split, the given array is divided into
    *N* equal sub-arrays along the vertical axis using the `vsplit()` and `split()`
    functions. The `split` function with `axis=0` performs the same operation as the
    `vsplit()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `vsplit(arr, 3)` function divides the array into
    three sub-arrays. Each part is a row of the original array. Let''s see another
    function, `split()`, which can be utilized as a vertical and horizontal split,
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `split(arr, 3)` function divides the array into three
    sub-arrays. Each part is a row of the original array. The split output is similar
    to the `vsplit()` function when `axis=0` and the split output is similar to the
    `hsplit()` function when `axis=1`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the data type of NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen in the preceding sections, NumPy supports multiple data types,
    such as `int`, `float`, and complex numbers. The `astype()` function converts
    the data type of the array. Let''s see an example of the `astype()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created one NumPy array and checked its data
    type using the `dtype` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the data type of an array using the `astype()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have changed the column data type from integer to
    float using `astype()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tolist()` function converts a NumPy array into a Python list. Let''s see
    an example of the `tolist()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have converted an array into a Python list object
    using the `tolist()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating NumPy views and copies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the Python functions return either a copy or a view of the input array.
    A Python copy stores the array in another location while a view uses the same
    memory content. This means copies are separate objects and treated as a deep copy
    in Python. Views are the original base array and are treated as a shallow copy.
    Here are some properties of copies and views:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifications in a view affect the original data whereas modifications in a
    copy do not affect the original array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views use the concept of shared memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies require extra space compared to views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies are slower than views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand the concept of copy and view using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating a NumPy array, let''s perform object copy operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see the original array and the assigned array
    have the same object ID, meaning both are pointing to the same object. Copies
    and views both have different object IDs; both will have different objects, but
    view objects will reference the same original array and a copy will have a different
    replica of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with this example and update the values of the original array
    and check its impact on views and copies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can conclude from the results that the view is
    the original array. The values changed when we updated the original array and
    the copy is a separate object because its values remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slicing in NumPy is similar to Python lists. Indexing prefers to select a single
    value while slicing is used to select multiple values from an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays also support negative indexing and slicing. Here, the negative
    sign indicates the opposite direction and indexing starts from the right-hand
    side with a starting value of `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af682864-72cd-48e8-873c-546195356d50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check this out using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the slice operation, we use the colon symbol to select the collection of
    values. Slicing takes three values: start, stop, and step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0585afca-cac7-4b8c-8da9-a60acc19ff62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we have used `3` as the starting index and `6` as
    the stopping index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, only the starting index is given. `3` is the starting
    index. This slice operation will select the values from the starting index to
    the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e19f5cd6-bb53-4eeb-8392-f0303183cd43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, the slice operation will select values from the third
    value from the right side of the array to the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61da429a-0f75-4f4a-b18a-61c8bf16dbfe.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the start, stop, and step index are 2, 7, and 2, respectively.
    Here, the slice operation selects values from the second index to the sixth (one
    less than the stop value) index with an increment of 2 in the index value. So,
    the output will be 2, 4, and 6.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean and fancy indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indexing techniques help us to select and filter elements from a NumPy array.
    In this section, we will focus on Boolean and fancy indexing. Boolean indexing
    uses a Boolean expression in the place of indexes (in square brackets) to filter
    the NumPy array. This indexing returns elements that have a true value for the
    Boolean expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Fancy indexing is a special type of indexing in which elements of an array
    are selected by an array of indices. This means we pass the array of indices in
    brackets. Fancy indexing also supports multi-dimensional arrays. This will help
    us to easily select and modify a complex multi-dimensional set of arrays. Let''s
    see an example as follows to understand fancy indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created a 5*4 matrix and selected the rows using
    integer indices. You can also visualize or internalize this output from the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd8c91ee-2ea1-4af4-8120-632f0678b61d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the code for this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example results in the first value, `[1,2]`, and second value,
    `[2,3]`, as the row and column index. The array will select the value at the first
    and second index values, which are 7 and 12.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python lists do not support direct vectorizing arithmetic operations. NumPy
    offers a faster-vectorized array operation compared to Python list loop-based
    operations. Here, all the looping operations are performed in C instead of Python,
    which makes it faster. Broadcasting functionality checks a set of rules for applying
    binary functions, such as addition, subtraction, and multiplication, on different
    shapes of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In all three preceding examples, we can see the addition of two arrays of the
    same size. This concept is known as broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, two matrices were multiplied. Let''s perform addition
    and multiplication with a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding two examples, the matrix is added and multiplied by a scalar
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pandas DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pandas` library is designed to work with a panel or tabular data. `pandas`
    is a fast, highly efficient, and productive tool for manipulating and analyzing
    string, numeric, datetime, and time-series data. `pandas` provides data structures
    such as DataFrames and Series. A `pandas` DataFrame is a tabular, two-dimensional
    labeled and indexed data structure with a grid of rows and columns. Its columns
    are heterogeneous types. It has the capability to work with different types of
    objects, carry out grouping and joining operations, handle missing values, create
    pivot tables, and deal with dates. A `pandas` DataFrame can be created in multiple
    ways. Let''s create an empty DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have created an empty DataFrame. Let''s create
    a DataFrame using a dictionary of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have used a dictionary of the list to create a DataFrame.
    Here, the keys of the dictionary are equivalent to columns, and values are represented
    as a list that is equivalent to the rows of the DataFrame. Let''s create a DataFrame
    using the list of dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the DataFrame is created using a list of dictionaries.
    In the list, each item is a dictionary. Each key is the name of the column and
    the value is the cell value for a row. Let''s create a DataFrame using a list
    of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the DataFrame is created using a list of tuples. In the
    list, each item is a tuple and each tuple is equivalent to the row of columns.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pandas Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pandas` Series is a one-dimensional sequential data structure that is able
    to handle any type of data, such as string, numeric, datetime, Python lists, and
    dictionaries with labels and indexes. Series is one of the columns of a DataFrame.
    We can create a Series using a Python dictionary, NumPy array, and scalar value.
    We will also see the `pandas` Series features and properties in the latter part
    of the section. Let''s create some Python Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Python dictionary**: Create a dictionary object and pass it to the
    Series object. Let''s see the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Using a NumPy array**: Create a NumPy array object and pass it to the Series
    object. Let''s see the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Using a single scalar value**: To create a `pandas` Series with a scalar
    value, pass the scalar value and index list to a Series object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore some features of `pandas` Series:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a series by selecting a column, such as `country`, which
    happens to be the first column in the datafile. Then, show the type of the object
    currently in the local scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b78dd324-b22c-4f06-a72e-45d1a2b6763e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we have read the `WHO_first9cols.csv` file using the
    `read_csv()` function. You can download this file from the following GitHub location:[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02).
    In the output, you can see the top five records in the `WHO_first9cols` dataset
    using the `head()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas` Series data structure shares some of the common attributes of
    DataFrames and also has a `name` attribute. Explore these properties as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the column list of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the data types of DataFrame columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the slicing of a `pandas` Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to use pandas Series, let's move on to using Quandl to
    work on databases.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and querying the Quandl data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw `pandas` DataFrames that have a tabular structure
    similar to relational databases. They offer similar query operations on DataFrames.
    In this section, we will focus on Quandl. Quandl is a Canada-based company that
    offers commercial and alternative financial data for investment data analyst.
    Quandl understands the need for investment and financial quantitative analysts.
    It provides data using API, R, Python, or Excel.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will retrieve the Sunspot dataset from Quandl. We can use
    either an API or download the data manually in CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first install the Quandl package using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If you want to install the API, you can do so by downloading installers from
    [https://pypi.python.org/pypi/Quandl](https://pypi.python.org/pypi/Quandl) or
    by running the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: Using the API is free, but is limited to 50 API calls per day. If you require
    more API calls, you will have to request an authentication key. The code in this
    tutorial does not use a key. It should be simple to change the code to either
    use a key or read a downloaded CSV file. If you have difficulties, refer to the
    *Where to find help and references* section in [Chapter 1,](https://docs.google.com/document/d/1BDrtOc3RwvX2ZzT42tRXvfrzPQ8EMJRy/edit#bookmark=id.4d34og8)
    *Getting Started with Python Libraries*, or search through the Python docs at
    [https://docs.python.org/2/](https://docs.python.org/2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to query data in a `pandas` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we obviously have to download the data. After importing the
    Quandl API, get the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `head()` and `tail()` methods have a purpose similar to that of the Unix
    commands with the same name. Select the first *n* and last *n* records of a DataFrame,
    where *n* is an integer parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d47b5e81-6d11-4ced-af56-0a425dca7c88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check out the `tail` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b1a1be7-57e0-4856-bd8e-8f040083cd8e.png)'
  prefs: []
  type: TYPE_IMG
- en: The `head()` and `tail()` methods give us the first and last five rows of the
    Sunspot data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering columns**: `pandas` offers the ability to select columns. Let''s
    select columns in a `pandas` DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6c945a1-760f-42ba-a419-b90580d3f646.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Filtering rows**: `pandas` offers the ability to select rows. Let''s select
    rows in a `pandas` DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b792113a-06be-4e84-8328-41459c913d76.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Boolean filtering**: We can query data using Boolean conditions similar to
    the `WHERE` clause condition of SQL. Let''s filter the data greater than the arithmetic
    mean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df23803c-0e5b-40e3-b509-9bbcef800199.png)'
  prefs: []
  type: TYPE_IMG
- en: Describing pandas DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pandas` DataFrame has a dozen statistical methods. The following table
    lists these methods, along with a short description of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `describes` | This method returns a small table with descriptive statistics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | This method returns the number of non-NaN items. |'
  prefs: []
  type: TYPE_TB
- en: '| `mad` | This method calculates the mean absolute deviation, which is a robust
    measure similar to standard deviation. |'
  prefs: []
  type: TYPE_TB
- en: '| `median` | This method returns the median. This is equivalent to the value
    at the 50^(th) percentile. |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | This method returns the minimum value. |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | This method returns the maximum value. |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This method returns the mode, which is the most frequently occurring
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `std` | This method returns the standard deviation, which measures dispersion.
    It is the square root of the variance. |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | This method returns the variance. |'
  prefs: []
  type: TYPE_TB
- en: '| `skew` | This method returns skewness. Skewness is indicative of the distribution
    symmetry. |'
  prefs: []
  type: TYPE_TB
- en: '| `kurt` | This method returns kurtosis. Kurtosis is indicative of the distribution
    shape. |'
  prefs: []
  type: TYPE_TB
- en: 'Using the same data used in the previous section, we will demonstrate these
    statistical methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6340853c-6e5b-4b2c-a4f2-17e208467c60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `describe()` method will show most of the descriptive statistical measures
    for all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a142316e-f8c3-4cce-8bcf-90d92c61b54f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `count()` method counts the number of observations in each column. It helps
    us to check the missing values in the dataset. Except for the initial three columns,
    all the columns have missing values. Similarly, you can compute the median, standard
    deviation, mean absolute deviation, variance, skewness, and kurtosis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b49ad6b-b2be-4ce5-8033-08fb2a7fb89d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can compute deviation for all columns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61c3c45e-8bbe-4ea8-bf58-dc2a2149dc4e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code example is computing the standard deviation for each numeric
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping and joining pandas DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Grouping is a kind of data aggregation operation. The grouping term is taken
    from a relational database. Relational database software uses the `group by` keyword
    to group similar kinds of values in a column. We can apply aggregate functions
    on groups such as mean, min, max, count, and sum. The `pandas` DataFrame also
    offers similar kinds of capabilities. Grouping operations are based on the split-apply-combine
    strategy. It first divides data into groups and applies the aggregate operation,
    such as mean, min, max, count, and sum, on each group and combines results from
    each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c0e1cad-5051-4922-bdfc-4ae1665d7423.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now group the DataFrames based on literacy rates as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68a9df18-74b9-420f-9c09-79831ab1fd81.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the continent-wise average adult literacy rate in
    percentage was computed. You can also group based on multiple columns by passing
    a list of columns to the `groupby()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Join is a kind of merge operation for tabular databases. The join concept is
    taken from the relational database. In relational databases, tables were normalized
    or broken down to reduce redundancy and inconsistency, and join is used to select
    the information from multiple tables. A data analyst needs to combine data from
    multiple sources. `pandas` also offers to join functionality to join multiple
    DataFrames using the `merge()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand joining, we will take a taxi company use case. We are using two
    files: `dest.csv` and `tips.csv`. Every time a driver drops any passenger at their
    destination, we will insert a record (employee number and destination) into the
    `dest.csv` file. Whenever drivers get a tip, we insert the record (employee number
    and tip amount) into the `tips.csv` file. You can download both the files from
    the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eb01529-0df4-4aa2-9cf5-33c04e76e460.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code block, we have read the `dest.csv` file using the `read_csv()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45f599b5-2a83-4787-975e-b5fed56e3225.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code block, we have read the `tips.csv` file using the `read_csv()`
    method. We will now check out the various types of joins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner join**: Inner join is equivalent to the intersection operation of a
    set. It will select only common records in both the DataFrames. To perform inner
    join, use the `merge()` function with both the DataFrames and common attribute
    on the parameter and inner value to show the parameter. The `on` parameter is
    used to provide the common attribute based on the join will be performed and `how`
    defines the type of join:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/562d1827-9400-4c6b-baff-47754275b7a0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Full outer join**: Outer join is equivalent to a union operation of the set.
    It merges the right and left DataFrames. It will have all the records from both
    DataFrames and fills NaNs where the match will not be found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eebc7b2f-18f9-451f-a5e9-c2f60cd2f97f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Right outer join**: In the right outer join, all the records from the right
    side of the DataFrame will be selected. If the matched records cannot be found
    in the left DataFrame, then it is filled with NaNs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f2768a8-e08f-4f2e-9412-e758579c511e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Left outer join**: In the left outer join, all the records from the left
    side of the DataFrame will be selected. If the matched records cannot be found
    in the right DataFrame, then it is filled with NaNs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae22b284-1120-404b-8c6d-6fa6253106f0.png)'
  prefs: []
  type: TYPE_IMG
- en: We will now move on to checking out missing values in the datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Working with missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most real-world datasets are messy and noisy. Due to their messiness and noise,
    lots of values are either faulty or missing. `pandas` offers lots of built-in
    functions to deal with missing values in DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check missing values in a DataFrame**: `pandas`'' `isnull()` function checks
    for the existence of null values and returns `True` or `False`, where `True` is
    for null and `False` is for not-null values. The `sum()` function will sum all
    the `True` values and returns the count of missing values. We have tried two ways
    to count the missing values; both show the same output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d8d5ea8-250d-4c28-94d2-417bd627526b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Drop missing values**: A very naive approach to deal with missing values
    is to drop them for analysis purposes. `pandas` has the `dropna()` function to
    drop or delete such observations from the DataFrame. Here, the `inplace=True`
    attribute makes the changes in the original DataFrame:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/521ce6a9-094e-418a-98ba-3ec10d0c0d51.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the number of observations is reduced to 118 from 202.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fill the missing values**: Another approach is to fill the missing values
    with zero, mean, median, or constant values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f523082f-2d4c-4beb-b9a3-ca4ce9b9439e.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have filled the missing values with 0\. This is all about handling
    missing values.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on pivot tables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pivot tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pivot table is a summary table. It is the most popular concept in Excel.
    Most data analysts use it as a handy tool to summarize theire results. `pandas`
    offers the `pivot_table()` function to summarize DataFrames. A DataFrame is summarized
    using an aggregate function, such as mean, min, max, or sum. You can download
    the dataset from the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f93bf27f-dff2-4d72-aa5e-acd1de1de70e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code block, we have read the `purchase.csv` file using the
    `read_csv()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will summarize the dataframe using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c2e812a-3151-48a1-b588-d13de92bfd17.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the `purchase` DataFrame is summarized. Here, `index`
    is the `Weather` column, `columns` is the `Food` column, and `values` is the aggregated
    sum of the `Number` column. `aggfun` is initialized with the `np.sum` parameter.
    It's time to learn how to deal with dates in `pandas` DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with dates is messy and complicated. You can recall the Y2K bug, the
    upcoming 2038 problem, and time zones dealing with different problems. In time-series
    datasets, we come across dates. `pandas` offers date ranges, resamples time-series
    data, and performs date arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a range of dates starting from January 1, 2020, lasting for 45 days,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: January has less than 45 days, so the end date falls in February, as you can
    check for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '`date_range()` freq parameters can take values such as `B` for business day
    frequency, `W` for weekly frequency, `H` for hourly frequency, `M` for minute
    frequency, `S` for second frequency, `L` for millisecond frequency, and `U` for
    microsecond frequency. For more details, you can refer to the official documentation
    at [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '**pandas date range:** The `date_range()` function generates sequences of date
    and time with a fixed-frequency interval:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4093374-fb5b-482d-b37c-3ce27d243884.png)'
  prefs: []
  type: TYPE_IMG
- en: '`to_datetime()`: `to_datetime()` converts a timestamp string into datetime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert a timestamp string into a datetime object in the specified format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '**Handling an unknown format string**: Unknown input format can cause value
    errors. We can handle this by using an errors parameter with `coerce`. `coerce`
    will set invalid strings to NaT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the second date is still not valid and cannot be converted
    into a datetime object. The errors parameter helped us to handle such errors by
    inputting the value `NaT` (not a time).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the NumPy and pandas libraries. Both libraries
    help deal with arrays and DataFrames. NumPy arrays have the capability to deal
    with n-dimensional arrays. We have learned about various array properties and
    operations. Our main focus is on data types, data type as an object, reshaping,
    stacking, splitting, slicing, and indexing.
  prefs: []
  type: TYPE_NORMAL
- en: We also focused on the `pandas` library for Python data analysis. We saw how
    `pandas` mimics the relational database table functionality. It offers functionality
    to query, aggregate, manipulate, and join data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy and `pandas` work well together as a tool and make it possible to perform
    basic data analysis. At this point, you might be tempted to think that `pandas`
    is all we need for data analysis. However, there is more to data analysis than
    meets the eye.
  prefs: []
  type: TYPE_NORMAL
- en: Having picked up the fundamentals, it's time to proceed to data analysis with
    the commonly used statistics functions in [Chapter 3](dec623f2-210e-4cb0-900b-7eb039a4fb91.xhtml),
    *Statistics*. This includes the usage of statistical concepts.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to read the books mentioned in the *References* section for
    exploring NumPy and `pandas` in further detail and depth.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ivan Idris, *NumPy Cookbook – Second Edition*, Packt Publishing, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ivan Idris, *Learning NumPy Array*, Packt Publishing, 2014.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ivan Idris, *NumPy: Beginner''s Guide* *– Third Edition*, Packt Publishing,
    2015.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L. (L.-H.) Chin and T. Dutta, *NumPy Essentials*, Packt Publishing, 2016.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T. Petrou, *Pandas Cookbook*, Packt Publishing, 2017.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F. Anthony, *Mastering pandas*, Packt Publishing, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Heydt, *Mastering pandas for Finance*, Packt Publishing, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T. Hauck, *Data-Intensive Apps with pandas How-to*, Packt Publishing, 2013.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Heydt, *Learning pandas*, Packt Publishing, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
