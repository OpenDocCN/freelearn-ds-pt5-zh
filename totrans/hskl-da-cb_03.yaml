- en: Chapter 3. The Science of Words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a number in another base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a number from another base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for a substring using Data.ByteString
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching a string using the Boyer–Moore–Horspool algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching a string using the Rabin-Karp algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting a string on lines, words, or arbitrary tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the longest common subsequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing a phonetic code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the edit distance between two strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the Jaro–Winkler distance between two strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding strings within one-edit distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing spelling mistakes using edit distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Introduction](img/ch03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many interesting analysis techniques can be used on a large corpus of words.
    Whether it be examining the structure of a sentence or the content of a book,
    these recipes will introduce us to some useful tools.
  prefs: []
  type: TYPE_NORMAL
- en: When manipulating strings for data analysis, some of the most common functions
    are among substring search and edit distance computations. Since numbers are often
    found in a corpus of text, this chapter will start by showing how to represent
    numbers in an arbitrary base as a string. We will cover a couple of string-searching
    algorithms and then focus on extracting text to study not only the words but also
    how the words are used together.
  prefs: []
  type: TYPE_NORMAL
- en: Many practical applications can be constructed given the simple set of tools
    provided in this section. For example, in the last recipe, we will demonstrate
    a way to correct spelling mistakes. How we use these algorithms is entirely up
    to our creativity, but at least having them at our disposal is an excellent start.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a number in another base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are a natural way to represent numbers in different bases due to the
    inclusion of letters as digits. This recipe will tell us how to convert a number
    to a string that can be printed as output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to import the following two functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to represent a number in a particular base as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the mapping between numbers and letters for digits larger than nine
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the result using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the printed output when running the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `showIntAtBase` function takes in a base, the desired number, and its mapping
    from number to printable digit. We order our digits in the following manner: 0,
    1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f, and so on, up to 36 characters. Putting
    it all together, we get a convenient way to represent a decimal number in any
    base.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read a string representing a number from another base as a decimal integer,
    refer to the *Reading a number from another base* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a number from another base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decimal, binary, and hexadecimal are widely used numeral systems that are often
    represented using a string. This recipe will show how to convert a string representation
    of a number in an arbitrary base to its decimal integer. We use the `readInt`
    function, which is the dual of the `showIntAtBase` function described in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import `readInt` and the following functions for character manipulation as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to convert a string representing a number in a particular
    base to a decimal integer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the mapping between letters and numbers for larger digits, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the result using the following line of codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The printed output is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `readInt` function reads an unsigned integral value and converts it to
    the specified base. It takes in the base as the first argument, valid characters
    as the second argument, and its mapping from character to number as the third
    argument. We order our digits in the following order: 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, a, b, c, d, e, f, and so on up to 36 characters. Putting it all together,
    we get a convenient way to convert a string representation of a number in an arbitrary
    base to a decimal number.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe assumes that a valid string is passed into the `base` function for
    conversion. Further error checks are necessary to ensure that erroneous input
    such as `"a" 'base' 4` should not result in an answer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do the reverse, refer to the *Displaying a number in another base* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a substring using Data.ByteString
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many algorithms to search for a string within another string. This
    recipe will use an existing `breakSubstring` function in the `Data.ByteString`
    library to do most of the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ByteString` documentation establishes its merits by declaring the following
    claim:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"[A ByteString is] a time- and space-efficient implementation of byte vectors
    using packed Word8 arrays, suitable for high performance use, both in terms of
    large data quantities, or high speed requirements. Byte vectors are encoded as
    strict Word8 arrays of bytes, held in a ForeignPtr, and can be passed between
    C and Haskell with little effort."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: More information and documentation can be obtained on the package web page at
    [http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html](http://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `breakSubstring` function as well as the `Data.ByteString.Char8`
    package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pack the strings as a `ByteString` and feed them into `breakSubstring` which
    has the following type: `ByteString -> ByteString -> (ByteString, ByteString)`.
    Then determine whether the string is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try out some tests in `main` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing `main` will print out the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `breakSubstring` function recursively checks if the pattern is a prefix
    of the string. To lazily find the first occurrence of a string, we can call `snd
    (breakSubstring pat str)`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another elegant way to quickly find a substring is by using the `isInfixOf`
    function provided by both `Data.List` and `Data.ByteString`. Moreover, we can
    also use the `OverloadedStrings` language extension to remove verbiage, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on the length of the pattern we're trying to find and the length of
    the whole string itself, other algorithms may provide better performance. Refer
    to the *Searching a string using the Boyer-Moore-Horspool algorithm* and *Searching
    a string using the Rabin-Karp algorithm* recipes for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a string using the Boyer-Moore-Horspool algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When searching for a pattern in a string, we refer to the pattern as the **needle**
    and the whole corpus as the **haystack**. The Horspool string search algorithm
    implemented in this recipe performs well for almost all pattern lengths and alphabet
    sizes, but is ideal for large alphabet sizes and large needle sizes. Empirical
    benchmarks can be found by navigating to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm](http://orion.lcg.ufrj.br/Dr.Dobbs/books/book5/chap10.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: By preprocessing the query, the algorithm is able to efficiently skip redundant
    comparisons. In this recipe, we will implement a simplified version called Horspool's
    algorithm, which achieves the same average best case as the Boyer-Moore algorithm,
    benefits from having a smaller overhead cost, but may in very rare circumstances
    suffer the same worst-case running time as the naive search when the algorithm
    performs too many matches. The Boyer-Moore algorithms should only be used if the
    extra prepossessing time and space required are acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using a couple `Data.Map` functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For convenience, define tuples representing character indices as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the search algorithm to use the recursive `bmh''` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Recursively find the pattern in the current index until the index moves past
    the length of the string, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following printed output displays the first index of the matching substring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This algorithm compares the desired pattern to a moving window through the text.
    The efficiency comes from how quickly the moving window shifts left to right through
    this text. In the Horspool algorithm, the query is compared to the current window
    character by character from right to left, and the window shifts by the size of
    the query in the best case.
  prefs: []
  type: TYPE_NORMAL
- en: Another version of the Horspool algorithm designed by Remco Niemeijer can be
    found at [http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore](http://bonsaicode.wordpress.com/2009/08/29/programming-praxis-string-search-boyer-moore).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Boyer-Moore algorithm ensures a faster worst case, but also endures slightly
    more initial overhead. Refer to the following commands to use the Boyer-Moore
    algorithm from the `Data.ByteString.Search` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Feed two `ByteString` types to the `indices` function to run the search as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out the following indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By benchmarking the performance of this library, we can see that longer search
    needles really improve runtime. We modify the code to search through a huge corpus
    of words from a file called `big.txt` to find multiple needles. Here, we use the
    `deepseq` function to force evaluation, so Haskell''s lazy nature won''t ignore
    it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compile this code with special runtime system (RTS) control for easy
    profiling as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We use the text from `norvig.com/big.txt` as our corpus. Searching for 25 long
    needles takes just about 0.06 seconds; however, searching for 25 short needles
    takes a sluggish 0.19 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For another efficient string searching algorithm, refer to the *Searching a
    string using the Rabin-Karp algorithm* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a string using the Rabin-Karp algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rabin-Karp algorithm finds a pattern in a body of text by matching a unique
    representation of the pattern against a moving window. The unique representation,
    or hash, is computed by considering a string as a number written in an arbitrary
    base of 26 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of Rabin-Karp is in searching for many needles in a haystack.
    It's not very efficient to search for just a single string. After the initial
    preprocessing of the corpus, the algorithm can quickly find matches.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `Data.ByteString.Search` library from Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `OverloadedStrings` language extension to facilitate the `ByteString`
    manipulations in our code as follows. It essentially allows polymorphic behavior
    for strings so that the GHC compiler may infer it as a `ByteString` type when
    necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the Rabin-Karp algorithms as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a couple of patterns to find and obtain the corpus from a `big.txt`
    file, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the Rabin-Karp algorithm on all the search patterns as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code prints out all indices found for each needle as a list of tuples. The
    first element of the tuple is the position in the haystack that the needle was
    found. The second element of the tuple is a list of indices of the needles. In
    our recipe, we find one instance of "preparing to go away" and two instances of
    "is some letter of recommendation."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rabin-Karp, a fixed window moves from left to right, comparing the unique
    hash values for efficient comparisons. The hash function converts a string to
    its numerical representation. Here''s an example of converting a string into base
    b equal to 256: *"hello" = h'' * b⁴ + e'' * b³ + l'' * b² + l'' * b¹ + o'' * b⁰*
    (which results in 448378203247), where each letter `h'' = ord h` (which results
    in 104), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see another efficient string searching algorithm, refer to the *Searching
    a string using the Boyer-Moore-Horspool algorithm* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a string on lines, words, or arbitrary tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Useful data is often interspersed between delimiters, such as commas or spaces,
    making string splitting vital for most data analysis tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an `input.txt` file similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `split` package using Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only function we will need is `splitOn`, which is imported as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First we split the string into lines, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The lines are printed in a list as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we separate a string on spaces as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The words are printed in a list as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we show how to split a string on an arbitrary value using the following
    lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The values are split on the commas as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we show splitting on multiple letters as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finding the longest common subsequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to compare string similarity is by finding their longest common subsequence.
    This is useful in finding differences between mutations of data such as source
    code or genome sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subsequence of a string is the same string with zero or more of the indices
    removed. So, some possible subsequences of "BITCOIN" could be "ITCOIN", "TON",
    "BIN", or even "BITCOIN" itself, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the longest common subsequence](img/6331OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The longest common subsequence is exactly what it sounds like. It is the longest
    subsequence common to both strings. For example, the longest common subsequence
    of "find the lights" and "there are four lights" is "the lights."
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the `data-memocombinators` package from Cabal. This allows us to minimize
    redundant computations to improve runtime as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only import we will need is this handy package to easily support memoization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a convenience function to enable memoization of functions that take
    in two string arguments, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the largest common subsequence function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Internally, define a function that returns the longer length string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the function on two strings as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the longest common subsequence between the two strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm is implemented naively, with memoization added to the recursive
    calls. If the first two items of a list are the same, then the longest common
    subsequence is the `lcs` function applied to the remaining parts of the list.
    Otherwise, the longest common subsequence is the longer of the two possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Naively, this algorithm will stall when given two strings as small as 10 characters
    each. Since the code breaks down to multiple identical subproblems, we can easily
    use a simple `memoize` function that remembers already computed values, improving
    the runtime dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Computing a phonetic code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we're dealing with a corpus of English words, then we can categorize them
    into phonetic codes to see how similar they sound. Phonetic codes work for any
    alphabetical strings, not just actual words. We will use the `Text.PhoneticCode`
    package to compute the Soundex and Phoneix phonetic codes. The package documentation
    can be found on Hackage at [http://hackage.haskell.org/package/phonetic-code](http://hackage.haskell.org/package/phonetic-code).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the phonetic code library from Cabal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the phonetic code functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a list of similar-sounding words as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the phonetic codes on these words, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be printed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `phonix` produces a finer categorization than `soundex`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithms perform simple string manipulations based on heuristic English-language-dependent
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metaphone is an improvement over the Soundex algorithm and can be found at [http://aspell.net/metaphone](http://aspell.net/metaphone).
  prefs: []
  type: TYPE_NORMAL
- en: Computing the edit distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The edit distance or Levenshtein distance is the minimum number of simple string
    operations required to convert one string into another. In this recipe, we will
    compute the edit distance based on only insertions, deletions, and substitutions
    of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Review the equation shown in the following figure obtained from the Wikipedia
    article about the Levenshtein distance ([http://en.wikipedia.org/wiki/Levenshtein_distance](http://en.wikipedia.org/wiki/Levenshtein_distance)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *a* and *b* are the two strings, and i and j are numbers representing
    their lengths.
  prefs: []
  type: TYPE_NORMAL
- en: The Haskell code will be a direct translation of this mathematical formula.
  prefs: []
  type: TYPE_NORMAL
- en: Also, install the `data-memocombinators` package from Cabal. This allows us
    to minimize redundant computations to improve runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only import we will need is the ability to easily memoize functions using
    the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the Levenshtein distance function exactly as described in the formula
    using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the indicator function that returns 1 if the characters don't match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a convenience function to enable memoization of functions that take
    in two string arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the edit distance between two strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This algorithm recursively tries all deletions, insertions, and substitutions
    and finds the minimum distance from one string to another.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another measurement is described in the *Computing the Jaro-Winkler distance
    between two strings* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the Jaro-Winkler distance between two strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jaro-Winkler distance measures string similarity represented as a real number
    between 0 and 1\. The value 0 corresponds to no similarity, and 1 corresponds
    to an identical match.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithm behind the function comes from the following mathematical formula
    presented in the Wikipedia article about the Jaro-Winkler distance [http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance](http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6331OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding formula, the following are the representations of the variables
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s1* is the first string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*s2* is the second string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* is the number of identical characters within a distance of at the most
    half the length of the longer string. These are called matching characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t* is half the number of matching characters that are not in the same index.
    In other words, it is half the number of transpositions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need access to the `elemIndices` function, which is imported as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the Jaro-Winkler function based on the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the variables used, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to convert an integer to `Double` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to find the number of matching characters within a
    specified distance, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a helper function to find the number of matching characters from a specific
    character at a specified index as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test out the algorithm by printing out a couple of examples as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The similarities are printed out as such, implying "marisa" is closer to "magical"
    than "haskell" is to "hackage".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to compute string similarity is defined in the previous recipe entitled
    *Computing the Edit Distance*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding strings within one-edit distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to find strings that are one-edit distance
    away from a specified string. This function can be used to correct spelling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm in this recipe is based heavily on Peter Norvig's spell corrector
    algorithm described at [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html).
    Take a look at and study the `edits1` Python function implemented there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import a couple of character and list functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to return strings that are one-edit distance away, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list of strings with one character deleted, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list of strings with two characters swapped, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list of strings with one of the characters replaced by another letter
    in the alphabet, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list of strings with one character inserted anywhere, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the alphabet and a helper function to convert a string to lowercase
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to obtain unique elements from a list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out all possible strings that are one-edit distance away from the following
    string, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'More intuitively, we''ve created a neighborhood of words that are different
    by only 1 insertion, deletion, or substitution, or transpositions. The following
    figure tries to show this neighborhood:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/6331OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can recursively apply `edit1` to find strings that are an arbitrary edit
    distance away. However, for values of *n* greater than three, this will take an
    unacceptably long time. In the following code, `edits1` `''` is a function that
    takes in a list of strings and produces all strings that are one-edit distance
    away from these. Then in `editsN`, we simply apply the `edits1''` function iteratively
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function is very useful in implementing a spell corrector described in
    the *Fixing spelling mistakes* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing spelling mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When gathering human-provided data, spelling mistakes may sneak in. This recipe
    will correct a misspelled word using Peter Norvig's simple heuristic spellchecker
    described at [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html).
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is just one approach to a very difficult problem in machine learning.
    We can use it as a starting point or as an influence to implement a more powerful
    solution with better results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to Norvig's spell-correction Python algorithm located at [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The core algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform raw text into lowercase alphabetical words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute a frequency map of all the words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define functions to produce all strings within an edit distance of one or two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find all possible candidates of a misspelling by looking up valid words within
    this edit distance of one or two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, pick out the candidate with the highest frequency of occurrence in
    the trained corpus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Haskell algorithm below mimics this Python code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to automatically correct the spelling of each word in a sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get the words from a body of text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute a frequency map of the words provided, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find strings one-edit distance away as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find words that are apart by an edit distance of two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function to obtain unique elements from a list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find known words from a list of strings as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Correct a spelling mistake by returning the most common candidate as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather a list of known words used in common literature from `big.txt`. The
    file is available at [http://norvig.com/big.txt](http://norvig.com/big.txt), or
    we can make our own. Test out the spell corrector as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The correct spellings are printed out as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm assumes that spelling mistakes occur one- or two-edit distances
    away. It establishes a list of known words within one- or two-edit distances and
    returns the most commonly used word based on the frequency map generated by reading
    in a corpus of real-world text.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This algorithm runs quickly, but it is very simplistic. This recipe provides
    a starting point to implement a spell corrector, but is certainly not state of
    the art. Some improvements that can be added to the code could involve parallelizing,
    caching, or designing better heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more in-depth analysis about the `edit1` function, refer to the *Finding
    strings within one-edit distance* recipe.
  prefs: []
  type: TYPE_NORMAL
