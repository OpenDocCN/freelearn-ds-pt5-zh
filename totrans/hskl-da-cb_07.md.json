["```py\n$ cat input.txt\n\n4\n3\n2\n5\n3\n4\n1\n3\n12\n3\n\n```", "```py\n    clean raw = map (\\s -> read s :: Double) (lines raw)\n    ```", "```py\n    avg :: [Double] -> Double\n    avg (x:xs) = a*x + (1-a)*(avg xs)\n    where a = 0.95\n    avg [] = 0\n    ```", "```py\n    mean xs = (sum xs) / (fromIntegral (length xs))\n    ```", "```py\n    main = do\n    rawInput <- readFile \"input.txt\"\n    let input = clean rawInput\n    print input\n    putStrLn $  \"mean is \" ++ (show.mean) input\n    putStrLn $  \"moving average is \" ++ (show.avg) input\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [4.0,3.0,2.0,5.0,3.0,4.0,1.0,3.0,12.0,3.0]\n    mean is 4.0\n    moving average is 3.9478627675211913\n    ```", "```py\n$ cat input.txt\n\n3\n4\n2\n5\n6\n4\n2\n6\n4\n1\n\n```", "```py\n$ cabal install heap\n\n```", "```py\n    import Data.Heap\n    import Data.Maybe (fromJust)\n    ```", "```py\n    clean raw = map (\\s -> read s :: Int) (lines raw)\n    ```", "```py\n    median (x:xs) maxheap minheap = case viewHead maxheap of\n      Just theMax  -> if x < theMax\n                 then median xs (insert x maxheap) minheap\n                 else median xs maxheap (insert x minheap)\n      Nothing -> median xs (insert x maxheap) minheap\n    ```", "```py\n    median [] maxheap minheap\n      | size maxheap + 1 < size minheap = \n                     median [] (insert minelem maxheap) $ \n           (snd.fromJust.view) minheap\n      | size minheap + 1 < size maxheap = \n                  median [] ((snd.fromJust.view) maxheap) $ \n                  insert maxelem minheap\n      | size maxheap == size minheap = \n        (fromIntegral maxelem + fromIntegral minelem)/2.0\n      | size maxheap > size minheap = fromIntegral maxelem\n      | otherwise = fromIntegral minelem\n      where maxelem = fromJust (viewHead maxheap)\n            minelem = fromJust (viewHead minheap)\n    ```", "```py\n    main = do\n      rawInput <- readFile \"input.txt\"\n      let input = clean rawInput\n     print $ input\n    print $ median input \n           (empty :: MaxHeap Int) (empty :: MinHeap Int)\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [3,4,2,5,6,4,2,6,4,1]\n    4.0\n\n    ```", "```py\n$ cabal install statistics-linreg\n\n```", "```py\n    import Statistics.LinearRegression\n    import qualified Data.Vector.Unboxed as U\n    ```", "```py\n    main = do\n      let xs =\n        U.fromList [1.0, 2.0, 3.0, 4.0, 5.0] :: U.Vector Double\n      let ys = \n        U.fromList [1.0, 2.0, 1.3, 3.75, 2.25]::U.Vector Double\n\n      let (b, m) = linearRegression xs ys\n\n      print $ concat [\"y = \", show m, \" x + \", show b]\n    ```", "```py\n    $ runhaskell Main.hs\n\n    \"y = 0.425 x + 0.785\"\n\n    ```", "```py\n$ cabal install dsp\n\n```", "```py\n    import Data.Array (listArray, elems)\n    import Matrix.LU (solve)\n    ```", "```py\n    fit d vals = elems $ solve mat vec  \n    where mat = listArray ((1,1), (d,d)) $ matrixArray\n       vec = listArray (1,d) $ take d vals\n       matrixArray = concat [ polys x d \n                                    | x <- [0..fromIntegral (d-1)]]\n             polys x d = map (x**) [0..fromIntegral (d-1)]\n    ```", "```py\n    main = print $ fit 3 [1,6,17,34,57,86,121,162,209,262,321]\n    ```", "```py\n     $ runhaskell Main.hs\n\n     [1.0,2.0,3.0]\n\n    ```", "```py\n$ cabal install hstats\n\n```", "```py\n    $ cabal install\n\n    ```", "```py\n    import Math.Statistics\n    ```", "```py\n    main = do print $ covMatrix matrixArray\n      where matrixArray = [ [1,1,0,0] \n                          , [0,1,0,1] \n                          , [1,1,0,1] ]\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [ [ 0.333, 0.000, 0.167]\n    , [ 0.000, 0.333, 0.167]\n    , [ 0.167, 0.167, 0.250] ]\n\n    ```", "```py\n    import Data.List (tails, nub, sort)\n    ```", "```py\n    pairs xs = [(x, y) | (x:ys) <- tails (nub xs), y <- ys]\n    ```", "```py\n    main = print $ pairs [1,2,3,3,4]\n    ```", "```py\n    [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]\n\n    ```", "```py\n$ cabal install hstats\n\n```", "```py\n$ cat ratings.csv\n4,5,4,4,3\n2,5,4,3,1\n5,5,5,5,5\n\n```", "```py\n    import Math.Statistics (pearson)\n    import Text.CSV\n    import Data.List (tails, nub, sort)\n    ```", "```py\n    calcSimilarities (Left err) = error \"error parsing\"\n    calcSimilarities (Right csv) = head $ reverse $ sort $ zip \n      [ pearson (convertList a) (convertList b) \n      | (a,b) <- pairs csv]\n      $ (pairs csv)\n    ```", "```py\n    convertList :: [String] -> [Double]\n\n    convertList = map read\n    ```", "```py\n    pairs xs = [(x, y) | (x:ys) <- tails (nub xs), y <- ys]\n    ```", "```py\n    main = do\n      let fileName = \"ratings.csv\"\n      input <- readFile filename\n\n      let csv = parseCSV fileName input\n\n      print $ calcSimilarities csv\n    ```", "```py\n    $ runhaskell Main.hs\n\n    (0.89442719909999159,([\"4\",\"5\",\"4\",\"4\",\"3\"],[\"2\",\"5\",\"4\",\"3\",\"1\"]))\n\n    ```", "```py\n$ cabal install probability\n\n```", "```py\n    import qualified Numeric.Probability.Distribution as Dist\n    import Numeric.Probability.Distribution ((??), (?=<<), )\n    ```", "```py\n    prob p = Dist.choose p True False\n    ```", "```py\n    a :: Dist.T Rational Bool\n    a = prob 0.2\n    ```", "```py\n    b :: Dist.T Rational Bool\n    b = prob 0.05\n    ```", "```py\n    c :: Bool -> Bool -> Dist.T Rational Bool\n    c False False = prob 0.9\n    c False True = prob 0.5\n    c True False = prob 0.3\n    c True True = prob 0.1\n    ```", "```py\n    d :: Bool -> Dist.T Rational Bool\n    d False = prob 0.1\n    d True = prob 0.4\n    ```", "```py\n    e :: Bool -> Dist.T Rational Bool\n    e False = prob 0.5\n    e True = prob 0.2\n    ```", "```py\n    data Network = N {aVal :: Bool\n    , bVal :: Bool\n    , cVal :: Bool\n    , dVal :: Bool\n    , eVal :: Bool }\n    deriving (Eq, Ord, Show)\n    ```", "```py\n    bNetwork :: Dist.T Rational Network\n    bNetwork = do a' <- a\n                  b' <- b\n                  c' <- c a' b'\n                  d' <- d c'\n                  e' <- e c'\n                  return (N a' b' c' d' e')\n    ```", "```py\n    main = print $ eVal ?? dVal ?=<< bNetwork\n    ```", "```py\n    $ runhaskell Main.hs\n\n    3643 % 16430\n\n    ```", "```py\n$ cabal install probability\n\n```", "```py\n    import qualified Numeric.Probability.Distribution as Dist\n    import Numeric.Probability.Distribution ((??))\n    import Control.Monad.Trans.State (StateT(StateT, runStateT), evalStateT)\n    import Control.Monad (replicateM)\n    import Data.List (delete)\n    ```", "```py\n    data Suit = Club | Spade | Heart | Diamond\n      deriving (Eq,Ord,Show,Enum)\n    ```", "```py\n    data Rank = Plain Int | Jack | Queen | King | Ace\n      deriving (Eq,Ord,Show)\n    ```", "```py\n    type Card = (Rank,Suit)\n    ```", "```py\n    plains :: [Rank]\n    plains = map Plain [2..10]\n    ```", "```py\n    faces :: [Rank]\n    faces = [Jack,Queen,King,Ace]\n    ```", "```py\n    isFace :: Card -> Bool\n    isFace (r,_) = r `elem` faces\n    ```", "```py\n    isPlain :: Card -> Bool\n    isPlain (r,_) = r `elem` plains\n    ```", "```py\n    ranks :: [Rank]\n    ranks = plains ++ faces\n    ```", "```py\n    suits :: [Suit]\n    suits = [Club, Spade, Heart, Diamond]\n    ```", "```py\n    deck :: [Card]\n    deck = [ (r,s) | r <- ranks, s <- suits ]\n    ```", "```py\n    selectOne :: (Fractional prob, Eq a) =>\n       StateT ([a]) (Dist.T prob) a\n    selectOne =\n       StateT $ Dist.uniform . removeEach\n    ```", "```py\n    select :: (Fractional prob, Eq a) => Int -> [a] -> Dist.T prob [a]\n    select n = evalStateT (replicateM n selectOne)\n    ```", "```py\n    removeEach xs = zip xs (map (flip delete xs) xs)\n    ```", "```py\n    main = print $ \n    Dist.just [(Plain 3, Heart), (Plain 3, Diamond)] ?? select 2 deck\n    ```", "```py\n    3.770739064856712e-4\n\n    ```", "```py\n$ cabal install markov-chain\n\n```", "```py\n    import Data.MarkovChain\n    import System.Random (mkStdGen)\n    ```", "```py\n    main = do\n    rawText <- readFile \"big.txt\"\n    let g = mkStdGen 100\n    putStrLn $ \"Character by character: \\n\"\n    putStrLn $ take 100 $ run 3 rawText 0 g\n    putStrLn $ \"\\nWord by word: \\n\"\n    putStrLn $ unwords $ take 100 $ run 2 (words rawText)0 g\n    ```", "```py\n    $ runhaskell Main.hs\n\n    Generated character by character: \n\n    The evaturn bring everice Ana Paciously skuling from to was\n    fing, of rant of and sway.\n\n    5\\. Whendent \n\n    Generated word by word: \n\n    The Project gratefully accepts contributions of money, though there was a brief word, showing that he would do so. He could hear all that she had to reply; the room scanned Princess Mary's heartbeat so violently at this age, so dangerous to life, by the friends of the Russians, was trying to free his serfs--and that till the eggs mature, when by their Creator with certain small vessels but no me....\" And the cavalry, Colonel, but I don't wish to know which it has a fit, and there was a very large measure, attributed to eating this root. But\n\n    ```", "```py\n    ngram :: Int -> [a] -> [[a]]\n    ngram n xs \n      | n <= length xs = take n xs : ngram n (drop 1 xs)\n      | otherwise = []\n    ```", "```py\n    main = print $ ngram 3 \"hello world\"\n    ```", "```py\n    [\"hel\",\"ell\",\"llo\",\"lo \",\"o w\",\" wo\",\"wor\",\"orl\",\"rld\"]\n\n    ```", "```py\n    import Control.Monad (replicateM)\n    import System.Random (randomR, getStdRandom)\n    ```", "```py\n    type Inputs = [Float]\n    type Weights = [Float]\n    type Threshold = Float\n    type Output = Float\n    type Expected = Float\n    type Actual = Float\n    type Delta = Float\n    type Interval = Int\n    type Step = (Weights, Interval)\n    ```", "```py\n    output :: Inputs -> Weights -> Threshold -> Output\n    output xs ws t \n      | (dot xs ws) > t = 1\n      | otherwise = 0\n      where dot as bs = sum $ zipWith (*) as bs\n    ```", "```py\n    adjustWeights :: Inputs -> Weights -> Expected -> Actual -> Weights\n    adjustWeights xs ws ex ac = add ws delta\n      where delta = map (err * learningRate *) xs\n            add = zipWith (+)\n            err = ex - ac\n            learningRate = 0.1\n    ```", "```py\n    step :: Inputs -> Weights -> Expected -> Weights\n    step xs ws ex = adjustWeights xs ws ex (output xs ws t)\n      where t = 0.2\n    ```", "```py\n    epoch :: [(Inputs, Expected)] -> Weights -> (Weights, Delta)\n    epoch inputs ws = (newWeights, delta)\n      where newWeights = foldl \n        (\\acc (xs, ex) -> step xs acc ex) ws inputs\n        delta = (sum (absSub newWeights ws)) / length' ws\n        absSub as bs = map abs $ zipWith (-) as bs\n        length' = fromIntegral . length\n    ```", "```py\n    run :: [(Inputs, Expected)] -> Weights -> Interval -> Step\n    run inputs ws n\n      | delta == 0.0 = (newWeights, n)\n      | otherwise = run inputs newWeights (n+1)\n      where (newWeights, delta) = epoch inputs ws\n    ```", "```py\n    initialWeights :: Int -> IO [Float]\n    initialWeights nb = do\n      let interval = randomR (-0.5,0.5)\n      (replicateM nb (getStdRandom interval))        \n    ```", "```py\n    main :: IO ()\n    main = do\n      w <- initialWeights 2\n      let (ws,i) = run [ ([0,0],0)\n                       , ([0,1],0)\n                       , ([1,0],0)\n                       , ([1,1],1) ] w 1\n      print (ws,i)\n    ```", "```py\n    ([0.17867908,3.5879448e-1],8)\n\n    ```"]