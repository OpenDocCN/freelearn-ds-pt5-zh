<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 2. Python Environments"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 2. Python Environments</h1></div></div></div><p class="calibre11">In this chapter, we will cover the following recipes:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Using NumPy libraries</li><li class="listitem">Plotting with matplotlib</li><li class="listitem">Machine learning with scikit-learn</li></ul></div><div class="calibre2" title="Introduction"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec33" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Introduction</h1></div></div></div><p class="calibre11">In this chapter, we will introduce you to the Python environment, which will be used extensively throughout this book. We will start with NumPy, which is a Python library that is used to handle arrays and matrices efficiently. It forms the basis for most of the other libraries used in this book. We <a id="id112" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>will then introduce a Python plotting library called matplotlib. Our final recipe is about a machine learning library called scikit-learn.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Using NumPy libraries"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec34" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Using NumPy libraries</h1></div></div></div><p class="calibre11">NumPy provides <a id="id113" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>an efficient way of handling very large arrays in Python. Most of the Python scientific libraries use NumPy internally for the array and matrix operations. In this book, we will be using NumPy extensively. We will introduce NumPy in this recipe.</p><div class="calibre2" title="Getting ready"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec101" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Getting ready</h2></div></div></div><p class="calibre11">We will write a series of Python statements manipulating arrays and matrices, and learn how to use NumPy on the way. Our intent is to get you used to working with NumPy arrays, as NumPy will serve as the basis for most of the recipes in this book.</p></div><div class="calibre2" title="How to do it…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec102" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How to do it…</h2></div></div></div><p class="calibre11">Let's start by creating some simple matrices and arrays:</p><div class="calibre2"><pre class="programlisting">#Recipe_1a.py
# Importing numpy as np
import numpy as np
# Creating arrays
a_list = [1,2,3]
an_array = np.array(a_list)
# Specify the datatype
an_array = np.array(a_list,dtype=float)


# Creating matrices
a_listoflist = [[1,2,3],[5,6,7],[8,9,10]]
a_matrix = np.matrix(a_listoflist,dtype=float)</pre></div><p class="calibre11">Now we will write a small convenience function in order to inspect our NumPy objects:</p><div class="calibre2"><pre class="programlisting">#Recipe_1b.py
# A simple function to examine given numpy object 
def display_shape(a):
    print 
    print a
    print
    print "Nuber of elements in a = %d"%(a.size)
    print "Number of dimensions in a = %d"%(a.ndim)
    print "Rows and Columns in a ",a.shape
    print 

display_shape(a_matrix)</pre></div><p class="calibre11">Let's see some <a id="id114" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>alternate ways of creating arrays:</p><div class="calibre2"><pre class="programlisting">#Recipe_1c.py
# Alternate ways of creating arrays
# 1. Leverage np.arange to create numpy array
created_array = np.arange(1,10,dtype=float)
display_shape(created_array)

# 2. Using np.linspace to create numpy array
created_array = np.linspace(1,10)
display_shape(created_array)

# 3. Create numpy arrays in using np.logspace
created_array = np.logspace(1,10,base=10.0)
display_shape(created_array)

# Specify step size in arange while creating
# an array. This is where it is different
# from np.linspace
created_array = np.arange(1,10,2,dtype=int)
display_shape(created_array)</pre></div><p class="calibre11">We will now look at the creation of some special matrices:</p><div class="calibre2"><pre class="programlisting">#Recipe_1d.py
# Create a matrix will all elements as 1
ones_matrix = np.ones((3,3))
display_shape(ones_matrix)
# Create a matrix with all elements as 0
zeros_matrix = np.zeros((3,3))
display_shape(zeros_matrix)

# Identity matrix
# k parameter  controls the index of 1
# if k =0, (0,0),(1,1,),(2,2) cell values
# are set to 1 in a 3 x 3 matrix
identity_matrix = np.eye(N=3,M=3,k=0)
display_shape(identity_matrix)
identity_matrix = np.eye(N=3,k=1)
display_shape(identity_matrix)</pre></div><p class="calibre11">Armed with the knowledge of array and matrix creation, let's see some shaping operations:</p><div class="calibre2"><pre class="programlisting">Recipe_1e.py
# Array shaping
a_matrix = np.arange(9).reshape(3,3)
display_shape(a_matrix)
.
.
.
display_shape(back_array)</pre></div><p class="calibre11">Now, proceed to see some matrix operations:</p><div class="calibre2"><pre class="programlisting">#Recipe_1f.py
# Matrix operations
a_matrix = np.arange(9).reshape(3,3)
b_matrix = np.arange(9).reshape(3,3)
.
.
.
print "f_matrix, row sum",f_matrix.sum(axis=1)</pre></div><p class="calibre11">Finally, let's see some reverse, copy, and grid operations:</p><div class="calibre2"><pre class="programlisting">#Recipe_1g.py
# reversing elements
display_shape(f_matrix[::-1])
.
.
.
zz = zz.flatten()</pre></div><p class="calibre11">Let's look at some <a id="id115" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>random number generation routines in the NumPy library:</p><div class="calibre2"><pre class="programlisting">#Recipe_1h.py
# Random numbers
general_random_numbers = np.random.randint(1,100, size=10)
print general_random_numbers
.
.
.
uniform_rnd_numbers = np.random.normal(loc=0.2,scale=0.2,size=(3,3))</pre></div></div><div class="calibre2" title="How it works…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec103" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How it works…</h2></div></div></div><p class="calibre11">Let's start by including the NumPy library:</p><div class="calibre2"><pre class="programlisting"># Importing numpy as np
import numpy as np</pre></div><p class="calibre11">Let's proceed with looking at the various ways in which we can create an array in NumPy:</p><div class="calibre2"><pre class="programlisting"># Arrays
a_list = [1,2,3]
an_array = np.array(a_list)
# Specify the datatype
an_array = np.array(a_list,dtype=float)</pre></div><p class="calibre11">An array can be created from a list. In the preceding example, we declared a list of three elements. We can then use <code class="literal">np.array()</code> to convert the list to a NumPy one-dimensional array.</p><p class="calibre11">The datatype can <a id="id116" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>also be specified, as seen in the last line of the preceding code:</p><p class="calibre11">We will now move from arrays to matrices:</p><div class="calibre2"><pre class="programlisting"># Matrices
a_listoflist = [[1,2,3],[5,6,7],[8,9,10]]
a_matrix = np.matrix(a_listoflist,dtype=float)</pre></div><p class="calibre11">We will create a matrix from a <code class="literal">listoflist</code>. Once again, we can specify the datatype.</p><p class="calibre11">Before we move further, we will define a <code class="literal">display_shape</code> function. We will use this function frequently further on:</p><div class="calibre2"><pre class="programlisting">def display_shape(a):
    print 
    print a
    print
    print "Nuber of elements in a = %d"%(a.size)
    print "Number of dimensions in a = %d"%(a.ndim)
    print "Rows and Columns in a ",a.shape
    print</pre></div><p class="calibre11">Every NumPy object <a id="id117" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>has the following three properties:</p><p class="calibre11">
<span class="strong1"><strong class="calibre12">size</strong></span>: The number of elements in the given NumPy object</p><p class="calibre11">
<span class="strong1"><strong class="calibre12">ndim</strong></span>: The number of dimensions</p><p class="calibre11">
<span class="strong1"><strong class="calibre12">shape</strong></span>: The shape returns a tuple with the dimensions of the object</p><p class="calibre11">This function prints out all the three properties in addition to printing the original element.</p><p class="calibre11">Let's call this function with the matrix that we created previously:</p><div class="calibre2"><pre class="programlisting">display_shape(a_matrix)</pre></div><div class="mediaobject"><img src="Images/B04041_02_01.jpg" alt="How it works…" class="calibre21"/></div><p class="calibre11">As you can see, our matrix has nine elements in it, and there are two dimensions. Finally, we can see the shape displays both the dimensions and number of elements in each dimension. In this case, we have a matrix with three rows and three columns.</p><p class="calibre11">Let's now see a couple of other ways of creating arrays:</p><div class="calibre2"><pre class="programlisting">created_array = np.arange(1,10,dtype=float)
display_shape(created_array)</pre></div><p class="calibre11">The NumPy arrange function returns evenly spaced values in the given interval. In this case, we want an evenly spaced number between 1 and 10. Refer to the following link for more information <a id="id118" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>about arange:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html">http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html</a>
</p><div class="calibre2"><pre class="programlisting"># An alternate way to create array
created_array = np.linspace(1,10)
display_shape(created_array)</pre></div><p class="calibre11">NumPy's <code class="literal">linspace</code> is <a id="id119" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>similar to arrange. The difference is how we will request the number of samples that are required. With <code class="literal">linspace</code>, we can say how many elements we need between the given range. By default, it returns 50 elements. However, in arange, we will need to specify the step size:</p><div class="calibre2"><pre class="programlisting">created_array = np.logspace(1,10,base=10.0)
display_shape(created_array)</pre></div><p class="calibre11">NumPy provides you with several functions to create special types of arrays:</p><div class="calibre2"><pre class="programlisting">ones_matrix = np.ones((3,3))
display_shape(ones_matrix)

# Create a matrix with all elements as 0
zeros_matrix = np.zeros((3,3))
display_shape(zeros_matrix)</pre></div><p class="calibre11">The <code class="literal">ones()</code> and <code class="literal">zeros()</code> functions are used to create a matrix with 1 and 0 respectively:</p><div class="mediaobject"><img src="Images/B04041_02_02.jpg" alt="How it works…" class="calibre22"/></div><p class="calibre11">Identity that the matrices are created, as follows:</p><div class="calibre2"><pre class="programlisting">identity_matrix = np.eye(N=3,M=3,k=0)
display_shape(identity_matrix)</pre></div><p class="calibre11">The <code class="literal">k</code> parameter <a id="id120" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>controls the index where value <code class="literal">1</code> has to start:</p><div class="calibre2"><pre class="programlisting">identity_matrix = np.eye(N=3,k=1)
display_shape(identity_matrix)</pre></div><div class="mediaobject"><img src="Images/B04041_02_03.jpg" alt="How it works…" class="calibre23"/></div><p class="calibre11">The shape of the arrays can be controlled by the <code class="literal">reshape</code> function:</p><div class="calibre2"><pre class="programlisting"># Array shaping
a_matrix = np.arange(9).reshape(3,3)
display_shape(a_matrix)</pre></div><p class="calibre11">By passing <code class="literal">-1</code>, we can <a id="id121" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>reshape the array to as many dimensions as needed:</p><div class="calibre2"><pre class="programlisting"># Paramter -1 refers to as many as dimension needed
back_to_array = a_matrix.reshape(-1)
display_shape(back_to_array)</pre></div><div class="mediaobject"><img src="Images/B04041_02_04.jpg" alt="How it works…" class="calibre24"/></div><p class="calibre11">The <code class="literal">ravel</code> and <code class="literal">flatten</code> functions can be used to convert a matrix to a one-dimensional array:</p><div class="calibre2"><pre class="programlisting">a_matrix = np.arange(9).reshape(3,3)
back_array = np.ravel(a_matrix)
display_shape(back_array)

a_matrix = np.arange(9).reshape(3,3)
back_array = a_matrix.flatten()
display_shape(back_array)</pre></div><div class="mediaobject"><img src="Images/B04041_02_05.jpg" alt="How it works…" class="calibre25"/></div><p class="calibre11">
</p><p class="calibre11">Let's look at some matrix operations, such as addition:</p><div class="calibre2"><pre class="programlisting">c_matrix = a_matrix + b_matrix</pre></div><p class="calibre11">We will also look at element-wise multiplication:</p><div class="calibre2"><pre class="programlisting">d_matrix = a_matrix * b_matrix</pre></div><p class="calibre11">The following code shows a matrix multiplication operation:</p><div class="calibre2"><pre class="programlisting">e_matrix = np.dot(a_matrix,b_matrix)</pre></div><p class="calibre11">Finally, we will <a id="id122" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>transpose a matrix:</p><div class="calibre2"><pre class="programlisting">f_matrix = e_matrix.T</pre></div><p class="calibre11">The <code class="literal">min</code> and <code class="literal">max</code> functions can be used to find the minimum and maximum elements in a matrix. The <code class="literal">sum</code> function can be used to find the sum of the rows or columns in a matrix:</p><div class="calibre2"><pre class="programlisting">print
print "f_matrix,minimum = %d"%(f_matrix.min())
print "f_matrix,maximum = %d"%(f_matrix.max())
print "f_matrix, col sum",f_matrix.sum(axis=0)
print "f_matrix, row sum",f_matrix.sum(axis=1)</pre></div><div class="mediaobject"><img src="Images/B04041_02_06.jpg" alt="How it works…" class="calibre26"/></div><p class="calibre11">The elements of a matrix can be reversed in the following way:</p><div class="calibre2"><pre class="programlisting"># reversing elements
display_shape(f_matrix[::-1])</pre></div><p class="calibre11">The <code class="literal">copy</code> function can be used to copy a matrix, as follows:</p><div class="calibre2"><pre class="programlisting"># Like python all elements are used by reference
# if copy is needed copy() command is used
f_copy = f_matrix.copy()</pre></div><p class="calibre11">Finally, let's look at the <a id="id123" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>mgrid functionality:</p><div class="calibre2"><pre class="programlisting"># Grid commands
xx,yy,zz = np.mgrid[0:3,0:3,0:3]
xx = xx.flatten()
yy = yy.flatten()
zz = zz.flatten()</pre></div><p class="calibre11">The <code class="literal">mgrid</code> functionality can be used to get the coordinates in the m-dimension. In the preceding example, we have three dimensions. In each dimension, our values range from <code class="literal">0</code> to <code class="literal">3</code>. Let us print <code class="literal">xx</code>, <code class="literal">yy</code>, and <code class="literal">zz</code> to understand a bit more:</p><div class="mediaobject"><img src="Images/B04041_02_07.jpg" alt="How it works…" class="calibre27"/></div><p class="calibre11">Let's see the first element of each array. [<code class="literal">0</code>,<code class="literal">0</code>,<code class="literal">0</code>] is the first coordinate in our three-dimensional space. The second element in all three arrays, [<code class="literal">0</code>,<code class="literal">0</code>,<code class="literal">1</code>] is another point in our space. Similarly, using <code class="literal">mgrid</code>, we captured all the points in our three-dimensional coordinate system.</p><p class="calibre11">NumPy provides us with a module called random in order to give routines, which can be used to generate random numbers. Let's look at some examples of random number generation:</p><div class="calibre2"><pre class="programlisting"># Random numbers
general_random_numbers = np.random.randint(1,100, size=10)
print general_random_numbers</pre></div><p class="calibre11">Using the <code class="literal">randint</code> function in the random module, we can generate random integer numbers. We can pass the <code class="literal">start</code>, <code class="literal">end</code>, and <code class="literal">size</code> parameters. In our case, our start is <code class="literal">1</code>, our end is <code class="literal">100</code>, and our size is <code class="literal">10</code>. We want 10 random integers between 1 and 100. Let's look at the output that is returned:</p><div class="mediaobject"><img src="Images/B04041_02_23.jpg" alt="How it works…" class="calibre28"/></div><p class="calibre11">Random numbers from other distributions can also be produced. Let's see an example where we get 10 random numbers from a <code class="literal">normal</code> distribution:</p><div class="calibre2"><pre class="programlisting">uniform_rnd_numbers = np.random.normal(loc=0.2,scale=0.2,size=10)
print uniform_rnd_numbers</pre></div><p class="calibre11">Using the <code class="literal">normal</code> function, we will generate a random sample from a <code class="literal">normal</code> distribution. The mean and standard deviation parameters of the <code class="literal">normal</code> distribution are specified by the <code class="literal">loc</code> and <code class="literal">scale</code> parameters. Finally, <code class="literal">size</code> determines the number of samples.</p><p class="calibre11">By passing a tuple with the row and column values, we can generate a random matrix as well:</p><div class="calibre2"><pre class="programlisting">uniform_rnd_numbers = np.random.normal(loc=0.2,scale=0.2,size=(3,3))</pre></div><p class="calibre11">In the preceding example, we generated a 3 x 3 matrix, which is shown in the following code:</p><div class="mediaobject"><img src="Images/B04041_02_24.jpg" alt="How it works…" class="calibre29"/></div></div><div class="calibre2" title="There's more…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec104" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>There's more…</h2></div></div></div><p class="calibre11">You can refer to the <a id="id124" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>following link for some excellent NumPy <a id="id125" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>documentation:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.numpy.org/">http://www.numpy.org/</a>
</p></div><div class="calibre2" title="See also"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec105" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>See also</h2></div></div></div><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><span class="strong1"><em class="calibre15">Plotting with matplotlib</em></span> recipe in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch03.xhtml" title="Chapter 3. Data Analysis – Explore and Wrangle">Chapter 3</a>, <span class="strong1"><em class="calibre15">Analyzing Data - Explore &amp; Wrangle</em></span></li><li class="listitem"><span class="strong1"><em class="calibre15">Machine Learning with Scikit Learn</em></span> recipe in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch03.xhtml" title="Chapter 3. Data Analysis – Explore and Wrangle">Chapter 3</a>, <span class="strong1"><em class="calibre15">Analyzing Data - Explore &amp; Wrangle</em></span></li></ul></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Plotting with matplotlib"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec35" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Plotting with matplotlib</h1></div></div></div><p class="calibre11">Matplotlib <a id="id126" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Python is a two-dimensional plotting library. All kinds of plots, including histograms, scatter plots, line plots, dot plots, heat maps, and others, can be generated by Python. In this book, we will use the <code class="literal">pyplot</code> interface of <code class="literal">matplotlib</code> for all our visualization requirements.</p><div class="calibre2" title="Getting ready"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec106" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Getting ready</h2></div></div></div><p class="calibre11">In this recipe, we will introduce basic plotting mechanisms using <code class="literal">pyplot</code>. We will use <code class="literal">pyplot</code> in almost all our recipes for visualization in this book.</p><p class="calibre11">We used matplotlib version 1.3.1 for all the recipes in this book. In your command line, you can invoke the <code class="literal">__version__</code> attribute to check for the version:</p><div class="mediaobject"><img src="Images/B04041_02_14.jpg" alt="Getting ready" class="calibre30"/></div></div><div class="calibre2" title="How to do it…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec107" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How to do it…</h2></div></div></div><p class="calibre11">Let's start by <a id="id127" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>looking at how to plot simple graphs using matplotlib's <code class="literal">pyplot</code> module:</p><div class="calibre2"><pre class="programlisting">#Recipe_2a.py
import numpy as np
import matplotlib.pyplot as plt
def simple_line_plot(x,y,figure_no):
    plt.figure(figure_no)
    plt.plot(x,y)
    plt.xlabel('x values')
    plt.ylabel('y values')
    plt.title('Simple Line')
    
    
def simple_dots(x,y,figure_no):
    plt.figure(figure_no)
    plt.plot(x,y,'or')
    plt.xlabel('x values')
    plt.ylabel('y values')
    plt.title('Simple Dots')
    
    
def simple_scatter(x,y,figure_no):
    plt.figure(figure_no)
    plt.scatter(x,y)
    plt.xlabel('x values')
    plt.ylabel('y values')
    plt.title('Simple scatter')
    

def scatter_with_color(x,y,labels,figure_no):
    plt.figure(figure_no)
    plt.scatter(x,y,c=labels)
    plt.xlabel('x values')
    plt.ylabel('y values')
    plt.title('Scatter with color')
    


if __name__ == "__main__":

    plt.close('all')
    # Sample x y data for line and simple dot plots
    x = np.arange(1,100,dtype=float)
    y = np.array([np.power(xx,2) for xx in x])
    
    figure_no=1
    simple_line_plot(x,y,figure_no)
    figure_no+=1
    simple_dots(x,y,figure_no)

 
    # Sample x,y data for scatter plot
    x = np.random.uniform(size=100)
    y = np.random.uniform(size=100)
    
    figure_no+=1
    simple_scatter(x,y,figure_no)
    figure_no+=1
    label = np.random.randint(2,size=100)
    scatter_with_color(x,y,label,figure_no)
    plt.show()</pre></div><p class="calibre11">Now we will proceed to look at some advanced topics, including generating heat maps and labeling the <span class="strong1"><em class="calibre15">x</em></span> and <span class="strong1"><em class="calibre15">y</em></span> axes:</p><div class="calibre2"><pre class="programlisting">#Recipe_2b.py
import numpy as np
import matplotlib.pyplot as plt
def x_y_axis_labeling(x,y,x_labels,y_labels,figure_no):
    plt.figure(figure_no)
    plt.plot(x,y,'+r')
    plt.margins(0.2)
    plt.xticks(x,x_labels,rotation='vertical')
    plt.yticks(y,y_labels,)
    

def plot_heat_map(x,figure_no):
    plt.figure(figure_no)
    plt.pcolor(x)
    plt.colorbar()


if __name__ == "__main__":

    plt.close('all')
    x = np.array(range(1,6))
    y = np.array(range(100,600,100))
    x_label = ['element 1','element 2','element 3','element 4','element 5']
    y_label = ['weight1','weight2','weight3','weight4','weight5']
    
    x_y_axis_labeling(x,y,x_label,y_label,1)
    
    
    x = np.random.normal(loc=0.5,scale=0.2,size=(10,10))
    plot_heat_map(x,2)
    
    plt.show()</pre></div></div><div class="calibre2" title="How it works…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec108" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How it works…</h2></div></div></div><p class="calibre11">We will start by importing the required modules. While using <code class="literal">pyplot</code>, it's recommended that you import NumPy:</p><div class="calibre2"><pre class="programlisting">import numpy as np
import matplotlib.pyplot as plt</pre></div><p class="calibre11">Let's start by following the code from the main function. There may be graphs from the previously run program. It is good practice to close them all, as we will use more graphs in our program:</p><div class="calibre2"><pre class="programlisting">    plt.close('all')</pre></div><p class="calibre11">We will proceed by generating some data using NumPy to demonstrate plotting using <code class="literal">pyplot</code>:</p><div class="calibre2"><pre class="programlisting">    # Sample x y data for line and simple dot plots
    x = np.arange(1,100,dtype=float)
    y = np.array([np.power(xx,2) for xx in x])</pre></div><p class="calibre11">We generated 100 <a id="id128" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>elements in both our x and y variables. Our y is a square of our x variable.</p><p class="calibre11">Let's proceed to doing a simple line plot:</p><div class="calibre2"><pre class="programlisting">    figure_no=1
    simple_line_plot(x,y,figure_no)</pre></div><p class="calibre11">When our program has multiple plots, it's a good practice to number each plot. Variable <code class="literal">figure_no</code> is used to number our plots. Let's look at the <code class="literal">simple_line_plot</code> function:</p><div class="calibre2"><pre class="programlisting">def simple_line_plot(x,y,figure_no):
    plt.figure(figure_no)
    plt.plot(x,y)
    plt.xlabel('x values')
    plt.ylabel('y values')
    plt.title('Simple Line')</pre></div><p class="calibre11">As you can see, we started numbering our plots by calling the figure function in <code class="literal">pyplot</code>. We passed the figure no variable from our main program. After this, we simply called the plot function with our x and y values. We can make our plot meaningful by giving names to our x and y axes using the <code class="literal">xlabel</code> and <code class="literal">ylabel</code> functions respectively. Finally, we can also give a title to our plot. That is it. Our first simple line plot is ready. The plot will not be displayed till the <code class="literal">show()</code> function is called. In our code, we will invoke the <code class="literal">show()</code> function in order to see all the plots together. Our plot will look as follows:</p><div class="mediaobject"><img src="Images/B04041_02_08.jpg" alt="How it works…" class="calibre31"/></div><p class="calibre11">Here, we plotted the values <code class="literal">x</code> on the x axis and <code class="literal">x squared</code> on the y axis.</p><p class="calibre11">We created a simple line plot. We can see a nice curve as our <span class="strong1"><strong class="calibre12">y values</strong></span> are squares of our <span class="strong1"><strong class="calibre12">x values</strong></span>.</p><p class="calibre11">Let's move on to our <a id="id129" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>next plot:</p><div class="calibre2"><pre class="programlisting">    figure_no+=1
    simple_dots(x,y,figure_no)</pre></div><p class="calibre11">We will increment our figure number and call the <code class="literal">simple_dots</code> function. We want to plot our <span class="strong1"><em class="calibre15">x</em></span> and <span class="strong1"><em class="calibre15">y</em></span> values as dots instead of a line. Let's look at the <code class="literal">simple_dots</code> function:</p><div class="calibre2"><pre class="programlisting">def simple_dots(x,y,figure_no):
    plt.figure(figure_no)
    plt.plot(x,y,'or')
    plt.xlabel('x values')
    plt.ylabel('y values')
    plt.title('Simple Dots')</pre></div><p class="calibre11">Every line is similar to our previous function except the following line:</p><div class="calibre2"><pre class="programlisting">    plt.plot(x,y,'or')</pre></div><p class="calibre11">The <code class="literal">or</code> parameter says that we need dots <code class="literal">(o)</code>, and the dots should be in in the color red (r). The following is the output of the preceding command:</p><div class="mediaobject"><img src="Images/B04041_02_09.jpg" alt="How it works…" class="calibre32"/></div><p class="calibre11">Let's move to our next plot.</p><p class="calibre11">We are going to see a <a id="id130" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>scatter plot. Let's generate some data using NumPy:</p><div class="calibre2"><pre class="programlisting">    # Sample x,y data for scatter plot
    x = np.random.uniform(size=100)
    y = np.random.uniform(size=100)</pre></div><p class="calibre11">We sampled 100 data points from a uniform distribution. Now we will proceed to call the <code class="literal">simple_scatter</code> function in order to generate our scatter plot:</p><div class="calibre2"><pre class="programlisting">    figure_no+=1
    simple_scatter(x,y,figure_no)</pre></div><p class="calibre11">In the <code class="literal">simple_scatter</code> function, all the lines are similar to the previous plotting routines except for the following line:</p><div class="calibre2"><pre class="programlisting">    plt.scatter(x,y)</pre></div><p class="calibre11">Instead of calling the plot function in <code class="literal">pyplot</code>, we invoked the <code class="literal">scatter</code> function. Our plot will look as follows:</p><div class="mediaobject"><img src="Images/B04041_02_10.jpg" alt="How it works…" class="calibre33"/></div><p class="calibre11">Let's move on to our <a id="id131" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>final plot, which is a scatter plot, but the points are colored based on the class label that they belong to:</p><div class="calibre2"><pre class="programlisting">    figure_no+=1
    label = np.random.randint(2,size=100)
    scatter_with_color(x,y,label,figure_no)</pre></div><p class="calibre11">We will increment our figure in order to keep track of our graph. In the next line, we will assign some random labels, either <code class="literal">1</code> or <code class="literal">0</code>, to our points. Finally, we will call the <code class="literal">scatter_with_color</code> function with our <span class="strong1"><em class="calibre15">x</em></span>, <span class="strong1"><em class="calibre15">y</em></span>, and label variables.</p><p class="calibre11">In the function, let's look at the line that differentiates this code from the previous scatter plot code:</p><div class="calibre2"><pre class="programlisting">    plt.scatter(x,y,c=labels)</pre></div><p class="calibre11">We will pass our labels to a <code class="literal">c</code> parameter, which stands for color. Each label will be assigned a unique color. In <a id="id132" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>our example, all the points that are labeled as <code class="literal">0</code> will get a color that is different from the points that are labeled as <code class="literal">1</code>, as follows:</p><div class="mediaobject"><img src="Images/B04041_02_11.jpg" alt="How it works…" class="calibre34"/></div><p class="calibre11">Let's move on to plotting some heat maps, and axis labeling.</p><p class="calibre11">Once again, we will start with the main function:</p><div class="calibre2"><pre class="programlisting">    plt.close('all')
    x = np.array(range(1,6))
    y = np.array(range(100,600,100))
    x_label = ['element 1','element 2','element 3','element 4','element 5']
    y_label = ['weight1','weight2','weight3','weight4','weight5']
    
    x_y_axis_labeling(x,y,x_label,y_label,1)</pre></div><p class="calibre11">As a good practice, we will close all the previous figures by calling the <code class="literal">close</code> function. We will proceed with generating some data. Our x is an array of five elements, starting from <code class="literal">1</code> and ending with <code class="literal">5</code>. Our y is an array of five elements, starting from <code class="literal">100</code> and ending with <code class="literal">500</code>. We defined the two <code class="literal">x_label</code> and <code class="literal">y_label</code> lists, which will serve as the labels for our plot. Finally, we invoked the <code class="literal">x_y_axis_labeling</code> function in order to demonstrate the concept of labeling our tickers in the <span class="strong1"><em class="calibre15">x</em></span> and <span class="strong1"><em class="calibre15">y</em></span> axes.</p><p class="calibre11">Let's look at the following function:</p><div class="calibre2"><pre class="programlisting">def x_y_axis_labeling(x,y,x_labels,y_labels,figure_no):
    plt.figure(figure_no)
    plt.plot(x,y,'+r')
    plt.margins(0.2)
    plt.xticks(x,x_labels,rotation='vertical')
    plt.yticks(y,y_labels,)</pre></div><p class="calibre11">We will do a simple dot plot by calling pyplot's dot function. However, in this case, we want our points to be displayed as <code class="literal">+</code> instead of <code class="literal">o</code>. Hence, we will specify <code class="literal">+r</code>. Our color of choice is red, hence <code class="literal">r</code>.</p><p class="calibre11">In the next two lines, we will specify what our x axis and y axis tickers need to be. By calling the <code class="literal">xticks</code> function, we will pass on our x values and their labels. In addition, we will say that we want the <a id="id133" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>text to be rotated vertically so that they don't overlap each other. Similarly, we will specify the tickers for the <span class="strong1"><em class="calibre15">y</em></span> axis. Let's look at our plot, as follows:</p><div class="mediaobject"><img src="Images/B04041_02_12.jpg" alt="How it works…" class="calibre35"/></div><p class="calibre11">Let's see how to generate heat maps using <code class="literal">pyplot</code>:</p><div class="calibre2"><pre class="programlisting">    x = np.random.normal(loc=0.5,scale=0.2,size=(10,10))
    plot_heat_map(x,2)</pre></div><p class="calibre11">We will generate some data for our heat map. In this case, we generated a 10 x 10 matrix filled with values from a normal distribution of a mean specified by a <code class="literal">loc</code> variable of <code class="literal">0.5</code> and standard deviation specified by a <code class="literal">scale</code> variable of <code class="literal">0.2</code>. We will invoke the <code class="literal">plot_heat_map</code> function with this matrix. The second parameter is the figure number:</p><div class="calibre2"><pre class="programlisting">def plot_heat_map(x,figure_no):
    plt.figure(figure_no)
    plt.pcolor(x)
    plt.colorbar()</pre></div><p class="calibre11">We will call the <code class="literal">pcolor</code> function in order to generate a heat map. The next line invokes the <code class="literal">colorbar</code> function to <a id="id134" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>display the color gradients for our range of values:</p><div class="mediaobject"><img src="Images/B04041_02_13.jpg" alt="How it works…" class="calibre36"/></div></div><div class="calibre2" title="There's more…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec109" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>There's more…</h2></div></div></div><p class="calibre11">For more information <a id="id135" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>on matplotlib, you can refer to the general matplotlib documentation at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://matplotlib.org/faq/usage_faq.html">http://matplotlib.org/faq/usage_faq.html</a>.</p><p class="calibre11">The following link is an <a id="id136" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>excellent tutorial on <code class="literal">pyplot</code>:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://matplotlib.org/users/pyplot_tutorial.html">http://matplotlib.org/users/pyplot_tutorial.html</a>
</p><p class="calibre11">Matplotlib provides excellent three-dimensional plotting capabilities. Refer to the following link for more information:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html">http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html</a>
</p><p class="calibre11">The pylab module in matplotlib combines the name space of NumPy with <code class="literal">pyplot</code>. Pylab can also be used to <a id="id137" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>generate the various types of plots shown in this recipe.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Machine learning with scikit-learn"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec36" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Machine learning with scikit-learn</h1></div></div></div><p class="calibre11">Scikit-learn is a <a id="id138" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>versatile machine learning library in Python. We <a id="id139" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>will use this library extensively in this book. We used scikit-learn version 0.15.2 for all the recipes in this book. In the command line, you can invoke the <code class="literal">__version__</code> attribute to check for the version:</p><div class="mediaobject"><img src="Images/B04041_02_15.jpg" alt="Machine learning with scikit-learn" class="calibre37"/></div><div class="calibre2" title="Getting ready"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec110" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Getting ready</h2></div></div></div><p class="calibre11">In this recipe, we will demonstrate some of the capabilities of scikit-learn and learn about some of their API organization so that we can follow it seamlessly in our future recipes.</p></div><div class="calibre2" title="How to do it…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec111" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How to do it…</h2></div></div></div><p class="calibre11">Scikit-learn provides <a id="id140" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>us with an inbuilt dataset. Let's see how to access this dataset and use it:</p><div class="calibre2"><pre class="programlisting">#Recipe_3a.py
from sklearn.datasets import load_iris,load_boston,make_classification                         make_circles, make_moons


# Iris dataset
data = load_iris()
x = data['data']
y = data['target']
y_labels = data['target_names']
x_labels = data['feature_names']

print
print x.shape
print y.shape
print x_labels
print y_labels

# Boston dataset
data = load_boston()
x = data['data']
y = data['target']
x_labels = data['feature_names']

print
print x.shape
print y.shape
print x_labels


# make some classification dataset
x,y = make_classification(n_samples=50,n_features=5, n_classes=2)

print
print x.shape
print y.shape

print x[1,:]
print y[1]

# Some non linear dataset
x,y = make_circles()
import numpy as np
import matplotlib.pyplot as plt
plt.close('all')
plt.figure(1)
plt.scatter(x[:,0],x[:,1],c=y)

x,y = make_moons()
import numpy as np
import matplotlib.pyplot as plt
plt.figure(2)
plt.scatter(x[:,0],x[:,1],c=y)

plt.show()</pre></div><p class="calibre11">Let's proceed with seeing how we can invoke some machine learning functionalities in scikit-learn:</p><div class="calibre2"><pre class="programlisting">#Recipe_3b.py
import numpy as np
from sklearn.preprocessing import PolynomialFeatures
# Data Preprocessing routines
x = np.asmatrix([[1,2],[2,4]])
poly = PolynomialFeatures(degree = 2)
poly.fit(x)
x_poly = poly.transform(x)

print "Original x variable shape",x.shape
print x
print
print "Transformed x variables",x_poly.shape
print x_poly


#alternatively 
x_poly = poly.fit_transform(x)


from sklearn.tree import DecisionTreeClassifier
from sklearn.datasets import load_iris

data = load_iris()
x = data['data']
y = data['target']

estimator = DecisionTreeClassifier()
estimator.fit(x,y)
predicted_y = estimator.predict(x)
predicted_y_prob = estimator.predict_proba(x)
predicted_y_lprob = estimator.predict_log_proba(x)


from sklearn.pipeline import Pipeline

poly = PolynomialFeatures(n=3)
tree_estimator = DecisionTreeClassifier()

steps = [('poly',poly),('tree',tree_estimator)]
estimator = Pipeline(steps=steps)
estimator.fit(x,y)
predicted_y = estimator.predict(x)</pre></div></div><div class="calibre2" title="How it works…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec112" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How it works…</h2></div></div></div><p class="calibre11">Let's load the <a id="id141" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>scikit learn library and import the module that contains the various functions in order to extract the inbuilt datasets:</p><div class="calibre2"><pre class="programlisting">from sklearn.datasets import load_iris,load_boston,make_classification</pre></div><p class="calibre11">The first dataset that <a id="id142" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>we will look at is the iris dataset. Refer to <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://en.wikipedia.org/wiki/Iris_flower_data_set">https://en.wikipedia.org/wiki/Iris_flower_data_set</a> for more information.</p><p class="calibre11">Introduced by Sir Donald Fisher, this is a classic dataset for a classification problem:</p><div class="calibre2"><pre class="programlisting">data = load_iris()
x = data['data']
y = data['target']
y_labels = data['target_names']
x_labels = data['feature_names']</pre></div><p class="calibre11">The <code class="literal">load_iris</code> function, when invoked, returns a dictionary object. The predictor <code class="literal">x</code>, response variable <code class="literal">y</code>, response variable names, and feature names can be extracted by querying the dictionary object with the appropriate keys.</p><p class="calibre11">Let's proceed to print <a id="id143" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>them and see their values:</p><div class="calibre2"><pre class="programlisting">print
print x.shape
print y.shape
print x_labels
print y_labels</pre></div><div class="mediaobject"><img src="Images/B04041_02_16.jpg" alt="How it works…" class="calibre38"/></div><p class="calibre11">As you can see, our predictors have 150 instances and four attributes. Our <code class="literal">response</code> variable has 150 instances and a class label for each of the rows in our predictor set. We will then print out the attribute names, petal and sepal width and length, and finally, the class labels. In most of our future recipes, we will use this dataset extensively.</p><p class="calibre11">Let's proceed to inspect another inbuilt dataset called the Boston housing dataset used in a regression problem:</p><div class="calibre2"><pre class="programlisting"># Boston dataset
data = load_boston()
x = data['data']
y = data['target']
x_labels = data['feature_names']</pre></div><p class="calibre11">The data is loaded pretty much the same as was iris, and the various components of the data, including the predictors and response variables, are queried using the respective keys from the dictionary. Let's print these variables in order to inspect them:</p><div class="mediaobject"><img src="Images/B04041_02_17.jpg" alt="How it works…" class="calibre39"/></div><p class="calibre11">As you can see, our predictor set x has 506 instances and 13 attributes. Our response variable has 506 <a id="id144" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>entries. Finally, we will also print out the names of our attributes.</p><p class="calibre11">Scikit-learn also provides <a id="id145" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>us with functions that will help us produce a random classification dataset with some desired properties:</p><div class="calibre2"><pre class="programlisting"># make some classification dataset
x,y = make_classification(n_samples=50,n_features=5, n_classes=2)</pre></div><p class="calibre11">The <code class="literal">make_classification</code> function is a function that can be used to generate a classification dataset. In our example, we generated a dataset with 50 instances that are dictated by the <code class="literal">n_samples</code> parameter, five attributes, <code class="literal">n_features</code> parameters, and two classes set by the <code class="literal">n_classes</code> parameter. Let's inspect the output of this function:</p><div class="calibre2"><pre class="programlisting">print x.shape
print y.shape

print x[1,:]
print y[1]</pre></div><div class="mediaobject"><img src="Images/B04041_02_18.jpg" alt="How it works…" class="calibre40"/></div><p class="calibre11">As you can see, our predictor x has 150 instances with five features. Our response variable has 150 instances, with a class label for each of the prediction instances.</p><p class="calibre11">We will print out the second record in our predictor set, <code class="literal">x</code>. You can see that we have a vector of dimension <code class="literal">5</code>, relating to the five features that we requested. Finally, we will also print the response variable, <code class="literal">y</code>. For the second row of our predictors, the class label is <code class="literal">1</code>.</p><p class="calibre11">Scikit-learn also <a id="id146" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>provides us with the functions that can generate data with nonlinear relationships:</p><div class="calibre2"><pre class="programlisting"># Some non linear dataset
x,y = make_circles()
import numpy as npimport matplotlib.pyplot as plt
plt.close('all')
plt.figure(1)
plt.scatter(x[:,0],x[:,1],c=y)</pre></div><p class="calibre11">You should be familiar with <code class="literal">pyplot</code> now from the previous recipe. Let's see our plot first to understand the <a id="id147" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>nonlinear relationship:</p><div class="mediaobject"><img src="Images/B04041_02_19.jpg" alt="How it works…" class="calibre41"/></div><p class="calibre11">As you can see, our classification has produced two concentric circles. Our <code class="literal">x</code> is a dataset with two variables. Variable <code class="literal">y</code> is the class label. As shown by the concentric circle, the relationship between our prediction variable is nonlinear.</p><p class="calibre11">Another interesting <a id="id148" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>function to produce a nonlinear relationship is <code class="literal">make_moons</code> from scikit-learn:</p><div class="calibre2"><pre class="programlisting">x,y = make_moons()
import numpy as np
import matplotlib.pyplot as plt
plt.figure(2)
plt.scatter(x[:,0],x[:,1],c=y)</pre></div><p class="calibre11">Let's look at its plot in order to understand the nonlinear relationship:</p><div class="mediaobject"><img src="Images/B04041_02_20.jpg" alt="How it works…" class="calibre42"/></div><p class="calibre11">The crescent-shaped plot shows that the attributes in our predictor set x are nonlinearly related to each other.</p><p class="calibre11">Let's switch gears <a id="id149" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>to understand the API structure of scikit-learn. One of the major advantages of using scikit-learn is its clean API structure. All the data <a id="id150" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>modeling classes deriving from the <code class="literal">BaseEstimator</code> class have to strictly implement the <code class="literal">fit</code> and <code class="literal">transform</code> functions. We will see some examples to learn more about this.</p><p class="calibre11">Let's start with the preprocessing module in scikit-learn:</p><div class="calibre2"><pre class="programlisting">import numpy as np
from sklearn.preprocessing import PolynomialFeatures</pre></div><p class="calibre11">We will use the <code class="literal">PolynomialFeatures</code> class in order to demonstrate the ease of using scikit-learn's SDK. Refer <a id="id151" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>to the following link for polynomials:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://en.wikipedia.org/wiki/Polynomial">https://en.wikipedia.org/wiki/Polynomial</a>
</p><p class="calibre11">With a set of predictor variables, we may want to add some more variables to our predictor set in order to see if our model accuracy can be improved. We can use the polynomials of the existing features as a new feature. The <code class="literal">PolynomialFeatures</code> class helps us do this:</p><div class="calibre2"><pre class="programlisting"># Data Preprocessing routines
x = np.asmatrix([[1,2],[2,4]])</pre></div><p class="calibre11">We will first create a dataset. In this case, our dataset has two instances and two attributes:</p><div class="calibre2"><pre class="programlisting">poly = PolynomialFeatures(degree = 2)</pre></div><p class="calibre11">We will proceed to instantiate our <code class="literal">PolynomialFeatures</code> class with the required degree of polynomials. In this case, it will be a second degree:</p><div class="calibre2"><pre class="programlisting">poly.fit(x)
x_poly = poly.transform(x)</pre></div><p class="calibre11">Then, there are two <a id="id152" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>functions, fit and transform. The <code class="literal">fit</code> function is used to do the necessary calculations for the transformation. In this case, fit is redundant, but we will see some more examples of how fit is used later in this recipe.</p><p class="calibre11">The <code class="literal">transform</code> function takes the input and, based on the calculations performed by fit, transforms the given input:</p><div class="calibre2"><pre class="programlisting">#alternatively 
x_poly = poly.fit_transform(x)</pre></div><p class="calibre11">Alternatively, in this <a id="id153" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>case, fit and transform can be called in one shot. Let's look at the value and shape of our original and transformed x variable:</p><div class="mediaobject"><img src="Images/B04041_02_22.jpg" alt="How it works…" class="calibre43"/></div><p class="calibre11">Any class that implements a machine learning method in scikit-learn has to deliver from BaseEstimator. See the <a id="id154" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>following link for BaseEstimator:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html">http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html</a>
</p><p class="calibre11">BaseEstimator expects that the implementation class provides both the <code class="literal">fit</code> and <code class="literal">transform</code> methods. This way the API is kept very clean.</p><p class="calibre11">Let's see another example. Here, we imported a class called <code class="literal">DecisionTreeClassifier</code> from the module tree. <code class="literal">DecisionTreeClassifier</code> implements the decision tree algorithm:</p><div class="calibre2"><pre class="programlisting">from sklearn.tree import DecisionTreeClassifier</pre></div><p class="calibre11">Let's put this class into action:</p><div class="calibre2"><pre class="programlisting">from sklearn.datasets import load_iris

data = load_iris()
x = data['data']
y = data['target']

estimator = DecisionTreeClassifier()
estimator.fit(x,y)
predicted_y = estimator.predict(x)
predicted_y_prob = estimator.predict_proba(x)
predicted_y_lprob = estimator.predict_log_proba(x)</pre></div><p class="calibre11">Let's use the iris <a id="id155" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dataset to see how the tree algorithm can be used. We will load the iris dataset in the <code class="literal">x</code> and <code class="literal">y</code> variables. We will then instantiate <code class="literal">DecisonTreeClassifier</code>. We will proceed to build the model by invoking the <code class="literal">fit</code> function and passing our <code class="literal">x predictor</code> and <code class="literal">y response</code> variable. This will build the tree model. Now, we are ready with our model to do some predictions. We will use the <code class="literal">predict</code> function in <a id="id156" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>order to predict the class labels for the given input. As you can see, we leveraged the same fit and predict method as in <code class="literal">PolynomialFeatures</code>. There are two other methods, <code class="literal">predict_proba</code>, which gives the probability of the prediction, and <code class="literal">predict_log_proba</code>, which provides the logarithm of the prediction probability.</p><p class="calibre11">Let's now see another interesting utility called pipe lining. Various machine learning methods can be chained together using pipe lining:</p><div class="calibre2"><pre class="programlisting">from sklearn.pipeline import Pipeline

poly = PolynomialFeatures(n=3)
tree_estimator = DecisionTreeClassifier()</pre></div><p class="calibre11">Let's start by instantiating the data processing routines, <code class="literal">PolynomialFeatures</code> and <code class="literal">DecisionTreeClassifier</code>:</p><div class="calibre2"><pre class="programlisting">steps = [('poly',poly),('tree',tree_estimator)]</pre></div><p class="calibre11">We will define a list of tuples to indicate the order of our chaining. We want to run the polynomial feature generation, followed by our decision tree:</p><div class="calibre2"><pre class="programlisting">estimator = Pipeline(steps=steps)
estimator.fit(x,y)
predicted_y = estimator.predict(x)</pre></div><p class="calibre11">We can now instantiate our Pipeline object with the list declared using the steps variable. Now, we can proceed to do business as usual by calling the <code class="literal">fit</code> and <code class="literal">predict</code> methods.</p><p class="calibre11">We can invoke the <code class="literal">named_steps</code> attribute in order to inspect the models in the various stages of our pipeline:</p><div class="mediaobject"><img src="Images/B04041_02_21.jpg" alt="How it works…" class="calibre44"/></div></div><div class="calibre2" title="There's more…"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec113" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>There's more…</h2></div></div></div><p class="calibre11">There are a lot more <a id="id157" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dataset creation functions available in scikit-learn. Refer <a id="id158" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>to the following link:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://scikit-learn.org/stable/datasets/">http://scikit-learn.org/stable/datasets/</a>
</p><p class="calibre11">While creating <a id="id159" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>nonlinear datasets using <code class="literal">make_circle</code> and <code class="literal">make_moons</code>, we mentioned that a lot of desired properties can be added to the dataset. The data can be corrupted slightly by inducing incorrect class labels. Refer to the following link for a list of options that are available in order to introduce such nuances in the data:</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html">http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html</a>
</p><p class="calibre11">
<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html">http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html</a>
</p></div><div class="calibre2" title="See also"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title3"><a id="ch02lvl2sec114" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>See also</h2></div></div></div><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><span class="strong1"><em class="calibre15">Plotting</em></span> recipe in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch02.xhtml" title="Chapter 2. Python Environments">Chapter 2</a>, <span class="strong1"><em class="calibre15">Working with Python Environments</em></span></li></ul></div></div></div></div>



  </body></html>