["```py\n$ cat input.txt\n\nAnd how will you inquire, Socrates,\ninto that which you know not? \nWhat will you put forth as the subject of inquiry? \nAnd if you find what you want, \nhow will you ever know that \nthis is what you did not know?\n\n```", "```py\n    main :: IO ()\n    main = do\n\n    ```", "```py\n    input <- readFile \"input.txt\"\n    print $ countWords input\n\n    ```", "```py\n    countWords :: String -> [Int]\n    countWords input = map (length.words) (lines input)\n\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [6,6,10,7,6,7]\n\n    ```", "```py\n$ runhaskell Main.hs\n\nMain.hs: input.txt: openFile: does not existâ€¦\n\n```", "```py\nmycode: input.txt: openFile: does not exist (No such file or directory)\n\n```", "```py\n    import Control.Exception (catch, SomeException)\n    ```", "```py\n    import System.Environment (getArgs)\n    ```", "```py\n    main :: IO ()\n    main = do\n    ```", "```py\n    args <- getArgs\n      let filename = case args of\n        (a:_) -> a\n            _ -> \"input.txt\"\n    ```", "```py\n      input <- catch (readFile fileName)\n        $ \\err -> print (err::SomeException) >> return \"\"\n    ```", "```py\n      print $ countWords input\n    ```", "```py\n    countWords input = map (length.words) (lines input)\n    ```", "```py\nexists <- doesFileExist filename\ninput <- if exists then readFile filename else return \"\"\n```", "```py\nimport System.Directory (doesFileExist)\n```", "```py\n$ cat input.csv \n\nname,age\nAlex,22\nAnish,22\nBecca,23\nJasdev,22\nJohn,21\nJonathon,21\nKelvin,22\nMarisa,19\nShiv,22\nVinay,22\n\n```", "```py\n$ cabal install csv\n\n```", "```py\n    import Text.CSV\n    ```", "```py\n    main :: IO ()\n    main = do\n      let fileName = \"input.csv\"\n      input <- readFile fileName\n    ```", "```py\n      let csv = parseCSV fileName input\n      either handleError doWork csv\n    handleError csv = putStrLn \"error parsing\"\n    doWork csv = (print.findOldest.tail) csv\n    ```", "```py\n    findOldest :: [Record] -> Record\n    findOldest [] = []\n    findOldest xs = foldl1\n              (\\a x -> if age x > age a then x else a) xs\n\n    age [a,b] = toInt a\n\n    toInt :: String -> Int                               \n    toInt = read\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [\"Becca\", \"23\"]\n\n    ```", "```py\n$ cat input.json\n\n{\"name\":\"Gauss\", \"nationality\":\"German\", \"born\":1777, \"died\":1855}\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n    ```", "```py\n    import Data.Aeson\n    import Control.Applicative\n    import qualified Data.ByteString.Lazy as B\n    ```", "```py\n    data Mathematician = Mathematician \n                         { name :: String\n                         , nationality :: String\n                         , born :: Int\n                         , died :: Maybe Int\n                         } \n    ```", "```py\n    instance FromJSON Mathematician where\n      parseJSON (Object v) = Mathematician\n                             <$> (v .: \"name\")\n                             <*> (v .: \"nationality\")\n                             <*> (v .: \"born\")\n                             <*> (v .:? \"died\")\n    ```", "```py\n    main :: IO ()\n    main = do\n    ```", "```py\n      input <- B.readFile \"input.json\"\n\n      let mm = decode input :: Maybe Mathematician\n\n      case mm of\n        Nothing -> print \"error parsing JSON\"\n        Just m -> (putStrLn.greet) m\n    ```", "```py\n    greet m = (show.name) m ++ \n              \" was born in the year \" ++ \n              (show.born) m\n    ```", "```py\n    $ runhaskell Main.hs\n\n    \"Gauss\" was born in the year 1777\n\n    ```", "```py\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE DeriveGeneric #-}\nimport Data.Aeson\nimport qualified Data.ByteString.Lazy as B\nimport GHC.Generics\n\ndata Mathematician = Mathematician { name :: String\n                                   , nationality :: String\n                                   , born :: Int\n                                   , died :: Maybe Int\n                                   } deriving Generic\n\ninstance FromJSON Mathematician\n\nmain = do\n  input <- B.readFile \"input.json\"\n  let mm = decode input :: Maybe Mathematician\n  case mm of\n    Nothing -> print \"error parsing JSON\"\n    Just m -> (putStrLn.greet) m\n\ngreet m = (show.name) m ++\" was born in the year \"++ (show.born) m\n```", "```py\n$ cat input.xml\n\n<thread>\n    <email>\n        <to>Databender</to>\n        <from>Princess</from>\n        <date>Thu Dec 18 15:03:23 EST 2014</date>\n        <subject>Joke</subject>\n        <body>Why did you divide sin by tan?</body>\n    </email>\n    <email>\n        <to>Princess</to>\n        <from>Databender</from>\n        <date>Fri Dec 19 3:12:00 EST 2014</date>\n        <subject>RE: Joke</subject>\n        <body>Just cos.</body>\n    </email>\n</thread>\n```", "```py\n$ cabal install hxt\n\n```", "```py\n    import Text.XML.HXT.Core\n    ```", "```py\n    main :: IO ()\n    main = do\n        input <- readFile \"input.xml\"\n    ```", "```py\n        dates <- runX $ readString [withValidate no] input \n            //> hasName \"date\" \n            //> getText\n    ```", "```py\n        print dates\n    ```", "```py\n     $ runhaskell Main.hs\n\n    [\"Thu Dec 18 15:03:23 EST 2014\", \"Fri Dec 19 3:12:00 EST 2014\"]\n\n    ```", "```py\n$ cat input.html\n\n<!DOCTYPE html>\n<html>\n    <body>\n        <h1>Course Listing</h1>\n        <table>\n            <tr>\n                <th>Course</th>\n                <th>Time</th>\n                <th>Capacity</th>\n            </tr>\n            <tr>\n                <td>CS 1501</td>\n                <td>17:00</td>\n                <td>60</td>\n            </tr>\n            <tr>\n                <td>MATH 7600</td>\n                <td>14:00</td>\n                <td>25</td>\n            </tr>\n            <tr>\n                <td>PHIL 1000</td>\n                <td>9:30</td>\n                <td>120</td>\n            </tr>\n        </table>\n    </body>\n</html>\n```", "```py\n$ cabal install hxt\n$ cabal install split\n\n```", "```py\n    import Text.XML.HXT.Core\n    import Data.List.Split (chunksOf)\n    ```", "```py\n    main :: IO ()\n    main = do\n      input <- readFile \"input.html\"\n    ```", "```py\n      texts <- runX $ readString \n               [withParseHTML yes, withWarnings no] input \n        //> hasName \"td\"\n        //> getText\n    ```", "```py\n      let rows = chunksOf 3 texts\n      print $ findBiggest rows\n    ```", "```py\n    findBiggest :: [[String]] -> [String]\n    findBiggest [] = []\n    findBiggest items = foldl1 \n                        (\\a x -> if capacity x > capacity a \n                                 then x else a) items\n\n    capacity [a,b,c] = toInt c\n    capacity _ = -1\n\n    toInt :: String -> Int\n    toInt = read\n    ```", "```py\n    $ runhaskell Main.hs\n\n    {\"PHIL 1000\", \"9:30\", \"120\"}\n\n    ```", "```py\n$ cabal install HandsomeSoup\n$ cabal install hxt\n\n```", "```py\n    import Text.XML.HXT.Core\n    import Text.HandsomeSoup\n    ```", "```py\n    main :: IO ()\n    main = do\n    ```", "```py\n        let doc = fromUrl \"http://en.wikipedia.org/wiki/Narwhal\"\n    ```", "```py\n        links <- runX $ doc >>> css \"#bodyContent a\" ! \"href\"\n        print links\n    ```", "```py\n$ cabal install HandsomeSoup\n$ cabal install hxt\n\n```", "```py\n    import Network.HTTP\n    import Network.URI (parseURI)\n    import Text.XML.HXT.Core\n    import Text.HandsomeSoup\n    import Data.Maybe (fromJust)\n    ```", "```py\n    myRequestURL = \"http://www.virginia.edu/cgi-local/ldapweb\"\n\n    myRequest :: String -> Request_String\n    myRequest query = Request { \n        rqURI = fromJust $ parseURI myRequestURL\n      , rqMethod = POST\n      , rqHeaders = [ mkHeader HdrContentType \"text/html\"\n                    , mkHeader HdrContentLength $ show $ length body ]\n      , rqBody = body\n      }\n      where body = \"whitepages=\" ++ query\n    ```", "```py\n    main :: IO ()\n    main = do\n      response <- simpleHTTP $ myRequest \"poon\"\n    ```", "```py\n      html <- getResponseBody response\n      let doc = readString [withParseHTML yes, withWarnings no] html\n    ```", "```py\n      rows <- runX $ doc >>> css \"td\" //> getText\n      print rows\n    ```", "```py\n$ cabal install hxt\n$ cabal install HandsomeSoup\n\n```", "```py\n    import Network.HTTP\n    import Network.URI\n    import Text.XML.HXT.Core\n    import Text.HandsomeSoup\n    ```", "```py\n    type SearchResult = Either SearchResultErr [String]\n    data SearchResultErr = NoResultsErr \n                         | TooManyResultsErr \n                         | UnknownErr     \n                         deriving (Show, Eq)\n    ```", "```py\n    getDoc query = do  \n        rsp <- simpleHTTP $ myRequest query\n        html <- getResponseBody rsp\n        return $ readString [withParseHTML yes, withWarnings no] html\n    ```", "```py\n    scanDoc doc = do\n        errMsg <- runX $ doc >>> css \"h3\" //> getText\n\n        case errMsg of \n            [] -> do \n                text <- runX $ doc >>> css \"td\" //> getText \n                return $ Right text\n            \"Error: Sizelimit exceeded\":_ -> \n                return $ Left TooManyResultsErr\n            \"Too many matching entries were found\":_ -> \n                return $ Left TooManyResultsErr\n            \"No matching entries were found\":_ -> \n                return $ Left NoResultsErr\n            _ -> return $ Left UnknownErr\n    ```", "```py\n    main :: IO ()\n    main = main' \"a\"\n    ```", "```py\n    main' query = do\n        print query\n        doc <- getDoc query\n        searchResult <- scanDoc doc\n        print searchResult\n        case searchResult of\n            Left TooManyResultsErr -> \n                main' (nextDeepQuery query)\n            _ -> if (nextQuery query) >= endQuery \n                  then print \"done!\" else main' (nextQuery query)\n    ```", "```py\n    nextDeepQuery query = query ++ \"a\"\n\n    nextQuery \"z\" = endQuery\n    nextQuery query = if last query == 'z'\n                      then nextQuery $ init query\n                      else init query ++ [succ $ last query]\n    endQuery = [succ 'z']\n    ```", "```py\n$ sudo apt-get install mongodb\n\n```", "```py\n$ mkdir ~/db\n$ mongod --dbpath ~/db\n\n```", "```py\n$ mongo\n> db.people.insert( {first: \"Joe\", last: \"Shmoe\"} )\n\n```", "```py\n$ cabal install mongoDB\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings, ExtendedDefaultRules #-}\n    import Database.MongoDB\n    ```", "```py\n    main :: IO ()\n    main = do\n        let db = \"test\"\n        pipe <- runIOE $ connect (host \"127.0.0.1\")\n        e <- access pipe master db run\n        close pipe\n        print e\n    ```", "```py\n    run = getData\n\n    getData = rest =<< find (select [] \"people\") {sort=[]}\n    ```", "```py\n$ cabal install mongoDB\n\n```", "```py\n$ cabal install split\n$ cabal install uri\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings, ExtendedDefaultRules #-}\n    import Database.MongoDB\n    import Text.URI\n    import Data.Maybe\n    import qualified Data.Text as T\n    import Data.List.Split\n    ```", "```py\n    mongoURI = \"mongodb://user:pass@ds12345.mongolab.com:53788/mydb\"\n    ```", "```py\n    uri = fromJust $ parseURI mongoURI\n\n    getUser = head $ splitOn \":\" $ fromJust $ uriUserInfo uri\n\n    getPass = last $ splitOn \":\" $ fromJust $ uriUserInfo uri\n\n    getHost = fromJust $ uriRegName uri\n\n    getPort = case uriPort uri of \n        Just port -> show port \n        Nothing -> (last.words.show) defaultPort\n\n    getDb = T.pack $ tail $ uriPath uri\n    ```", "```py\n    main :: IO ()\n    main = do\n        let hostport = getHost ++ \":\" ++ getPort\n        pipe <- runIOE $ connect (readHostPort hostport)\n        e <- access pipe master getDb run\n        close pipe\n        print e\n    ```", "```py\n    run = do\n      auth (T.pack getUser) (T.pack getPass)\n      getData\n\n    getData = rest =<< find (select [] \"people\") {sort=[]}\n    ```", "```py\n$ sudo apt-get install sqlite3\n\n```", "```py\n$ sqlite3 test.db \"CREATE TABLE test \\\n(id INTEGER PRIMARY KEY, str text); \\\nINSERT INTO test (str) VALUES ('test string');\"\n\n```", "```py\n$ cabal install sqlite-simple\n\n```", "```py\n    {-# LANGUAGE OverloadedStrings #-}\n\n    import Control.Applicative\n    import Database.SQLite.Simple\n    import Database.SQLite.Simple.FromRow\n    ```", "```py\n    data TestField = TestField Int String deriving (Show)\n\n    instance FromRow TestField where\n      fromRow = TestField <$> field <*> field\n    ```", "```py\n    main :: IO ()\n    main = do\n      conn <- open \"test.db\"\n      r <- query_ conn \"SELECT * from test\" :: IO [TestField]\n      mapM_ print r\n      close conn\n    ```"]