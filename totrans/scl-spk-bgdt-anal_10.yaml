- en: Everything is Connected - GraphX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Technology made large populations possible; large populations now make technology
    indispensable."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Joseph Wood Krutch'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how many real-world problems can be modeled (and
    resolved) using graphs. We see that Apache Spark comes with its own graph library,
    and what you learned about RDDs can be used here too (this time as vertex and
    edge RDDs).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to graph theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VertexRDD and EdgeRDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pregel API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PageRank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to graph theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand graphs, let's look at Facebook and how you typically use
    Facebook. Every day you use your smart phone to post messages on your friend's
    wall or update your status. Your friends are all posting messages and photos and
    videos of their own.
  prefs: []
  type: TYPE_NORMAL
- en: You have friends, your friends have friends, who have friends, and so on. Facebook
    has settings that let you make new friends or remove friends from your friend
    list. Facebook also has permissions, which allow granular control on who sees
    what and who can communicate with who.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you consider that there are a billion Facebook users, the friends
    and friend's friends list for all users gets quite large and complicated. It is
    hard to even comprehend and manage all the different relationships or friendships.
  prefs: []
  type: TYPE_NORMAL
- en: So, if someone wants to find out if you and another person *X* are related at
    all, they can simply start by looking at all your friends and all your friends'
    friends, and so on, and try to get to the person *X*. If person *X* is a friend
    of a friend, then you and person *X* are indirectly connected.
  prefs: []
  type: TYPE_NORMAL
- en: Search for a celebrity or two in your Facebook account and see if someone is
    a friend of your friend. Maybe you can try to add them as a friend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to build the storage and retrieval of such data about people and their
    friends so as to allow us to answer questions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Is X a friend of Y?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are X and Y connected directly or within two steps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many friends does X have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can start by trying out a simple data structure such as an array such that
    every person has an array of friends. So now, it's easy to just take the length
    of the array to answer 3\. We can also just scan the array and quickly answer
    1\. Now, question 2 will need little more work, take the array of friends of *X*
    and for each such friend scan the array of friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have sort of solved the problem by having a specialized data structure as
    shown in the following example where we create a case class `Person` and then
    add friends to build a relationship like this `john` | `ken` | `mary` | `dan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we build out the `Person()` instances for all Facebook users and add the
    friends to the arrays as the preceding code shows, then eventually, we will be
    able to perform lots of the queries on who is a friend and what is the relationship
    between any two persons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the data structures'' `Person()` instances and
    how they are related to each other logically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to use the preceding graph and just find out **John**''s friends,
    **John**''s friend''s friends and so on so that we can quickly find out direct
    friends, indirect friends (friends level 2), and level 3 (friends'' friends''
    friends), you will see something like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can easily extend the `Person()` class and provide more and more functionality
    to answer different questions. That is not the point here, what we want to look
    at is the preceding diagram showing `Person` and friends of the `Person` and how
    drawing all the friends of each `Person` yields in a mesh of relationships between
    persons.
  prefs: []
  type: TYPE_NORMAL
- en: We now introduce the graph theory, which stems from the field of Mathematics.
    Graph theory defines a graph as a structure made up of vertices, nodes, or points,
    which are connected by edges, arcs, and lines. If you consider a set of `Vertices`
    as `V` and a set of `Edges` as `E`, then a `Graph G` can be defined as an ordered
    pair of `V` and `E`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In our example of the Facebook friends drawing, we can simply consider each
    of the persons as a vertex in the set of vertices and then each link between any
    two persons can be considered as an edge in the set of edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'By this logic, we can list the **Vertices** and **Edges** as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This depiction as a mathematical graph yields to various methodologies of traversing
    and querying the Graph using mathematical techniques. When the techniques are
    applied to computer science as a way to develop programmatical methods to perform
    the math necessary, the formal approach is, of course, to develop algorithms to
    implement the mathematical rules at a scalable efficient level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already attempted to implement a simple graph-like program using the
    case class `Person`, but this is just the simplest use case, which should make
    it obvious that there are a lot of sophisticated extensions possible, such as
    the following questions to be answered:'
  prefs: []
  type: TYPE_NORMAL
- en: What's the best way from X to Y? An example of such a question can be your car
    GPS telling you the best way to go to the grocery store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the critical edges, which can cause partitions of the graph? An example
    of such a question is to determine the critical links connecting the internet
    services/water pipes/power lines of various cities in the state. A critical edge
    breaks connectivity and produces two subgraphs of well-connected cities, but there
    will not be any communication between the two subgraphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering the preceding questions yields to several algorithms such as minimum
    spanning tree, shortest path , page rank, **ALS** (**alternating least squares**),
    and max-cut min-flow algorithms, and so on, which are applicable to a broad set
    of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The other examples are LinkedIn profiles and connections, Twitter followers,
    Google page rank, airline scheduling, GPS in your car, and so on, where you can
    clearly see a graph of vertices and edges. Using graph algorithms, the graph seen
    earlier in the Facebook, LinkedIn, Google examples can be analyzed using various
    algorithms to yield different business use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shown below are illustration of some real-life use cases of graphs which show
    the use of graphs and graph algorithms in some real-life use cases such as:'
  prefs: []
  type: TYPE_NORMAL
- en: help determine flight routes between airports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: plan how to layout water pipelines to all the households in the locality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make your car GPS to plan the route to drive to the grocery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: design how the internet traffic is routed from city to city, state to state
    and country to country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now start digging deeper into how we can use Spark GraphX.
  prefs: []
  type: TYPE_NORMAL
- en: GraphX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the preceding section, we can model many real-life use cases as
    Graphs with a set of vertices and a set of edges linking the vertices. We also
    wrote simple code trying to implement some basic graph operations and queries
    such as, *Is X a friend of Y* ? However, as we explored further, the algorithms
    only get more complicated along with use cases and also the size of graphs is
    much much larger than can be handled on one machine.
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to fit one billion Facebook users along with all their friendship
    relations into one machine or even a few machines.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is to look beyond the one machine and few machines thrown
    together and rather start considering highly scalable architectures to implement
    the complex graph algorithms, which can handle the volume of data and complex
    interconnections of the data elements. We have already seen an introduction to
    Spark, how Spark solves some challenges of distributed computing and big data
    analytics. We also saw real-time stream processing and Spark SQL along with DataFrames
    and RDDs. Can we also solve the challenges of graph algorithms? The answer to
    this is GraphX, which comes with Apache Spark and just like other libraries, sits
    on top of Spark Core.
  prefs: []
  type: TYPE_NORMAL
- en: GraphX extends the spark RDD by providing a graph abstraction on top of the
    RDD concept. Graphs in GraphX are created using the concept of vertices or nodes
    to represent the objects and edges or links to describe the relation between objects
    and GraphX provides the means to realize many use cases, which suit the graph
    processing paradigm. In this section, we will learn about GraphX, how to create
    vertices, edges, and graphs comprising vertices and edges. We will also write
    code to learn by example some techniques surrounding graph algorithms and processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started , you will need to import some packages as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The fundamental data structure of GraphX is a graph, which abstractly represents
    a graph with arbitrary objects associated with vertices and edges. The graph provides
    basic operations to access and manipulate the data associated with vertices and
    edges as well as the underlying structure. Like Spark RDDs, the graph is a functional
    data structure in which mutating operations return new graphs. This immutable
    nature of the `Graph` object makes it possible to do large-scale parallel computations
    without the risk of running into synchronization problems.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent updates or modification of objects is the primary reason for complex
    multithreading programming done in many programs.
  prefs: []
  type: TYPE_NORMAL
- en: The graph defines the basic data structure and there is a helper class `GraphOps`,
    which contains additional convenience operations and graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph is defined as follows as a class template with two attributes specifying
    the data type of the two pieces, which make up the graph, namely, the vertices
    and the edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A graph consists of vertices and edges as we already discussed. The set of vertices
    is in a special data structure known as `VertexRDD`. Similarly, the set of edges
    is in a special data structure known as `EdgeRDD`. Together the vertices and edges
    form the graph and all the subsequent operations can be done using the two data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the declaration of the class `Graph` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the two main components of the `Graph` class, the `VertexRDD`,
    and the `EdgeRDD`.
  prefs: []
  type: TYPE_NORMAL
- en: VertexRDD and EdgeRDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `VertexRDD` contains the set of vertices or nodes in a special data structure
    and an `EdgeRDD` contains the set of edges or links between the nodes/vertices
    again in a special data structure. Both the `VertexRDD` and the `EdgeRDD` are
    based on RDDs and the `VertexRDD` deals with every single node in the graph while
    the `EdgeRDD` contains all links between all nodes. In this section, we will look
    at how to create `VertexRDD` and `EdgeRDD` and then use these objects in building
    a graph.
  prefs: []
  type: TYPE_NORMAL
- en: VertexRDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen earlier, the `VertexRDD` is an RDD containing the vertices and their
    associated attributes. Each element in the RDD represents a vertex or node in
    the graph. In order to maintain the uniqueness of the vertex, we need to have
    a way of assigning a unique ID to each of the vertexes. For this purpose, GraphX
    defines a very important identifier known as `VertexId`.
  prefs: []
  type: TYPE_NORMAL
- en: '`VertexId` is defined as a 64-bit vertex identifier that uniquely identifies
    a vertex within a graph. It does not need to follow any ordering or any constraints
    other than uniqueness.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of `VertexId` is as follows as simply an alias for a 64-bit
    `Long` number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `VertexRDD` extends an RDD of a pair of VertexID and vertex attributes represented
    by `RDD[(VertexId, VD)]`. It also ensures that there is only one entry for each
    vertex and by preindexing the entries for fast, efficient joins. Two VertexRDDs
    with the same index can be joined efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`VertexRDD` also implements many functions, which provide important functionality
    related to graph operations. Each function typically accepts inputs of vertices
    represented by `VertexRDD`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load vertices into a `VertexRDD` of users. For this, we shall first
    declare a case class `User` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the file `users.txt`, create the `VertexRDD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **VertexID** | **Name** | **Occupation** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | John | Accountant |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Mark | Doctor |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Sam | Lawyer |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Liz | Doctor |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Eric | Accountant |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Beth | Accountant |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Larry | Engineer |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Marry | Cashier |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Dan | Doctor |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Ken | Librarian |'
  prefs: []
  type: TYPE_TB
- en: 'Each line of the file `users.txt` contains **VertexId** , the **Name**, and
    the **Occupation**, so we can use the `String` split function here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: EdgeRDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EdgeRDD` represents the set of Edges between the vertices and is a member
    of the Graph class as seen earlier. `EdgeRDD`, just like `VertexRDD`, extends
    from RDD and takes both Edge attributes and Vertex attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '`EdgeRDD[ED, VD]` extends `RDD[Edge[ED]]` by storing the edges in columnar
    format on each partition for performance. It may additionally store the vertex
    attributes associated with each edge to provide the triplet view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: EdgeRDD also implements many functions, which provide important functionality
    related to graph operations. Each function typically accepts inputs of edges represented
    by EdgeRDD. Each Edge consists of a source vertexId, destination vertexId and
    edge attributes such as a `String`, `Integer`, or any case class. In the following
    example, we use a `String` friend as the attribute. Later in this chapter, we
    use the distance in miles (`Integer`) as the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create EdgeRDD by reading a file of pairs of vertexIds:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source Vertex ID** | **Target/Destination Vertex ID** | **Distance in Miles**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 10 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 4 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 10 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 7 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 7 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Each line of the `friends.txt` file contains the source `vertexId` and destination
    `vertexId`, so we can use the `String` split function here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have vertices and edges, so it is time to put everything together and
    explore how we can build a `Graph` from the lists of vertices and edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Graph` object, we can look at the vertices and edges using the `collect()`
    function, which will show all vertices and edges. Each vertex is of the form (`VertexId`,
    `User`) and each edge is of the form (`srcVertexId`, `dstVertexId`, `edgeAttribute`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a graph created, we will look at various operations in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Graph operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the operations we can directly perform using `Graph` object,
    such as filtering the vertices and edges of the graph to filter out based on some
    attribute of the object. We will also see an example of `mapValues()`, which can
    transform the graph to yield a custom RDD.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's examine the vertices and the edges using the `Graph` object we
    created in the previous section and then look at some graph operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function call to `filter()` restricts the vertex set to the set of vertices
    satisfying the given predicate. This operation preserves the index for efficient
    joins with the original RDD, and it sets bits in the bitmask rather than allocating
    new memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using `filter`, we can filter out everything but the vertex for user `Mark`,
    which can be done either using the vertexId or the `User.name` attribute. We can
    also filter for the `User.occupation` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to accomplish the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also perform `filter` on the edges too, using either the source vertexId
    or the destination vertexId. So we can filter out the edges to show only the edges,
    which originate from `John` (vertexId = 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: MapValues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mapValues()` maps each vertex attribute, preserving the index so as not to
    change the vertexId. Changing the vertexId would have changed the index so much
    that subsequent operations would fail and the vertices will not be reachable anymore.
    Hence, it is important to not change the vertexIds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of this function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`mapValues()` can also operate on the edges and maps the values in an edge
    partitioning preserving the structure but changing the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the example code invoking `mapValues()` in the vertices and
    edges. MapValues on vertices transforms the vertices to list of pairs of (`vertexId`
    , `User.name`). MapValues on edges transforms the edges to triplets of (`srcId`,
    `dstId`, `string`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: aggregateMessages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core aggregation operation in GraphX is `aggregateMessages`, which applies
    a user-defined `sendMsg` function to each edge triplet in the graph and then uses
    the `mergeMsg` function to aggregate these messages at their destination vertex.
    `aggregateMessages` is used in many graph algorithms, where we have to exchange
    information between vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the signature for this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The key functions are the `sendMsg` and `mergeMsg`, which determine what gets
    sent either to source vertex or destination vertex of an edge. Then, `mergeMsg`
    processes the messages received from all the Edges and performs a computation
    or aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of calling `aggregateMessages` on the `Graph`
    graph, where we send a message to all destination vertices. The merge strategy
    at each vertex is to just add all the messages being received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: TriangleCounting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A triangle is created if two neighbors of a vertex are connected by an edge.
    In other words, a user will create a triangle with the two friends who are friends
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Graph has a function `triangleCount()`, which computes the triangles in the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code used to count the triangles in the graph by first
    invoking the `triangleCount` function and then by joining the triangles with the
    vertices (users) to generate the output of each user and the triangle the user
    belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The diagram of the two triangles we just computed in the preceding code shows
    the two triangles, (**John**, **Mark**, **Sam**) and (**Ken**, **Mary**, **Beth**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pregel API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are inherently recursive data structures as properties of vertices depend
    on properties of their neighbors, which in turn depend on properties of their
    own neighbors. As a consequence, many important graph algorithms iteratively recompute
    the properties of each vertex until a fixed-point condition is reached. A range
    of graph-parallel abstractions have been proposed to express these iterative algorithms.
    GraphX exposes a variant of the Pregel API.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, the Pregel operator in GraphX is a bulk-synchronous parallel
    messaging abstraction constrained to the topology of the graph. The Pregel operator
    executes in a series of steps in which vertices receive the sum of their inbound
    messages from the previous super step, compute a new value for the vertex property,
    and then send messages to neighboring vertices in the next super step. Using Pregel,
    messages are computed in parallel as a function of the edge triplet and the message
    computation has access to both the source and destination vertex attributes. Vertices
    that do not receive a message are skipped within a super step. The Pregel operators
    terminate iteration and return the final graph when there are no messages remaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some algorithms which come built-in using Pregel API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ConnectedComponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ShortestPaths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traveling salesman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PageRank (covered in the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Pregel API signature is shown in the following code, which shows the various
    arguments needed. The exact usage will be shown in the subsequent sections, so
    you can refer to this signature for clarification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ConnectedComponents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connected components are essentially subgraphs within a graph, where the vertices
    are connected to each other in some way. This means that every vertex in the same
    component has an edge to/from some other vertex in the component. Whenever no
    other edge exists to connect a vertex to a component, a new component is created
    with that specific vertex. This continues until all vertices are in some component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph object provides a `connectComponents()` function to compute the connected
    components. This uses the Pregel API underneath to calculate the component a vertex
    belongs to. The following is the code to calculate connected components in the
    graph. Obviously, in this example, we had only one connected component, so it
    shows one as the component number for all users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Traveling salesman problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traveling salesman problem tried to find the shortest path through an undirected
    graph traversing every vertex, for example, user, John, wants to drive to every
    other user minimizing the total distance driven. As the number of vertices and
    edges increase, the number of permutations also increases polynomially to cover
    all the possible paths from vertex to vertex. The time complexity increases polynomially
    to a point that the problem can take a very long time to solve. Rather than solve
    it completely and accurately, an approach known as a **greedy** algorithm is used
    to solve the problem as optimally as possible.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the traveling salesman problem, the greedy approach is to quickly choose
    the shortest edge, knowing that this could be a nonoptimal selection if we traverse
    further depth-wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram of the greedy algorithm on the graph of users and friends is as follows,
    where we see the traversal picking the shortest weighted edge at each vertex.
    Also note that the vertices **Larry** (**7**) and **Liz** (**4**) are never visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ShortestPaths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Shortest paths algorithm finds the path between two vertices by starting at
    the source Vertex and then traversing the edges connecting the vertices to other
    vertices until it reaches the target vertex. The shortest paths algorithm works
    by exchanging messages between various vertices. Also this shortest paths algorithm
    is not directly a part of the `Graph` or `GraphOps` objects, rather must be invoked
    using `lib.ShortestPaths()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`ShortestPaths` picks the shortest paths in terms of number of hops between
    the two vertices. The following diagram shows three ways **John** can reach **Larry**
    and two of the paths are of length 2 and one of length 3\. From the results of
    the preceding code, it clearly shows that the path chosen from **Larry** to John
    is of length 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is shown in the output in above code block as a vector containing
    the length of the path and the nodes `(7,(Map(1 -> 2),User(Larry,Engineer)))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also compute the shortest path using weighted edges, which means every
    edge connecting users is not the same. For example, if we can consider the edge
    value/weight/attribute as the distance between where each user lives, we get a
    weighted graph. In this case, the shortest path is calculated by the distance
    between two users in miles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The following is a diagram that uses Pregel API to compute the **Single Source
    Shortest Path** from **John** to **Larry** starting from initialization and iteration
    by iteration until we reach the best paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialization of the graph is done by setting the value of vertex representing
    **John** to zero and all other vertices to positive infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the initialization is complete, we will use Pregel for four iterations
    of recomputing the vertex values. In each iteration, we go through all the vertices
    and, at each vertex, check whether there is a better path from a source vertex
    to a destination vertex. If there is such an edge/path, then the vertex value
    is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's define two functions *distance(v)* and *distance(s, t)*, where *distance(v)*
    gives the value of a vertex and *distance(s,t)* gives the value of the edge connecting
    *s* to *t*.
  prefs: []
  type: TYPE_NORMAL
- en: In Iteration 1, every user except John is set to infinity and John is at 0,
    since he is the source vertex. Now, we use Pregel to loop through the vertices
    and check whether there is anything better than infinity. Using Ken as an example,
    we will check if *distance("John") + distance("John", "Ken") < distance("Ken")*.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to checking whether *0 + 5 < Infinity*, which is `true`;
    so we update Ken's distance to *5*.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we check for Mary, *distance("Ken") + distance("Ken", "Mary") < distance("Mary")*,
    which turns out to be `false`, since at that time Ken is still at infinity. Hence,
    in iteration 1, we could only update the users who are connected to John.
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration, Mary, Liz, Eric and so on, are all updated since now
    we have updated values for Ken, Mark, and Sam from iteration 1\. This continues
    for a number of iterations specified in the Pregel API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shown below are the illustrations of the various iterations when computing
    single source shortest path on the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The shortest paths from **John** to **Larry** after four iterations shows that
    the shortest path is five miles. The path from **John** to **Larry** can be seen
    if you follow the path **John** | **Mark** | **Sam** | **Larry**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PageRank** is one of the most important algorithms in the graph processing
    space. Originating at Google, the algorithm named after Larry page, the founder
    of Google, has evolved into many types of use cases based on the concept of ranking
    vertices or nodes based on relationships or edges.'
  prefs: []
  type: TYPE_NORMAL
- en: Google PageRank works by counting the number and quality of links to a page
    to determine a rough estimate of how important the website is. The underlying
    assumption is that more important websites are likely to receive more links from
    other websites. For more information, you can read the description at [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)
  prefs: []
  type: TYPE_NORMAL
- en: Using Google PageRank as an example, you can improve the relative importance
    of a web page on your company website or maybe your blog by promoting the web
    page among other popular websites and technical blogs. Using this approach, your
    blog website may appear in Google search results about some article higher than
    other similar web pages, if there are a lot of third-party websites, which show
    your blog website and the content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Search Engine Optimization** (**SEO**) is one of the biggest industries in
    the marketing world, where pretty much every website out there is investing into
    this technology. SEO involves various techniques and strategies essentially to
    improve how far up your website appears in any search engine results when anyone
    searches for some relevant words. This is based on Google PageRank-like concept.'
  prefs: []
  type: TYPE_NORMAL
- en: If you consider web pages as nodes/vertices and the hyperlinks between the web
    pages as edges, we essentially created a graph. Now, if you can count the rank
    of a web page as the number of hyperlinks/edges pointed into such as your `myblog.com`
    site having links on `cnn.com` or `msnbc.com` so that a user can click on the
    link and come to your `myblog.com` page. This can be a factor representing the
    importance of the `myblog.com` vertex. If we apply this simple logic recursively,
    we eventually end up with a rank assigned to each vertex calculated using the
    number of incoming edges and PageRank based on the ranks of the source vertices.
    A page that is linked to by many pages with high PageRank receives a high rank
    itself. Let's look at how to solve the PageRank problem at a big data scale using
    Spark GraphX. As we have seen, PageRank measures the importance of each vertex
    in a graph, assuming an edge from **a** to **b** represents the value of **b**
    boosted by **a**. For example, if a Twitter user is followed by many others, the
    user will be ranked highly.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphX comes with static and dynamic implementations of PageRank as methods
    on the `pageRank` object. Static PageRank runs for a fixed number of iterations,
    while dynamic PageRank runs until the ranks converge. `GraphOps` allows calling
    these algorithms directly as methods on the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The diagram of the PageRank algorithm on the graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced graph theory using Facebook as an example;
    Apache Spark's graph processing library GraphX, `VertexRDD`, and EdgeRDDs; graph
    operators, `aggregateMessages`, `TriangleCounting`, and the Pregel API; and use
    cases such as the PageRank algorithm. We have also seen the traveling salesman
    problem and connected components and so on. We have seen how the GraphX API can
    be used to develop graph processing algorithms at scale.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](part0343.html#A73GU1-21aec46d8593429cacea59dbdcd64e1c), *Learning
    Machine Learning - Spark MLlib and ML*, we will explore the exciting world of
    Apache Spark's Machine Learning library.
  prefs: []
  type: TYPE_NORMAL
