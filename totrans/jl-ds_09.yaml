- en: Chapter 9. Time Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The capacity to demonstrate and perform decision modeling and examination is
    a crucial component of some real-world applications ranging from emergency medical
    treatment in intensive care units to military commands and control frameworks.
    Existing methodologies and techniques for deduction have not been progressively
    viable with applications where exchange offs between decision quality and computational
    tractability are essential. A successful way to deal with time-critical element
    decision modeling should give express backing to the demonstration of transient
    procedures and for managing time-critical circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Forecasting?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision-making processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Time Series?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trend analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of seasonality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARIMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is forecasting?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take the example of an organization that needs to find out the demand
    for its inventory in the near future, to maximize the return on investment.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, numerous stock frameworks apply for indeterminate demand. The
    stock parameters in these frameworks require evaluations of the demand and forecast
    error distributions.
  prefs: []
  type: TYPE_NORMAL
- en: The two phases of these frameworks, forecasting and stock control, are frequently
    analyzed autonomously. It is essential to comprehend the cooperation between demand
    estimating and stock control since this impacts the execution of the stock framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forecasting requirements include:'
  prefs: []
  type: TYPE_NORMAL
- en: Each decision gets to be operational sooner or later, so it ought to be based
    on figures of future conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figures are required all through an organization and they should absolutely
    not be created by a disconnected gathering of forecasters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forecasting is never "wrapped up". Forecasts are required constantly, and as
    time proceeds onward, the effect of the forecasts on real execution is measured,
    original forecasts are overhauled, and decisions are adjusted, and this goes on
    in a loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision maker makes use of forecasting models to carry out the decisions.
    They are regularly utilized to demonstrate the procedure to research the effect
    of various strategies reflectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is helpful to break the components of decision making into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrollable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources (that define the problem situation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision-making process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a system? Frameworks are shaped with parts set up together in a specific
    way, keeping in mind the end goal to meet a specific a target. The relationship
    between the parts figures out what the framework does and its overall capacities.
    Along these lines, the connections in a framework are regularly more critical
    than the individual parts. When all is said and done, the frameworks that are
    building blocks for different frameworks are called subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamics of a system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A framework that does not change is a static framework. A hefty portion of business
    frameworks are rapid frameworks, which mean that their states change after some
    time. We allude to the way a framework changes after some time as the framework's
    conduct. What's more, when the framework's improvement takes a typical pattern,
    we say the framework has a behavior pattern. Whether a framework is static or
    dynamic relies upon how it changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision-making process has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance measure (or indicator)**: The development of powerful measures
    is seen as important in every organization. Performance measures give the desirable
    levels of results, that is, the target of your choice. The goal is essential in
    recognizing the anticipating action:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategic**: Return on Investment, growth, and innovations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tactical**: Cost, quantity, and customer satisfaction'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational**: Target setting and conformance with standard'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: Resources are the consistent components that don''t change amid
    the time range of the forecast. Resources are the variables that characterize
    the decision issue. Strategic decisions ordinarily have longer time horizons than
    both the tactical and the operational choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forecasts**: Forecast information originates from the environment of the
    decision maker. Uncontrollable inputs must be determined or predicted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decisions**: Decision inputs are the collection of all conceivable approaches
    that are possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction**: Associations among the preceding decision parts are the logical,
    scientific functions representing the circumstances and end result connections
    among inputs, resources, forecasts, and the result. At the point when the result
    of a decision relies upon the strategy, we transform one or more parts of the
    risky circumstance with the aim of realizing an attractive change in some other
    part of it. We succeed in the event that we know about the connection among the
    parts of the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Decision making includes the choice of a strategy that is chosen
    by the decision maker. The way that our strategy influences the result of a choice
    relies upon how the forecasts and different inputs are interrelated and how they
    identify with the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is TimeSeries?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A time series is an arrangement of insights, typically gathered at standard
    intervals. Time series information normally happens in numerous applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Economics**: For example, monthly data for unemployment, hospital admissions,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finance**: For example, daily exchange rate, a share price, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environmental**: For example, daily rainfall, air quality readings, and so
    on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Medicine**: For example, ECG brain wave activity every 2 to 8 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The techniques for time series investigation predate those for general stochastic
    procedures and Markov chains. The goals of time series analysis are to portray
    and outline time series data, fit low-dimensional models, and to make desirable
    forecasts.
  prefs: []
  type: TYPE_NORMAL
- en: Trends, seasonality, cycles, and residuals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One straightforward strategy for depicting a series is that of classical disintegration.
    The idea is that the arrangement can be segmented into four components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trend (Tt)**: Long-term movements in the mean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seasonal effects (It)**: Cyclical fluctuations related to the calendar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycles (Ct)**: Other cyclical fluctuations (such as a business cycle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Residuals (Et)**: Other random or systematic fluctuations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea is to create separate models for these four elements and then combine
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additively**: *Xt = Tt + It + Ct + Et*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplicatively**:  *Xt = Tt It Ct Et*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difference from standard linear regression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The information is not inexorably independent and is not, as a matter of course, indistinguishably
    distributed. One characteristic for time series is that it is a rundown of observations
    where the ordering matters. Sequence is essential on the grounds that there is
    reliance and changing the sequence could change the importance of the information.
  prefs: []
  type: TYPE_NORMAL
- en: Basic objectives of the analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic objective usually is to determine a model that describes the pattern
    of the time series. Uses for such a model are:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the important features of the time series pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how the past affects the future or how two time series can "interact"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forecasting future values of the series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving as a control standard for a variable that measures the quality of products
    in some manufacturing situations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two basic types of "time domain" model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinary regression models that use time indices as x-variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful for an initial description of the data and form the basis of several
    simple forecasting methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ARIMA models (for Autoregressive Integrated Moving Average):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models that relate the present value of a series to past values and past prediction
    errors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Important characteristics to consider first
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some important questions to first consider when looking at a time series are:'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a trend?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern in which the measurements tend to increase or decrease over time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The effect of seasonality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a regularly repeating pattern of highs and lows related to calendar
    time such as seasons, quarters, months, days of the week, and so on?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any outliers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In regression, outliers are at a distance from the trend line. With time series
    data, the outliers are at a distance from other data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a period unrelated to seasonality factors?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a constant variance over a definite period of time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any abrupt changes to either side?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following plot is an example of random numbers over time. By a time series
    plot, we simply mean that the variable is plotted against time. Similar plots
    can be made for heartbeats over time, market fluctuations, seismic graphs, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Important characteristics to consider first](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some features of the plot include:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no consistent trend (upward or downward) over the entire time span.
    The series appears to slowly wander up and down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some obvious outliers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to judge whether the variance is constant or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systematic pattern and random noise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in most different analyses, in time series analysis it is accepted that the
    information comprises of a systematic pattern (as a set arrangement of identifiable
    segments) and random noise (error), which typically makes the pattern hard to
    recognize. Most of the time, series analysis systems include some type of filtering
    through noise, keeping in mind the end goal to make the pattern more identifiable.
  prefs: []
  type: TYPE_NORMAL
- en: Two general aspects of time series patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most of the time, series patterns can be portrayed regarding two fundamental
    classes of segments:'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pattern is a generally straight or (regularly) nonlinear part that progresses
    after some time and does not rehash (probably) inside the time range caught by
    our data.
  prefs: []
  type: TYPE_NORMAL
- en: Regularity may have a formally similar nature; in any case, it rehashes itself
    in systematic intervals after some time. These two general classes of time series
    components may coexist in actual real-life data.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, offers of an organization can quickly grow over the years, yet
    they still follow predictable seasonal patterns (for example, as much as 30% of
    yearly deals every year are made in October, while just 10% are made in March).
  prefs: []
  type: TYPE_NORMAL
- en: Trend analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are no demonstrated "programmed" systems to distinguish pattern segments
    in the time series data. In any case, the length of the pattern is repetitive
    (increasing or decreasing in a consistent manner) and some portion of data analysis
    is ordinarily not extremely difficult. In the event that the time series information
    contains considerable errors, then the initial phase during the time spent pattern
    distinguishing proof is smoothing.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smoothing dependably includes some type of neighborhood averaging of data such
    that the non-systematic parts of individual perceptions offset each other. The
    most widely recognized method is moving normal smoothing. This replaces every
    component of the series by either the simple or weighted normal of n encompassing
    components, where n is the width of the smoothing "window".
  prefs: []
  type: TYPE_NORMAL
- en: 'Medians can be utilized rather than means. Here are some advantages of medians:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the smoothing window, its results are less biased by outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are outliers in the data, middle smoothing regularly delivers smoother
    or more "reliable" curves than moving normal, taking into account the same window
    width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamental weakness of middle smoothing is that without clear outliers
    it might deliver more jagged curves than moving normal and it doesn't take into
    account weighting.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numerous monotonous time series information can be satisfactorily approximated
    by a linear function. If there is a reasonable monotonous nonlinear part, the
    data initially should be changed to evacuate the nonlinearity. Normally a logarithmic,
    exponential, or (less frequently) polynomial function can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of seasonality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Seasonal dependency (seasonality) is another general part of the time series
    design. For example, if we see a time series graph of buying trends, we can see
    that there is a huge spike during the end of October and December every year.
    This pattern repeats every year.
  prefs: []
  type: TYPE_NORMAL
- en: Autocorrelation correlogram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Seasonal patterns of time series can be analyzed by means of correlograms. The
    correlogram graphically and numerically shows the **autocorrelation function (ACF),**
    which are serial relationship coefficients (and their standard errors) for sequential
    lags in a predetermined range of lags.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges of two standard errors for every lag are generally set apart in correlograms,
    yet commonly the size of autocorrelation is of more interest than its dependability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the correlogram for the `mtcars` dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autocorrelation correlogram](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examining correlograms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We must remember while examining correlograms that autocorrelations for successive
    lags are formally dependent. For example, if the primary component is firmly related
    to the second, and the second to the third, then the main component should likewise
    be to some degree related to the third one, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Partial autocorrelations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another helpful strategy to inspect serial dependencies is to look at the **partial
    autocorrelation capacity** (**PACF**), an expansion of autocorrelation, where
    the dependence on the intermediate components (those inside the lag) is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Removing serial dependency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Serial dependency for a specific lag of k can be evacuated by differencing the
    series, that is, changing over every *i*th component of the series into its difference
    from the *(i-k)*th component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two explanations behind such changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Seasonal dependencies of a hidden nature can be recognized in the series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARIMA and other procedures require that we make the series stationary, which
    itself requires removing the seasonal dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARIMA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have discussed the numerical modeling of the procedure of time series analysis.
    In real life, patterns are not so clear and the observations generally have a considerable
    amount of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements are to:'
  prefs: []
  type: TYPE_NORMAL
- en: Find hidden patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate forecasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now understand ARIMA and how it can help us with getting these.
  prefs: []
  type: TYPE_NORMAL
- en: Common processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Autoregressive procedure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most time series comprise of components that are serially dependent as in you
    can evaluate a coefficient or an arrangement of coefficients that depict back-to-back
    components of the series from particular, time-lagged (past) components.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stationary prerequisite. The autoregressive procedure is stable only within
    a certain range of parameters that the parameters fall into. Previous effects
    can pile up and affect the consecutive points and the series may not be stationary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving normal procedure. Autonomous from the autoregressive procedure, every
    component in the series can likewise be influenced by the past error (or arbitrary
    shock) that can't be represented by the autoregressive component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Invertibility necessity. There is a "duality" between the moving normal procedure
    and the autoregressive procedure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moving normal equation can be transformed into an autoregressive structure.
    In any case, undifferentiated from the stationary condition depicted over, this
    must be done if the moving normal parameters take after specific conditions, that
    is, if the model is invertible. Also, the series won't be stationary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ARIMA methodology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Autoregressive moving average model.
  prefs: []
  type: TYPE_NORMAL
- en: The general model presented by Box and Jenkins (1976) incorporates autoregressive,
    and in addition, moving normal parameters and unequivocally incorporates differencing
    in the detailing of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the three sorts of parameters in the model are:'
  prefs: []
  type: TYPE_NORMAL
- en: The autoregressive parameters (p)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quantity of differencing passes (d)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving normal parameters (q)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the documentation presented by Box and Jenkins, models are abridged as ARIMA
    (p, d, q).
  prefs: []
  type: TYPE_NORMAL
- en: Identification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input series for ARIMA should be stationary. It must have a steady mean,
    difference, and autocorrelation through time. Subsequently, for the most part,
    the series first should be differenced until it is stationary (this, likewise,
    regularly requires log changing the data to make the variance stable).
  prefs: []
  type: TYPE_NORMAL
- en: The quantity of times the series should be differenced to accomplish stationarity
    is reflected in the "d" parameter. So as to decide the fundamental level of differencing,
    we need to look at the plot of the data and auto-correlogram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Noteworthy changes in level (solid upward or descending changes) ordinarily
    require first order nonseasonal (lag=1) differencing:'
  prefs: []
  type: TYPE_NORMAL
- en: Solid changes of incline generally require second order nonseasonal differencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimation and forecasting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is estimation. Here the parameters are assessed (utilizing function
    minimization systems) so that the sum of squared residuals is minimized. The assessments
    of the parameters are utilized as a part of the last stage (forecasting) to compute
    new estimations of the series (past those incorporated into the input dataset)
    and confidence intervals for those predicted values.
  prefs: []
  type: TYPE_NORMAL
- en: The estimation procedure is performed on changed (differenced) information before
    the forecasted figures are produced. It is required that the series should be
    integrated so that the forecasts are communicated in values compatible with the
    input data.
  prefs: []
  type: TYPE_NORMAL
- en: The constant in ARIMA models
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the standard autoregressive and moving normal parameters, ARIMA models
    may likewise incorporate a constant. The representation of this constant is dependent
    on the model that is fit:'
  prefs: []
  type: TYPE_NORMAL
- en: If in the model there are no autoregressive parameters present, then the mean
    of the series is the expected value of the constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If in the model there are autoregressive parameters present, then the intercept
    is represented by the constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identification phase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before the estimation can start, we have to settle on (distinguish) the particular
    number and kind of ARIMA parameters to be evaluated. The significant instruments
    utilized as a part of the ID stage are:'
  prefs: []
  type: TYPE_NORMAL
- en: Plots of the arrangement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correlograms of autocorrelation (ACF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial autocorrelation (PACF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice is not direct and in less typical cases requires experience as well
    as a decent arrangement of experimentation with option models (and also the specialized
    parameters of ARIMA).
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, a good amount of experimental time series patterns can be adequately
    approximated utilizing one of the five fundamental models. These models are based
    on the shape of the **autocorrelogram** (**ACF**) and **partial auto correlogram**
    (**PACF**):'
  prefs: []
  type: TYPE_NORMAL
- en: 'One autoregressive parameter (p):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACF: Exponential decay'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PACF: Spike at lag 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No correlation for other lags
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two autoregressive parameters (p):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACF: A sine-wave shape pattern or a set of exponential decays'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PACF: Spikes at lags 1 and 2'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No correlation for other lags
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One moving average parameter (q):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACF: Spike at lag 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No correlation for other lags
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PACF: Damps out exponentially'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two moving average parameters (q):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACF: Spikes at lags 1 and 2'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No correlation for other lags
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PACF: A sine-wave shape pattern or a set of exponential decays'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One autoregressive (p) and one moving average (q) parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACF: Exponential decay starting at lag 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PACF: Exponential decay starting at lag 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Seasonal models
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A series in which a pattern repeats seasonally over time requires special models.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to the simple ARIMA parameters in seasonal models:'
  prefs: []
  type: TYPE_NORMAL
- en: Seasonal autoregressive (ps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seasonal differencing (ds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seasonal moving normal parameters (qs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, let's take the model (0,1,2)(0,1,1).
  prefs: []
  type: TYPE_NORMAL
- en: 'This depicts a model that incorporates:'
  prefs: []
  type: TYPE_NORMAL
- en: No autoregressive parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two general moving normal parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One regular moving normal parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seasonal lag utilized for the seasonal parameters is normally decided amid
    the identification proof stage and should be expressly indicated.
  prefs: []
  type: TYPE_NORMAL
- en: The general suggestions concerning the choice of parameters to be assessed (taking
    into account ACF and PACF) likewise apply to seasonal models. The principle distinction
    is that in seasonal series, ACF and PACF will indicate sizable coefficients at
    products of the seasonal lag.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter estimation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few distinct techniques for assessing the parameters. Every one
    of them should fundamentally deliver the same estimates, yet might be pretty much
    proficient for any given model. Generally, amid the parameter estimation stage,
    a function minimization calculation is utilized to maximize the probability (likelihood)
    of the watched series given the parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: This requires the computing of the (conditional) aggregates of squares (SS)
    of the residuals, given the separate parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this requires the calculation of the (conditional) sums of squares
    (SS) of the residuals, given the respective parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different methods have been proposed to compute the SS for the residuals:'
  prefs: []
  type: TYPE_NORMAL
- en: The approximate maximum likelihood method according to McLeod and Sales (1983)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The approximate maximum likelihood method with backcasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact maximum likelihood method according to Melard (1984)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation of the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Parameter estimates**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Report surmised *t* values, figured from the parameter standard errors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no significance, then the separate parameter can most of the time
    be dropped from the model without considerably influencing the overall fit of
    the model
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other quality criteria**: Another clear and normal measure of the quality
    of the model is the exactness of its forecasts created taking into account partial
    data so that the forecasts can be contrasted and known (unique) observations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupted time series ARIMA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might want to assess the effect of one or more discrete occasions on the
    qualities in the time series. These kinds of interruptions on time series analysis
    are portrayed in subtle elements in McDowall, McCleary, Meidinger, and Hay (1980).
    McDowall, et al., recognize three noteworthy sorts of effects that are conceivable:'
  prefs: []
  type: TYPE_NORMAL
- en: Permanent abrupt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permanent gradual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abrupt temporary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential smoothing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exponential smoothing has turned out to be exceptionally well known as a forecasting
    strategy for various types of time series data. The strategy was freely created
    by Brown and Holt. Brown worked for the US Navy during World War II, where his
    task was to design a tracking system for fire-control information to compute the
    location of submarines. Later, he connected this strategy to the forecasting of
    interest for spare parts (an inventory control issue).
  prefs: []
  type: TYPE_NORMAL
- en: Simple exponential smoothing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A simple model for a time series t would be to consider every observation as
    comprising of a constant (*b*) and an error component (epsilon), that is: *Xt
    = b + t*.'
  prefs: []
  type: TYPE_NORMAL
- en: The constant b is generally steady in every fragment of the series; however,
    it may change gradually after some time. On the off chance of fitting, then one
    approach to seclude the genuine estimation of b, and therefore the orderly or
    unsurprising part of the series, is to figure a sort of moving normal, where the
    current and quickly new observations are doled out more prominent weight than
    the particular older observations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exponential smoothing fulfills precisely such weighting where exponentially
    smaller weights are doled out to older observations. The specific formula for
    simple exponential smoothing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*St = a*Xt + (1-a)*St-1*'
  prefs: []
  type: TYPE_NORMAL
- en: At the point when connected recursively to each progressive observation in the
    series, each new smoothed value (forecast) is figured as the weighted normal of
    the present observation and the past smoothed observation.
  prefs: []
  type: TYPE_NORMAL
- en: The past smoothed observation was processed from the past observed value and
    the smoothed quality before the past perception, and so on. Subsequently, each
    smoothed value is the weighted normal of the past perceptions where the weights
    decrease exponentially relying upon the estimation of the parameter (alpha).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the off chance that it is equivalent to 1 (one), then the past perceptions
    are overlooked altogether; if it is equivalent to 0 (zero), then the present perception
    is disregarded totally, and the smoothed worth comprises completely of the past
    smoothed quality (which is processed from the smoothed perception before it, and
    so on; along these lines every single smoothed quality will be equivalent to the
    underlying smoothed worth S0). Estimations in the middle will deliver transitional
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: If it is equal to 1, then the past observations are ignored completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it is equal to 0, then the current observation is ignored completely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smoothed value consists completely of the past smoothed value (which, in
    turn, is computed from the smoothed observation before it, and so on; thus all
    smoothed values will be equal to the initial smoothed value, S0). Estimations
    in the middle will deliver transitional results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The hypothetical model for the process hidden in the observed time series, simple
    exponential smoothing, will frequently create precise forecasts.
  prefs: []
  type: TYPE_NORMAL
- en: Indices of lack of fit (error)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most direct method for assessing the exactness of the forecasts in light
    of a specific value is to just plot the observed values and the one-stage ahead
    of forecasts. This plot can likewise incorporate the residuals (scaled against
    the right *Y* axis), so that locales of better or most noticeably bad fit can
    likewise effectively be distinguished.
  prefs: []
  type: TYPE_NORMAL
- en: 'This visual check of the precision of forecasts is frequently the most intense
    technique for figuring out if or not the present exponential smoothing model fits
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean error**: The **mean error** (**ME**) quality is essentially processed
    as the normal error value (normal of observed minus one-stage ahead forecast):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, a downside of this measure is that positive and negative error values
    can counterbalance each other, so this measure is not a decent marker of general
    fit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean absolute error:** The **mean absolute error** (**MAE**) value is processed
    as the normal absolute error value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is 0 (zero) then the fit (forecast) is considered perfect.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared with the mean squared error value, this measure of fit will neglect
    anomalies, therefore, one of a kind or uncommon large error values will influence
    the MAE less than the MSE value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sum **of squared error (SSE) and mean squared error**: These values are calculated
    as the aggregate (or normal) of the squared error values. This is the most normally
    utilized absence of-fit indicator as a part of statistical fitting strategies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Percentage error (PE)**: All the preceding measures depend on the actual
    error value. It might appear to be sensible to rather express the absence of fit
    as far as the relative deviation of the one-stage ahead forecasts from the observed
    values, which is with respect to the magnitude of the observed values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, when attempting to foresee month-to-month deals that may fluctuate
    generally from month to month, we might be fulfilled if our expectation "hits
    the objective" with about ±10% precision. At the end of the day, the outright
    errors might be of less interest, but rather more are the relative errors in the
    forecasts:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEt = 100*(Xt - Ft )/Xt*'
  prefs: []
  type: TYPE_NORMAL
- en: Here *Xt* is the observed value at time *t*, and *Ft* is the forecasts (smoothed
    values).
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean percentage error (MPE)**: This value is computed as the average of the
    PE values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean absolute percentage error (MAPE)**: As is the situation with the mean
    error value, a mean percentage error close to 0 (zero) can be created by substantial
    positive and negative rate percentage errors that offset each other. Consequently,
    a superior measure of relative general fit is the mean absolute percentage error.
    Additionally, this measure is generally more significant than the mean squared
    mistake:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, realizing that the normal forecast is "off" by ±5% is a helpful
    result all by itself, though a mean squared error of 30.8 is not quickly interpretable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic search for best parameter**: A quasi-Newton function minimization
    procedure (the same as in ARIMA) is utilized to minimize either the mean squared
    error, mean absolute error, or mean total rate error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The initially smoothed value S0**: We require a S0 value keeping in mind
    the end goal to process the smoothed quality (forecast) for the main observation
    in the series. Depending upon the decision of the parameter (that is, when it
    is near zero), the underlying value for the smoothing procedure can influence
    the nature of the forecasts for some observations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation in Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TimeSeries is a registered package. So like other packages, we can add it to
    your Julia packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The TimeArray time series type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four fields for the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp`: The timestamp field consists of a vector of values of a child
    type of `TimeType`, in practice, either `Date` or `DateTime`. The `DateTime` type
    is similar to the Date type except it represents time frames smaller than a day.
    For the construction of a TimeArray to work, this vector needs to be sorted. If
    the vector includes dates that are not sequential, the construction of the object
    will error out. The vector also needs to be ordered from the oldest to latest
    date, but this can be handled by the constructor and will not prohibit an object
    from being created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: The values field holds the data from the time series and its row
    count must match the length of the timestamp array. If these do not match, the
    constructor will fail. All the values inside the values array must be of the same
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colnames`: The `colnames` field is a vector of type UTF8 String and contains
    the names of the columns for each column in the values field. The length of this
    vector must match the column count of the values array, or the constructor will
    fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta`:The meta field defaults to holding nothing, which is represented by
    type Void. This default is designed to allow programmers to ignore this field.
    For those who wish to utilize this field, `meta` can hold common types such as
    String or more elaborate user-defined types. One might want to assign a name to
    an object that is immutable versus relying on variable bindings outside of the
    object''s type fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll be using historical financial datasets available in the `MarketData`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go through the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through some more records and statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also go through them using the column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the records using Date, it can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also list the records over the range of the dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use two different columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using time constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some specific methods that can segment on time ranges if the condition
    is met.
  prefs: []
  type: TYPE_NORMAL
- en: when
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The when method allows aggregating elements from a `TimeArray` into specific
    time periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: `dayofweek` or `month`. Here are some dates methods with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: from
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: findwhen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is probably one of the most used and efficient methods. It tests a condition
    and returns the `Date` or `DateTime` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: find
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `find` method is similar to `findwhen`. It tests a condition and returns
    a vector of Int, representing the row in the array where the condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Mathematical, comparison, and logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These methods are also supported by the TimeSeries package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use mathematical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '+ or .+: Mathematical element-wise addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- or .-: Mathematical element-wise subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* or .*: Mathematical element-wise multiplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: './: Mathematical element-wise division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.^: Mathematical element-wise exponentiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '% or .%: Mathematical element-wise remainder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: .> element-wise greater-than comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .< element-wise less-than comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .== element-wise equivalent comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .>= element-wise greater-than or equal comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .<= element-wise less-than or equal comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .!= element-wise not-equivalent comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '& element-wise logical AND'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| element-wise logical OR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!, ~ element-wise logical NOT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $ element-wise logical XOR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying methods to TimeSeries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Common transformation of time series data involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Lagging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windowing operations and aggregation operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `lag` method is putting yesterday''s value in today''s timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is applying lag on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Lead
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lead is opposite to the lag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As the cl is 500 rows long we can lead till that. For now, we will lead by
    400:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Percentage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most common time series operations is to calculate the change in
    percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This shows the percentage change from the previous record.
  prefs: []
  type: TYPE_NORMAL
- en: Combining methods in TimeSeries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two `TimeArrays` can be merged to generate a meaningful array.
  prefs: []
  type: TYPE_NORMAL
- en: Merge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Merge joins two TimeArrays. By default, it joins using an inner join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we provided the type of join we want to perform. We
    can also do right or outer joins.
  prefs: []
  type: TYPE_NORMAL
- en: Collapse
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `collapse` method is used to compress data into a larger time frame.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is used for transformations in the timeseries data. The first argument
    of this method is a binary function (the time stamp and the values). This method
    returns two values, respectively the new time stamp and the new vector of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You apply the map method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This transforms the records for the particular time provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what is forecasting and why it is needed in
    a business. Forecasting helps to identify the demand and take necessary steps,
    as well as in other domains it helps to predict weather, and so on. The decision-making
    process is highly affected by the results of forecasting. Time Series is the arrangement
    of insights, typically gathered at standard intervals. It has been used in various
    domains such as medical, weather, finance markets, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the different types of models and how to analyze trends
    in Time Series. We also took into consideration seasonality effects on the Time
    series analysis. We discussed ARIMA in detail and also explored the Time Series
    library of Julia.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[http://timeseriesjl.readthedocs.io/en/latest/](http://timeseriesjl.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://documents.software.dell.com/statistics/textbook/time-series-analysis](https://documents.software.dell.com/statistics/textbook/time-series-analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://home.ubalt.edu/ntsbarsh/stat-data/forecast.htm](http://home.ubalt.edu/ntsbarsh/stat-data/forecast.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://userwww.sfsu.edu/efc/classes/biol710/timeseries/timeseries1.htm](http://userwww.sfsu.edu/efc/classes/biol710/timeseries/timeseries1.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://onlinecourses.science.psu.edu/stat510/node/47](https://onlinecourses.science.psu.edu/stat510/node/47)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4.htm](http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
