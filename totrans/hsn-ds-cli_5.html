<html><head></head><body>
        

                            
                    <h1 class="header-title">Loops, Functions, and String Processing</h1>
                
            
            
                
<p class="mce-root">Sometimes, magic one-liners are insufficient for manipulating data. Loops and conditionals enable us to iterate over data in interesting ways without sticking to default behavior. </p>
<p class="mce-root">Bash views non-binary files and streams as collections of characters. We commonly think of these characters as groups of strings separated by some kind of whitespace. It makes sense that some of the most useful and common tools in the command-line universe are the ones that search and manipulate these strings.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400"><kbd>for</kbd> loops</li>
<li style="font-weight: 400"><kbd>while</kbd> loops</li>
<li style="font-weight: 400">File test conditionals</li>
<li style="font-weight: 400">Numeric comparisons</li>
<li style="font-weight: 400">String case statements</li>
<li style="font-weight: 400">Using regular expressions and <kbd>grep</kbd> to search and filter</li>
<li style="font-weight: 400">String transformations using <kbd>awk</kbd>, <kbd>sed</kbd>, and <kbd>tr</kbd></li>
<li style="font-weight: 400">Sorting lists of strings with <kbd>sort</kbd> and <kbd>uniq</kbd></li>
</ul>
<p>Along the way, we'll see how we can pipe the results of one program into another to get the results we want.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Once, twice, three times a lady loops</h1>
                
            
            
                
<p>Few command-line tools have implicit looping and conditionals built into them. Often, tasks will only operate on each line of an input stream and then terminate. The shell provides just enough control flow and conditionals to solve many complex problems, making up for any deficiencies that command-line tools have for operating on data.</p>
<p>The almighty <kbd>for</kbd> loop is a common loop idiom, however bash's <kbd>for</kbd> loop might feel a little unfamiliar to users of more traditional languages. The <kbd>for</kbd> loop allows you to iterate over a list of words, and assign each one to a variable for processing. For example, (pun intended):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-878 image-border" src="img/ada257e1-0797-4f71-b0f6-a8b281d81153.png" style="width:39.25em;height:5.92em;"/></p>
<p>Often, we want a more traditional range of numbers in our <kbd>for</kbd> loops. The <kbd>POSIX</kbd> method of generating a number range is to use the <kbd>seq</kbd> command, as in <kbd>seq -- $(seq 1 1 5)</kbd>, which will generate numbers from 1 (the first argument) to 5 (the third argument) in steps of 1 increment (the second argument). </p>
<p>In the following examples, you'll notice we are using bracket expansions, <kbd>{}</kbd>, and parentheses, <kbd>()</kbd>. For more information about both, check out <a href="https://ss64.com/bash/syntax-brackets.html">https://ss64.com/bash/syntax-brackets.html</a>.</p>
<p>Modern versions of <kbd>bash</kbd> provide an easy shorthand for this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-879 image-border" src="img/17774fa8-f1c3-44c6-b4fd-fdf1f1f63607.png" style="width:38.58em;height:7.08em;"/></p>
<p>We can also set the amount that the sequence is incremented by:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-880 image-border" src="img/2ed52b37-5d53-40ba-878d-a7ab14d4cf4d.png" style="width:35.08em;height:5.67em;"/></p>
<p class="mce-root"/>
<p>Alternatively, we can use the <kbd>bash</kbd> supported C-like syntax:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-881 image-border" src="img/b4aa359d-7e15-48f5-a7de-fba201b5b3f7.png" style="width:41.67em;height:7.67em;"/></p>
<p>Looping for a specified number of times may be what we need, but we can also pass in the result of a sub-command to generate the list of things to loop over. For example, we may want to do something to each file in the current directory:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-882 image-border" src="img/f8cf46e8-8f49-4489-9544-1512e3610085.png" style="width:119.58em;height:16.00em;"/></p>
<p>Often, we may want to test one or more conditionals, especially in loops. Bash has an <kbd>if-then</kbd> construct, like most languages:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-883 image-border" src="img/bc85b83b-d991-43b1-b387-add64e2200f9.png" style="width:126.58em;height:8.50em;"/></p>
<p>The statement inside the brackets is a test, and bash contains a set of special tests, such as <kbd>-f</kbd> for common tasks. Here's a list of some of the most common ones:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Test type</strong></p>
</td>
<td>
<p><strong>Parameter</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-O</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is owned by the effective user ID</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-f</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is a regular file</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-G</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is owned by the effective group ID</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-r</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is readable</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-w</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is writable</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-x</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is executable</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-s</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and has a size greater than zero</p>
</td>
</tr>
<tr>
<td>
<p>Filesystem</p>
</td>
<td>
<p><kbd>-h</kbd></p>
</td>
<td>
<p><kbd>True</kbd> if file exists and is a symbolic link</p>
</td>
</tr>
<tr>
<td>
<p>Arithmetic</p>
</td>
<td>
<p><kbd>&lt;=</kbd></p>
</td>
<td>
<p>Less than equal</p>
</td>
</tr>
<tr>
<td>
<p>Arithmetic</p>
</td>
<td>
<p><kbd>&gt;=</kbd></p>
</td>
<td>
<p>Greater than equal</p>
</td>
</tr>
<tr>
<td>
<p>Arithmetic</p>
</td>
<td>
<p><kbd>&lt;</kbd> </p>
</td>
<td>
<p>Less than</p>
</td>
</tr>
<tr>
<td>
<p>Arithmetic</p>
</td>
<td>
<p><kbd>&gt;</kbd> </p>
</td>
<td>
<p>Greater than</p>
</td>
</tr>
<tr>
<td>
<p>Arithmetic</p>
</td>
<td>
<p><kbd>!=</kbd></p>
</td>
<td>
<p>Not equal</p>
</td>
</tr>
<tr>
<td>
<p>Arithmetic</p>
</td>
<td>
<p><kbd>=</kbd></p>
</td>
<td>
<p>Equal</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Like other languages, we can also include <kbd>else-if</kbd> tests, and finally an <kbd>else if</kbd> nothing else matches:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-884 image-border" src="img/48ae89f3-e5f2-4ffd-93e3-75e7711430ff.png" style="width:119.67em;height:9.75em;"/></p>
<p>Even though the <kbd>if-else</kbd> construct exists, most shell scripts use the pipeline semantics of <kbd>&amp;&amp; (AND)</kbd> and <kbd>|| (OR)</kbd>. We briefly mentioned this in <a href="ea035d0b-e34a-481c-87f4-53c45869e4a3.xhtml">Chapter 3</a>, <em>Obtaining and Working with Data and Detached Processing and Terminal Multiplexers</em>, but here's a more detailed example:</p>
<pre>[ 0 = 1 ] &amp;&amp; echo "a" || ([0==2] &amp;&amp; echo b || echo c)<br/>[ -f /myconfig ] &amp;&amp; read_params /myconfig</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">It's the end of the world as we know it while and until </h1>
                
            
            
                
<p>Let's explore two more options for assisting with iteration. The <kbd>while</kbd> construct allows for the repetitive execution of a list or set of commands as long as the command that controls the <kbd>while</kbd> loop exits successfully. Let's see an example:</p>
<p>Let's say I wanted to print the <kbd>"hello!"</kbd> string four times in a script—no more and no less. We can do so with the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-885 image-border" src="img/88518703-1714-4788-904c-b7a3ba02a38d.png" style="width:12.50em;height:16.08em;"/></p>
<p>Let's save and run this script to see what happens.</p>
<p>Don't forget to <kbd>chmod -x</kbd> these scripts to make them executable.</p>
<p>Executing the script produces the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-886 image-border" src="img/00080cc2-726b-4440-98c5-a1d875db5c32.png" style="width:22.92em;height:8.08em;"/></p>
<p>Notice that, in the script, we created a variable called <kbd>i="0"</kbd>. This sets the <kbd>i</kbd> variable to zero. Do you see the <kbd>while [ $i -lt 4 ]</kbd> block? This allows us to run the loop as the <kbd>i</kbd> variable is less than the <kbd>4</kbd> integer. Go ahead and play around with this code for a bit to get a better understanding. Also, you can <kbd>man [</kbd> for more information.</p>
<p>In our while script, we counted up until four for our output. Let's use the <kbd>until</kbd> construct to count down and provide the <kbd>goodbye!</kbd> output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-887 image-border" src="img/be4e8256-218b-4c48-a3bd-5a219b2650fc.png" style="width:12.17em;height:15.42em;"/></p>
<p>Let's save and run this script to see what happens:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-888 image-border" src="img/bbc9c002-41c4-481c-b557-1878fe92d685.png" style="width:23.83em;height:15.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The simple case</h1>
                
            
            
                
<p>Frequently, string comparison is done using the test operator, <kbd>[</kbd>. This is ill-advised in bash, as there's a much more convenient format for string comparison, using the <kbd>case</kbd> statement. Here's a simple example:</p>
<pre><br/> testcase() {<br/> for VAR; do<br/> case “${VAR}” in<br/>         '') echo “empty”;;<br/>         a) echo “a”;;<br/>        b) echo “b”;;<br/>        c) echo “c”;;<br/>        *) echo “not a, b, c”;;<br/> esac<br/> done<br/> }<br/> testcase '' foo a bar b c d</pre>
<p>The <kbd>testcase</kbd> function lets us test the <kbd>case</kbd> statement by wrapping it in a <kbd>for</kbd> loop that assigns each function argument to the <kbd>VAR</kbd> variable, then executes the <kbd>case</kbd> statement. With the <kbd>foo a bar b c d</kbd> arguments, we can expect the following output:</p>
<pre> empty<br/> not a, b, c<br/> a<br/> not a, b, c<br/> b<br/> c<br/> d<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Pay no heed to the magician redirecting your attention</h1>
                
            
            
                
<p>Looping is great for working over sequences of data in an iterative fashion, but sometimes, when you're doing all that work, you get lots of irrelevant output. Enter our little magician: the output redirection operator, <kbd><em>&gt;</em></kbd>. This operator directs output to a specified file or file descriptor. We've talked about file descriptors, they are integers that the OS uses to identify a file handle that has been opened, and by default there are three opened for every process: <kbd>stdin</kbd>, <kbd>stdout</kbd>, and <kbd>stderr</kbd>. The default file descriptors, denoted by <kbd>fd#</kbd>, are <kbd>fd0</kbd> for standard input, <kbd>fd1</kbd> for standard output, and <kbd>fd2</kbd> for standard error. The <kbd><em>&gt;</em></kbd> operator by default, redirects <kbd>stdout</kbd>, the equivalent of <kbd>1&gt;</kbd>, unless it's preceded by an integer file-descriptor. Let's see some examples of output redirection, before we get lost in what we're referring to:</p>
<pre><strong>ls /<br/>ls / &gt;/dev/null<br/>ls /foobar 2&gt;/dev/null<br/>ls / /foobar &gt;stdout_and_stderr.log 2&gt;&amp;1<br/>ls / /foobar &gt;stdout.log 2&gt;stderr.log<br/>ls / /foobar 2&gt;&amp;1 &gt;/dev/null</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Normal messaging is sent to standard output, and is rendered as text in your Terminal window. This is how <kbd>ls /</kbd> will show the contents of the root filesystem to your Terminal. In the second invocation, we use <kbd>&gt;</kbd> to indicate that <kbd>stdout</kbd> should be redirected to <kbd>/dev/null</kbd>, which will discard the output. The third sends error messages to <kbd>dev/null</kbd>, so they don't render to the Terminal. The fourth example redirects <kbd>stdout</kbd> to a file named <kbd>stdout_and_stderr.log</kbd> and then copies <kbd>stderr</kbd> to the same location as <kbd>stdout</kbd> with <kbd>&amp;1</kbd>. The fifth example splits <kbd>stdout</kbd> to <kbd>stdout.log</kbd> and <kbd>stderr</kbd> to <kbd>stderr.log</kbd>. The sixth example doesn't<em> </em>redirect <kbd>stderr</kbd> to <kbd>/dev/null</kbd>, rather it redirects <kbd>stderr</kbd> to where <kbd>stdout</kbd> is pointing at the time of the assignment—the Terminal and then <kbd>stdout</kbd> is redirected to <kbd>/dev/null</kbd>. This shows that the order of operators matters and diligence should be paid to ensure that assignments occur in definition order. The last point to make is that because <kbd>stdout</kbd> is a file descriptor, and not the Terminal, it's possible to direct other output to the Terminal, and have <kbd>stdout</kbd> directed to another file descriptor that won't result in Terminal output.</p>
<p>There are three less-frequently-used redirection operators: <kbd>&lt;</kbd> for input redirection, <kbd>&gt;&gt;</kbd> for output append redirection, and <kbd>&lt;&lt;</kbd> for <kbd>HEREDOC</kbd>. Input redirection is used to feed data into a pipeline, like this:</p>
<pre><strong>cat &lt;stdout.log | grep lines</strong><br/></pre>
<p>This will read <kbd>stdout.log</kbd> into the standard input of the <kbd>cat</kbd> command, which will write its output to the pipe operator. There's really not much more to input redirection, as pipelines implicitly set the <kbd>stdout</kbd> of the previous command to the standard input of the next command. We also mentioned the append operator, <kbd>&gt;&gt;</kbd> , and it's necessary to point out that the <kbd>&gt;</kbd> redirection operator truncates files to zero content before writing. This behavior isn't desired if data needs to be preserved between runs. To clarify, this truncates data in <kbd>keys.log</kbd>:</p>
<pre><strong>grep keyword &gt; keys.log</strong></pre>
<p>The other option is appending the following:</p>
<pre><strong>grep keyword &gt;&gt; keys.log</strong></pre>
<p class="mce-root"/>
<p>Lastly, the <kbd>heredoc</kbd> operator, <kbd>&lt;&lt;</kbd>, it replaces standard input with a predefined text-stream book ended by a keyword that follows <kbd>&lt;&lt; KEYWORD</kbd>. For example, the following example can be used to truncate an <kbd>options.conf</kbd> file and write the three option values into the file:</p>
<pre><strong>cat &lt;&lt;EOF &gt;options.conf<br/>option=true<br/>option2=false<br/>option3=cat<br/>EOF</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Regular expressions and grep</h1>
                
            
            
                
<p>One key task you will face over and over is matching particular patterns of text. The match might be as simple as finding one instance of a specific string in a body of text, or it could be much more complicated. A great tool for matching text is the language of regular expressions. A regular expression is an abstract way of expressing certain types of string-matching patterns.</p>
<p>Contrary to popular belief, regular expressions can't match everything you might want to match. They're limited to certain types of matches, and depending on the particular flavor of regular expression implementation, they could have a little more or a little less power. As an academic exercise, one might try to characterize exactly what you can match and what you can't. It's a very interesting endeavor that cuts to the very core of theoretical computer science. But we won't be doing that here: we are here to do practical things!</p>
<p>First up, you'll want to find a way to test your regular expressions. There are several tools available on the web that allow you to interactively test your matches. A couple of good ones are listed at the end of this section. Of course, this is a command-line book, and you can test matches yourself just by putting test text in a file and using <kbd>grep</kbd>. Grep is a program that takes a regular expression and emits the lines in the input stream that match that regular expression (by default, it emits lines where any substring of the line matches the regular expression).</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Exact matches</h1>
                
            
            
                
<p>A regular expression is a string itself. Several characters are reserved, that is, when they're present in the string, they have a special meaning. Any non-reserved character in the <kbd>regex</kbd> must be matched exactly, in the exact order that it appears. Notably, a <kbd>regex</kbd> that's nothing but a normal character must be an exact match on the entire string.</p>
<p>You do multiple things with a <kbd>regex</kbd>. Sometimes, you may require that the entire target strings match. Other times, you may want to find if and where a substring of the target string matches.</p>
<p>Here's a table of <kbd>regex</kbd> pattern matches:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 100px">
<p><strong>Regex</strong></p>
</td>
<td style="width: 105px">
<p><strong>String</strong></p>
</td>
<td style="width: 155px">
<p><strong>Matches?</strong></p>
</td>
<td style="width: 316px">
<p><strong>Matches substring?</strong></p>
</td>
</tr>
<tr>
<td style="width: 100px">
<p>abc</p>
</td>
<td style="width: 105px">
<p>abc</p>
</td>
<td style="width: 155px">
<p>Yes</p>
</td>
<td style="width: 316px">
<p>Yes</p>
</td>
</tr>
<tr>
<td style="width: 100px">
<p>abc</p>
</td>
<td style="width: 105px">
<p>abcd</p>
</td>
<td style="width: 155px">
<p>No</p>
</td>
<td style="width: 316px">
<p>Yes (abcd)</p>
</td>
</tr>
<tr>
<td style="width: 100px">
<p>abc</p>
</td>
<td style="width: 105px">
<p>def</p>
</td>
<td style="width: 155px">
<p>No</p>
</td>
<td style="width: 316px">
<p>No</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's look for an exact match on the <kbd>aardvark</kbd> string in the review titles of our test dataset:</p>
<pre><strong> zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | grep aardvark</strong> </pre>
<p>The red-highlighted content is the matched content:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-781 image-border" src="img/23b0669d-2c44-4eab-93c6-9d9d9315f664.png" style="width:129.33em;height:11.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Character sets</h1>
                
            
            
                
<p>After an exact string, you might want to match one of a couple of characters instead of one exactly. To do this, we use the <kbd>characters []</kbd> bracket to enclose the list of characters that we might want to match. We can only match one of the possible characters inside the brackets.</p>
<p>Here's a table of <kbd>regex</kbd> pattern matches:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 109px">
<p><strong>Regex</strong></p>
</td>
<td style="width: 107px">
<p><strong>String</strong></p>
</td>
<td style="width: 159px">
<p><strong>Matches?</strong></p>
</td>
<td style="width: 324px">
<p><strong>Matches substring?</strong></p>
</td>
</tr>
<tr>
<td style="width: 109px">
<p><kbd>ab[cd]</kbd></p>
</td>
<td style="width: 107px">
<p><kbd>abc</kbd></p>
</td>
<td style="width: 159px">
<p>Yes</p>
</td>
<td style="width: 324px">
<p>Yes</p>
</td>
</tr>
<tr>
<td style="width: 109px">
<p><kbd>ab[cd]</kbd></p>
</td>
<td style="width: 107px">
<p><kbd>abcd</kbd></p>
</td>
<td style="width: 159px">
<p>No</p>
</td>
<td style="width: 324px">
<p>Yes (abcd)</p>
</td>
</tr>
<tr>
<td style="width: 109px">
<p><kbd>ab[cd]</kbd></p>
</td>
<td style="width: 107px">
<p><kbd>abe</kbd></p>
</td>
<td style="width: 159px">
<p>No</p>
</td>
<td style="width: 324px">
<p>No</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's see whether there are any examples of a capitalized <kbd>aardvark</kbd> in our review data:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | grep [Aa]ardvark</strong></pre>
<p>The red-highlighted content is the matched content:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-782 image-border" src="img/c901a393-5b7d-40c3-b4d0-fe629d6545c9.png" style="width:132.67em;height:15.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dot the i (or anything else)</h1>
                
            
            
                
<p>The dot character, <kbd>.</kbd>, is a one-character wildcard character. It will match anything. There are also restricted wildcards that only match certain types of characters: <kbd>\d</kbd> matches a digit, <kbd>\w</kbd> matches any alphanumeric character or an underscore, and <kbd>\s</kbd> matches whitespace.</p>
<p>Here's a table of <kbd>regex</kbd> pattern matches:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 141px">
<p><strong>Regex</strong></p>
</td>
<td style="width: 130px">
<p><strong>String</strong></p>
</td>
<td style="width: 145px">
<p><strong>Matches?</strong></p>
</td>
<td style="width: 296px">
<p><strong>Matches substring?</strong></p>
</td>
</tr>
<tr>
<td style="width: 141px">
<p><kbd>\s..ick</kbd></p>
</td>
<td style="width: 130px">
<p>The trick</p>
</td>
<td style="width: 145px">
<p>Yes</p>
</td>
<td style="width: 296px">
<p>Yes</p>
</td>
</tr>
<tr>
<td style="width: 141px">
<p><kbd>...</kbd></p>
</td>
<td style="width: 130px">
<p><kbd>abcd</kbd></p>
</td>
<td style="width: 145px">
<p>No</p>
</td>
<td style="width: 296px">
<p>Yes (abcd)</p>
</td>
</tr>
<tr>
<td style="width: 141px">
<p><kbd>abc\ddef</kbd></p>
</td>
<td style="width: 130px">
<p><kbd>abc_def</kbd></p>
</td>
<td style="width: 145px">
<p>No</p>
</td>
<td style="width: 296px">
<p>No</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We could have done the last search for a capital A (or anything else starting our <kbd>ardvark</kbd> string) using a dot:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | grep .ardvark<em> </em></strong></pre>
<p class="mce-root"/>
<p>The red-highlighted content is the matched content:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-783 image-border" src="img/d292d85e-ddff-49c1-a060-c797d3556100.png" style="width:129.75em;height:15.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Capture groups</h1>
                
            
            
                
<p>We can set apart groups of characters with parentheses. While not terribly useful on their own, these groups can be combined with other operators to do very useful things. We call these groups capture groups because the <kbd>regex</kbd> engine captures what was matched inside the group. Later on, you can use what was captured to match something else.</p>
<p>We will show some examples of using capture groups later, in the section on <kbd>awk</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Either or, neither nor</h1>
                
            
            
                
<p>The pipe character, <kbd>|</kbd>, lets us match one or the other of something. We can delineate where the pair starts by using a capture group. Invoke the following:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | grep -E '(aardvark|giraffe)'<em> </em></strong></pre>
<p>The red-highlighted content is the matched content:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-785 image-border" src="img/6480d26b-d9f3-4f7e-addb-5041be827137.png" style="width:146.17em;height:34.50em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Repetition</h1>
                
            
            
                
<p>There are three heavily-used operators that let us match repetitions. They are the question mark, <kbd>?</kbd>, the plus, <kbd>+</kbd>, and the asterisk, <kbd>*</kbd>.</p>
<p>The question mark, <kbd>?</kbd>, matches exactly <kbd>0</kbd> or <kbd>1</kbd> instances of the thing it's applied to (a character, set, or group). Invoke the following:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | grep -E '(a)?ardvark'</strong> </pre>
<p>The red-highlighted content is the matched content:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-786 image-border" src="img/4a31491c-6988-4137-b270-b5205d76d60e.png" style="width:138.50em;height:15.42em;"/></p>
<p>The plus operator, <kbd>+</kbd>, matches one or more things, and the asterisk operator, <kbd>*</kbd>, matches <kbd>0</kbd> or more things. Invoke the following:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | grep -E 'aaaaaaa(a)*' | head -n 3<em> </em></strong></pre>
<p>It produces this output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-787 image-border" src="img/df2cda4b-b1c1-4a2a-8a76-b78999c0c692.png" style="width:152.83em;height:13.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other operators</h1>
                
            
            
                
<p>You can match many things with <kbd>regex</kbd>, and each implementation of <kbd>regex</kbd> is a little different. I suggest looking at these resources for a full treatment of each kind of <kbd>regex</kbd> and what you can do with them:</p>
<ul>
<li>A great, comprehensive site with many examples: <a href="https://www.regular-expressions.info/">https://www.regular-expressions.info/</a></li>
<li>A site to test and debug different types of <kbd>regex</kbd>: <a href="https://regex101.com/">https://regex101.com/</a></li>
<li>Another <kbd>regex</kbd> test site: <a href="https://www.regexpal.com/">https://www.regexpal.com/</a></li>
<li>A library of <kbd>regex</kbd> instances that others have created: <a href="http://www.regexlib.com">http://www.regexlib.com</a></li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Putting it all together</h1>
                
            
            
                
<p>As a recap, we have the following operators:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Use</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Brackets []</kbd></p>
</td>
<td>
<p>Specifies sets of characters to match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Capture Group ()</kbd></p>
</td>
<td>
<p>Groups characters, and pulls out what was matched later</p>
</td>
</tr>
<tr>
<td>
<p>Or <kbd>|</kbd></p>
</td>
<td>
<p>Matches one of two things</p>
</td>
</tr>
<tr>
<td>
<p><kbd>?</kbd></p>
</td>
<td>
<p>Matches zero or one times</p>
</td>
</tr>
<tr>
<td>
<p><kbd>+</kbd></p>
</td>
<td>
<p>Matches one or more times</p>
</td>
</tr>
<tr>
<td>
<p><kbd>*</kbd></p>
</td>
<td>
<p>Matches zero or more times</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">awk, sed, and tr</h1>
                
            
            
                
<p>In this section, we will be looking at <kbd>awk</kbd>, <kbd>sed</kbd>, and <kbd>tr</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">awk</h1>
                
            
            
                
<p><kbd>awk</kbd> (including the <kbd>gnu</kbd> implementation, <kbd>gawk</kbd>) is designed for streaming text processing, data extraction, and reporting. An <kbd>awk</kbd> program is structured as a set of patterns that are matched, and actions to take when those patterns are matched:</p>
<pre>pattern {action}<br/>pattern {action}<br/>pattern {action}<br/>…</pre>
<p>For each record (usually each line of text passed to <kbd>awk</kbd>), each pattern is tested to see whether the record matches, and if so, the action is taken. Additionally, each record is automatically split into a list of fields by a delimiter (any run of whitespace by default). The default action, if none is given, is to print the record. The default pattern is to match everything. There are two special patterns, <kbd>BEGIN</kbd> and <kbd>END</kbd>, which are matched only before any records are processed, or after, respectively.</p>
<p><kbd>awk</kbd> is very good at doing certain kinds of math on input streams, which we'll discuss later in the book. For strings, <kbd>awk</kbd> is great at filtering an input stream on complex conditions, doing transformations on input data, and combinations of these things.</p>
<p class="mce-root"/>
<p>Filtering on a complex condition is as easy as supplying the filter condition as a pattern and the default action (which is to say, nothing). <kbd>awk</kbd> will then, by default, print out the whole line. As an example, we might want to simulate grep by matching on a regular expression:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | awk '/aardvark/'</strong><em> </em></pre>
<p>The preceding code produces this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-788 image-border" src="img/ebf9e265-3ffd-4e1d-aba3-bcd60ea6c6e7.png" style="width:133.83em;height:11.75em;"/></p>
<p>Here, the forward slashes indicate that the string inside is a <kbd>regex</kbd>. We can even get rid of <kbd>cut</kbd> here, as <kbd>awk</kbd> itself can look for the tab field separators. If we do this, we need to tell <kbd>awk</kbd> that we're looking for substrings of the appropriate field. The special variables, <kbd>$1</kbd>, <kbd>$2</kbd>, and so on, represent the fields of each record. <kbd>$0</kbd> is the entire record. Invoke the following:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | awk -F"\t" '$13 ~ /aardvark/'<em> </em></strong></pre>
<p>The preceding code produces this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-789 image-border" src="img/0be2ce9f-7e36-44b3-867a-a8707bba9734.png" style="width:162.50em;height:20.67em;"/></p>
<p>We printed the entire record here since we didn't cut it in advance, and we told <kbd>awk</kbd> to do the default, which is printing the entire record. Maybe we want to just print out the title, field <kbd>6</kbd>, when we match <kbd>aardvark</kbd> in the review description. We have to add a non-default action to our filter:</p>
<pre><strong>&gt; zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | awk -F"\t" '$13 ~ /aardvark/ {print $6}'<em> </em></strong></pre>
<p>The preceding code generates this output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-790 image-border" src="img/64f4b185-df59-4540-bebc-9e24b7817197.png" style="width:147.00em;height:11.08em;"/></p>
<p class="mce-root"/>
<p>We can also do things such as picking out the fields we want, re-ordering them, and printing them out with a different field separator which we define in the <kbd>BEGIN</kbd> pattern:</p>
<pre><strong>&gt; zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | awk -F"\t" 'BEGIN {OFS=";"} ; $13 ~ /aardvark/ {print $6, $2, $3}'<em> </em></strong></pre>
<p>The preceding code looks like this in the Terminal:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-791 image-border" src="img/dd9317e4-7700-4761-9633-b0b38182733b.png" style="width:163.08em;height:10.25em;"/></p>
<p>More information on <kbd>awk</kbd> can be found at <a href="https://www.gnu.org/software/gawk/manual/gawk.html">https://www.gnu.org/software/gawk/manual/gawk.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">sed</h1>
                
            
            
                
<p><kbd>sed</kbd> is an alternative to <kbd>awk</kbd> for line-by-line stream editing. One of the most common uses of <kbd>sed</kbd> is for easy <kbd>regex</kbd> replacement. For example, we can pipe the strings that contain <kbd>aardvark</kbd> that we found in the review descriptions and replace them with <kbd>giraffe</kbd>:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | awk '/aardvark/' | sed 's/aardvark/giraffe/g'</strong> </pre>
<p>The preceding code should output the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-792 image-border" src="img/567245f3-acb2-4465-be62-ceb3e62cd023.png" style="width:163.08em;height:11.75em;"/></p>
<p><kbd>sed</kbd> can also delete lines matching a pattern:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | awk '/aardvark/' | sed '/ant/d'</strong></pre>
<p>The preceding code produces this output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-793 image-border" src="img/b3975028-dff4-4139-81e5-bb8425379ce7.png" style="width:150.17em;height:10.00em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Sed has almost 30 commands in addition to more complex stream processing.</p>
<p>More information on sed can be found at <a href="https://www.gnu.org/software/sed/manual/sed.html">https://www.gnu.org/software/sed/manual/sed.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">tr</h1>
                
            
            
                
<p>The <kbd>tr</kbd> command is somewhat simpler than <kbd>awk</kbd> or <kbd>sed</kbd>, but sometimes it's just what's needed: <kbd>tr</kbd> translates or deletes characters from a stream.</p>
<p>Say we really hate the letter <kbd>a</kbd> and we'd like to replace all of them with <kbd>b</kbd>. With <kbd>tr</kbd>, this is simple:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | cut -f13 | awk '/aardvark/' | tr 'a' 'b'</strong> </pre>
<p>The preceding code produces this output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-794 image-border" src="img/825ec6c8-1621-4d4a-ac2f-33f2484ad312.png" style="width:147.58em;height:11.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">sort and uniq </h1>
                
            
            
                
<p>After <kbd>awk</kbd>, <kbd>sed</kbd>, and <kbd>tr</kbd>, <kbd>sort</kbd>, and <kbd>uniq</kbd> are going to be a breeze.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">sort</h1>
                
            
            
                
<p><kbd>sort</kbd>, well, sorts a stream of strings (or numbers). It won't remove duplicates, it keeps them. By default, <kbd>sort</kbd> puts things in alphabetical order.</p>
<p>We can see <kbd>sort</kbd> in action by piping one column of data (using <kbd>cut</kbd>) from a few lines (using head) from our example data:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | head -n 10 | cut -f13 | sort<em> </em></strong></pre>
<p class="mce-root"/>
<p>The preceding code produces this output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-795 image-border" src="img/2f690674-0a78-4f50-84ab-1212b346b303.png" style="width:133.33em;height:28.42em;"/></p>
<p>If you pass <kbd>sort</kbd> the <kbd>-n</kbd> flag, it will <kbd>sort</kbd> numerically instead:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | head -n 10 | tail -n +2 | cut -f13,8 | sort -n<em> </em></strong></pre>
<p>The preceding code produces this output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-796 image-border" src="img/43d738f9-6aa3-461a-8045-84dedd6a3871.png" style="width:153.08em;height:25.83em;"/></p>
<p>Sometimes, you might want to sort on just a part of the data. In this way, you can start to treat these streams of data more like a database. You can use the <kbd>-k</kbd> option to sort data by columns, along with the <kbd>-t</kbd> option if your data is delimited by something other than tabs. We can use this, for example, to find the review with the most helpful votes:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | head -n 50000 | tail -n +2 | sort -t$'\t' -k9n,9  | tail -n 1<em> </em></strong></pre>
<p>The preceding code produces lots of output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-431 image-border" src="img/9673d4fc-1004-47d1-95fc-e623312d4002.png" style="width:199.25em;height:18.08em;"/></p>
<p>Here, we pass the <kbd>-k9n</kbd>, <kbd>9</kbd> option to sort from column <kbd>9</kbd> to column <kbd>9</kbd> (just the one column), and we pass <kbd>n</kbd> to sort numerically.</p>
<p class="mce-root"/>
<p>You can also sort on more than one column. Say we wanted to sort first by column <kbd>9</kbd> descending, but them by column <kbd>10</kbd> ascending:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | head -n 50000 | tail -n +2 | sort -t$'\t' -k9nr,9 -k10n,10  | tail -n 1<em> </em></strong></pre>
<p>The preceding code produces the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-889 image-border" src="img/91fb911a-2eca-48e5-b168-92f0ee848968.png" style="width:162.50em;height:10.17em;"/></p>
<p>In this example, we found the review with the least helpful votes but the most total votes as a tiebreak.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">uniq</h1>
                
            
            
                
<p><kbd>uniq</kbd> is a funny little program that usually just removes adjacent identical lines in a stream of data. We put it in with <kbd>sort</kbd> because, usually, you see it used with data piped from <kbd>sort</kbd> to count the unique values in a stream of data:</p>
<pre><strong>zcat amazon_reviews_us_Digital_Ebook_Purchase_v1_01.tsv.gz | head -n 50000 | tail -n +2 | cut -f8 | sort | uniq<em> </em></strong></pre>
<p>It produces this counting sequence:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-433 image-border" src="img/076eac1e-ac25-49aa-ae3e-8ee71e2f8056.png" style="width:160.17em;height:21.08em;"/></p>
<p>We can see the only possible star ratings are <kbd>1</kbd> through <kbd>5</kbd>.</p>
<p><kbd>uniq</kbd> has some other uses, but this is by far the main use of <kbd>uniq</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered the breadth of bash's control structures and dived into input/output redirection. These features can be leveraged to enhance your command-line functions and enable small scripts that process data in loops without having to resort to a full-fledged programming language for some simple data processing. </p>
<p>We also looked at a lot of ways to slice and dice characters and strings. While many use cases may be covered using string manipulation alone, often we'll want to delve a little deeper into the data represented by these streams to extract useful information.</p>
<p>In the next chapter, we'll look at doing this by using the command line and data streams as a database.</p>


            

            
        
    </body></html>