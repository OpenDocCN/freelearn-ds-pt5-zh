<html><head></head><body>
        

                            
                    <h1 class="header-title">Jupyter Julia Scripting</h1>
                
            
            
                
<p>Julia is a language that was specifically designed to be used for high-performance, numerical computing. Most importantly, it differs from the previous scripting languages that have been covered in this book (R and to a certain extent, Python) in that Julia is a full language  and not limited to data handling.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li> Adding Julia scripting to your installation</li>
<li> Basic Julia in Jupyter</li>
<li> Julia limitations in Jupyter</li>
<li> Standard Julia capabilities</li>
<li> Julia visualizations in Jupyter</li>
<li> Julia Vega plotting</li>
<li> Julia parallel processing</li>
<li> Julia control flow</li>
<li> Julia regular expressions</li>
<li> Julia unit testing</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Julia scripting to your installation</h1>
                
            
            
                
<p>We will install Julia on macOS and Windows. There are very similar steps in both environments due to using Anaconda as the basis for the installation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Julia scripts to Jupyter</h1>
                
            
            
                
<p>Once Julia is available on your machine, enabling Julia within Jupyter is readily accomplished.</p>
<p class="mce-root"/>
<p>First, we need to install Julia on our Windows machine. Navigate to the Julia download page (<a href="http://julialang.org/downloads/">http://julialang.org/downloads/</a>), download the correct version, which is Julia 0.6.1 for most environments, and run the installation with the standard default settings.</p>
<p>You must run the Julia installation as an Administrator on your machine. After downloading the file, open the <kbd>Downloads</kbd> folder, right-click on the Julia executable, and select Run as administrator.</p>
<p>Once the install is complete, you should verify that everything worked. Select Julia from the programs list and run the Julia program. You should see the command line with Julia displayed, as shown in the following screenshot:</p>
<div><img src="img/6a363cf1-9dbf-4a8e-bcae-c9ccb5070b36.png" style="width:42.42em;height:32.92em;"/></div>
<p>The current version of Julia will not automatically include updates to any packages that may be used. For that, we run the following command to add Julia to Jupyter:</p>
<pre><strong>Pkg.update()</strong> </pre>
<p class="mce-root"/>
<p>This will result in a number of packages being updated or installed on to your machine. Your display will look something like the following screenshot:</p>
<div><img src="img/8dee0148-eef3-4aad-909c-a0a21180c33a.png" style="width:32.17em;height:34.50em;"/></div>
<p>Julia uses font color as feedback. I entered the text <kbd>Pkg.update()</kbd> in white at the top of the screen; successful execution steps are in blue, and possible problems are shown in red. You must wait for the installation to complete.</p>
<p>This is quite an involved process, where the system looks to see what packages need to be updated and installed, installs each one, verifies that each was successful, and then does it all again until there is nothing left to update.</p>
<p>The last line should have read the following:</p>
<pre><strong>INFO: Package database updated</strong> </pre>
<p>At this point, you can close the Julia window (by using the <kbd>quit()</kbd> command).</p>
<p>One last step is to open your Notebook (by using the <kbd>jupyter notebook</kbd> command), and if you open the New menu (in the upper-right corner of the screen), you should see a Julia type available, as shown in the following screenshot:</p>
<div><img src="img/245ee21a-58a5-4b84-b320-de633788231c.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Julia packages to Jupyter</h1>
                
            
            
                
<p>The standard installation for Julia under Jupyter has many packages that are commonly used in Julia programming. However, if you do need to add another package, a small number of steps are required to be followed:</p>
<ol>
<li>Close down your Notebook (including the server).</li>
<li>Run the Julia command-line program:</li>
</ol>
<pre style="padding-left: 90px">Pkg.add("DataFrames") 
Pkg.add("RDatasets") 
quit(); </pre>
<ol start="3">
<li>Restart your Notebook. The package should be available in your Julia script, for example,  <kbd>library("name of the package you want to add")</kbd>.</li>
</ol>
<p>I would recommend adding the preceding two packages right away, as they are needed for many scripts.</p>
<p>The first time you use a package in Julia, you will see a line highlighted in light red that shows Julia is precompiling, such as this: <kbd>INFO: Precompiling module Dataframes...</kbd></p>
<p>You can use the <kbd>Pkg.add(...)</kbd> function directly in your script, but that doesn't seem correct. Every time you run your script, the system will attempt to validate whether you have the specified package, install it into your environment if needed, and even tell you whether it is out of date. None of these steps belong to part of your script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic Julia in Jupyter</h1>
                
            
            
                
<p>In this example, we will use the Iris dataset for some standard analysis. So, start a new Julia Notebook and call it <kbd>Julia Iris</kbd>. We can enter a small script to see how the steps progress for a Julia script.</p>
<p>This script uses another package for plotting, which is called <kbd>Gadfly</kbd>. You will have to go through similar steps as to the ones we went through in the previous section to install the package before operating the script.</p>
<p>Enter the following script into separate cells of your Notebook:</p>
<pre>using RDatasets<br/>using DataFrames<br/>using Gadfly<br/>set_default_plot_size(5inch, 5inch/golden); plot(dataset("datasets","iris"), x="SepalWidth", y="SepalLength", color="Species") </pre>
<p><kbd>RDatasets</kbd> is a library that contains several of the commonly used R datasets, such as <kbd>iris</kbd>. This is a simple script—we define the libraries that we are going to use, set the size of the <kbd>plot</kbd> area, and plot out the <kbd>iris</kbd> data points (<kbd>color</kbd> coded to <kbd>Species</kbd>).</p>
<p class="mce-root"/>
<p>So, you will end up with a starting screen that looks like the following screenshot:</p>
<div><img src="img/fec1f011-ce80-4f10-8bd2-2221f8b84c4c.png"/></div>
<p>I have used Markdown cells for the text cells. These serve as documentation of the processing and are not interpreted by the engine.</p>
<p>We should take note of a few aspects of the Julia Notebook view:</p>
<ul>
<li>We have the Julia logo (the three colored circles) in the upper-right corner. You will have seen this logo running in other Julia installations (as we saw earlier when we ran the Julia command line previously).</li>
<li> The circle to the right of the Julia logo is a busy indicator. When your script starts, the title of the table says busy as Julia is starting. When your script is running, the circle is filled in black. When it is not running, it is empty.</li>
<li> The rest of the menu items are the same as before.</li>
</ul>
<p>On my Windows machine, it took quite a while for the Julia Notebook to start for the first time. The Kernel starting, please wait... message was displayed for several minutes.</p>
<p class="mce-root"/>
<p>If you run the script (using the <strong>Cell</strong> | Run All menu command), your output should look like what's shown in the following screenshot:</p>
<div><img src="img/00f085b2-5274-48dc-be8c-311b70c0480a.png"/></div>
<p>The display continues with other statistics about each of the sets, such as <kbd>PetalWidth</kbd> and so on.</p>
<p>Note the <kbd>WARNING</kbd> message about an incompatibility between sublibraries. Even with the time it took to install and update packages, there were still unresolved issues.</p>
<p class="mce-root"/>
<p>The more interesting part of this is <kbd>plot</kbd> of the data points:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cb29c2d4-c038-446b-9b2b-af4de89f89be.png"/></p>
<p>I noticed that if you hover the mouse over a graphic, you get grid lines displayed and a slide bar to adjust the zoom level (as shown in the upper-right part of the preceding screenshot).</p>
<p>So, just as if you ran the script in the Julia interpreter, you get your output (with the numerical prefix). Jupyter has counted the statements so that we have incremental numbering of the cells. Jupyter has not done anything special to print out variables.</p>
<p>We started the server, created a new Notebook, and saved it as Julia <kbd>iris</kbd>. If we open the IPYNB file on disk (using a text editor), we can see the following:</p>
<pre>{ 
  "cells": [ 
    ...&lt;similar to previously displayed&gt; 
  ], 
  "metadata": { 
  "kernelspec": { 
   "display_name": "Julia 0.6.1", 
   "language": "julia", 
   "name": "julia-0.6" 
  }, 
  "language_info": { 
   "file_extension": ".jl", 
   "mimetype": "application/julia", 
   "name": "julia", 
   "version": "0.6.1" 
  } 
 }, 
 "nbformat": 4, 
 "nbformat_minor": 1 
} 
 </pre>
<p>This is a little different than what we saw in the previous chapters with other Notebook language coding. Particularly, <kbd>metadata</kbd> clearly targets the script cells to be Julia script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia limitations in Jupyter</h1>
                
            
            
                
<p>I have written Julia scripts and accessed different Julia libraries without issue in Jupyter. I have not noticed any limitations on its use or any performance degradation. I imagine some aspects of Julia that are very screen dependent (such as using the <strong>Julia webstack</strong> to build a website) may be hampered by conflicting uses of the same concept.</p>
<p>I have repeatedly seen updates being run when I am attempting to run a Julia script, as shown in the following screenshot. I am not sure why they decided to always update the underlying tool rather than use what is in play and have the user specify whether to update libraries:</p>
<div><img src="img/3a15611e-d6ad-47fa-9315-8d08a9bef36c.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>I have also noticed that once a Julia Notebook is opened, even though I have closed the page, it will still display Running on the home page. I don't recall seeing this behavior with the other script languages that are available.</p>
<p>Another issue has been trying to use a secured package in my script, for example, <kbd>plotly</kbd>. It appears to be a clean process to get credentials, but using the prescribed methods for passing your credentials to <kbd>plotly</kbd> does not work under Windows. I am hesitant to provide examples that do not work in both environments.</p>
<p>Further interactions with Windows are also limited, for example, attempting to access environment variables by calls to standard C libraries that are not normally present on a Windows installation.</p>
<p>I have another issue with Julia itself, regardless of running under Jupyter or not. When using a package, it will complain about features that are used in the package that have been deprecated or improved. As a user of the package, I have no control over this behavior, so it does not help me in my work.</p>
<p>Lastly, running some of these scripts takes several minutes. The scripts used are small. It seems to take a long time for the Julia kernel to start.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Standard Julia capabilities</h1>
                
            
            
                
<p>Similar to functions that are used in other languages, Julia can perform most of the rudimentary statistics on your data by using the <kbd>describe</kbd> function, as shown in the example script that follows:</p>
<pre>using RDatasets 
describe(dataset("datasets", "iris"))</pre>
<p>This script accesses the <kbd>iris</kbd> dataset and displays summary statistics on the dataset.</p>
<p>If we were to build a Notebook to show <kbd>describe</kbd> in use against the <kbd>iris</kbd> dataset (which we loaded in the previous example), we would end up with a display such as this: </p>
<div><img src="img/861cf12e-30a9-4cb4-bb91-a92d2ec27d20.png" style="width:40.33em;height:31.00em;"/></div>
<p>You can see the standard statistics that have been generated for each of the variables in the dataset. I thought it was interesting that the count and percentage of <kbd>NA</kbd> values in the dataset are provided. I have found that I usually have to double-check to exclude this data by using other languages. This is a quick, built-in reminder.</p>
<p>The warning message is complaining about a compatibility issue with one of the datetime libraries used, even though it is not used in this Notebook.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia visualizations in Jupyter</h1>
                
            
            
                
<p>The most popular tool for visualizations in Julia is the <kbd>Gadfly</kbd> package. We can add the <kbd>Gadfly</kbd> package (as described at the beginning of this chapter) by using the <kbd>add</kbd> function:</p>
<pre>Pkg.add("Gadfly") </pre>
<p class="mce-root"/>
<p>From then on, we can make reference to the <kbd>Gadfly</kbd> package in any script by using the following:</p>
<pre>using Gadfly </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia Gadfly scatterplot</h1>
                
            
            
                
<p>We can use the <kbd>plot()</kbd> function with standard defaults (no type arguments) to generate a scatterplot. For example, with the following simple script:</p>
<pre>using Gadfly 
srand(111) 
plot(x=rand(7), y=rand(7)) </pre>
<p>We use the <kbd>srand()</kbd> function in all examples that use random results. The <kbd>srand()</kbd> function sets the random number seed value so that all of the results in this chapter are reproducible.</p>
<p>We generate a nice, clean scatterplot, as shown in the following screenshot:</p>
<div><img src="img/8d797e18-a514-4b39-a4ce-8ec5995e18a0.png"/></div>
<p class="mce-root"/>
<p>I did notice that if you click on the ? symbol that appears in the top-right of the graphic if you click on the graphic, a message box is displayed that enables finer control over the graphic to do the following:</p>
<ul>
<li>Pan across the image (especially if it expands beyond the window)</li>
<li>Zoom in, out</li>
<li>Reset:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/f328b8f6-425a-4721-87e2-463aa453634b.png" style="width:42.67em;height:28.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia Gadfly histogram</h1>
                
            
            
                
<p>We can produce other graph types as well, for example, <kbd>histogram</kbd>, by using the following script:</p>
<pre>using Gadfly 
srand(111) 
plot(x=randn(113), Geom.histogram(bincount=10)) </pre>
<p>This script generates <kbd>113</kbd> random numbers and generates <kbd>histogram</kbd> of the results.</p>
<p class="mce-root"/>
<p>We will see something like the following screenshot:</p>
<div><img src="img/c4d59d60-d484-40d7-910b-a463ff5b7bd1.png" style="width:44.92em;height:34.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia Winston plotting</h1>
                
            
            
                
<p>Another graphics package in Julia is <kbd>Winston</kbd>. It has similar plotting capabilities to <kbd>Gadfly</kbd> (I think <kbd>Gadfly</kbd> is more up-to-date). We can produce a similar plot of random numbers by using the following script:</p>
<pre>using Winston 
# fix the random seed so we have reproducible results 
srand(111) 
# generate a plot 
pl = plot(cumsum(rand(100) .- 0.5), "g", cumsum(rand(100) .- 0.5), "b") 
# display the plot 
display(pl) </pre>
<p>Note that you have to specifically display the plot. The <kbd>Winston</kbd> package assumes that you want to store the graphic as a file, so the <kbd>plot</kbd> function generates an object for handling.</p>
<p>Moving this into a Notebook, we get the following screenshot:</p>
<div><img src="img/196c6351-f62d-44de-a52b-068a09c9413a.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia Vega plotting</h1>
                
            
            
                
<p>Another popular graphics package is <kbd>Vega</kbd>. The main feature of <kbd>Vega</kbd> is the ability to describe your graphic by using language primitives such as JSON. <kbd>Vega</kbd> produces most of the standard plots. Here is an example script using <kbd>Vega</kbd> for a pie chart:</p>
<pre class="mce-root">Pkg.add("Vega") 
using Vega 
stock = ["chairs", "tables", "desks", "rugs", "lamps"]; 
quantity = [15, 10, 10, 5, 20]; 
piechart(x = stock, y = quantity) </pre>
<p>The resultant output in Jupyter may look like the following screenshot:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><strong><img src="img/0ad89c95-c57d-41ff-aae1-e87d7de149ea.png"/></strong></p>
<p>Note the <kbd>INFO: Precompiling module Vega.</kbd> package. Even though the package had been loaded as part of the install or update process, it still needed to adjust the library on first use.</p>
<p>The generated graphic produced under Jupyter is shown in the following screenshot</p>
<p class="MsoTitle"><kbd>Vega</kbd> gives you the option on the resultant display to Save as PNG. I think this is a useful feature, allowing you to embed the generated graphic(s) in another document:</p>
<div><img src="img/a64fba07-d41b-4fad-b25f-178c3545a47e.png" style="width:48.17em;height:41.00em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia PyPlot plotting</h1>
                
            
            
                
<p>Another plotting package available is <kbd>PyPlot</kbd>. <kbd>PyPlot</kbd> is one of the standard Python visualization libraries and is directly accessible from Julia. We can take this small script to produce an interesting visualization:</p>
<pre>#Pkg.add("PyPlot") 
using PyPlot 
precipitation = [0,0,0,0,0,0,0,0,0,0,0.12,0.01,0,0,0,0.37,0,0,0,0,0.01,0,0,0,0.01,0.01,0,0.17,0.01,0.11,0.31] 
date = collect(1:31) 
fig = figure(1, figsize=(4, 4)) 
plot(date, precipitation, ".") 
title("Boston Precipitation") 
xlabel("May 2013") 
ylabel("Precipitation") </pre>
<p>The resultant output in Jupyter may look like what's shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/85d1bee4-7214-4883-8889-a7cc1ddb3cda.png"/></p>
<p>Again, we have Julia updating a package before executing our Notebook until, finally, we get the graphic on <kbd>Precipitation</kbd>:</p>
<div><img src="img/5acf802c-ba07-438a-a499-7f18dc9696b9.png" style="width:35.00em;height:31.83em;"/></div>
<p>It's interesting that Boston has such diverse precipitation—most of the month has none, and then there are a couple of days that have a deluge.</p>
<p>A reminder: Jupyter will attempt to put most of the output into a small scrolling window. Just clicking in the left-hand side of the display will expand the entire contents of the scroll panel.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia parallel processing</h1>
                
            
            
                
<p>An advanced built-in feature of Julia is to use parallel processing in your script. Normally, you can specify the number of processes that you want to use directly in Julia. However, under Jupyter, you would use the <kbd>addprocs()</kbd> function to add an additional process available for use in your script, for example, look at this small script:</p>
<pre>addprocs(1) 
srand(111) 
r = remotecall(rand, 2, 3, 4) 
s = @spawnat 2 1 .+ fetch(r) 
fetch(s) </pre>
<p>It makes a call to <kbd>rand</kbd>, the random number generator, with that code executing on the second parameter to the function call (process <kbd>2</kbd>), and then passes the remaining arguments to the <kbd>rand</kbd> function there (making rand generate a 3×4 matrix of random numbers). <kbd>spawnat</kbd> is a macro that evaluates the processes mentioned previously. Then, <kbd>fetch</kbd> accesses the result of the spawned processes.</p>
<p>We can see the results in the example under Jupyter, as shown in the following screenshot:</p>
<div><img src="img/c6289b67-d8e3-419b-97fe-6ada0b688915.png"/></div>
<p>So, this is not a dramatic spawned process type of calculation, but you can easily imagine much more involved processes that are readily available in Jupyter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia control flow</h1>
                
            
            
                
<p>Julia has a complete set of control flows. As an example, we could have a small function <kbd>larger</kbd> that determines the larger of two numbers:</p>
<pre>function larger(x, y)  
    if (x&gt;y)  
        return x 
    end 
    return y 
end 
println(larger(7,8)) </pre>
<p>There are several features that you must note:</p>
<ul>
<li>The <kbd>end</kbd> statement for the <kbd>if</kbd> statement</li>
<li><kbd>end</kbd>, as the closing of the function</li>
<li>The indentation of the statements within the function</li>
<li>The indentation of the handling of a true condition within an <kbd>if</kbd> statement</li>
</ul>
<p>If we run this under Jupyter, we would see the expected output, as shown in the following screenshot:</p>
<div><img src="img/8e24a6fa-8294-4387-be06-278908e5c562.png"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia regular expressions</h1>
                
            
            
                
<p>Julia has built-in regular expression handling—as would most modern programming languages. There is no need for using statements, since regular expressions are basic features of strings in Julia.</p>
<p>We could have a small script that validates whether a string is a valid phone number, for example:</p>
<pre>ismatch(r"^\([0-9]{3}\)[0-9]{3}-[0-9]{4}$", "(781)244-1212") 
ismatch(r"^\([0-9]{3}\)[0-9]{3}-[0-9]{4}$", "-781-244-1212") </pre>
<p>When run under Jupyter, we would see the expected results. The first number is conformant to the format and the second is not:</p>
<div><img src="img/faf1873c-efcc-4392-b37a-011139512d54.png" style="width:37.17em;height:14.42em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Julia unit testing</h1>
                
            
            
                
<p>As a full language, Julia has unit-testing abilities to make sure that your code is performing as expected. The unit tests usually reside in the tests folder.</p>
<p>Two of the standard functions available for unit testing in Julia are <kbd>FactCheck</kbd> and <kbd>Base.Test</kbd>. They both do the same thing, but react differently to failed tests. <kbd>FactCheck</kbd> will generate an error message that will not stop processing on a failure. If you provide an error handler, that error handler will take control of the test.</p>
<p><kbd>Base.Test</kbd> will throw an exception and stop processing on the first test failure. In that regard, it is probably not useful as a unit-testing function so much as a runtime test that you may put in place to make sure parameters are within reason or otherwise. Just stop processing before something bad happens.</p>
<p class="mce-root"/>
<p>Both packages are built in to the standard Julia distributions.</p>
<p>As an example, we can create a unit tests Notebook that does the same tests and see the resulting, different responses for errors (meaning, test failures).</p>
<p>For <kbd>FactCheck</kbd>, we will use the following script:</p>
<pre>using FactCheck 
f(x) = x^3 
facts("cubes") do 
    @fact f(2) --&gt; 8 
    @fact f(2) --&gt; 7 
End </pre>
<p>We are using the <kbd>FactCheck</kbd> package. The simple function we are testing is cubing a number, but it could be anything. We wrap our tests in a <kbd>facts() do...End</kbd> block. Each of the tests is run within the block which is separate from any other block—so as to group our unit tests together—and is prefixed with <kbd>@fact</kbd>. Also, note that we are testing whether the function result following <kbd>--&gt;</kbd> is the right-hand argument.</p>
<p>When we run this in Jupyter, we see the expected results, as shown in the following screenshot:</p>
<div><img src="img/d06a9fb0-98d5-462e-9f35-c1f1221e77ec.png"/></div>
<p class="mce-root"/>
<p>You can see the failed test, why it failed, what line it was on, and so on, as well as the summary for the <kbd>facts</kbd> block that was executed, that is, the number of tests that passed (<kbd>Verified</kbd>) and the number of tests that <kbd>Failed</kbd>. Note that the script continued to run on to the next line.</p>
<p>For <kbd>Base.Test</kbd>, we have a similar script:</p>
<pre>using Base.Test f(x) = x^3 @test f(2) == 8 @test f(2) == 7 </pre>
<p>We are using the <kbd>Base.Test</kbd> package. The function definition we are using is, again, cubing. Then, each test is individually—not as part of a <kbd>test</kbd> block—prefixed with <kbd>@test</kbd>. Running this script in Jupyter, we see similar results as the ones that are shown in the following screenshot:</p>
<div><img src="img/87a2f1d1-285f-4b6e-a9d9-8e2cacf20a7d.png" style="width:44.00em;height:17.17em;"/></div>
<p>The failed test information is displayed. However, in this case, the script stopped executing at this point. Hence, I would only consider this for runtime checks to validate input formats.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we added the ability to use Julia scripts in our Jupyter Notebook. We added a Julia library that's not included in the standard Julia installation. We saw basic features of Julia in use, and also outlined some of the limitations that are encountered using Julia in Jupyter. We displayed graphics using some of the graphics packages available, including <kbd>Gadfly</kbd>, <kbd>Winston</kbd>, <kbd>Vega</kbd>, and <kbd>PyPlot</kbd>. Finally, we saw parallel processing in action, a small control flow example, and how to add unit testing to your Julia script.</p>
<p>In the next chapter, we will learn all about using JavaScript in a Jupyter Notebook.</p>


            

            
        
    </body></html>