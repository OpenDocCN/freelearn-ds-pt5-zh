- en: Data Visualization and Prediction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making predictions is usually precarious. However, there are methods that have
    been in use that provide some confidence in your results. Under Jupyter, we can
    use Python and/or R for predictions with readily available functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Make a prediction using scikit-learn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: scikit-learn is a machine learning toolset built using Python. Part of the package
    is supervised learning, where the sample data points have attributes that allow
    you to assign the data points into separate classes. We use an estimator that
    assigns a data point to a class and makes predictions as to other data points
    with similar attributes. In scikit-learn, an estimator provides two functions,
    `fit()` and `predict()`, providing mechanisms to classify data points and predict
    classes of other data points, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will be using the housing data from [https://uci.edu/](https://uci.edu/) (I
    think this is data for the Boston area). There are a number of factors including
    a price factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will break up the dataset into a training set and a test set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the training set, we will produce a model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then use the model against the test set and evaluate how well our model
    fits the actual data for predicting housing prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The attributes in the dataset (in corresponding order in our data frame) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CRIM** | **per capita crime rate by town** |'
  prefs: []
  type: TYPE_TB
- en: '| `ZN` | proportion of residential land zoned for lots over 25,000 sq.ft. |'
  prefs: []
  type: TYPE_TB
- en: '| `INDUS` | proportion of non-retail business acres per town |'
  prefs: []
  type: TYPE_TB
- en: '| `CHAS` | Charles River dummy variable (`= 1` if tract bounds river; `0` otherwise)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NOX` | nitric oxides concentration (parts per 10 million) |'
  prefs: []
  type: TYPE_TB
- en: '| `RM` | average number of rooms per dwelling |'
  prefs: []
  type: TYPE_TB
- en: '| `AGE` | proportion of owner-occupied units built prior to 1940 |'
  prefs: []
  type: TYPE_TB
- en: '| `DIS` | weighted distances to five Boston employment centers |'
  prefs: []
  type: TYPE_TB
- en: '| `RAD` | index of accessibility to radial highways |'
  prefs: []
  type: TYPE_TB
- en: '| `TAX` | full-value property-tax rate per $10,000 |'
  prefs: []
  type: TYPE_TB
- en: '| `PTRATIO` | pupil-teacher ratio by town |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | *1000(Bk - 0.63)^2* where *Bk* is the proportion of black residents
    by town |'
  prefs: []
  type: TYPE_TB
- en: '| `LSTAT` | % lower status of the population |'
  prefs: []
  type: TYPE_TB
- en: '| `MEDV` | Median value of owner-occupied homes in $1,000''s |'
  prefs: []
  type: TYPE_TB
- en: 'The following coding is followed by a discussion of the algorithm used and
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the `head()` function is the first few rows of the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b4abf3c-153f-4452-b502-fa92767d3ddb.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the preceding `describe` statement gives us some quick statistics
    on the data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ec1918c-75cb-4643-992d-7dde81c07065.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When splitting up the dataset between training and test sets, we use random
    allocation between the two. This gives us an unbiased set of data to work with.
    However, in order for you to reproduce the results shown here, you need to use
    the same random seed/starting value. This is why the `random.seed()` call is made.
    In practice, you would forgo this method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of these are small numbers, except for a positive correlation with #6
    at 3.8 for the number of rooms and a negative correlation with #8 at -1.5 for
    the distance from the business center. It is interesting how people value being
    close to work so highly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an MSE of 23, which seems very low in comparison to the size of the
    numbers being worked with. Now, let us graph our results to get a good visual
    of what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Visually, we appear to have a good fit. Most of the data points are aligned
    with the axis drawn through. There are, as always, a few distinct outliers such
    as at *20*, *50*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be50e5ba-bd26-4f82-a0fe-0ad2ccad1861.png)![](img/8fae67be-da54-476d-ae7a-14bcd0a9605f.png)**
    **# Make a prediction using R'
  prefs: []
  type: TYPE_NORMAL
- en: We can perform the same analysis using R in a notebook. The functions are different
    for the different language, but the functionality is very close.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the same algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split the dataset into training and testing partitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a model based on the training partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the model to predict from the testing partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare predicted versus actual testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The coding is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the dataset is in the right order for our modeling.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The data display, shown as follows, plots every variable against every other
    variable in the dataset. I am looking to see if there are any nice 45 degree ''lines''
    showing great symmetry between the variables, with the idea that maybe we should
    remove one as the other suffices as a contributing factor. The interesting items
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHAS`: Charles River access, but that is a binary value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LSTAT` (lower status population) and `MDEV` (price) have an inverse relationship—but
    price will not be a factor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOX` (smog) and `DIST` (distance to work) have an inverse relationship. I
    think we want that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, there doesn''t appear to be any relationship between the data items:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7469f515-7daa-4354-a7e8-7d2f7bb836d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We go about forcing the seed, as before, to be able to reproduce results. We
    then split the data into training and testing partitions made with the `createDataPartitions`
    function. We can then train our model and test the resultant model for validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is interesting that this model also picked up on a high premium for Charles
    River views affecting the price. Also, like that, this model provides `p-value`
    (good confidence in the model):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like a pretty good correlation, very close to a 45 degree mapping.
    The exception is that the predicted values are a little higher than actuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79ca2a39-3cb8-49c4-8a22-f54746e311af.png)** **# Interactive visualization'
  prefs: []
  type: TYPE_NORMAL
- en: There is a Python package, Bokeh, that can be used to generate a figure in your
    notebook where the user can interact and change the figure.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I am using the same data from the histogram example later in
    this chapter (also included in the file set for this chapter) to display an interactive
    Bokeh histogram.
  prefs: []
  type: TYPE_NORMAL
- en: The coding is as follows:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**We can see the histogram displayed as follows. There is little being done
    automatically to clean up the graph, such as move counters around or the uninteresting
    axes labels. I assume there are options with the `Histogram` function that would
    allow further changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a7b7992-570e-4e6b-9e4d-a709eca9e425.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the widgets across the top of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side is a Bokeh icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the right side are icons for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the image to another portion of the screen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Magnifying
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Wheel zoom-slide wheel to zoom in/out
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the image to disk
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh the image
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive help on Bokeh functions**  **# Plotting using Plotly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotly is an interesting mix. It is a subscription website that provides significant
    data analysis graphing functionality. You can use the free version of the software,
    but you still need to log in with credentials to use it. The graphics functions
    are available in a variety of languages from Node.js to Python and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the graphics generated are available in Plotly and in your local notebook.
    If you mark the graphic as public, then you can access it from the notebook, just
    like any other graphic over the internet. Similarly, as a web graphic, you can
    select from the display and save locally as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the voting histogram again, but using Plotly's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I think this is one of the nicer renderings that I have seen for a histogram
    using the out-of-the-box options/settings. We have the same histogram we had seen
    previously, just displayed using more eye-appealing attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6e195ed-27c8-4579-be22-306541091ae2.png)** **# Creating a human density
    map'
  prefs: []
  type: TYPE_NORMAL
- en: I had originally planned on producing a worldwide human density map, but the
    graphics available don't allow for setting the color of each country. So, I built
    a density map for the United States.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain graphic shapes for each of the states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the density for each state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide on a color range and apply the lowest density to one end of the range
    and the highest to the other end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine it's density
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup that density value in the range and select a color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw the state
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is coded with the following (comments embedded as the code proceeds):**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**We see a color-coded density map in the following figure. I am not sure why
    Minnesota and Wisconsin did not match up with the data (they show no color for
    the density in the map). The data file looks correct and does appear to map to
    the image points.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The packages used in this example would need to be installed, as they are not
    part of the standard set issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8de833df-ebec-462b-a03a-5aac1fe1a03b.png)**  **# Draw a histogram of
    social data'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a wide variety of social sites that produce datasets. In this example,
    we will gather one of the datasets and produce a histogram from the data. The
    specific dataset is the voting behavior on WIKI from [https://snap.stanford.edu/data/wiki-Vote.html](https://snap.stanford.edu/data/wiki-Vote.html).
    Each data item shows user number `N` voted for user number `X`. So, we produce
    some statistics in a histogram to analyze voting behavior by:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering all of the voting that took place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each vote:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment a counter that says who voted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment a counter that says who was voted for
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Massage the data so we can display it in two histograms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The coding is as follows:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Python will automatically assign the first column as the index into the table,
    regardless of whether the index is re-used (as is this case). You can see in the
    `describe()` results only the `ToNodeId` column is mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we produce grouped totals by the number of votes by a person and number
    of votes for a person. I assume there is a built-in function that would do this
    more nicely, but I did not find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can already see some big numbers in there, like `743`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the following plot, with the now familiar display of votes by users.
    I think this is one of the plainer layouts I have seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3b9b68-3e71-4e4d-a94d-a1d679d28f24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we make a histogram of the references made for a user with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the votes by users plot as follows. I hadn''t expected such lopsided
    results: only a few people vote a lot and only a few people got significant votes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e1121bc-a31a-4b70-ba40-41c9620f8ed8.png)**  **# Plotting 3D data'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the data analysis packages (R, Python, and so on) have significant data
    visualization capabilities. An interesting one is to display data in three dimensions.
    Often, when three dimensions are used, unexpected visualizations appear.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we are using the car dataset from [https://uci.edu/](https://uci.edu/).
    It is a well-used dataset with several attributes for vehicles, for example, `mpg`,
    `weight`, and `acceleration`. What if we were to plot three of those data attributes
    together and see if we can recognize any apparent rules?
  prefs: []
  type: TYPE_NORMAL
- en: The coding involved is as follows:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**In the following code, we plot out the data according to three axes that
    appear to be significant factors—weight, miles per gallon, and the number of cylinders
    in the engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unexpectedly, there appears to be three levels by the apparent three lines
    of data points, regardless of weight:'
  prefs: []
  type: TYPE_NORMAL
- en: Six cylinders with higher mpg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lower mpg four cylinder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A higher mpg for four cylinder vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I would have expected the weight to have a bigger effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/aa52296f-33f9-424a-b808-b67c42896dbe.png)**  **# Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we used prediction models from Python and R under Jupyter.
    We used Matplotlib for data visualization. We used interactive plotting (under
    Python). And we covered several graphing techniques available in Jupyter. We created
    a density map with SciPy. We used histograms to visualize social data. Lastly,
    we generated a 3D plot under Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at accessing data in different ways under
    Jupyter.**
  prefs: []
  type: TYPE_NORMAL
