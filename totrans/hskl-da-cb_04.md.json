["```py\n$ cabal install hashable\n\n```", "```py\n    import Data.Hashable\n    ```", "```py\n    main = do\n      print $ hash \"foo\" \n    ```", "```py\n      print $ hashWithSalt 1 \"foo\"\n      print $ hashWithSalt 2 \"foo\"\n    ```", "```py\n      print $ hash [ (1 :: Int, \"hello\", True)\n                   , (0 :: Int, \"goodbye\", False) ]\n    ```", "```py\n    $ runhaskell Main.hs\n\n    7207853227093559468\n    367897294438771247\n    687941543139326482\n    6768682186886785615\n    ```", "```py\n$ cabal install hashable\n\n```", "```py\n    {-# LANGUAGE DeriveGeneric #-}\n    ```", "```py\n    import GHC.Generics (Generic)\n    import Data.Hashable\n    ```", "```py\n    data Point = Point Int Int\n               deriving (Eq, Generic)\n\n    instance Hashable Point\n    ```", "```py\n    main = do\n        let p1 = Point 1 1\n        let p2 = Point 1 1\n        let p3 = Point 3 5\n    ```", "```py\n    if p1 == p2\n      then putStrLn \"p1 = p2\"\n      else putStrLn \"p1 /= p2\"\n      if hash p1 == hash p2\n      then putStrLn \"hash p1 = hash p2\"\n      else putStrLn \"hash p1 /= hash p2\"\n    ```", "```py\n      if p1 == p3\n        then putStrLn \"p1 = p3\"\n        else putStrLn \"p1 /= p3\"\n      if hash p1 == hash p3\n        then putStrLn \"hash p1 = hash p3\"\n        else putStrLn \"hash p1 /= hash p3\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    p1 = p2\n    hash p1 = hash p2\n    p1 /= p3\n    hash p1 /= hash p3\n\n    ```", "```py\n    hashPtrWithSalt :: Ptr a   --  pointer to the data to hash\n                    -> Int     --  length, in bytes\n                    -> Int     --  salt\n                    -> IO Int  --  hash value\n    ```", "```py\n    hashByteArrayWithSalt\n        :: ByteArray#  --  data to hash\n        -> Int         --  offset, in bytes\n        -> Int         --  length, in bytes\n        -> Int         --  salt\n        -> Int         --  hash value\n    ```", "```py\n$ cabal install cryptohash\n\n```", "```py\n    import Data.ByteString.Char8 (ByteString, pack)\n    import Crypto.Hash\n    ```", "```py\n    skein512_512 :: ByteString -> Digest Skein512_512\n    skein512_512 bs = hash bs\n\n    skein512_384 :: ByteString -> Digest Skein512_384\n    skein512_384 bs = hash bs\n\n    skein512_256 :: ByteString -> Digest Skein512_256\n    skein512_256 bs = hash bs\n\n    skein512_224 :: ByteString -> Digest Skein512_224\n    skein512_224 bs = hash bs\n\n    skein256_256 :: ByteString -> Digest Skein256_256\n    skein256_256 bs = hash bs\n\n    skein256_224 :: ByteString -> Digest Skein256_224\n    skein256_224 bs = hash bs\n\n    sha3_512 :: ByteString -> Digest SHA3_512\n    sha3_512 bs = hash bs\n\n    sha3_384 :: ByteString -> Digest SHA3_384\n    sha3_384 bs = hash bs\n\n    sha3_256 :: ByteString -> Digest SHA3_256\n    sha3_256 bs = hash bs\n\n    sha3_224 :: ByteString -> Digest SHA3_224\n    sha3_224 bs = hash bs\n\n    tiger :: ByteString -> Digest Tiger\n    tiger bs = hash bs\n\n    whirlpool :: ByteString -> Digest Whirlpool\n    whirlpool bs = hash bs\n\n    ripemd160 :: ByteString -> Digest RIPEMD160\n    ripemd160 bs = hash bs\n\n    sha512 :: ByteString -> Digest SHA512\n    sha512 bs = hash bs\n\n    sha384 :: ByteString -> Digest SHA384\n    sha384 bs = hash bs\n\n    sha256 :: ByteString -> Digest SHA256\n    sha256 bs = hash bs\n\n    sha224 :: ByteString -> Digest SHA224\n    sha224 bs = hash bs\n\n    sha1 :: ByteString -> Digest SHA1\n    sha1 bs = hash bs\n\n    md5 :: ByteString -> Digest MD5\n    md5 bs = hash bs\n\n    md4 :: ByteString -> Digest MD4\n    md4 bs = hash bs\n\n    md2 :: ByteString -> Digest MD2\n    md2 bs = hash bs\n    ```", "```py\n    main = do\n      let input = pack \"haskell data analysis\"\n      putStrLn $ \"Skein512_512: \" ++ (show.skein512_512) input\n      putStrLn $ \"Skein512_384: \" ++ (show.skein512_384) input\n      putStrLn $ \"Skein512_256: \" ++ (show.skein512_256) input\n      putStrLn $ \"Skein512_224: \" ++ (show.skein512_224) input\n      putStrLn $ \"Skein256_256: \" ++ (show.skein256_256) input\n      putStrLn $ \"Skein256_224: \" ++ (show.skein256_224) input\n      putStrLn $ \"SHA3_512: \" ++ (show.sha3_512) input\n      putStrLn $ \"SHA3_384: \" ++ (show.sha3_384) input\n      putStrLn $ \"SHA3_256: \" ++ (show.sha3_256) input\n      putStrLn $ \"SHA3_224: \" ++ (show.sha3_224) input\n      putStrLn $ \"Tiger: \" ++ (show.tiger) input\n      putStrLn $ \"Whirlpool: \" ++ (show.whirlpool) input\n      putStrLn $ \"RIPEMD160: \" ++ (show.ripemd160) input\n      putStrLn $ \"SHA512: \" ++ (show.sha512) input\n      putStrLn $ \"SHA384: \" ++ (show.sha384) input\n      putStrLn $ \"SHA256: \" ++ (show.sha256) input\n      putStrLn $ \"SHA224: \" ++ (show.sha224) input\n      putStrLn $ \"SHA1: \" ++ (show.sha1) input\n      putStrLn $ \"MD5: \" ++ (show.md5) input\n      putStrLn $ \"MD4: \" ++ (show.md4) input\n      putStrLn $ \"MD2: \" ++ (show.md2) input\n    ```", "```py\n    $ runhaskell Main.hs\n\n    ```", "```py\n$ cabal install cryptohash\n\n```", "```py\n    import Crypto.Hash\n    import qualified Data.ByteString as BS\n    ```", "```py\n    md5 :: BS.ByteString -> Digest MD5\n    md5 bs = hash bs\n    ```", "```py\n    sha256 :: BS.ByteString -> Digest SHA256\n    sha256 bs = hash bs\n    ```", "```py\n    sha512 :: BS.ByteString -> Digest SHA512\n    sha512 bs = hash bs\n    ```", "```py\n    main = do\n      byteStr <- BS.readFile \"Main.hs\"\n    ```", "```py\n        putStrLn $ \"MD5: \" ++ (show.md5) byteStr\n        putStrLn $ \"SHA256: \" ++ (show.sha256) byteStr\n        putStrLn $ \"SHA512: \" ++ (show.sha512) byteStr\n    ```", "```py\n    $ runhaskell Main.hs\n\n    MD5: 242334e552ae8ede926de9c164356d18\n\n    SHA256:\n    50364c25e0e9a835df726a056bd5370657f37d20aabc82e0b1719a343ab505d8\n\n    SHA512: 1ad6a9f8922b744c7e5a2d06bf603c267ca6becbf52b2b22f8e5a8e2d82fb52d87ef4a13c9a405b06986d5d19b170d0fd05328b8ae29f9d92ec0bca80f7b60e7\n\n    ```", "```py\n    import System.Mem.StableName\n    ```", "```py\n    data Point = Point [Int]\n    ```", "```py\n      main = do\n        let p1 = Point [1..]\n        let p2 = Point [2,4]\n    ```", "```py\n    sn1 <- makeStableName p1\n    sn2 <- makeStableName p2\n    print $ hashStableName sn1\n    print $ hashStableName sn2\n    ```", "```py\n    $ runhaskell Main.hs\n\n    22\n    23\n\n    ```", "```py\n$ wget norvig.com/big.txt\n\n```", "```py\n$ cabal install unordered-containers\n\n```", "```py\n    import Data.HashMap.Lazy\n    import Data.Set (Set)\n    import qualified Data.Set as Set\n    ```", "```py\n    emptyMap = empty :: HashMap Int (Set String)\n    ```", "```py\n    insertWord m w = insertWith append key val m\n      where append new old = Set.union new old \n        key = length w\n        val = Set.singleton w\n    ```", "```py\n    wordsOfLength len m = Set.size(lookupDefault Set.empty len m )\n    ```", "```py\n    constructMap text = foldl (\\m w -> insertWord m w) emptyMap (words text)\n    ```", "```py\n    main = do\n      text <- readFile \"big.txt\"\n      let m = constructMap text\n      print [wordsOfLength s m | s <- [1..30]]\n    ```", "```py\n    $ runhaskell Main.hs\n\n    [59,385,1821,4173,7308,9806,11104,11503,10174,7948,5823,4024,2586,1597,987,625,416,269,219,139,115,78,51,50,27,14,17,15,11,7]\n\n    ```", "```py\n$ cabal install cityhash\n\n```", "```py\n    import Data.Digest.CityHash\n    import Data.ByteString.Char8 (pack)\n    import Data.Word (Word64)\n    import Data.LargeWord (Word128)\n    ```", "```py\n    main = do\n     (pack str) (1 :: Word128)  let str = \"cityhash\"\n      print $ cityHash64 (pack str)\n      print $ cityHash64WithSeed (pack str) (1 :: Word64)\n      print $ cityHash64WithSeed (pack str) (2 :: Word64)\n      print $ cityHash128 (pack str)\n      print $ cityHash128WithSeed\n      print $ cityHash128WithSeed (pack str) (2 :: Word128)\n    ```", "```py\n    $ runhaskell Main.hs\n\n    11900721293443925155\n    10843914211836357278\n    12209340445019361150\n    116468032688941434670559074973810442908\n    218656848647432546431274347445469875003\n    45074952647722073214392556957268553766\n\n    ```", "```py\n$ cabal install geohash\n\n```", "```py\n    import Data.Geohash\n    ```", "```py\n      main = do\n        let geohash1 = encode 10 (37.775, -122.419)\n        putStrLn $ \"geohash1 is \" ++ (show geohash1)\n    ```", "```py\n    case geohash1 of\n      Just g -> putStrLn $ \"decoding geohash1: \" ++ (show.decode) g\n      Nothing -> putStrLn \"error encoding\"\n    ```", "```py\n    let geohash2 = encode 10 (37.175, -125.419)\n    putStrLn $ \"geohash2 is \" ++ (show geohash2)\n    ```", "```py\n    case geohash2 of\n    Just g -> putStrLn $ \"decoding geohash2: \" ++ (show.decode) g\n    Nothing -> putStrLn \"error encoding\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    geohash1 is Just \"9q8yyk9pqd\"\n\n    decoding geohash1: Just (37.775000631809235,-122.4189966917038)\n\n    geohash2 is Just \"9nwg6p88j6\"\n\n    decoding geohash2: Just (37.175001204013824,-125.4190045595169)\n\n    ```", "```py\n$ cabal install bloomfilter\n\n```", "```py\n    import Data.BloomFilter (fromListB, elemB, emptyB, insertB)\n    import Data.BloomFilter.Hash (cheapHashes)\n    import Data.Map (Map, empty, insertWith)\n    import qualified Data.Map as Map\n    ```", "```py\n    removeUniques strands = foldl bloomMapCheck \n                            (emptyBloom, emptyMap) strands\n\n      where emptyBloom = emptyB (cheapHashes 3) 1024\n            emptyMap = empty :: Map String Int\n            bloomMapCheck (b, m) x\n            | elemB x b = (b, insertWith (+) x 1 m)\n            | otherwise = (insertB x b, m)\n    ```", "```py\n    main = do\n    let strands = [\"GAT\", \"GATC\", \"CGT\", \"GAT\"\n                            , \"GAT\", \"CGT\", \"GAT\", \"CGT\"]\n    print $ snd $ removeUniques strands\n    ```", "```py\n    $ runhaskell Main.hs\n\n    fromList [(\"CGT\",2),(\"GAT\",3)]\n\n    ```", "```py\n$ cabal install murmur-hash\n\n```", "```py\n    import Data.Digest.Murmur32\n    ```", "```py\n    data Point = Point Int Int\n      instance (Hashable32 Point) where \n      hash32Add (Point x y) h = x `hash32Add` (y `hash32Add` h)\n    ```", "```py\n    main = do\n      let p1 = Point 0 0\n      let p2 = Point 2 3\n      putStrLn $ \"hash of string: \" \n                               ++ (show.hash32) \"SO FAST WOW.\"\n      putStrLn $ \"hash of a data-type: \" ++ (show.hash32) p1\n      putStrLn $ \"hash of another data-type: \" ++ (show.hash32) p2\n    ```", "```py\n    $ runhaskell Main.hs\n\n    hash of string: Hash32 0xa18fa3d2\n\n    hash of a data-type: Hash32 0x30408e22\n\n    hash of another data-type: Hash32 0xfda11257\n\n    ```", "```py\n$ sudo apt-get install libphash0-dev\n\n```", "```py\n$ cabal install phash\n\n```", "```py\n    import Data.PHash\n    import Data.Maybe (fromJust, isJust)\n    ```", "```py\n    main = do\n      phash1 <- imageHash \"image1.jpg\"\n      putStrLn $ \"image1: \" ++ show phash1\n    ```", "```py\n      phash2 <- imageHash \"image2.jpg\"\n        putStrLn $ \"image2: \" ++ show phash2\n    ```", "```py\n      phash3 <- imageHash \"image3.jpg\"\n      putStrLn $ \"image3: \" ++ show phash3\n    ```", "```py\n      if isJust phash1 && isJust phash2\n        then do putStr \"hamming distance between image1 and image2: \"\n        print $ hammingDistance (fromJust phash1) (fromJust phash2)\n      else print \"Error, could not read images\"\n    ```", "```py\n      if isJust phash1 && isJust phash3\n        then do putStr \"hamming distance between image1 and image3: \"\n        print $ hammingDistance \n        (fromJust phash1) (fromJust phash3)\n      else print \"Error, could not read images\"\n    ```", "```py\n    $ runhaskell Main.hs\n\n    image1: Just (PHash 14057618708811251228)\n\n    image2: Just (PHash 14488838648009883164)\n\n    image3: Just (PHash 9589915937059962524)\n\n    hamming distance between image1 and image2: 4\n\n    hamming distance between image1 and image3: 10\n\n    ```"]